import { validate, v4 } from 'uuid';
import { createExplorerMessenger } from '@coveo/explorer-messenger';

function emit({ config, environment, event, listenerManager, }) {
    const { url, token, mode } = config;
    const isEnabled = mode !== "disabled";
    if (isEnabled) {
        listenerManager.call(event);
        environment.send(url, token, event);
    }
}

const clientIdKey = "visitorId";

function createClientIdManager(environmentManager) {
    return {
        getClientId: () => {
            const environment = environmentManager.get();
            const storage = environment.storage;
            const existingClientId = storage.getItem(clientIdKey);
            const clientId = existingClientId && validate(existingClientId)
                ? existingClientId
                : environment.generateUUID();
            storage.setItem(clientIdKey, clientId);
            return clientId;
        },
    };
}

const version = "1.2.15";

/**
 * Can be used to both check if the first bit is set (for any utf-8 multibyte part),
 * and to detect "following bytes" (which start with `10xx_xxxx`)
 */
const UTF8_HIGH_BIT = 0b1000_0000;
/** Header for a 2-byte code point: `110x_xxxx`. Can also be used as bit-mask to check for "following bytes". */
const UTF8_HEADER_2 = 0b1100_0000;
/** Header for a 3-byte code point: `1110_xxxx`. Can also be used as bit-mask to check for "header 2". */
const UTF8_HEADER_3 = 0b1110_0000;
/** Header for a 4-byte code point: `1111_0xxx`. Can also be used as bit-mask to check for "header 3". */
const UTF8_HEADER_4 = 0b1111_0000;
/** Bit-mask for "header 4".  */
const UTF8_HEADER_4_MASK = 0b1111_1000;
function utf8ByteCountFromFirstByte(firstByte) {
    if ((firstByte & UTF8_HEADER_4_MASK) === UTF8_HEADER_4) {
        return 4;
    }
    if ((firstByte & UTF8_HEADER_4) === UTF8_HEADER_3) {
        return 3;
    }
    if ((firstByte & UTF8_HEADER_3) === UTF8_HEADER_2) {
        return 2;
    }
    return 1;
}
/**
 * Truncate a URL to an arbitrary length, taking care to not break inside a percent escape or UTF-8 multibyte sequence.
 *
 * @param input The input to truncate to the specified limit.
 * @param limit The limit to apply; if negative, no truncation is applied.
 * @returns The URL, possibly truncated to a length near limit (at most 11 characters less than limit).
 */
function truncateUrl(input, limit) {
    if (limit < 0 || input.length <= limit) {
        return input;
    }
    // A valid escape sequence is a percent followed by 2 hexadecimal characters; check if we split one up.
    let end = input.indexOf("%", limit - 2);
    if (end < 0 || end > limit) {
        end = limit;
    }
    else {
        limit = end;
    }
    // Check that truncating at end won't break up an UTF-8 multibyte sequence half-way,
    // by peeking backwards to find the first byte of an UTF-8 sequence (if present).
    while (end > 2 && input.charAt(end - 3) == "%") {
        const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
        // Note: if parsing fails, NaN gets coerced to 0 by the bitwise and.
        if ((peekByte & UTF8_HIGH_BIT) != UTF8_HIGH_BIT) {
            break;
        }
        end -= 3;
        // Check if we reached the first byte by checking it is not a "follow byte": 10xx_xxxx.
        if ((peekByte & UTF8_HEADER_2) != UTF8_HIGH_BIT) {
            // If the full code point is there, keep it.
            if (limit - end >= utf8ByteCountFromFirstByte(peekByte) * 3) {
                end = limit;
            }
            // Otherwise, end is already set at the correct point to truncate at (the start of the multibyte sequence).
            break;
        }
    }
    return input.substring(0, end);
}

function getEventConfig(config) {
    const { trackingId } = config;
    return { trackingId };
}
function getSource(config) {
    return (config.source || []).concat([`relay@${version}`]);
}
function createMeta(type, config, environment, clientIdManager) {
    const { getReferrer, getLocation, getUserAgent } = environment;
    const eventConfig = getEventConfig(config);
    const clientId = clientIdManager.getClientId();
    return Object.freeze({
        type,
        config: eventConfig,
        ts: Date.now(),
        source: getSource(config),
        clientId,
        userAgent: getUserAgent(),
        referrer: truncate(getReferrer()),
        location: truncate(getLocation()),
    });
}
function truncate(url) {
    const limit = 1024;
    return url !== null ? truncateUrl(url, limit) : null;
}

function createRelayEvent(type, payload, config, environment, clientIdManager) {
    return {
        ...payload,
        meta: createMeta(type, config, environment, clientIdManager),
    };
}

const ANY_EVENT_TYPE = "*";
function createListenerManager() {
    const listeners = [];
    function getListenerIndex({ type, callback }) {
        return listeners.findIndex((listener) => listener.type === type && listener.callback === callback);
    }
    function isMatchesType(listener, type) {
        return listener.type === "*" || type === listener.type;
    }
    function add(listener) {
        if (getListenerIndex(listener) < 0) {
            listeners.push(listener);
        }
        return () => remove(listener.type, listener.callback);
    }
    function call(event) {
        listeners.forEach((listener) => {
            if (isMatchesType(listener, event.meta.type)) {
                try {
                    listener.callback(event);
                }
                catch (e) {
                    console.error(e);
                }
            }
        });
    }
    function removeMultiple(type) {
        if (type === ANY_EVENT_TYPE) {
            listeners.length = 0;
        }
        else {
            for (let i = listeners.length - 1; i >= 0; i--) {
                if (listeners[i].type === type) {
                    listeners.splice(i, 1);
                }
            }
        }
    }
    function removeOne(listener) {
        const index = getListenerIndex(listener);
        if (index >= 0) {
            listeners.splice(index, 1);
        }
    }
    function remove(type, callback) {
        if (callback) {
            removeOne({ type, callback });
        }
        else {
            removeMultiple(type);
        }
    }
    return {
        add,
        call,
        remove,
    };
}

function pick({ url, token, trackingId, ...rest }) {
    return Object.freeze({
        url,
        token,
        trackingId,
        ...(!!rest.mode && { mode: rest.mode }),
        ...(!!rest.source && { source: rest.source }),
        ...(!!rest.environment && { environment: rest.environment }),
    });
}
function createConfigManager(initialConfig) {
    let _config = pick(initialConfig);
    return {
        get: () => _config,
        update: (updatedConfig) => {
            _config = pick({ ..._config, ...updatedConfig });
        },
    };
}

const cookieManager = createCookieManager();
function createCookieManager() {
    const prefix = "coveo_";
    const getDomain = (host) => {
        const parts = host.split(".").slice(-2);
        return parts.length == 2 ? parts.join(".") : "";
    };
    return {
        getItem(key) {
            const cookiePrefix = `${prefix}${key}=`;
            const cookieArray = document.cookie.split(";");
            for (const cookie of cookieArray) {
                const prettifyCookie = cookie.replace(/^\s+/, "");
                if (prettifyCookie.lastIndexOf(cookiePrefix, 0) === 0) {
                    return prettifyCookie.substring(cookiePrefix.length, prettifyCookie.length);
                }
            }
            return null;
        },
        setItem(key, data, expire) {
            const domain = getDomain(window.location.hostname);
            const expireSection = `;expires=${new Date(new Date().getTime() + expire).toUTCString()}`;
            const domainSection = domain ? `;domain=${domain}` : "";
            document.cookie = `${prefix}${key}=${data}${expireSection}${domainSection};path=/;SameSite=Lax`;
        },
        removeItem(key) {
            this.setItem(key, "", -1);
        },
    };
}

function createBrowserStorage() {
    return {
        getItem(key) {
            return cookieManager.getItem(key) || localStorage.getItem(key);
        },
        removeItem(key) {
            cookieManager.removeItem(key);
            localStorage.removeItem(key);
        },
        setItem(key, data) {
            const oneYear = 31556952000;
            localStorage.setItem(key, data);
            cookieManager.setItem(key, data, oneYear);
        },
    };
}

function getReferrer() {
    const referrer = document.referrer;
    return referrer === "" ? null : referrer;
}
function buildBrowserEnvironment() {
    return {
        runtime: "browser",
        send: (url, token, event) => {
            const response = navigator.sendBeacon(`${url}?access_token=${token}`, new Blob([JSON.stringify([event])], {
                type: "application/json",
            }));
            const messenger = createExplorerMessenger();
            messenger.sendMessage({ kind: "EVENT_PROTOCOL", event, url, token });
            if (!response) {
                throw new Error(`Failed to send the event(s) because the payload size exceeded the maximum allowed size (32 KB). Please contact support if the problem persists.`);
            }
        },
        getReferrer: () => getReferrer(),
        getLocation: () => window.location.href,
        getUserAgent: () => navigator.userAgent,
        generateUUID: () => v4(),
        storage: createBrowserStorage(),
    };
}

// From: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#feature-detecting_localstorage
function localStorageAvailable() {
    try {
        const x = "__storage_test__";
        localStorage.setItem(x, x);
        localStorage.removeItem(x);
        return true;
    }
    catch (e) {
        return (e instanceof DOMException &&
            e.name === "QuotaExceededError" &&
            // acknowledge QuotaExceededError only if there's something already stored
            localStorage &&
            localStorage.length !== 0);
    }
}

function createNullStorage() {
    return {
        getItem() {
            return null;
        },
        removeItem() {
            return;
        },
        setItem() {
            return;
        },
    };
}

function buildNullEnvironment() {
    return {
        runtime: "null",
        send: () => undefined,
        getReferrer: () => null,
        getLocation: () => null,
        getUserAgent: () => null,
        generateUUID: () => "",
        storage: createNullStorage(),
    };
}

function buildEnvironment(configManager) {
    const active = configManager.get().mode !== "disabled";
    const environmentFromConfig = configManager.get().environment;
    const nullEnvironment = buildNullEnvironment();
    if (active && environmentFromConfig) {
        return {
            storage: nullEnvironment.storage,
            ...environmentFromConfig,
            runtime: "custom",
        };
    }
    if (active && isBrowser() && localStorageAvailable()) {
        return buildBrowserEnvironment();
    }
    return nullEnvironment;
}
function isBrowser() {
    try {
        return typeof window === "object";
    }
    catch {
        return false;
    }
}
function createEnvironmentManager(configManager) {
    return {
        get: () => Object.freeze(buildEnvironment(configManager)),
    };
}

/**
 * Initializes the Relay library object.
 * @param {RelayConfig} initialConfig
 * @returns {Relay}
 */
function createRelay(initialConfig) {
    const configManager = createConfigManager(initialConfig);
    const listenerManager = createListenerManager();
    const environmentManager = createEnvironmentManager(configManager);
    const clientIdManager = createClientIdManager(environmentManager);
    return {
        emit: (type, payload) => {
            const config = configManager.get();
            const environment = environmentManager.get();
            const event = createRelayEvent(type, payload, config, environment, clientIdManager);
            return emit({
                config,
                environment,
                event,
                listenerManager,
            });
        },
        getMeta: (type) => createMeta(type, configManager.get(), environmentManager.get(), clientIdManager),
        on: (type, callback) => listenerManager.add({ type, callback }),
        off: (type, callback) => listenerManager.remove(type, callback),
        updateConfig: (config) => configManager.update(config),
        version,
    };
}

export { buildBrowserEnvironment, clientIdKey, createRelay };
