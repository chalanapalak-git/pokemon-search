import { ArrayValue, BooleanValue, NumberValue, RecordValue, StringValue, } from '@coveo/bueno';
import { createAction, createAsyncThunk } from '@reduxjs/toolkit';
import { initiateFollowUpEndpoint } from '../../api/knowledge/answer-generation/endpoints/follow-up/follow-up-endpoint.js';
import { requiredNonEmptyString, validatePayload, } from '../../utils/validate-payload.js';
import { selectAgentId } from '../configuration/configuration-selectors.js';
import { answerContentFormatSchema, citationSchema, } from '../generated-answer/generated-answer-actions.js';
import { constructGenerateFollowUpAnswerParams, } from './follow-up-answer-request.js';
const stringValue = new StringValue({ required: true });
export const setIsEnabled = createAction('followUpAnswers/setIsEnabled', (payload) => validatePayload(payload, new BooleanValue({ required: true })));
export const setFollowUpAnswersConversationId = createAction('followUpAnswers/setFollowUpAnswersConversationId', (payload) => validatePayload(payload, requiredNonEmptyString));
export const createFollowUpAnswer = createAction('followUpAnswers/createFollowUpAnswer', (payload) => validatePayload(payload, {
    question: requiredNonEmptyString,
}));
export const setActiveFollowUpAnswerId = createAction('followUpAnswers/setActiveFollowUpAnswerId', (payload) => validatePayload(payload, requiredNonEmptyString));
export const setFollowUpAnswerContentFormat = createAction('followUpAnswers/setFollowUpAnswerContentFormat', (payload) => validatePayload(payload, {
    contentFormat: answerContentFormatSchema,
    answerId: requiredNonEmptyString,
}));
export const setFollowUpIsLoading = createAction('followUpAnswers/setFollowUpIsLoading', (payload) => validatePayload(payload, {
    isLoading: new BooleanValue({ required: true }),
    answerId: requiredNonEmptyString,
}));
export const followUpMessageChunkReceived = createAction('followUpAnswers/followUpMessageChunkReceived', (payload) => validatePayload(payload, {
    textDelta: stringValue,
    answerId: requiredNonEmptyString,
}));
export const followUpCitationsReceived = createAction('followUpAnswers/followUpCitationsReceived', (payload) => validatePayload(payload, {
    citations: new ArrayValue({
        required: true,
        each: new RecordValue({
            values: citationSchema,
        }),
    }),
    answerId: requiredNonEmptyString,
}));
export const followUpCompleted = createAction('followUpAnswers/followUpCompleted', (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
    cannotAnswer: new BooleanValue({ required: false }),
}));
export const followUpFailed = createAction('followUpAnswers/followUpFailed', (payload) => validatePayload(payload, {
    message: new StringValue(),
    code: new NumberValue({ min: 0 }),
    answerId: requiredNonEmptyString,
}));
export const likeFollowUp = createAction('followUpAnswers/likeFollowUp', (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
}));
export const dislikeFollowUp = createAction('followUpAnswers/dislikeFollowUp', (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
}));
export const submitFollowUpFeedback = createAction('followUpAnswers/submitFollowUpFeedback', (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
}));
export const resetFollowUpAnswers = createAction('followUpAnswers/resetFollowUpAnswers');
export const generateFollowUpAnswer = createAsyncThunk('generatedAnswerWithFollowUps/generateFollowUpAnswer', async (question, { getState, dispatch, extra: { logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state)?.trim();
    const generateFollowUpAnswerParams = constructGenerateFollowUpAnswerParams(question, state);
    if (!agentId) {
        logger.warn('Missing agentId in engine configuration. ' +
            'The generateFollowUpAnswer action requires an agent ID.');
        return;
    }
    if (!generateFollowUpAnswerParams.conversationId) {
        logger.warn('Missing conversationId when generating a follow-up answer. ' +
            'The generateFollowUpAnswer action requires an existing conversation.');
        return;
    }
    dispatch(createFollowUpAnswer({ question }));
    await dispatch(initiateFollowUpEndpoint({
        strategyKey: 'follow-up-answer',
        ...generateFollowUpAnswerParams,
    }));
});
