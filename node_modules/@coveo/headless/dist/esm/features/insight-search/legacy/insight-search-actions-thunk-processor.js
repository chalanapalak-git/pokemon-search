import { isNullOrUndefined } from '@coveo/bueno';
import { isErrorResponse, isSuccessResponse, } from '../../../api/search/search-api-client.js';
import { applyDidYouMeanCorrection } from '../../did-you-mean/did-you-mean-actions.js';
import { logDidYouMeanAutomatic } from '../../did-you-mean/did-you-mean-insight-analytics-actions.js';
import { snapshot } from '../../history/history-actions.js';
import { extractHistory } from '../../history/history-state.js';
import { updateQuery } from '../../query/query-actions.js';
import { getQueryInitialState } from '../../query/query-state.js';
import { mapSearchResponse, } from '../../search/search-mappings.js';
import { getSearchInitialState } from '../../search/search-state.js';
import { logQueryError } from '../insight-search-analytics-actions.js';
import { buildInsightSearchRequest } from '../insight-search-request.js';
export class AsyncInsightSearchThunkProcessor {
    config;
    onUpdateQueryForCorrection;
    constructor(config, onUpdateQueryForCorrection = (modification) => {
        this.dispatch(updateQuery({ q: modification }));
    }) {
        this.config = config;
        this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
    }
    async fetchFromAPI({ request, mappings }, options) {
        const startedAt = Date.now();
        const response = mapSearchResponse(await this.extra.apiClient.query(request, options), mappings);
        const duration = Date.now() - startedAt;
        const queryExecuted = this.getState().query?.q || '';
        return {
            response,
            duration,
            queryExecuted,
            requestExecuted: request,
        };
    }
    async process(fetched, mappedRequest) {
        return (this.processQueryErrorOrContinue(fetched) ??
            (await this.processQueryCorrectionsOrContinue(fetched, mappedRequest)) ??
            this.processSuccessResponse(fetched));
    }
    processQueryErrorOrContinue(fetched) {
        if (isErrorResponse(fetched.response)) {
            this.dispatch(logQueryError(fetched.response.error));
            return this.rejectWithValue(fetched.response.error);
        }
        return null;
    }
    async processQueryCorrectionsOrContinue(fetched, mappedRequest) {
        const state = this.getState();
        const successResponse = this.getSuccessResponse(fetched);
        if (!successResponse || !state.didYouMean) {
            return null;
        }
        const { enableDidYouMean, automaticallyCorrectQuery } = state.didYouMean;
        const { results, queryCorrections, queryCorrection } = successResponse;
        if (!enableDidYouMean || !automaticallyCorrectQuery) {
            return null;
        }
        const shouldExecuteLegacyDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
        const shouldExecuteNextDidYouMeanAutoCorrection = !isNullOrUndefined(queryCorrection) &&
            !isNullOrUndefined(queryCorrection.correctedQuery);
        const shouldExitWithNoAutoCorrection = !shouldExecuteLegacyDidYouMeanAutoCorrection &&
            !shouldExecuteNextDidYouMeanAutoCorrection;
        if (shouldExitWithNoAutoCorrection) {
            return null;
        }
        const processedDidYouMean = shouldExecuteLegacyDidYouMeanAutoCorrection
            ? await this.processLegacyDidYouMeanAutoCorrection(fetched)
            : this.processNextDidYouMeanAutoCorrection(fetched);
        this.logOriginalAnalyticsQueryBeforeAutoCorrection(fetched, mappedRequest);
        this.dispatch(snapshot(extractHistory(this.getState())));
        return processedDidYouMean;
    }
    async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
        const originalQuery = this.getCurrentQuery();
        const originalSearchSuccessResponse = this.getSuccessResponse(originalFetchedResponse);
        if (!originalSearchSuccessResponse.queryCorrections) {
            return null;
        }
        const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
        const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
        if (isErrorResponse(retried.response)) {
            this.dispatch(logQueryError(retried.response.error));
            return this.rejectWithValue(retried.response.error);
        }
        this.dispatch(snapshot(extractHistory(this.getState())));
        return {
            ...retried,
            response: {
                ...retried.response.success,
                queryCorrections: originalSearchSuccessResponse.queryCorrections,
            },
            automaticallyCorrected: true,
            originalQuery,
            analyticsAction: logDidYouMeanAutomatic(),
        };
    }
    processNextDidYouMeanAutoCorrection(originalFetchedResponse) {
        const successResponse = this.getSuccessResponse(originalFetchedResponse);
        const { correctedQuery, originalQuery } = successResponse.queryCorrection;
        this.onUpdateQueryForCorrection(correctedQuery);
        return {
            ...originalFetchedResponse,
            response: {
                ...successResponse,
            },
            queryExecuted: correctedQuery,
            automaticallyCorrected: true,
            originalQuery,
            analyticsAction: logDidYouMeanAutomatic(),
        };
    }
    async automaticallyRetryQueryWithCorrection(correction) {
        this.dispatch(updateQuery({ q: correction }));
        const state = this.getState();
        const fetched = await this.fetchFromAPI(await buildInsightSearchRequest(state));
        this.dispatch(applyDidYouMeanCorrection(correction));
        return fetched;
    }
    processSuccessResponse(fetched) {
        this.dispatch(snapshot(extractHistory(this.getState())));
        return {
            ...fetched,
            response: this.getSuccessResponse(fetched),
            automaticallyCorrected: false,
            originalQuery: this.getCurrentQuery(),
            analyticsAction: this.analyticsAction,
        };
    }
    getSuccessResponse(fetched) {
        if (isSuccessResponse(fetched.response)) {
            return fetched.response.success;
        }
        return null;
    }
    getStateAfterResponse(query, duration, previousState, response) {
        return {
            ...previousState,
            query: {
                q: query,
                enableQuerySyntax: previousState.query?.enableQuerySyntax ??
                    getQueryInitialState().enableQuerySyntax,
            },
            search: {
                ...getSearchInitialState(),
                duration,
                response,
                results: response.results,
            },
        };
    }
    logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse, mappedRequest) {
        const state = this.getState();
        const fetchedResponse = mapSearchResponse(originalFetchedResponse.response, mappedRequest.mappings).success;
        this.analyticsAction?.()(this.dispatch, () => this.getStateAfterResponse(originalFetchedResponse.queryExecuted, originalFetchedResponse.duration, state, fetchedResponse), this.extra);
    }
    get extra() {
        return this.config.extra;
    }
    getState() {
        return this.config.getState();
    }
    get dispatch() {
        return this.config.dispatch;
    }
    get rejectWithValue() {
        return this.config.rejectWithValue;
    }
    getCurrentQuery() {
        const state = this.getState();
        return state.query?.q !== undefined ? state.query.q : '';
    }
    get analyticsAction() {
        return this.config.analyticsAction;
    }
}
