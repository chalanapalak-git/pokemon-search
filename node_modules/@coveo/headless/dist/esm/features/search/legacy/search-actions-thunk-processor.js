import { isNullOrUndefined } from '@coveo/bueno';
import { isErrorResponse, isSuccessResponse, } from '../../../api/search/search-api-client.js';
import { applyDidYouMeanCorrection } from '../../did-you-mean/did-you-mean-actions.js';
import { logDidYouMeanAutomatic } from '../../did-you-mean/did-you-mean-analytics-actions.js';
import { snapshot } from '../../history/history-actions.js';
import { extractHistory } from '../../history/history-state.js';
import { updateQuery } from '../../query/query-actions.js';
import { getQueryInitialState } from '../../query/query-state.js';
import { logTriggerQuery } from '../../triggers/trigger-analytics-actions.js';
import { applyQueryTriggerModification, updateIgnoreQueryTrigger, } from '../../triggers/triggers-actions.js';
import { logQueryError } from '../search-analytics-actions.js';
import { mapSearchResponse, } from '../search-mappings.js';
import { getSearchInitialState } from '../search-state.js';
import { buildSearchRequest } from './search-request.js';
export class AsyncSearchThunkProcessor {
    config;
    onUpdateQueryForCorrection;
    constructor(config, onUpdateQueryForCorrection = (modification) => {
        this.dispatch(updateQuery({ q: modification }));
    }) {
        this.config = config;
        this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
    }
    async fetchFromAPI({ mappings, request }, options) {
        const startedAt = Date.now();
        const response = mapSearchResponse(await this.extra.apiClient.search(request, options), mappings);
        const duration = Date.now() - startedAt;
        const queryExecuted = this.getState().query?.q || '';
        return { response, duration, queryExecuted, requestExecuted: request };
    }
    async process(fetched) {
        return (this.processQueryErrorOrContinue(fetched) ??
            (await this.processQueryCorrectionsOrContinue(fetched)) ??
            (await this.processQueryTriggersOrContinue(fetched)) ??
            this.processSuccessResponse(fetched));
    }
    processQueryErrorOrContinue(fetched) {
        if (isErrorResponse(fetched.response)) {
            this.dispatch(logQueryError(fetched.response.error));
            return this.rejectWithValue(fetched.response.error);
        }
        return null;
    }
    async processQueryCorrectionsOrContinue(fetched) {
        const state = this.getState();
        const successResponse = this.getSuccessResponse(fetched);
        if (!successResponse || !state.didYouMean) {
            return null;
        }
        const { enableDidYouMean, automaticallyCorrectQuery } = state.didYouMean;
        const { results, queryCorrections, queryCorrection } = successResponse;
        if (!enableDidYouMean || !automaticallyCorrectQuery) {
            return null;
        }
        const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
        const shouldExecuteModernDidYouMeanAutoCorrection = !isNullOrUndefined(queryCorrection) &&
            !isNullOrUndefined(queryCorrection.correctedQuery);
        const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection &&
            !shouldExecuteModernDidYouMeanAutoCorrection;
        if (shouldExitWithNoAutoCorrection) {
            return null;
        }
        const ret = shouldExecuteClassicDidYouMeanAutoCorrection
            ? await this.processLegacyDidYouMeanAutoCorrection(fetched)
            : this.processModernDidYouMeanAutoCorrection(fetched);
        this.dispatch(snapshot(extractHistory(this.getState())));
        return ret;
    }
    async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
        const originalQuery = this.getCurrentQuery();
        const originalSearchSuccessResponse = this.getSuccessResponse(originalFetchedResponse);
        if (!originalSearchSuccessResponse.queryCorrections) {
            return null;
        }
        const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
        const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
        if (isErrorResponse(retried.response)) {
            this.dispatch(logQueryError(retried.response.error));
            return this.rejectWithValue(retried.response.error);
        }
        this.logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse);
        this.dispatch(snapshot(extractHistory(this.getState())));
        return {
            ...retried,
            response: {
                ...retried.response.success,
                queryCorrections: originalSearchSuccessResponse.queryCorrections,
            },
            automaticallyCorrected: true,
            originalQuery,
            analyticsAction: logDidYouMeanAutomatic(),
        };
    }
    processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
        const successResponse = this.getSuccessResponse(originalFetchedResponse);
        const { correctedQuery, originalQuery } = successResponse.queryCorrection;
        this.onUpdateQueryForCorrection(correctedQuery);
        return {
            ...originalFetchedResponse,
            response: {
                ...successResponse,
            },
            queryExecuted: correctedQuery,
            automaticallyCorrected: true,
            originalQuery,
            analyticsAction: logDidYouMeanAutomatic(),
        };
    }
    logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse) {
        const state = this.getState();
        const successResponse = this.getSuccessResponse(originalFetchedResponse);
        this.analyticsAction?.()(this.dispatch, () => this.getStateAfterResponse(originalFetchedResponse.queryExecuted, originalFetchedResponse.duration, state, successResponse), this.extra);
    }
    async processQueryTriggersOrContinue(fetched) {
        const successResponse = this.getSuccessResponse(fetched);
        if (!successResponse) {
            return null;
        }
        const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === 'query')
            ?.content || '';
        if (!correctedQuery) {
            return null;
        }
        const ignored = this.getState().triggers?.queryModification.queryToIgnore;
        if (ignored === correctedQuery) {
            this.dispatch(updateIgnoreQueryTrigger(''));
            return null;
        }
        if (this.analyticsAction) {
            await this.dispatch(this.analyticsAction);
        }
        const originalQuery = this.getCurrentQuery();
        const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
        if (isErrorResponse(retried.response)) {
            this.dispatch(logQueryError(retried.response.error));
            return this.rejectWithValue(retried.response.error);
        }
        this.dispatch(snapshot(extractHistory(this.getState())));
        return {
            ...retried,
            response: {
                ...retried.response.success,
            },
            automaticallyCorrected: false,
            originalQuery,
            analyticsAction: logTriggerQuery(),
        };
    }
    getStateAfterResponse(query, duration, previousState, response) {
        return {
            ...previousState,
            query: {
                q: query,
                enableQuerySyntax: previousState.query?.enableQuerySyntax ??
                    getQueryInitialState().enableQuerySyntax,
            },
            search: {
                ...getSearchInitialState(),
                duration,
                response,
                results: response.results,
            },
        };
    }
    processSuccessResponse(fetched) {
        this.dispatch(snapshot(extractHistory(this.getState())));
        return {
            ...fetched,
            response: this.getSuccessResponse(fetched),
            automaticallyCorrected: false,
            originalQuery: this.getCurrentQuery(),
            analyticsAction: this.analyticsAction,
        };
    }
    getSuccessResponse(fetched) {
        if (isSuccessResponse(fetched.response)) {
            return fetched.response.success;
        }
        return null;
    }
    async automaticallyRetryQueryWithCorrection(correction) {
        this.onUpdateQueryForCorrection(correction);
        const fetched = await this.fetchFromAPI(await buildSearchRequest(this.getState()), { origin: 'mainSearch' });
        this.dispatch(applyDidYouMeanCorrection(correction));
        return fetched;
    }
    async automaticallyRetryQueryWithTriggerModification(modified) {
        this.dispatch(applyQueryTriggerModification({
            newQuery: modified,
            originalQuery: this.getCurrentQuery(),
        }));
        this.onUpdateQueryForCorrection(modified);
        const fetched = await this.fetchFromAPI(await buildSearchRequest(this.getState()), { origin: 'mainSearch' });
        return fetched;
    }
    getCurrentQuery() {
        const state = this.getState();
        return state.query?.q !== undefined ? state.query.q : '';
    }
    get extra() {
        return this.config.extra;
    }
    getState() {
        return this.config.getState();
    }
    get dispatch() {
        return this.config.dispatch;
    }
    get analyticsAction() {
        return this.config.analyticsAction;
    }
    get rejectWithValue() {
        return this.config.rejectWithValue;
    }
}
