import { isNullOrUndefined } from '@coveo/bueno';
import { arrayEqualStrictlyDifferentOrder } from '../../utils/compare-utils.js';
import { isValidKey, rangeDelimiterExclusive, rangeDelimiterInclusive, } from './search-parameter-serializer.js';
import { extendSearchParameters, isFacetPair, isRangeFacetPair, isValidSearchParam, } from './search-parameter-utils.js';
export function buildSSRSearchParameterSerializer() {
    return { toSearchParameters, serialize };
}
/**
 * Converts URLSearchParams or a record of search parameters into a {@link SearchParameters} object.
 *
 * @param urlSearchParams - The URLSearchParams or record of search parameters.
 * @returns The converted SearchParameters object.
 */
function toSearchParameters(urlSearchParams) {
    const searchParameters = {};
    const add = (key, value) => extendSearchParameters(searchParameters, key, value);
    if (urlSearchParams instanceof URLSearchParams) {
        urlSearchParams.forEach((value, key) => add(key, value));
    }
    else {
        Object.entries(urlSearchParams).forEach(([key, value]) => add(key, value));
    }
    return searchParameters;
}
/**
 * Serializes the search parameters to the provided URL.
 *
 * @param searchParameters - The search parameters to be serialized.
 * @param initialUrl - The initial URL to which the search parameters will be added.
 * @returns The serialized URL.
 */
function serialize(searchParameters, initialUrl) {
    const { searchParams } = initialUrl;
    const previousState = wipeSearchParamsFromUrl(searchParams);
    Object.entries(searchParameters).forEach(([key, value]) => isValidKey(key) &&
        applyToUrlSearchParam(searchParams, previousState, [key, value]));
    return initialUrl.href;
}
function wipeSearchParamsFromUrl(urlSearchParams) {
    const previousSearchParams = {};
    const keysToDelete = [];
    urlSearchParams.forEach((value, key) => {
        if (value !== undefined && isValidSearchParam(key)) {
            previousSearchParams[key] = [...(previousSearchParams[key] || []), value];
            keysToDelete.push(key);
        }
    });
    for (const key of keysToDelete) {
        urlSearchParams.delete(key);
    }
    return previousSearchParams;
}
function applyToUrlSearchParam(urlSearchParams, previousState, pair) {
    if (isNullOrUndefined(pair[1])) {
        return;
    }
    if (isFacetPair(pair)) {
        applyFacetValuesToSearchParams(urlSearchParams, previousState, pair);
        return;
    }
    if (isRangeFacetPair(pair)) {
        applyRangeFacetValuesToSearchParams(urlSearchParams, pair);
        return;
    }
    urlSearchParams.set(pair[0], `${pair[1]}`);
}
function applyFacetValuesToSearchParams(urlSearchParams, previousState, [key, value]) {
    Object.entries(value).forEach(([facetId, facetValues]) => {
        const id = `${key}-${facetId}`;
        const previousFacetValues = previousState[id] ?? [];
        // Verify whether the API has provided an identical set of values but with a different sorting order. In such a scenario, refrain from updating the URL. Instead, revert to the previous state and disregard the altered state with the modified order. This ensures that a new entry is not added to the history unless there is a change beyond just the sorting order.
        if (arrayEqualStrictlyDifferentOrder(previousFacetValues, value[facetId])) {
            previousFacetValues.forEach((v) => urlSearchParams.append(id, v));
            return;
        }
        urlSearchParams.delete(id);
        facetValues.forEach((v) => urlSearchParams.append(id, v));
    });
}
function applyRangeFacetValuesToSearchParams(urlSearchParams, [key, value]) {
    Object.entries(value).forEach(([facetId, facetValues]) => {
        const id = `${key}-${facetId}`;
        urlSearchParams.delete(id);
        facetValues.forEach(({ start, end, endInclusive }) => urlSearchParams.append(id, `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`));
    });
}
