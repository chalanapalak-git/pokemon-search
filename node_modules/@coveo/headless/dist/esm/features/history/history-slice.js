import { createReducer } from '@reduxjs/toolkit';
import { undoable } from '../../app/undoable.js';
import { arrayEqual } from '../../utils/compare-utils.js';
import { findActiveValueAncestry } from '../facets/category-facet-set/category-facet-utils.js';
import { redo, snapshot, undo } from './history-actions.js';
import { getHistoryInitialState } from './history-state.js';
// TODO: https://coveord.atlassian.net/browse/KIT-2969:
// Should be able to remove most of the code in this file following changes history management change
export const historyReducer = createReducer(getHistoryInitialState(), (builder) => {
    builder.addCase(snapshot, (state, action) => isEqual(state, action.payload) ? undefined : action.payload);
});
const isEqual = (current, next) => {
    return (isContextEqual(current.context, next.context) &&
        isDictionaryFieldContextEqual(current.dictionaryFieldContext, next.dictionaryFieldContext) &&
        isAdvancedSearchQueriesEqual(current.advancedSearchQueries, next.advancedSearchQueries) &&
        isTabSetEqual(current.tabSet, next.tabSet) &&
        isStaticFilterSetEqual(current.staticFilterSet, next.staticFilterSet) &&
        isFacetsEqual(current.facetSet, next.facetSet) &&
        isFacetsEqual(current.dateFacetSet, next.dateFacetSet) &&
        isFacetsEqual(current.numericFacetSet, next.numericFacetSet) &&
        isAutomaticFacetsEqual(current.automaticFacetSet, next.automaticFacetSet) &&
        isCategoryFacetsEqual(current.categoryFacetSet, next.categoryFacetSet) &&
        isPaginationEqual(current.pagination, next.pagination) &&
        isQueryEqual(current.query, next.query) &&
        isSortEqual(current, next) &&
        isPipelineEqual(current.pipeline, next.pipeline) &&
        isSearchHubEqual(current.searchHub, next.searchHub) &&
        isFacetOrderEqual(current.facetOrder, next.facetOrder) &&
        isDebugEqual(current.debug, next.debug));
};
const isContextEqual = (current, next) => JSON.stringify(current.contextValues) === JSON.stringify(next.contextValues);
const isDictionaryFieldContextEqual = (current, next) => JSON.stringify(current.contextValues) === JSON.stringify(next.contextValues);
const isTabSetEqual = (current, next) => {
    const currentTab = findActiveTab(current);
    const nextTab = findActiveTab(next);
    return currentTab?.id === nextTab?.id;
};
const findActiveTab = (tabSet) => {
    return Object.values(tabSet).find((tab) => tab.isActive);
};
const isStaticFilterSetEqual = (current, next) => {
    for (const [id, filter] of Object.entries(next)) {
        if (!current[id]) {
            return false;
        }
        const currentValues = getActiveStaticFilterValues(current[id]);
        const nextValues = getActiveStaticFilterValues(filter);
        if (JSON.stringify(currentValues) !== JSON.stringify(nextValues)) {
            return false;
        }
    }
    return true;
};
const getActiveStaticFilterValues = (filter) => {
    return filter.values.filter((value) => value.state !== 'idle');
};
const isFacetsEqual = (current, next) => {
    for (const [key, value] of Object.entries(next)) {
        if (!current[key]) {
            return false;
        }
        const currentSelectedValues = current[key].request.currentValues.filter((value) => value.state !== 'idle');
        const nextSelectedValues = value.request.currentValues.filter((value) => value.state !== 'idle');
        if (JSON.stringify(currentSelectedValues) !==
            JSON.stringify(nextSelectedValues)) {
            return false;
        }
    }
    return true;
};
const isCategoryFacetsEqual = (current, next) => {
    for (const [key, value] of Object.entries(next)) {
        if (!current[key]) {
            return false;
        }
        const currentSelectedValues = findActiveValueAncestry(current[key]?.request.currentValues).map(({ value }) => value);
        const nextSelectedValues = findActiveValueAncestry(value?.request.currentValues).map(({ value }) => value);
        if (JSON.stringify(currentSelectedValues) !==
            JSON.stringify(nextSelectedValues)) {
            return false;
        }
    }
    return true;
};
const isAutomaticFacetsEqual = (current, next) => {
    for (const [key, value] of Object.entries(next.set)) {
        if (!current.set[key]) {
            return false;
        }
        const currentSelectedValues = current.set[key].response.values.filter((value) => value.state !== 'idle');
        const nextSelectedValues = value.response.values.filter((value) => value.state !== 'idle');
        if (JSON.stringify(currentSelectedValues) !==
            JSON.stringify(nextSelectedValues)) {
            return false;
        }
    }
    return true;
};
const isPaginationEqual = (current, next) => current.firstResult === next.firstResult &&
    current.numberOfResults === next.numberOfResults;
const isQueryEqual = (current, next) => JSON.stringify(current) === JSON.stringify(next);
const isAdvancedSearchQueriesEqual = (current, next) => JSON.stringify(current) === JSON.stringify(next);
const isSortEqual = (current, next) => current.sortCriteria === next.sortCriteria;
const isPipelineEqual = (current, next) => current === next;
const isSearchHubEqual = (current, next) => current === next;
const isFacetOrderEqual = (current, next) => arrayEqual(current, next);
const isDebugEqual = (current, next) => current === next;
export const history = undoable({
    actionTypes: {
        redo: redo.type,
        undo: undo.type,
        snapshot: snapshot.type,
    },
    reducer: historyReducer,
});
