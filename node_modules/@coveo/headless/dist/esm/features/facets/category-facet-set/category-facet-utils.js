export function partitionIntoParentsAndValues(nestedValues) {
    if (!nestedValues) {
        return { parents: [], values: [] };
    }
    let parents = [];
    let values = nestedValues;
    while (values.length && values[0].children.length) {
        parents = [...parents, ...values];
        values = values[0].children;
    }
    const selectedLeafValue = values.find((v) => v.state === 'selected');
    if (selectedLeafValue) {
        parents = [...parents, selectedLeafValue];
        values = [];
    }
    return { parents, values };
}
export function findActiveValueAncestry(valuesAsTree) {
    const { activeValue, ancestryMap } = getActiveValueAndAncestryFromValueTree(valuesAsTree);
    return activeValue ? getActiveValueAncestry(activeValue, ancestryMap) : [];
}
function getActiveValueAndAncestryFromValueTree(valuesAsTrees) {
    const valueToVisit = [...valuesAsTrees];
    const ancestryMap = new Map();
    while (valueToVisit.length > 0) {
        const currentValue = valueToVisit.shift();
        if (currentValue.state === 'selected') {
            return { activeValue: currentValue, ancestryMap };
        }
        if (ancestryMap) {
            for (const childValue of currentValue.children) {
                ancestryMap.set(childValue, currentValue);
            }
        }
        valueToVisit.unshift(...currentValue.children);
    }
    return {};
}
function getActiveValueAncestry(activeValue, valueToParentMap) {
    const activeValueAncestry = [];
    if (!activeValue) {
        return [];
    }
    let lastParent = activeValue;
    do {
        activeValueAncestry.unshift(lastParent);
        lastParent = valueToParentMap.get(lastParent);
    } while (lastParent);
    return activeValueAncestry;
}
