import { ArrayValue, BooleanValue, NumberValue, RecordValue, StringValue, Value, } from '@coveo/bueno';
import { createAction } from '@reduxjs/toolkit';
import { parseDate } from '../../../../api/search/date/date-format.js';
import { formatRelativeDateForSearchApi, isRelativeDateFormat, } from '../../../../api/search/date/relative-date.js';
import { buildDateRange } from '../../../../controllers/core/facets/range-facet/date-facet/date-range.js';
import { requiredNonEmptyString, serializeSchemaValidationError, validatePayload, validatePayloadAndThrow, } from '../../../../utils/validate-payload.js';
import { deselectAllFacetValues } from '../../facet-set/facet-set-actions.js';
import { facetIdDefinition } from '../../generic/facet-actions-validation.js';
import { updateRangeFacetSortCriterion } from '../generic/range-facet-actions.js';
import { dateFacetValueDefinition } from '../generic/range-facet-validate-payload.js';
const dateRangeRequestDefinition = {
    start: requiredNonEmptyString,
    end: requiredNonEmptyString,
    endInclusive: new BooleanValue({ required: true }),
    state: requiredNonEmptyString,
};
const dateFacetRegistrationOptionsDefinition = {
    facetId: facetIdDefinition,
    field: requiredNonEmptyString,
    tabs: new RecordValue({
        options: {
            required: false,
        },
        values: {
            included: new ArrayValue({ each: new StringValue() }),
            excluded: new ArrayValue({ each: new StringValue() }),
        },
    }),
    activeTab: new StringValue({ required: false }),
    currentValues: new ArrayValue({
        required: false,
        each: new RecordValue({ values: dateRangeRequestDefinition }),
    }),
    generateAutomaticRanges: new BooleanValue({ required: true }),
    filterFacetCount: new BooleanValue({ required: false }),
    injectionDepth: new NumberValue({ required: false, min: 0 }),
    numberOfValues: new NumberValue({ required: false, min: 1 }),
    sortCriteria: new Value({ required: false }),
    rangeAlgorithm: new Value({ required: false }),
};
function getAbsoluteDate(date) {
    return isRelativeDateFormat(date)
        ? formatRelativeDateForSearchApi(date)
        : date;
}
export function validateManualDateRanges(options) {
    if (!options.currentValues) {
        return;
    }
    options.currentValues.forEach((value) => {
        const { start, end } = buildDateRange(value);
        if (parseDate(getAbsoluteDate(start)).isAfter(parseDate(getAbsoluteDate(end)))) {
            throw new Error(`The start value is greater than the end value for the date range ${value.start} to ${value.end}`);
        }
    });
}
export const registerDateFacet = createAction('dateFacet/register', (payload) => {
    try {
        validatePayloadAndThrow(payload, dateFacetRegistrationOptionsDefinition);
        validateManualDateRanges(payload);
        return { payload, error: null };
    }
    catch (error) {
        return { payload, error: serializeSchemaValidationError(error) };
    }
});
export const toggleSelectDateFacetValue = createAction('dateFacet/toggleSelectValue', (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new RecordValue({ values: dateFacetValueDefinition }),
}));
export const toggleExcludeDateFacetValue = createAction('dateFacet/toggleExcludeValue', (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new RecordValue({ values: dateFacetValueDefinition }),
}));
export const updateDateFacetValues = createAction('dateFacet/updateFacetValues', (payload) => {
    try {
        validatePayloadAndThrow(payload, {
            facetId: facetIdDefinition,
            values: new ArrayValue({
                each: new RecordValue({ values: dateFacetValueDefinition }),
            }),
        });
        validateManualDateRanges({ currentValues: payload.values });
        return { payload, error: null };
    }
    catch (error) {
        return { payload, error: serializeSchemaValidationError(error) };
    }
});
export const updateDateFacetSortCriterion = updateRangeFacetSortCriterion;
export const deselectAllDateFacetValues = deselectAllFacetValues;
