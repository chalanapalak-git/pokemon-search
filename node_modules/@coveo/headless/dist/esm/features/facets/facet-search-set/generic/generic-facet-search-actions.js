import { createAction, createAsyncThunk, } from '@reduxjs/toolkit';
import { requiredNonEmptyString, validatePayload, } from '../../../../utils/validate-payload.js';
import { facetIdDefinition } from '../../generic/facet-actions-validation.js';
import { buildCategoryFacetSearchRequest } from '../category/category-facet-search-request-builder.js';
import { buildSpecificFacetSearchRequest } from '../specific/specific-facet-search-request-builder.js';
const getExecuteFacetSearchThunkPayloadCreator = (isFieldSuggestionsRequest) => async (facetId, { getState, extra: { apiClient, validatePayload, navigatorContext } }) => {
    const state = getState();
    let req;
    validatePayload(facetId, requiredNonEmptyString);
    if (isSpecificFacetSearchState(state, facetId)) {
        req = await buildSpecificFacetSearchRequest(facetId, state, navigatorContext, isFieldSuggestionsRequest);
    }
    else {
        req = await buildCategoryFacetSearchRequest(facetId, state, navigatorContext, isFieldSuggestionsRequest);
    }
    const response = await apiClient.facetSearch(req);
    return { facetId, response };
};
export const executeFacetSearch = createAsyncThunk('facetSearch/executeSearch', getExecuteFacetSearchThunkPayloadCreator(false));
export const executeFieldSuggest = createAsyncThunk('facetSearch/executeSearch', getExecuteFacetSearchThunkPayloadCreator(true)); // We use the same action type because this action is meant to be handled by reducers the same way.
export const clearFacetSearch = createAction('facetSearch/clearResults', (payload) => validatePayload(payload, { facetId: facetIdDefinition }));
const isSpecificFacetSearchState = (s, facetId) => {
    return (s.facetSearchSet !== undefined &&
        s.facetSet !== undefined &&
        s.facetSet[facetId] !== undefined);
};
