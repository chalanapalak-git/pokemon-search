import { isNullOrUndefined } from '@coveo/bueno';
import { emptyQuestionAnswer } from '../../features/search/search-state.js';
import { pickNonBaseParams, unwrapError } from '../api-client-utils.js';
import { PlatformClient } from '../platform-client.js';
import { APICallsQueue } from './api-calls-queue.js';
import { getHtml } from './html/html-api-client.js';
import { buildAPIResponseFromErrorOrThrow, } from './search-api-error-response.js';
import { baseSearchRequest } from './search-api-params.js';
export class SearchAPIClient {
    options;
    constructor(options) {
        this.options = options;
    }
    async plan(req) {
        const response = await PlatformClient.call({
            ...baseSearchRequest(req, 'POST', 'application/json', '/plan'),
            requestParams: pickNonBaseParams(req),
            requestMetadata: { method: 'plan' },
            ...this.options,
        });
        if (response instanceof Error) {
            return buildAPIResponseFromErrorOrThrow(response);
        }
        const body = await response.json();
        if (isSuccessPlanResponse(body)) {
            return { success: body };
        }
        return {
            error: unwrapError({ response, body }),
        };
    }
    async querySuggest(req) {
        const response = await PlatformClient.call({
            ...baseSearchRequest(req, 'POST', 'application/json', '/querySuggest'),
            requestMetadata: { method: 'querySuggest' },
            requestParams: pickNonBaseParams(req),
            ...this.options,
        });
        if (response instanceof Error) {
            return buildAPIResponseFromErrorOrThrow(response);
        }
        const body = await response.json();
        const payload = { response, body };
        if (isSuccessQuerySuggestionsResponse(body)) {
            const processedResponse = await this.options.postprocessQuerySuggestResponseMiddleware(payload);
            return {
                success: processedResponse.body,
            };
        }
        return {
            error: unwrapError(payload),
        };
    }
    apiCallsQueues = {
        unknown: new APICallsQueue(),
        mainSearch: new APICallsQueue(),
        facetValues: new APICallsQueue(),
        foldingCollection: new APICallsQueue(),
        instantResults: new APICallsQueue(),
    };
    async search(req, options) {
        const origin = options?.origin ?? 'unknown';
        const response = await this.apiCallsQueues[origin].enqueue((signal) => PlatformClient.call({
            ...baseSearchRequest(req, 'POST', 'application/json', ''),
            requestParams: pickNonBaseParams(req),
            requestMetadata: { method: 'search', origin: options?.origin },
            ...this.options,
            signal: signal ?? undefined,
        }), { logger: this.options.logger, warnOnAbort: !options?.disableAbortWarning });
        if (response instanceof Error) {
            return buildAPIResponseFromErrorOrThrow(response, options?.disableAbortWarning);
        }
        const body = await response.json();
        const payload = { response, body };
        if (isSuccessSearchResponse(body)) {
            payload.body = shimResponse(body);
            const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
            return {
                success: processedResponse.body,
            };
        }
        return {
            error: unwrapError(payload),
        };
    }
    async facetSearch(req) {
        const response = await PlatformClient.call({
            ...baseSearchRequest(req, 'POST', 'application/json', '/facet'),
            requestParams: pickNonBaseParams(req),
            requestMetadata: { method: 'facetSearch' },
            ...this.options,
        });
        if (response instanceof Error) {
            throw response;
        }
        const body = await response.json();
        const payload = { response, body };
        const processedResponse = await this.options.postprocessFacetSearchResponseMiddleware(payload);
        return processedResponse.body;
    }
    async recommendations(req) {
        const response = await PlatformClient.call({
            ...baseSearchRequest(req, 'POST', 'application/json', ''),
            requestParams: pickNonBaseParams(req),
            requestMetadata: { method: 'recommendations' },
            ...this.options,
        });
        if (response instanceof Error) {
            throw response;
        }
        const body = await response.json();
        if (isSuccessSearchResponse(body)) {
            const payload = { response, body };
            payload.body = shimResponse(body);
            const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
            return {
                success: processedResponse.body,
            };
        }
        return {
            error: unwrapError({ response, body }),
        };
    }
    async html(req) {
        return getHtml(req, { ...this.options });
    }
    async fieldDescriptions(req) {
        const response = await PlatformClient.call({
            ...baseSearchRequest(req, 'GET', 'application/json', '/fields'),
            requestParams: {},
            requestMetadata: { method: 'fieldDescriptions' },
            ...this.options,
        });
        if (response instanceof Error) {
            throw response;
        }
        const body = await response.json();
        if (isSuccessFieldsDescriptionResponse(body)) {
            return { success: body };
        }
        return {
            error: unwrapError({ response, body }),
        };
    }
}
export const isSuccessResponse = (r) => {
    return r.success !== undefined;
};
export const isErrorResponse = (r) => {
    return r.error !== undefined;
};
export function isSuccessSearchResponse(body) {
    return body.results !== undefined;
}
export function shimResponse(response) {
    const empty = emptyQuestionAnswer();
    if (isNullOrUndefined(response.questionAnswer)) {
        response.questionAnswer = empty;
        return response;
    }
    response.questionAnswer = { ...empty, ...response.questionAnswer };
    return response;
}
function isSuccessQuerySuggestionsResponse(body) {
    return body.completions !== undefined;
}
function isSuccessPlanResponse(body) {
    return body.preprocessingOutput !== undefined;
}
function isSuccessFieldsDescriptionResponse(body) {
    return body.fields !== undefined;
}
