import { MultipleRecommendationError } from '../../common/errors.js';
import { recommendationInternalOptionKey } from '../types/controller-constants.js';
/**
 * Type guard to check if a controller definition is a recommendation controller.
 * A recommendation controller must have both the recommendation flag and a slotId.
 */
export function isRecommendationDefinition(controllerDefinition) {
    const hasRecommendationFlag = 'recommendation' in controllerDefinition &&
        controllerDefinition.recommendation === true;
    const hasValidSlotId = recommendationInternalOptionKey in controllerDefinition &&
        'slotId' in
            controllerDefinition[recommendationInternalOptionKey];
    return hasRecommendationFlag && hasValidSlotId;
}
/**
 * Extracts recommendation controller definitions from a controller definitions map.
 *
 * @param controllerDefinitions - Map of controller definitions
 * @returns Object containing only the recommendation controller definitions
 */
export function getRecommendationDefinitions(controllerDefinitions) {
    const recommendationMap = {};
    for (const [name, definition] of Object.entries(controllerDefinitions)) {
        if (isRecommendationDefinition(definition)) {
            recommendationMap[name] = definition;
        }
    }
    return recommendationMap;
}
export function filterRecommendationControllers(controllers, controllerDefinitions) {
    const slotIdSet = new Set();
    const ensureSingleRecommendationPerSlot = (slotId) => {
        throw new MultipleRecommendationError(slotId);
    };
    const filtered = Object.entries(controllerDefinitions).filter(([_, value]) => {
        if (!isRecommendationDefinition(value)) {
            return false;
        }
        const { slotId } = value[recommendationInternalOptionKey];
        const key = slotId;
        if (slotIdSet.has(slotId)) {
            ensureSingleRecommendationPerSlot(slotId);
            return false;
        }
        slotIdSet.add(key);
        return true;
    });
    const name = filtered.map(([name, _]) => name);
    return {
        /**
         * Go through all the controllers passed in argument and only refresh recommendation controllers.
         *
         * @param controllers - A record of all controllers where the key is the controller name and the value is the controller instance.
         * @param controllerNames - A list of all recommendation controllers to refresh
         */
        refresh(whitelist) {
            if (whitelist === undefined) {
                return;
            }
            const isRecommendationController = (key) => name.includes(key) && whitelist.includes(key);
            for (const [key, controller] of Object.entries(controllers)) {
                if (isRecommendationController(key)) {
                    controller.refresh?.();
                }
            }
        },
    };
}
