import { ArrayValue, RecordValue, Schema, StringValue } from '@coveo/bueno';
import { contextDefinition } from '../../../features/commerce/context/context-validation.js';
import { parametersDefinition } from '../../../features/commerce/parameters/parameters-schema.js';
import { nonEmptyString, nonRequiredEmptyAllowedString, } from '../../../utils/validate-payload.js';
import { SolutionType } from '../types/controller-constants.js';
import { getRecommendationDefinitions, isRecommendationDefinition, } from './recommendation-filter.js';
const requiredDefinition = {
    context: new RecordValue({
        options: { required: true },
        values: contextDefinition,
    }),
};
const listingDefinition = {
    ...requiredDefinition,
    searchParams: new RecordValue({
        values: parametersDefinition,
    }),
};
const standaloneDefinition = {
    ...requiredDefinition,
};
const searchDefinition = {
    ...requiredDefinition,
    searchParams: new RecordValue({
        options: { required: false },
        values: { q: nonRequiredEmptyAllowedString, ...parametersDefinition },
    }),
};
const recommendationsDefinition = (recommendationName) => ({
    ...requiredDefinition,
    recommendations: new ArrayValue({
        each: new StringValue({
            required: true,
            constrainTo: recommendationName,
            emptyAllowed: false,
        }),
        required: true,
    }),
    productId: nonEmptyString,
});
export const listingDefinitionSchema = new Schema(listingDefinition);
export const searchDefinitionSchema = new Schema(searchDefinition);
export const standaloneDefinitionSchema = new Schema(standaloneDefinition);
export const recommendationsDefinitionSchema = (recommendationName) => new Schema(recommendationsDefinition(recommendationName));
/**
 * Validates the build configuration based on the solution type.
 */
function validateBuildConfig(solutionType, controllerDefinitions, buildConfig) {
    const validationMap = {
        [SolutionType.listing]: listingDefinitionSchema,
        [SolutionType.search]: searchDefinitionSchema,
        [SolutionType.standalone]: standaloneDefinitionSchema,
        [SolutionType.recommendation]: recommendationsDefinitionSchema(Object.keys(getRecommendationDefinitions(controllerDefinitions))),
    };
    const schema = validationMap[solutionType];
    schema.validate(buildConfig);
}
/**
 * Controller wiring class that handles the complete wiring process.
 * Transforms simple user configuration into complex internal controller structures.
 */
class ControllerWirer {
    buildConfig;
    controllerDefinitions;
    controllerProps;
    constructor(buildConfig, controllerDefinitions, controllerProps) {
        this.buildConfig = buildConfig;
        this.controllerDefinitions = controllerDefinitions;
        this.controllerProps = controllerProps;
    }
    wireParameterManager() {
        if (!this.controllerDefinitions?.parameterManager)
            return;
        const { searchParams } = this.buildConfig;
        const { q, ...rest } = searchParams || {};
        const parameters = {
            ...{ q },
            ...(rest && typeof rest === 'object' ? rest : {}),
        };
        this.controllerProps.parameterManager = {
            initialState: { parameters },
        };
    }
    wireContext() {
        if (!this.controllerDefinitions?.context)
            return;
        const { context } = this.buildConfig;
        this.controllerProps.context = {
            initialState: {
                ...context,
            },
        };
    }
    wireCart() {
        if (!this.controllerDefinitions?.cart || !this.buildConfig.cart)
            return;
        this.controllerProps.cart = {
            initialState: this.buildConfig.cart,
        };
    }
    wireRecommendations() {
        if (!('recommendations' in this.buildConfig)) {
            return;
        }
        for (const recController in this.controllerDefinitions) {
            if (isRecommendationDefinition(this.controllerDefinitions[recController])) {
                this.controllerProps[recController] = {
                    initialState: {
                        ...('productId' in this.buildConfig && {
                            productId: this.buildConfig.productId,
                        }),
                    },
                };
            }
        }
    }
    /**
     * Wires all controllers based on solution type and controller definitions.
     * Handles the complete wiring process in a sequential manner.
     */
    wire(solutionType) {
        // Wire common controllers that apply to all solution types
        this.wireCart();
        this.wireContext();
        // Wire solution-specific controllers
        switch (solutionType) {
            case SolutionType.search:
            case SolutionType.listing: {
                this.wireParameterManager();
                break;
            }
            case SolutionType.recommendation: {
                this.wireRecommendations();
                break;
            }
            case SolutionType.standalone:
                // No additional wiring needed for standalone
                break;
            default: {
                // Exhaustive check - TypeScript will error if we miss a case
                const _exhaustiveCheck = solutionType;
                throw new Error(`Unsupported solution type: ${_exhaustiveCheck}`);
            }
        }
    }
}
/**
 * Converts simple user configuration (URL, language, currency, query) into the
 * nested structure required by the internal {@link Build} method. Automatically generates
 * appropriate controllers (context, cart, parameterManager) transparently.
 *
 * @param solutionType - The type of solution (search, listing, recommendation, standalone)
 * @param controllerDefinitions - Map of controller definitions to be initialized
 * @param buildConfig - Simple configuration object with simplified controller properties
 * @returns Formatted and validated controller properties map defined for the controller in the definition
 */
export function wireControllerParams(solutionType, controllerDefinitions, buildConfig) {
    validateBuildConfig(solutionType, controllerDefinitions, buildConfig);
    const controllerProps = buildConfig.controllers ?? {};
    new ControllerWirer(buildConfig, controllerDefinitions, controllerProps).wire(solutionType);
    return controllerProps;
}
