import { buildCommerceEngine, } from '../../../app/commerce-engine/commerce-engine.js';
import { stateKey } from '../../../app/state-key.js';
import { loadConfigurationActions } from '../../../features/commerce/configuration/configuration-actions-loader.js';
import { createWaitForActionMiddleware, createWaitForActionMiddlewareForRecommendation, } from '../../../utils/utils.js';
import { buildControllerDefinitions } from '../controller-utils.js';
import { SolutionType } from '../types/controller-constants.js';
import { wireControllerParams } from '../utils/controller-wiring.js';
import { augmentCommerceEngineOptions } from '../utils/engine-wiring.js';
function isListingFetchCompletedAction(action) {
    return /^commerce\/productListing\/fetch\/(fulfilled|rejected)$/.test(action.type);
}
function isSearchCompletedAction(action) {
    return /^commerce\/search\/executeSearch\/(fulfilled|rejected)$/.test(action.type);
}
function isRecommendationCompletedAction(action) {
    return /^commerce\/recommendations\/fetch\/(fulfilled|rejected)$/.test(action.type);
}
function noSearchActionRequired(_action) {
    return true;
}
function buildSSRCommerceEngine(solutionType, options, recommendationCount) {
    let actionCompletionMiddleware;
    const middlewares = [];
    const memo = new Set();
    switch (solutionType) {
        case SolutionType.listing:
            actionCompletionMiddleware = createWaitForActionMiddleware(isListingFetchCompletedAction);
            middlewares.push(actionCompletionMiddleware);
            break;
        case SolutionType.search:
            actionCompletionMiddleware = createWaitForActionMiddleware(isSearchCompletedAction);
            middlewares.push(actionCompletionMiddleware);
            break;
        case SolutionType.recommendation:
            middlewares.push(...Array.from({ length: recommendationCount }, () => createWaitForActionMiddlewareForRecommendation(isRecommendationCompletedAction, memo)));
            break;
        case SolutionType.standalone:
            actionCompletionMiddleware = createWaitForActionMiddleware(noSearchActionRequired);
            break;
        default:
            throw new Error('Unsupported solution type', solutionType);
    }
    const commerceEngine = buildCommerceEngine({
        ...options,
        middlewares: [
            ...(options.middlewares ?? []),
            ...middlewares.map(({ middleware }) => middleware),
        ],
    });
    return {
        ...commerceEngine,
        get [stateKey]() {
            return commerceEngine[stateKey];
        },
        waitForRequestCompletedAction() {
            return [...middlewares.map(({ promise }) => promise)];
        },
    };
}
export const buildFactory = (controllerDefinitions, options) => (solutionType) => async (buildOptions) => {
    const controllerProps = wireControllerParams(solutionType, controllerDefinitions, buildOptions);
    const enabledRecommendationControllers = buildOptions && 'recommendations' in buildOptions
        ? buildOptions
            ?.recommendations.length
        : 0;
    const engineOptions = augmentCommerceEngineOptions(options, buildOptions);
    const engine = buildSSRCommerceEngine(solutionType, engineOptions, enabledRecommendationControllers);
    const updateEngineConfiguration = (accessToken) => {
        const { updateBasicConfiguration } = loadConfigurationActions(engine);
        engine.dispatch(updateBasicConfiguration({
            accessToken,
        }));
    };
    if (options.onAccessTokenUpdate) {
        options.onAccessTokenUpdate(updateEngineConfiguration);
    }
    const controllers = buildControllerDefinitions({
        definitionsMap: controllerDefinitions ?? {},
        engine,
        solutionType,
        propsMap: controllerProps,
    });
    if (buildOptions && 'searchActions' in buildOptions) {
        buildOptions.searchActions.forEach((action) => {
            engine.dispatch(action);
        });
    }
    return {
        engine,
        controllers: controllers,
    };
};
