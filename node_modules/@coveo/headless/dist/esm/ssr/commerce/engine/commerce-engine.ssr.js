/**
 * Utility functions to be used for Commerce Server Side Rendering.
 */
import { createAccessTokenManager } from '../../common/access-token-manager.js';
import { buildFactory, } from '../factories/build-factory.js';
import { hydratedStaticStateFactory } from '../factories/hydrated-state-factory.js';
import { hydratedRecommendationStaticStateFactory } from '../factories/recommendation-hydrated-state-factory.js';
import { fetchRecommendationStaticStateFactory } from '../factories/recommendation-static-state-factory.js';
import { fetchStaticStateFactory } from '../factories/static-state-factory.js';
import { SolutionType } from '../types/controller-constants.js';
/**
 * Initializes a Commerce engine definition in SSR with given controllers definitions and commerce engine config.
 * @param options - The commerce engine definition
 * @returns Three utility functions to fetch the initial state of the engine in SSR, hydrate the state in CSR,
 *  and a build function that can be used for edge cases requiring more control.
 *
 * @group Engine
 */
export function defineCommerceEngine(options) {
    const { controllers: controllerDefinitions, ...engineOptions } = options;
    const setNavigatorContextProvider = (navigatorContextProvider) => {
        engineOptions.navigatorContextProvider = navigatorContextProvider;
    };
    const tokenManager = createAccessTokenManager(engineOptions.configuration.accessToken);
    const onAccessTokenUpdate = (updateCallback) => {
        tokenManager.registerCallback(updateCallback);
    };
    /**
     * HACK: We assign engineOptions by reference (not by value) to definitionOptions
     * so that when setNavigatorContextProvider() modifies engineOptions.navigatorContextProvider,
     * the factories will see the updated navigator context when they are called later.
     *
     * This works because:
     * 1. setNavigatorContextProvider() modifies engineOptions.navigatorContextProvider
     * 2. definitionOptions points to the same object as engineOptions
     * 3. When fetchStaticState() is called, it uses the current value from the shared object
     *
     * Without this reference sharing, definitionOptions would be a snapshot taken at
     * definition time, and navigator context updates would be ignored.
     *
     * TODO: This will be removed in the next major version with a cleaner design
     * where context is provided directly to fetchStaticState() rather than through
     * the engine definition.
     */
    const definitionOptions = engineOptions;
    definitionOptions.onAccessTokenUpdate = onAccessTokenUpdate;
    const getAccessToken = () => tokenManager.getAccessToken();
    const setAccessToken = (accessToken) => {
        engineOptions.configuration.accessToken = accessToken;
        tokenManager.setAccessToken(accessToken);
    };
    const build = buildFactory(controllerDefinitions, definitionOptions);
    const fetchStaticState = fetchStaticStateFactory(controllerDefinitions, definitionOptions);
    const hydrateStaticState = hydratedStaticStateFactory(controllerDefinitions, definitionOptions);
    const fetchRecommendationStaticState = fetchRecommendationStaticStateFactory(controllerDefinitions, definitionOptions);
    const hydrateRecommendationStaticState = hydratedRecommendationStaticStateFactory(controllerDefinitions, definitionOptions);
    return {
        listingEngineDefinition: {
            build: build(SolutionType.listing),
            fetchStaticState: fetchStaticState(SolutionType.listing),
            hydrateStaticState: hydrateStaticState(SolutionType.listing),
            setNavigatorContextProvider,
            getAccessToken,
            setAccessToken,
        },
        searchEngineDefinition: {
            build: build(SolutionType.search),
            fetchStaticState: fetchStaticState(SolutionType.search),
            hydrateStaticState: hydrateStaticState(SolutionType.search),
            setNavigatorContextProvider,
            getAccessToken,
            setAccessToken,
        },
        recommendationEngineDefinition: {
            build: build(SolutionType.recommendation),
            fetchStaticState: fetchRecommendationStaticState,
            hydrateStaticState: hydrateRecommendationStaticState,
            setNavigatorContextProvider,
            getAccessToken,
            setAccessToken,
        },
        // TODO KIT-3738 :  The standaloneEngineDefinition should not be async since no request is sent to the API
        standaloneEngineDefinition: {
            build: build(SolutionType.standalone),
            fetchStaticState: fetchStaticState(SolutionType.standalone),
            hydrateStaticState: hydrateStaticState(SolutionType.standalone),
            setNavigatorContextProvider,
            getAccessToken,
            setAccessToken,
        },
    };
}
