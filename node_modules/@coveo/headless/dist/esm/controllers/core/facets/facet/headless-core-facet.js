import { configuration } from '../../../../app/common-reducers.js';
import { disableFacet, enableFacet, updateFacetOptions, } from '../../../../features/facet-options/facet-options-actions.js';
import { isFacetEnabledSelector } from '../../../../features/facet-options/facet-options-selectors.js';
import { facetOptionsReducer as facetOptions } from '../../../../features/facet-options/facet-options-slice.js';
import { defaultFacetSearchOptions } from '../../../../features/facets/facet-search-set/facet-search-reducer-helpers.js';
import { specificFacetSearchSetReducer as facetSearchSet } from '../../../../features/facets/facet-search-set/specific/specific-facet-search-set-slice.js';
import { deselectAllFacetValues, registerFacet, updateFacetIsFieldExpanded, updateFacetNumberOfValues, updateFacetSortCriterion, } from '../../../../features/facets/facet-set/facet-set-actions.js';
import { executeToggleFacetExclude, executeToggleFacetSelect, } from '../../../../features/facets/facet-set/facet-set-controller-actions.js';
import { facetRequestSelector, facetResponseSelector, isFacetLoadingResponseSelector, } from '../../../../features/facets/facet-set/facet-set-selectors.js';
import { defaultFacetOptions, facetSetReducer as facetSet, } from '../../../../features/facets/facet-set/facet-set-slice.js';
import { isFacetValueExcluded, isFacetValueSelected, } from '../../../../features/facets/facet-set/facet-set-utils.js';
import { selectActiveTab } from '../../../../features/tab-set/tab-set-selectors.js';
import { loadReducerError } from '../../../../utils/errors.js';
import { omit } from '../../../../utils/utils.js';
import { validateOptions } from '../../../../utils/validate-payload.js';
import { buildController, } from '../../../controller/headless-controller.js';
import { determineFacetId } from '../_common/facet-id-determinor.js';
import { facetOptionsSchema, } from './headless-core-facet-options.js';
/**
 * Creates a `Facet` controller instance.
 *
 * @param engine - The headless engine.
 * @param props - The configurable `Facet` properties.
 * @param optionsSchema - The facet options schema to use when validating options upon facet initialization.
 * @returns A `Facet` controller instance.
 *
 * @group Controllers
 * @category Facet
 * */
export function buildCoreFacet(engine, props, optionsSchema = facetOptionsSchema) {
    if (!loadFacetReducers(engine)) {
        throw loadReducerError;
    }
    const { dispatch } = engine;
    const controller = buildController(engine);
    const facetId = determineFacetId(engine, props.options);
    const tabs = props.options.tabs ?? {};
    const activeTab = selectActiveTab(engine.state.tabSet);
    const registrationOptions = {
        ...defaultFacetOptions,
        ...omit('facetSearch', props.options),
        field: props.options.field,
        facetId,
        tabs,
        activeTab,
    };
    const options = {
        facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
        ...registrationOptions,
    };
    validateOptions(engine, optionsSchema, options, 'buildFacet');
    const getRequest = () => facetRequestSelector(engine.state, facetId);
    const getResponse = () => facetResponseSelector(engine.state, facetId);
    const getIsLoading = () => isFacetLoadingResponseSelector(engine.state);
    const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId);
    const getNumberOfActiveValues = () => {
        const { currentValues } = getRequest();
        return currentValues.filter((v) => v.state !== 'idle').length;
    };
    const computeCanShowLessValues = () => {
        const { currentValues } = getRequest();
        const initialNumberOfValues = options.numberOfValues;
        const hasIdleValues = !!currentValues.find((v) => v.state === 'idle');
        return initialNumberOfValues < currentValues.length && hasIdleValues;
    };
    dispatch(registerFacet(registrationOptions));
    return {
        ...controller,
        toggleSelect: (selection) => dispatch(executeToggleFacetSelect({ facetId: options.facetId, selection })),
        toggleExclude: (selection) => dispatch(executeToggleFacetExclude({ facetId: options.facetId, selection })),
        // Must use a function here to properly support inheritance with `this`.
        toggleSingleSelect: function (selection) {
            if (selection.state === 'idle') {
                dispatch(deselectAllFacetValues(facetId));
            }
            this.toggleSelect(selection);
        },
        // Must use a function here to properly support inheritance with `this`.
        toggleSingleExclude: function (selection) {
            if (selection.state === 'idle') {
                dispatch(deselectAllFacetValues(facetId));
            }
            this.toggleExclude(selection);
        },
        isValueSelected: isFacetValueSelected,
        isValueExcluded: isFacetValueExcluded,
        deselectAll() {
            dispatch(deselectAllFacetValues(facetId));
            dispatch(updateFacetOptions());
        },
        sortBy(criterion) {
            dispatch(updateFacetSortCriterion({ facetId, criterion }));
            dispatch(updateFacetOptions());
        },
        isSortedBy(criterion) {
            return this.state.sortCriterion === criterion;
        },
        showMoreValues() {
            const numberInState = getRequest().numberOfValues;
            const initialNumberOfValues = options.numberOfValues;
            const numberToNextMultipleOfConfigured = initialNumberOfValues - (numberInState % initialNumberOfValues);
            const numberOfValues = numberInState + numberToNextMultipleOfConfigured;
            dispatch(updateFacetNumberOfValues({ facetId, numberOfValues }));
            dispatch(updateFacetIsFieldExpanded({ facetId, isFieldExpanded: true }));
            dispatch(updateFacetOptions());
        },
        showLessValues() {
            const initialNumberOfValues = options.numberOfValues;
            const newNumberOfValues = Math.max(initialNumberOfValues, getNumberOfActiveValues());
            dispatch(updateFacetNumberOfValues({ facetId, numberOfValues: newNumberOfValues }));
            dispatch(updateFacetIsFieldExpanded({ facetId, isFieldExpanded: false }));
            dispatch(updateFacetOptions());
        },
        enable() {
            dispatch(enableFacet(facetId));
        },
        disable() {
            dispatch(disableFacet(facetId));
        },
        get state() {
            const request = getRequest();
            const response = getResponse();
            const isLoading = getIsLoading();
            const enabled = getIsEnabled();
            let sortCriterion;
            if (typeof request.sortCriteria === 'object') {
                sortCriterion =
                    request.sortCriteria.order === 'descending'
                        ? 'alphanumericDescending'
                        : 'alphanumeric';
            }
            else {
                sortCriterion = request.sortCriteria;
            }
            const values = response ? response.values : [];
            const hasActiveValues = values.some((facetValue) => facetValue.state !== 'idle');
            const canShowMoreValues = response ? response.moreValuesAvailable : false;
            const resultsMustMatch = request.resultsMustMatch;
            return {
                label: response?.label,
                facetId,
                tabs,
                values,
                sortCriterion,
                resultsMustMatch,
                isLoading,
                hasActiveValues,
                canShowMoreValues,
                canShowLessValues: computeCanShowLessValues(),
                enabled,
            };
        },
    };
}
function loadFacetReducers(engine) {
    engine.addReducers({ facetSet, facetOptions, configuration, facetSearchSet });
    return true;
}
