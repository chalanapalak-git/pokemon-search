import { resetAnswer, setId, streamAnswer, } from '../../../features/generated-answer/generated-answer-actions.js';
import { generatedAnswerReducer as generatedAnswer } from '../../../features/generated-answer/generated-answer-slice.js';
import { executeSearch } from '../../../features/search/search-actions.js';
import { loadReducerError } from '../../../utils/errors.js';
import { randomID } from '../../../utils/utils.js';
import { buildCoreGeneratedAnswer, } from './headless-core-generated-answer.js';
export const subscribeStateManager = {
    engines: {},
    setAbortControllerRef: (ref, genQaEngineId) => {
        subscribeStateManager.engines[genQaEngineId].abortController = ref;
    },
    getIsStreamInProgress: (genQaEngineId) => {
        if (!subscribeStateManager.engines[genQaEngineId].abortController ||
            subscribeStateManager.engines[genQaEngineId].abortController?.signal
                .aborted) {
            subscribeStateManager.engines[genQaEngineId].abortController = undefined;
            return false;
        }
        return true;
    },
    subscribeToSearchRequests: (engine) => {
        const strictListener = () => {
            const state = engine.state;
            const requestId = state.search.requestId;
            const streamId = state.search.extendedResults.generativeQuestionAnsweringId;
            const genQaEngineId = state.generatedAnswer.id;
            if (subscribeStateManager.engines[genQaEngineId].lastRequestId !== requestId) {
                subscribeStateManager.engines[genQaEngineId].lastRequestId = requestId;
                subscribeStateManager.engines[genQaEngineId].abortController?.abort();
                if (state.generatedAnswer.isEnabled === false) {
                    return;
                }
                engine.dispatch(resetAnswer());
            }
            const isStreamInProgress = subscribeStateManager.getIsStreamInProgress(genQaEngineId);
            if (!isStreamInProgress &&
                streamId &&
                streamId !== subscribeStateManager.engines[genQaEngineId].lastStreamId) {
                subscribeStateManager.engines[genQaEngineId].lastStreamId = streamId;
                if (state.generatedAnswer.isEnabled === false) {
                    return;
                }
                engine.dispatch(streamAnswer({
                    setAbortControllerRef: (ref) => subscribeStateManager.setAbortControllerRef(ref, genQaEngineId),
                }));
            }
        };
        return engine.subscribe(strictListener);
    },
};
/**
 * Creates a `GeneratedAnswer` controller instance using the search API stream pattern.
 *
 * @param engine - The headless engine.
 * @param props - The configurable `GeneratedAnswer` properties.
 * @returns A `GeneratedAnswer` controller instance.
 */
export function buildSearchAPIGeneratedAnswer(engine, analyticsClient, props = {}) {
    if (!loadGeneratedAnswerReducer(engine)) {
        throw loadReducerError;
    }
    const controller = buildCoreGeneratedAnswer(engine, analyticsClient, props);
    const getState = () => engine.state;
    if (engine.state.generatedAnswer.id &&
        !subscribeStateManager.engines[engine.state.generatedAnswer.id]) {
        subscribeStateManager.engines[engine.state.generatedAnswer.id] = {
            abortController: undefined,
            lastRequestId: engine.state.search.requestId,
            lastStreamId: engine.state.search.extendedResults.generativeQuestionAnsweringId ?? '',
        };
    }
    if (!engine.state.generatedAnswer.id) {
        const genQaEngineId = randomID('genQA-', 12);
        engine.dispatch(setId({ id: genQaEngineId }));
    }
    if (!subscribeStateManager.engines[engine.state.generatedAnswer.id]) {
        subscribeStateManager.engines[engine.state.generatedAnswer.id] = {
            abortController: undefined,
            lastRequestId: '',
            lastStreamId: '',
        };
    }
    subscribeStateManager.subscribeToSearchRequests(engine);
    const isSearchEngine = (engine) => 'executeFirstSearchAfterStandaloneSearchBoxRedirect' in engine;
    return {
        ...controller,
        get state() {
            return getState().generatedAnswer;
        },
        retry() {
            if (!isSearchEngine(engine)) {
                return;
            }
            engine.dispatch(executeSearch({
                legacy: analyticsClient.logRetryGeneratedAnswer(),
            }));
        },
    };
}
function loadGeneratedAnswerReducer(engine) {
    engine.addReducers({ generatedAnswer });
    return true;
}
