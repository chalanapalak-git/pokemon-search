import { NumberValue, Schema } from '@coveo/bueno';
import { configuration } from '../../../app/common-reducers.js';
import { nextPage, previousPage, registerPage, updatePage, } from '../../../features/pagination/pagination-actions.js';
import { minimumPage } from '../../../features/pagination/pagination-constants.js';
import { currentPageSelector, currentPagesSelector, maxPageSelector, } from '../../../features/pagination/pagination-selectors.js';
import { paginationReducer as pagination } from '../../../features/pagination/pagination-slice.js';
import { loadReducerError } from '../../../utils/errors.js';
import { validateInitialState, validateOptions, } from '../../../utils/validate-payload.js';
import { buildController, } from '../../controller/headless-controller.js';
const optionsSchema = new Schema({
    numberOfPages: new NumberValue({ default: 5, min: 0 }),
});
const initialStateSchema = new Schema({
    page: new NumberValue({ min: 1 }),
});
export function buildCorePager(engine, props = {}) {
    if (!loadPagerReducers(engine)) {
        throw loadReducerError;
    }
    const controller = buildController(engine);
    const { dispatch } = engine;
    const options = validateOptions(engine, optionsSchema, props.options, 'buildPager');
    const initialState = validateInitialState(engine, initialStateSchema, props.initialState, 'buildPager');
    const page = initialState.page;
    if (page) {
        dispatch(registerPage(page));
    }
    const getCurrentPage = () => {
        return currentPageSelector(engine.state);
    };
    const getCurrentPages = () => {
        const { numberOfPages } = options;
        return currentPagesSelector(engine.state, numberOfPages);
    };
    const getMaxPage = () => {
        return maxPageSelector(engine.state);
    };
    return {
        ...controller,
        get state() {
            const currentPage = getCurrentPage();
            const maxPage = getMaxPage();
            const hasPreviousPage = currentPage > minimumPage && maxPage > 0;
            const hasNextPage = currentPage < maxPage;
            return {
                currentPage,
                currentPages: getCurrentPages(),
                maxPage,
                hasPreviousPage,
                hasNextPage,
            };
        },
        selectPage(page) {
            dispatch(updatePage(page));
        },
        nextPage() {
            dispatch(nextPage());
        },
        previousPage() {
            dispatch(previousPage());
        },
        isCurrentPage(page) {
            return page === this.state.currentPage;
        },
    };
}
function loadPagerReducers(engine) {
    engine.addReducers({ configuration, pagination });
    return true;
}
