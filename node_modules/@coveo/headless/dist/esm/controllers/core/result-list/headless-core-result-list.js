import { ArrayValue, Schema, StringValue } from '@coveo/bueno';
import { configuration } from '../../../app/common-reducers.js';
import { registerFieldsToInclude } from '../../../features/fields/fields-actions.js';
import { fieldsReducer as fields } from '../../../features/fields/fields-slice.js';
import { searchReducer as search } from '../../../features/search/search-slice.js';
import { loadReducerError } from '../../../utils/errors.js';
import { validateOptions } from '../../../utils/validate-payload.js';
import { buildController, } from '../../controller/headless-controller.js';
import { buildCoreStatus, } from '../status/headless-core-status.js';
const optionsSchema = new Schema({
    fieldsToInclude: new ArrayValue({
        required: false,
        each: new StringValue({
            required: true,
            emptyAllowed: false,
        }),
    }),
});
/**
 * Creates a `ResultList` controller instance.
 *
 * @param engine - The headless engine.
 * @param props - The configurable `ResultList` properties.
 * @returns A `ResultList` controller instance.
 */
export function buildCoreResultList(engine, props) {
    if (!loadResultListReducers(engine)) {
        throw loadReducerError;
    }
    const controller = buildController(engine);
    const status = buildCoreStatus(engine);
    const { dispatch } = engine;
    const getState = () => engine.state;
    const options = validateOptions(engine, optionsSchema, props?.options, 'buildCoreResultList');
    if (options.fieldsToInclude) {
        dispatch(registerFieldsToInclude(options.fieldsToInclude));
    }
    const moreResultsAvailable = () => engine.state.search.results.length <
        engine.state.search.response.totalCountFiltered;
    let lastFetchCompleted = 0;
    let consecutiveFetches = 0;
    const maxConsecutiveFetches = 5;
    const minDelayBetweenFetches = 200;
    let errorLogged = false;
    const triggerFetchMoreResult = async () => {
        if (engine.state.search.isLoading) {
            return;
        }
        if (!moreResultsAvailable()) {
            engine.logger.info('No more results are available for the result list to fetch.');
            return;
        }
        const delayBetweenFetches = Date.now() - lastFetchCompleted;
        if (delayBetweenFetches < minDelayBetweenFetches) {
            consecutiveFetches++;
            if (consecutiveFetches >= maxConsecutiveFetches) {
                lastFetchCompleted = Date.now();
                !errorLogged &&
                    engine.logger.error(`The result list method "fetchMoreResults" execution prevented because it has been triggered consecutively ${maxConsecutiveFetches} times, with little delay. Please verify the conditions under which the function is called.`);
                errorLogged = true;
                return;
            }
        }
        else {
            consecutiveFetches = 0;
        }
        errorLogged = false;
        if (props?.fetchMoreResultsActionCreator) {
            await dispatch(props?.fetchMoreResultsActionCreator());
            lastFetchCompleted = Date.now();
        }
    };
    return {
        ...controller,
        get state() {
            const state = getState();
            return {
                ...status.state,
                results: state.search.results,
                moreResultsAvailable: moreResultsAvailable(),
                searchResponseId: state.search.searchResponseId,
            };
        },
        fetchMoreResults: triggerFetchMoreResult,
    };
}
function loadResultListReducers(engine) {
    engine.addReducers({ search, configuration, fields });
    return true;
}
