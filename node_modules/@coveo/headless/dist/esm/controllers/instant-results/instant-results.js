import { hasExpired } from '../../features/instant-items/instant-items-state.js';
import { clearExpiredResults, registerInstantResults, updateInstantResultsQuery, } from '../../features/instant-results/instant-results-actions.js';
import { instantResultsReducer as instantResults } from '../../features/instant-results/instant-results-slice.js';
import { fetchInstantResults } from '../../features/search/search-actions.js';
import { loadReducerError } from '../../utils/errors.js';
import { randomID } from '../../utils/utils.js';
import { validateOptions } from '../../utils/validate-payload.js';
import { buildController, } from '../controller/headless-controller.js';
import { instantResultsOptionsSchema, } from './instant-results-options.js';
/**
 * Creates an `InstantResults` controller instance.
 *
 * @param engine - The Headless engine.
 * @param props - The configurable `InstantResults` properties.
 * @returns An `InstantResults` controller instance.
 *
 * @group Controllers
 * @category InstantResults
 */
export function buildInstantResults(engine, props) {
    if (!loadInstantResultsReducers(engine)) {
        throw loadReducerError;
    }
    const controller = buildController(engine);
    const { dispatch } = engine;
    const getState = () => engine.state;
    const options = {
        searchBoxId: props.options.searchBoxId || randomID('instant-results-'),
        cacheTimeout: props.options.cacheTimeout || 6e4,
        maxResultsPerQuery: props.options.maxResultsPerQuery,
    };
    validateOptions(engine, instantResultsOptionsSchema, options, 'buildInstantResults');
    const searchBoxId = options.searchBoxId;
    dispatch(registerInstantResults({ id: searchBoxId }));
    const getStateForSearchBox = () => getState().instantResults[searchBoxId];
    const getCached = (q) => getStateForSearchBox().cache[q];
    const getQ = () => getStateForSearchBox().q;
    const getResults = () => {
        const cached = getCached(getQ());
        if (!cached) {
            return [];
        }
        if (cached.isLoading) {
            return [];
        }
        return cached.results;
    };
    return {
        ...controller,
        updateQuery(q) {
            if (!q) {
                return;
            }
            const cached = getCached(q);
            if (!cached ||
                (!cached.isLoading && (cached.error || hasExpired(cached)))) {
                dispatch(fetchInstantResults({
                    id: searchBoxId,
                    q,
                    maxResultsPerQuery: options.maxResultsPerQuery,
                    cacheTimeout: options.cacheTimeout,
                }));
            }
            dispatch(updateInstantResultsQuery({ id: searchBoxId, q }));
        },
        clearExpired() {
            dispatch(clearExpiredResults({
                id: searchBoxId,
            }));
        },
        get state() {
            const q = getQ();
            const cached = getCached(q);
            return {
                q,
                isLoading: cached?.isLoading || false,
                error: cached?.error || null,
                results: getResults(),
            };
        },
    };
}
function loadInstantResultsReducers(engine) {
    engine.addReducers({ instantResults: instantResults });
    return true;
}
