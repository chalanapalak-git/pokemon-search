import { answerGenerationApi } from '../../../api/knowledge/answer-generation/answer-generation-api.js';
import { selectAnswer, } from '../../../api/knowledge/answer-generation/endpoints/answer/answer-endpoint.js';
import { setAgentId } from '../../../features/configuration/configuration-actions.js';
import { dislikeFollowUp, generateFollowUpAnswer, likeFollowUp, } from '../../../features/follow-up-answers/follow-up-answers-actions.js';
import { followUpAnswersReducer as followUpAnswers } from '../../../features/follow-up-answers/follow-up-answers-slice.js';
import { selectAnswerApiQueryParams } from '../../../features/generated-answer/answer-api-selectors.js';
import { generateHeadAnswer } from '../../../features/generated-answer/generated-answer-actions.js';
import { loadReducerError } from '../../../utils/errors.js';
import { buildCoreGeneratedAnswer, } from '../../core/generated-answer/headless-core-generated-answer.js';
/**
 *
 * @internal
 *
 * Creates a `GeneratedAnswerWithFollowUps` controller instance using the Answer API stream pattern.
 *
 * @param engine - The headless engine.
 * @param props - The configurable `GeneratedAnswerWithFollowUps` properties.
 * @returns A `GeneratedAnswerWithFollowUps` controller instance.
 */
export function buildGeneratedAnswerWithFollowUps(engine, analyticsClient, props) {
    if (!props.agentId || props.agentId.trim() === '') {
        throw new Error('agentId is required for GeneratedAnswerWithFollowUps');
    }
    if (!loadReducers(engine)) {
        throw loadReducerError;
    }
    const { ...controller } = buildCoreGeneratedAnswer(engine, analyticsClient, props);
    const getState = () => engine.state;
    engine.dispatch(setAgentId(props.agentId));
    return {
        ...controller,
        get state() {
            const clientState = getState().generatedAnswer;
            const answerApiQueryParams = selectAnswerApiQueryParams(engine.state) ?? {};
            const headAnswerArgs = {
                ...answerApiQueryParams,
                strategyKey: 'head-answer',
            };
            const serverState = selectAnswer(headAnswerArgs, engine.state)?.data;
            const followUpAnswersState = getState().followUpAnswers;
            return {
                /** Server-owned (RTK Query) */
                answer: serverState?.answer,
                answerContentFormat: serverState?.contentFormat ?? 'text/plain',
                citations: serverState?.citations ?? [],
                isLoading: serverState?.isLoading ?? false,
                isStreaming: serverState?.isStreaming ?? false,
                ...(serverState?.error && { error: serverState.error }),
                answerId: serverState?.answerId,
                isAnswerGenerated: Boolean(serverState?.generated),
                cannotAnswer: serverState?.generated === false,
                /** Client-owned (Redux) */
                isVisible: clientState.isVisible,
                expanded: clientState.expanded,
                liked: clientState.liked,
                disliked: clientState.disliked,
                feedbackSubmitted: clientState.feedbackSubmitted,
                feedbackModalOpen: clientState.feedbackModalOpen,
                isEnabled: clientState.isEnabled,
                responseFormat: clientState.responseFormat,
                fieldsToIncludeInCitations: clientState.fieldsToIncludeInCitations,
                answerGenerationMode: clientState.answerGenerationMode,
                id: clientState.id,
                /** Follow-up answers state */
                followUpAnswers: followUpAnswersState,
            };
        },
        retry() {
            engine.dispatch(generateHeadAnswer());
        },
        like(answerId) {
            if (!answerId || this.state.answerId === answerId) {
                controller.like();
                return;
            }
            engine.dispatch(likeFollowUp({ answerId }));
        },
        dislike(answerId) {
            if (!answerId || this.state.answerId === answerId) {
                controller.dislike();
                return;
            }
            engine.dispatch(dislikeFollowUp({ answerId }));
        },
        logCopyToClipboard(answerId) {
            if (!answerId || this.state.answerId === answerId) {
                controller.logCopyToClipboard();
                return;
            }
            // Todo: SFINT-6581 implement logCopyFollowUp action and dispatch here
            console.warn('Method not yet implemented to send analytics for copy to clipboard on a followup answer');
        },
        askFollowUp(question) {
            if (!question || question.trim() === '') {
                return;
            }
            engine.dispatch(generateFollowUpAnswer(question));
        },
    };
}
function loadReducers(engine) {
    engine.addReducers({
        [answerGenerationApi.reducerPath]: answerGenerationApi.reducer,
        followUpAnswers,
    });
    return true;
}
