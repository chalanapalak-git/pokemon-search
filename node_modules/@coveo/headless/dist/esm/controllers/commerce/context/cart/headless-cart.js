import { stateKey } from '../../../../app/state-key.js';
import { emitCartActionEvent, emitPurchaseEvent, purchase, setItems, updateItemQuantity, } from '../../../../features/commerce/context/cart/cart-actions.js';
import { itemsSelector, } from '../../../../features/commerce/context/cart/cart-selector.js';
import { cartReducer as cart } from '../../../../features/commerce/context/cart/cart-slice.js';
import { cartSchema } from '../../../../features/commerce/context/cart/cart-validation.js';
import { loadReducerError } from '../../../../utils/errors.js';
import { validateInitialState } from '../../../../utils/validate-payload.js';
import { buildController, } from '../../../controller/headless-controller.js';
import { itemSelector, totalPriceSelector, totalQuantitySelector, } from './headless-cart-selectors.js';
/**
 * Creates a `Cart` controller instance.
 *
 * @param engine - The headless commerce engine.
 * @param props - The configurable `Cart` properties.
 * @returns A `Cart` controller instance.
 *
 * @group Buildable controllers
 * @category Cart
 */
export function buildCart(engine, props = {}) {
    if (!loadBaseCartReducers(engine)) {
        throw loadReducerError;
    }
    const { dispatch } = engine;
    const controller = buildController(engine);
    const getState = () => engine[stateKey].cart;
    const initialState = {
        ...props.initialState,
    };
    validateInitialState(engine, cartSchema, initialState, 'buildCart');
    // TODO: expose some helpers to facilitate storing / restoring the cart state for MPAs
    if (initialState.items !== undefined) {
        dispatch(setItems(initialState.items));
    }
    function isNewQuantityDifferent(currentItem, prevItem) {
        return prevItem ? prevItem.quantity !== currentItem.quantity : true;
    }
    function getCartAction(currentItem, prevItem) {
        const isCurrentQuantityGreater = !prevItem || currentItem.quantity > prevItem.quantity;
        return isCurrentQuantityGreater ? 'add' : 'remove';
    }
    function isEqual(currentItem, prevItem) {
        return prevItem
            ? currentItem.name === prevItem.name &&
                currentItem.price === prevItem.price &&
                currentItem.quantity === prevItem.quantity
            : false;
    }
    function createEcCartActionPayload(currentItem, prevItem) {
        const { quantity: currentQuantity, ...product } = currentItem;
        const action = getCartAction(currentItem, prevItem);
        const quantity = !prevItem
            ? currentQuantity
            : Math.abs(currentQuantity - prevItem.quantity);
        return {
            action,
            quantity,
            product,
        };
    }
    return {
        ...controller,
        empty: function () {
            for (const item of itemsSelector(getState())) {
                this.updateItemQuantity({ ...item, quantity: 0 });
            }
        },
        purchase(transaction) {
            dispatch(emitPurchaseEvent(transaction));
            dispatch(purchase());
        },
        updateItemQuantity(item) {
            const prevItem = itemSelector(getState(), item);
            const doesNotNeedUpdate = !prevItem && item.quantity <= 0;
            if (doesNotNeedUpdate || isEqual(item, prevItem)) {
                return;
            }
            if (isNewQuantityDifferent(item, prevItem)) {
                dispatch(emitCartActionEvent(createEcCartActionPayload(item, prevItem)));
            }
            dispatch(updateItemQuantity(item));
        },
        get state() {
            const cartState = getState();
            return {
                items: itemsSelector(cartState),
                totalQuantity: totalQuantitySelector(cartState),
                totalPrice: totalPriceSelector(cartState),
            };
        },
    };
}
export function createCartKey(item) {
    return `${item.productId},${item.name},${item.price}`;
}
function loadBaseCartReducers(engine) {
    engine.addReducers({ cart });
    return true;
}
