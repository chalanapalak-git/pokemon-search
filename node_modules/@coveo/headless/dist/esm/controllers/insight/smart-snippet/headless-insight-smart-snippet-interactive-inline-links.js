import { logOpenSmartSnippetInlineLink, logOpenSmartSnippetSuggestionInlineLink, } from '../../../features/question-answering/question-answering-insight-analytics-actions.js';
import { questionAnsweringReducer as questionAnswering } from '../../../features/question-answering/question-answering-slice.js';
import { searchReducer as search } from '../../../features/search/search-slice.js';
import { loadReducerError } from '../../../utils/errors.js';
import { getObjectHash } from '../../../utils/utils.js';
import { buildInteractiveResultCore, } from '../../core/interactive-result/headless-core-interactive-result.js';
/**
 * Creates the insight result controller for SmartSnippet.
 *
 * @param engine - The headless insight engine.
 * @param props - The configurable controller properties.
 * @param action - The action to be triggered on select.
 * @returns A controller instance.
 *
 * @group Controllers
 * @category SmartSnippetInteractiveInlineLinks
 */
export function buildSmartSnippetInteractiveInlineLinks(engine, props) {
    if (!loadSmartSnippetInteractiveInlineLinksReducer(engine)) {
        throw loadReducerError;
    }
    const getState = () => engine.state;
    const clickedRelatedQuestions = new Set();
    const inlineLinkWasClicked = (linkId) => {
        if (clickedRelatedQuestions.has(linkId)) {
            return true;
        }
        clickedRelatedQuestions.add(linkId);
        return false;
    };
    let lastSearchResponseId = null;
    const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
        if (lastSearchResponseId !== currentSearchResponseId) {
            lastSearchResponseId = currentSearchResponseId;
            interactiveResultsPerInlineLink = {};
            clickedRelatedQuestions.clear();
        }
    };
    const buildInlineLinkInteractiveResult = (link, linkId, questionAnswerId) => buildInteractiveResultCore(engine, { options: { selectionDelay: props?.options?.selectionDelay } }, () => {
        if (inlineLinkWasClicked(linkId)) {
            return;
        }
        engine.dispatch(questionAnswerId
            ? logOpenSmartSnippetSuggestionInlineLink({ questionAnswerId }, link)
            : logOpenSmartSnippetInlineLink(link));
    });
    let interactiveResultsPerInlineLink = {};
    const getInteractiveResult = (link, questionAnswerId) => {
        const { searchResponseId } = getState().search;
        resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
        const linkId = getObjectHash({ ...link, questionAnswerId });
        if (linkId in interactiveResultsPerInlineLink) {
            return interactiveResultsPerInlineLink[linkId];
        }
        interactiveResultsPerInlineLink[linkId] = buildInlineLinkInteractiveResult(link, linkId, questionAnswerId);
        return interactiveResultsPerInlineLink[linkId];
    };
    return {
        selectInlineLink(link, questionAnswerId) {
            getInteractiveResult(link, questionAnswerId)?.select();
        },
        beginDelayedSelectInlineLink(link, questionAnswerId) {
            getInteractiveResult(link, questionAnswerId)?.beginDelayedSelect();
        },
        cancelPendingSelectInlineLink(link, questionAnswerId) {
            getInteractiveResult(link, questionAnswerId)?.cancelPendingSelect();
        },
    };
}
function loadSmartSnippetInteractiveInlineLinksReducer(engine) {
    engine.addReducers({ search, questionAnswering });
    return true;
}
