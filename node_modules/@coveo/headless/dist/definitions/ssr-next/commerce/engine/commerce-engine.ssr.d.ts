/**
 * Utility functions to be used for Commerce Server Side Rendering.
 */
import type { Controller } from '../../../controllers/controller/headless-controller.js';
import { SolutionType } from '../types/controller-constants.js';
import type { ControllerDefinitionsMap } from '../types/controller-definitions.js';
import type { CommerceEngineDefinition, CommerceEngineDefinitionOptions } from '../types/engine.js';
/**
 * Initializes a Commerce engine definition in SSR with given controllers definitions and commerce engine config.
 * @param options - The commerce engine definition
 * @returns Three utility functions to fetch the initial state of the engine in SSR, hydrate the state in CSR,
 *  and a build function that can be used for edge cases requiring more control.
 *
 * @remarks
 * You can use the {@link InferStaticState} and {@link InferHydratedState} utility types with the returned engine definitions
 * to infer the types of static and hydrated state for your controllers.
 *
 * @example
 * ```ts
 * const { listingEngineDefinition } = defineCommerceEngine(engineConfig);
 *
 * const staticState = await listingEngineDefinition.fetchStaticState({
 *   navigatorContext: {/*...* /},
 *   context: {/*...* /},
 * });
 *
 * type SearchStaticState = InferStaticState<typeof listingEngineDefinition>;
 * type SearchHydratedState = InferHydratedState<typeof listingEngineDefinition>;
 * ```
 *
 * @group Engine
 */
export declare function defineCommerceEngine<TControllerDefinitions extends ControllerDefinitionsMap<Controller>>(options: CommerceEngineDefinitionOptions<TControllerDefinitions>): {
    listingEngineDefinition: CommerceEngineDefinition<TControllerDefinitions, SolutionType.listing>;
    searchEngineDefinition: CommerceEngineDefinition<TControllerDefinitions, SolutionType.search>;
    standaloneEngineDefinition: CommerceEngineDefinition<TControllerDefinitions, SolutionType.standalone>;
    recommendationEngineDefinition: CommerceEngineDefinition<TControllerDefinitions, SolutionType.recommendation>;
};
