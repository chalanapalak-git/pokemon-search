/**
 * @license
 *
 * Copyright 2026 Coveo Solutions Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *       http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/ssr-commerce.index.ts
var ssr_commerce_index_exports = {};
__export(ssr_commerce_index_exports, {
  Kind: () => Kind,
  ProductTemplatesHelpers: () => ProductTemplatesHelpers,
  ResultType: () => ResultType,
  SolutionType: () => SolutionType,
  SortBy: () => SortBy,
  SortOrder: () => SortOrder,
  VERSION: () => VERSION,
  buildCriterionExpression: () => buildCriterionExpression,
  buildDateSortCriterion: () => buildDateSortCriterion,
  buildFieldSortCriterion: () => buildFieldSortCriterion,
  buildNoSortCriterion: () => buildNoSortCriterion,
  buildParameterSerializer: () => buildParameterSerializer,
  buildQueryExpression: () => buildQueryExpression,
  buildQueryRankingExpressionSortCriterion: () => buildQueryRankingExpressionSortCriterion,
  buildRelevanceSortCriterion: () => buildRelevanceSortCriterion2,
  buildResultTemplatesManager: () => buildResultTemplatesManager,
  defineBreadcrumbManager: () => defineBreadcrumbManager,
  defineCart: () => defineCart,
  defineCommerceEngine: () => defineCommerceEngine,
  defineContext: () => defineContext,
  defineDidYouMean: () => defineDidYouMean,
  defineFacetGenerator: () => defineFacetGenerator,
  defineFilterSuggestionsGenerator: () => defineFilterSuggestionsGenerator,
  defineInstantProducts: () => defineInstantProducts,
  defineNotifyTrigger: () => defineNotifyTrigger,
  definePagination: () => definePagination,
  defineParameterManager: () => defineParameterManager,
  defineProductEnrichment: () => defineProductEnrichment,
  defineProductList: () => defineProductList,
  defineProductView: () => defineProductView,
  defineQueryTrigger: () => defineQueryTrigger,
  defineRecentQueriesList: () => defineRecentQueriesList,
  defineRecommendations: () => defineRecommendations,
  defineRedirectionTrigger: () => defineRedirectionTrigger,
  defineSearchBox: () => defineSearchBox,
  defineSort: () => defineSort,
  defineStandaloneSearchBox: () => defineStandaloneSearchBox,
  defineSummary: () => defineSummary,
  deserializeRelativeDate: () => deserializeRelativeDate,
  getAnalyticsNextApiBaseUrl: () => getAnalyticsNextApiBaseUrl,
  getCommerceApiBaseUrl: () => getCommerceApiBaseUrl,
  getOrganizationEndpoint: () => getOrganizationEndpoint,
  getSampleCommerceEngineConfiguration: () => getSampleCommerceEngineConfiguration,
  loadCartActions: () => loadCartActions,
  loadCategoryFacetSetActions: () => loadCategoryFacetSetActions,
  loadConfigurationActions: () => loadConfigurationActions,
  loadContextActions: () => loadContextActions,
  loadCoreFacetActions: () => loadCoreFacetActions,
  loadDateFacetActions: () => loadDateFacetActions,
  loadInstantProductsActions: () => loadInstantProductsActions,
  loadNumericFacetActions: () => loadNumericFacetActions,
  loadPaginationActions: () => loadPaginationActions,
  loadProductActions: () => loadProductActions,
  loadProductEnrichmentActions: () => loadProductEnrichmentActions,
  loadProductListingActions: () => loadProductListingActions,
  loadProductListingParametersActions: () => loadProductListingParametersActions,
  loadQueryActions: () => loadQueryActions,
  loadQuerySetActions: () => loadQuerySetActions,
  loadQuerySuggestActions: () => loadQuerySuggestActions,
  loadRecentQueriesActions: () => loadRecentQueriesActions,
  loadRecommendationsActions: () => loadRecommendationsActions,
  loadRegularFacetActions: () => loadRegularFacetActions,
  loadSearchActions: () => loadSearchActions,
  loadSearchParametersActions: () => loadSearchParametersActions,
  loadSortActions: () => loadSortActions,
  loadStandaloneSearchBoxSetActions: () => loadStandaloneSearchBoxSetActions,
  loadTriggersActions: () => loadTriggersActions,
  parseCriterionExpression: () => parseCriterionExpression,
  validateRelativeDate: () => validateRelativeDate
});
module.exports = __toCommonJS(ssr_commerce_index_exports);

// src/app/commerce-engine/commerce-engine-configuration.ts
var import_bueno5 = require("@coveo/bueno");

// src/features/commerce/context/cart/cart-validation.ts
var import_bueno2 = require("@coveo/bueno");

// src/utils/validate-payload.ts
var import_bueno = require("@coveo/bueno");
var requiredNonEmptyString = new import_bueno.StringValue({
  required: true,
  emptyAllowed: false
});
var nonEmptyString = new import_bueno.StringValue({
  required: false,
  emptyAllowed: false
});
var requiredEmptyAllowedString = new import_bueno.StringValue({
  required: true,
  emptyAllowed: true
});
var nonRequiredEmptyAllowedString = new import_bueno.StringValue({
  required: false,
  emptyAllowed: true
});
var nonEmptyStringArray = new import_bueno.ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
var optionalNonEmptyVersionString = new import_bueno.StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^\d+\.\d+\.\d+$/
});
var optionalTrackingId = new import_bueno.StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var requiredTrackingId = new import_bueno.StringValue({
  required: true,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var serializeSchemaValidationError = ({
  message,
  name,
  stack
}) => ({ message, name, stack });
var validatePayloadAndThrow = (payload, definition3) => {
  const isSchemaValue = "required" in definition3;
  if (isSchemaValue) {
    return {
      payload: new import_bueno.Schema({
        value: definition3
      }).validate({ value: payload }).value
    };
  }
  const asRecordValue = new import_bueno.RecordValue({
    options: { required: true },
    values: definition3
  });
  const isInvalid = asRecordValue.validate(payload);
  if (isInvalid) {
    throw new import_bueno.SchemaValidationError(isInvalid);
  }
  return { payload };
};
var validatePayload = (payload, definition3) => {
  try {
    return validatePayloadAndThrow(payload, definition3);
  } catch (error) {
    return {
      payload,
      error: serializeSchemaValidationError(error)
    };
  }
};
var validateInitialState = (engine, schema, obj, functionName) => {
  const message = `Check the initialState of ${functionName}`;
  return validateObject(
    engine,
    schema,
    obj,
    message,
    "Controller initialization error"
  );
};
var validateOptions = (engine, schema, obj, functionName) => {
  const message = `Check the options of ${functionName}`;
  return validateObject(
    engine,
    schema,
    obj,
    message,
    "Controller initialization error"
  );
};
var validateObject = (engine, schema, obj, validationMessage, errorMessage) => {
  try {
    return schema.validate(obj, validationMessage);
  } catch (error) {
    engine.logger.error(error, errorMessage);
    throw error;
  }
};

// src/features/commerce/context/cart/cart-validation.ts
var itemPayloadDefinition = {
  productId: requiredNonEmptyString,
  quantity: new import_bueno2.NumberValue({
    required: true,
    min: 0
  }),
  name: new import_bueno2.StringValue({ required: false }),
  price: new import_bueno2.NumberValue({ required: false, min: 0 })
};
var setItemsPayloadDefinition = new import_bueno2.ArrayValue({
  each: new import_bueno2.RecordValue({
    values: {
      ...itemPayloadDefinition
    }
  })
});
var cartDefinition = {
  items: setItemsPayloadDefinition
};
var cartSchema = new import_bueno2.Schema(cartDefinition);

// src/features/commerce/context/context-validation.ts
var import_bueno3 = require("@coveo/bueno");
var currencies = Intl.supportedValuesOf("currency");
var currencyDefinition = new import_bueno3.StringValue({
  required: true,
  emptyAllowed: false,
  constrainTo: currencies
});
var viewDefinition = {
  url: requiredNonEmptyString
};
var locationDefinition = {
  latitude: new import_bueno3.NumberValue({ min: -90, max: 90, required: true }),
  longitude: new import_bueno3.NumberValue({ min: -180, max: 180, required: true })
};
var customDefinition = {
  custom: new import_bueno3.RecordValue({
    options: { required: false }
  })
};
var contextDefinition = {
  language: requiredNonEmptyString,
  country: requiredNonEmptyString,
  currency: currencyDefinition,
  view: new import_bueno3.RecordValue({
    options: { required: true },
    values: viewDefinition
  }),
  location: new import_bueno3.RecordValue({
    options: { required: false },
    values: locationDefinition
  }),
  custom: new import_bueno3.RecordValue({
    options: { required: false }
  })
};
var contextSchema = new import_bueno3.Schema(contextDefinition);

// src/app/engine-configuration.ts
var import_bueno4 = require("@coveo/bueno");
var engineConfigurationDefinitions = {
  organizationId: requiredNonEmptyString,
  accessToken: requiredNonEmptyString,
  name: new import_bueno4.StringValue({
    required: false,
    emptyAllowed: false
  }),
  analytics: new import_bueno4.RecordValue({
    options: {
      required: false
    },
    values: {
      enabled: new import_bueno4.BooleanValue({
        required: false
      }),
      originContext: new import_bueno4.StringValue({
        required: false
      }),
      originLevel2: new import_bueno4.StringValue({
        required: false
      }),
      originLevel3: new import_bueno4.StringValue({
        required: false
      }),
      analyticsMode: new import_bueno4.StringValue({
        constrainTo: ["legacy", "next"],
        required: false,
        default: "next"
      }),
      proxyBaseUrl: new import_bueno4.StringValue({
        required: false,
        url: true
      }),
      trackingId: new import_bueno4.StringValue({
        required: false,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  environment: new import_bueno4.StringValue({
    required: false,
    default: "prod",
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  })
};

// src/app/commerce-engine/commerce-engine-configuration.ts
var commerceEngineConfigurationSchema = new import_bueno5.Schema({
  ...engineConfigurationDefinitions,
  analytics: new import_bueno5.RecordValue({
    options: { required: true },
    values: {
      enabled: new import_bueno5.BooleanValue({ required: false, default: true }),
      proxyBaseUrl: new import_bueno5.StringValue({ required: false, url: true }),
      source: new import_bueno5.RecordValue({
        options: { required: false },
        values: {
          "@coveo/atomic": nonEmptyString,
          "@coveo/quantic": nonEmptyString
        }
      }),
      trackingId: new import_bueno5.StringValue({
        required: true,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  context: new import_bueno5.RecordValue({
    options: { required: true },
    values: contextDefinition
  }),
  cart: new import_bueno5.RecordValue({
    values: cartDefinition
  }),
  proxyBaseUrl: new import_bueno5.StringValue({ required: false, url: true })
});
function getSampleCommerceEngineConfiguration() {
  return {
    accessToken: "xx564559b1-0045-48e1-953c-3addd1ee4457",
    analytics: {
      trackingId: "sports-ui-samples"
    },
    context: {
      language: "en",
      country: "US",
      currency: "USD",
      view: {
        url: "https://sports.barca.group"
      }
    },
    cart: {
      items: [
        {
          productId: "SP01057_00001",
          quantity: 1,
          name: "Kayaker Canoe",
          price: 800
        },
        {
          productId: "SP00081_00001",
          quantity: 1,
          name: "Bamboo Canoe Paddle",
          price: 120
        },
        {
          productId: "SP04236_00005",
          quantity: 1,
          name: "Eco-Brave Rashguard",
          price: 33
        },
        {
          productId: "SP04236_00005",
          quantity: 1,
          name: "Eco-Brave Rashguard",
          price: 33
        }
      ]
    },
    organizationId: "searchuisamples"
  };
}

// src/features/configuration/configuration-slice.ts
var import_bueno9 = require("@coveo/bueno");
var import_toolkit4 = require("@reduxjs/toolkit");

// src/features/search-parameters/search-parameter-actions.ts
var import_toolkit = require("@reduxjs/toolkit");

// src/features/search-parameters/search-parameter-schema.ts
var import_bueno6 = require("@coveo/bueno");
var searchParametersDefinition = {
  q: new import_bueno6.StringValue(),
  enableQuerySyntax: new import_bueno6.BooleanValue(),
  aq: new import_bueno6.StringValue(),
  cq: new import_bueno6.StringValue(),
  firstResult: new import_bueno6.NumberValue({ min: 0 }),
  numberOfResults: new import_bueno6.NumberValue({ min: 0 }),
  sortCriteria: new import_bueno6.StringValue(),
  f: new import_bueno6.RecordValue(),
  fExcluded: new import_bueno6.RecordValue(),
  cf: new import_bueno6.RecordValue(),
  nf: new import_bueno6.RecordValue(),
  mnf: new import_bueno6.RecordValue(),
  df: new import_bueno6.RecordValue(),
  debug: new import_bueno6.BooleanValue(),
  sf: new import_bueno6.RecordValue(),
  tab: new import_bueno6.StringValue(),
  af: new import_bueno6.RecordValue()
};

// src/features/search-parameters/search-parameter-actions.ts
var restoreSearchParameters = (0, import_toolkit.createAction)(
  "searchParameters/restore",
  (payload) => validatePayload(payload, searchParametersDefinition)
);
var restoreTab = (0, import_toolkit.createAction)(
  "searchParameters/restoreTab",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);

// src/features/tab-set/tab-set-actions.ts
var import_bueno7 = require("@coveo/bueno");
var import_toolkit2 = require("@reduxjs/toolkit");
var registerTab = (0, import_toolkit2.createAction)(
  "tab/register",
  (payload) => {
    const schema = new import_bueno7.RecordValue({
      values: {
        id: requiredNonEmptyString,
        expression: requiredEmptyAllowedString
      }
    });
    return validatePayload(payload, schema);
  }
);
var updateActiveTab = (0, import_toolkit2.createAction)(
  "tab/updateActiveTab",
  (id2) => {
    return validatePayload(id2, requiredNonEmptyString);
  }
);

// src/features/configuration/configuration-actions.ts
var import_bueno8 = require("@coveo/bueno");
var import_toolkit3 = require("@reduxjs/toolkit");

// src/utils/version.ts
var VERSION = "3.45.0";
var COVEO_FRAMEWORK = ["@coveo/atomic", "@coveo/quantic"];

// src/features/configuration/configuration-actions.ts
var originSchemaOnConfigUpdate = () => nonEmptyString;
var originSchemaOnUpdate = () => requiredNonEmptyString;
var updateBasicConfiguration = (0, import_toolkit3.createAction)(
  "configuration/updateBasicConfiguration",
  (payload) => validatePayload(payload, {
    accessToken: nonEmptyString,
    environment: new import_bueno8.StringValue({
      required: false,
      constrainTo: ["prod", "hipaa", "stg", "dev"]
    }),
    organizationId: nonEmptyString
  })
);
var updateSearchConfiguration = (0, import_toolkit3.createAction)(
  "configuration/updateSearchConfiguration",
  (payload) => {
    return validatePayload(payload, {
      proxyBaseUrl: new import_bueno8.StringValue({ required: false, url: true }),
      pipeline: new import_bueno8.StringValue({ required: false, emptyAllowed: true }),
      searchHub: nonEmptyString,
      timezone: nonEmptyString,
      locale: nonEmptyString,
      authenticationProviders: new import_bueno8.ArrayValue({
        required: false,
        each: requiredNonEmptyString
      })
    });
  }
);
var analyticsConfigurationSchema = {
  enabled: new import_bueno8.BooleanValue({ default: true }),
  originContext: originSchemaOnConfigUpdate(),
  originLevel2: originSchemaOnConfigUpdate(),
  originLevel3: originSchemaOnConfigUpdate(),
  proxyBaseUrl: new import_bueno8.StringValue({ required: false, url: true }),
  runtimeEnvironment: new import_bueno8.Value(),
  anonymous: new import_bueno8.BooleanValue({ default: false }),
  deviceId: nonEmptyString,
  userDisplayName: nonEmptyString,
  documentLocation: nonEmptyString,
  trackingId: optionalTrackingId,
  analyticsMode: new import_bueno8.StringValue({
    constrainTo: ["legacy", "next"],
    required: false,
    default: "next"
  }),
  source: new import_bueno8.RecordValue({
    options: { required: false },
    values: COVEO_FRAMEWORK.reduce(
      (acc, framework) => {
        acc[framework] = optionalNonEmptyVersionString;
        return acc;
      },
      {}
    )
  })
};
var updateAnalyticsConfiguration = (0, import_toolkit3.createAction)(
  "configuration/updateAnalyticsConfiguration",
  (payload) => {
    return validatePayload(payload, analyticsConfigurationSchema);
  }
);
var disableAnalytics = (0, import_toolkit3.createAction)("configuration/analytics/disable");
var enableAnalytics = (0, import_toolkit3.createAction)("configuration/analytics/enable");
var setOriginLevel2 = (0, import_toolkit3.createAction)(
  "configuration/analytics/originlevel2",
  (payload) => validatePayload(payload, { originLevel2: originSchemaOnUpdate() })
);
var setOriginLevel3 = (0, import_toolkit3.createAction)(
  "configuration/analytics/originlevel3",
  (payload) => validatePayload(payload, { originLevel3: originSchemaOnUpdate() })
);
var setAgentId = (0, import_toolkit3.createAction)(
  "knowledge/setAgentId",
  (payload) => validatePayload(payload, new import_bueno8.StringValue({ required: true }))
);

// src/features/configuration/configuration-state.ts
var import_dayjs = __toESM(require("dayjs"), 1);
var import_timezone = __toESM(require("dayjs/plugin/timezone.js"), 1);
var import_utc = __toESM(require("dayjs/plugin/utc.js"), 1);
import_dayjs.default.extend(import_utc.default);
import_dayjs.default.extend(import_timezone.default);
var getConfigurationInitialState = () => ({
  organizationId: "",
  accessToken: "",
  search: {
    locale: "en-US",
    timezone: import_dayjs.default.tz.guess(),
    authenticationProviders: []
  },
  analytics: {
    enabled: true,
    originContext: "Search",
    originLevel2: "default",
    originLevel3: "default",
    anonymous: false,
    deviceId: "",
    userDisplayName: "",
    documentLocation: "",
    analyticsMode: "next",
    source: {}
  },
  knowledge: {
    answerConfigurationId: "",
    agentId: void 0
  },
  environment: "prod"
});

// src/features/configuration/magic-cookie.ts
var pendragonCookieValueMatcher = /(^|; )Coveo-Pendragon=([^;]*)/;
function getMagicCookie() {
  if (typeof window === "undefined") {
    return false;
  } else {
    return pendragonCookieValueMatcher.exec(document.cookie)?.pop() || null;
  }
}

// src/features/configuration/configuration-slice.ts
var configurationReducer = (0, import_toolkit4.createReducer)(
  getConfigurationInitialState(),
  (builder) => builder.addCase(updateBasicConfiguration, (state, action) => {
    handleUpdateBasicConfiguration(state, action.payload);
  }).addCase(updateSearchConfiguration, (state, action) => {
    handleUpdateSearchConfiguration(state, action.payload);
  }).addCase(updateAnalyticsConfiguration, (state, action) => {
    handleUpdateAnalyticsConfiguration(state, action.payload);
  }).addCase(disableAnalytics, (state) => {
    state.analytics.enabled = false;
  }).addCase(enableAnalytics, (state) => {
    state.analytics.enabled = true;
  }).addCase(setOriginLevel2, (state, action) => {
    state.analytics.originLevel2 = action.payload.originLevel2;
  }).addCase(setOriginLevel3, (state, action) => {
    state.analytics.originLevel3 = action.payload.originLevel3;
  }).addCase(updateActiveTab, (state, action) => {
    state.analytics.originLevel2 = action.payload;
  }).addCase(restoreTab, (state, action) => {
    state.analytics.originLevel2 = action.payload;
  }).addCase(restoreSearchParameters, (state, action) => {
    if (!(0, import_bueno9.isNullOrUndefined)(action.payload.tab)) {
      state.analytics.originLevel2 = action.payload.tab;
    }
  }).addCase(setAgentId, (state, { payload }) => {
    state.knowledge.agentId = payload;
  })
);
function handleUpdateBasicConfiguration(state, payload) {
  if (!(0, import_bueno9.isNullOrUndefined)(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!(0, import_bueno9.isNullOrUndefined)(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateSearchConfiguration(state, payload) {
  if (!(0, import_bueno9.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.search.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.locale)) {
    state.search.locale = payload.locale;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.timezone)) {
    state.search.timezone = payload.timezone;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.authenticationProviders)) {
    state.search.authenticationProviders = payload.authenticationProviders;
  }
}
function handleUpdateAnalyticsConfiguration(state, payload) {
  if (!(0, import_bueno9.isNullOrUndefined)(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.originContext)) {
    state.analytics.originContext = payload.originContext;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.originLevel2)) {
    state.analytics.originLevel2 = payload.originLevel2;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.originLevel3)) {
    state.analytics.originLevel3 = payload.originLevel3;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.analyticsMode)) {
    state.analytics.analyticsMode = payload.analyticsMode;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.source)) {
    state.analytics.source = payload.source;
  }
  try {
    const magicCookie = getMagicCookie();
    if (magicCookie) {
      state.analytics.analyticsMode = "next";
      state.analytics.trackingId = magicCookie;
    }
  } catch (_) {
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.runtimeEnvironment)) {
    state.analytics.runtimeEnvironment = payload.runtimeEnvironment;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.anonymous)) {
    state.analytics.anonymous = payload.anonymous;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.deviceId)) {
    state.analytics.deviceId = payload.deviceId;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.userDisplayName)) {
    state.analytics.userDisplayName = payload.userDisplayName;
  }
  if (!(0, import_bueno9.isNullOrUndefined)(payload.documentLocation)) {
    state.analytics.documentLocation = payload.documentLocation;
  }
}

// src/app/common-reducers.ts
var configuration = configurationReducer;

// src/app/state-key.ts
var stateKeyDescription = "coveo-headless-internal-state";
var stateKey = Symbol.for(stateKeyDescription);
var redactEngine = (engine) => new Proxy(engine, {
  ownKeys(target) {
    return Reflect.ownKeys(target).filter((key) => key !== stateKey);
  },
  get(target, prop, receiver) {
    if (typeof prop === "symbol" && prop.description === stateKeyDescription && prop !== stateKey) {
      engine.logger.warn(
        "You might be loading Headless twice. Please check your setup.\nIf you are trying to access the inner state... Don't"
      );
    }
    return Reflect.get(target, prop, receiver);
  }
});

// src/features/commerce/context/context-slice.ts
var import_toolkit6 = require("@reduxjs/toolkit");

// src/features/commerce/context/context-actions.ts
var import_toolkit5 = require("@reduxjs/toolkit");
var setContext = (0, import_toolkit5.createAction)(
  "commerce/context/set",
  (payload) => validatePayload(payload, contextDefinition)
);
var setView = (0, import_toolkit5.createAction)(
  "commerce/context/setView",
  (payload) => validatePayload(payload, viewDefinition)
);
var setLocation = (0, import_toolkit5.createAction)(
  "commerce/context/setLocation",
  (payload) => validatePayload(payload, locationDefinition)
);
var setCustom = (0, import_toolkit5.createAction)(
  "commerce/context/setCustom",
  (payload) => validatePayload({ custom: payload }, customDefinition)
);

// src/features/commerce/context/context-state.ts
var getContextInitialState = () => ({
  language: "",
  country: "",
  currency: "",
  view: {
    url: ""
  }
});

// src/features/commerce/context/context-slice.ts
var contextReducer = (0, import_toolkit6.createReducer)(
  getContextInitialState(),
  (builder) => {
    builder.addCase(setContext, (_, { payload }) => {
      return payload;
    }).addCase(setView, (state, { payload }) => {
      state.view = payload;
    }).addCase(setLocation, (state, { payload }) => {
      state.location = payload;
    }).addCase(setCustom, (state, { payload }) => {
      state.custom = payload.custom;
    });
  }
);

// src/features/commerce/pagination/pagination-selectors.ts
var perPagePrincipalSelector = (state) => state.commercePagination?.principal.perPage || 0;
var perPageRecommendationSelector = (state, slotId) => state.commercePagination?.recommendations[slotId]?.perPage || 0;
var totalEntriesPrincipalSelector = (state) => state.commercePagination?.principal.totalEntries || 0;
var totalEntriesRecommendationSelector = (state, slotId) => state.commercePagination?.recommendations[slotId]?.totalEntries || 0;
var pagePrincipalSelector = (state) => state.commercePagination?.principal.page || 0;
var pageRecommendationSelector = (state, slotId) => state.commercePagination?.recommendations[slotId]?.page || 0;

// src/features/commerce/parameters/parameters-schema.ts
var import_bueno10 = require("@coveo/bueno");
var parametersDefinition = {
  f: new import_bueno10.RecordValue(),
  fExcluded: new import_bueno10.RecordValue(),
  lf: new import_bueno10.RecordValue(),
  cf: new import_bueno10.RecordValue(),
  nf: new import_bueno10.RecordValue(),
  nfExcluded: new import_bueno10.RecordValue(),
  mnf: new import_bueno10.RecordValue(),
  mnfExcluded: new import_bueno10.RecordValue(),
  df: new import_bueno10.RecordValue(),
  dfExcluded: new import_bueno10.RecordValue(),
  sortCriteria: new import_bueno10.RecordValue(),
  page: new import_bueno10.NumberValue({ min: 0 }),
  perPage: new import_bueno10.NumberValue({ min: 1 })
};

// src/features/facets/category-facet-set/category-facet-utils.ts
function findActiveValueAncestry(valuesAsTree) {
  const { activeValue, ancestryMap } = getActiveValueAndAncestryFromValueTree(valuesAsTree);
  return activeValue ? getActiveValueAncestry(activeValue, ancestryMap) : [];
}
function getActiveValueAndAncestryFromValueTree(valuesAsTrees) {
  const valueToVisit = [...valuesAsTrees];
  const ancestryMap = /* @__PURE__ */ new Map();
  while (valueToVisit.length > 0) {
    const currentValue = valueToVisit.shift();
    if (currentValue.state === "selected") {
      return { activeValue: currentValue, ancestryMap };
    }
    if (ancestryMap) {
      for (const childValue of currentValue.children) {
        ancestryMap.set(childValue, currentValue);
      }
    }
    valueToVisit.unshift(...currentValue.children);
  }
  return {};
}
function getActiveValueAncestry(activeValue, valueToParentMap) {
  const activeValueAncestry = [];
  if (!activeValue) {
    return [];
  }
  let lastParent = activeValue;
  do {
    activeValueAncestry.unshift(lastParent);
    lastParent = valueToParentMap.get(lastParent);
  } while (lastParent);
  return activeValueAncestry;
}

// src/features/parameter-manager/parameter-manager-selectors.ts
function getQ(section, querySelector2, initialState) {
  if (section === void 0) {
    return {};
  }
  const q = querySelector2(section);
  const shouldInclude = q !== initialState;
  return shouldInclude ? { q } : {};
}
function getSortCriteria(section, sortCriteriaSelector, initialState) {
  if (section === void 0) {
    return {};
  }
  const sortCriteria = sortCriteriaSelector(section);
  const shouldInclude = sortCriteria !== initialState;
  return shouldInclude ? { sortCriteria } : {};
}
function getFacets(section, facetIsEnabled, valuesSelector, out) {
  if (section === void 0) {
    return {};
  }
  const facets = Object.entries(section).filter(([facetId2]) => facetIsEnabled(facetId2)).map(([facetId2, { request }]) => {
    const selectedValues = valuesSelector(request);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(facets).length ? { [out]: facets } : {};
}

// src/features/commerce/pagination/pagination-state.ts
function getCommercePaginationInitialState() {
  return {
    principal: getCommercePaginationInitialSlice(),
    recommendations: {}
  };
}
function getCommercePaginationInitialSlice() {
  return {
    page: 0,
    perPage: 0,
    totalEntries: 0,
    totalPages: 0
  };
}

// src/features/commerce/sort/sort.ts
var import_bueno11 = require("@coveo/bueno");

// src/features/sort/sort.ts
var SortBy = /* @__PURE__ */ ((SortBy3) => {
  SortBy3["Relevance"] = "relevance";
  SortBy3["Fields"] = "fields";
  return SortBy3;
})(SortBy || {});
var SortDirection = /* @__PURE__ */ ((SortDirection2) => {
  SortDirection2["Ascending"] = "asc";
  SortDirection2["Descending"] = "desc";
  return SortDirection2;
})(SortDirection || {});
var buildRelevanceSortCriterion = () => ({
  by: "relevance" /* Relevance */
});

// src/features/commerce/sort/sort.ts
var buildFieldsSortCriterion = (fields) => ({
  by: "fields" /* Fields */,
  fields
});
var sortCriterionDefinition = new import_bueno11.RecordValue({
  options: {
    required: false
  },
  values: {
    by: new import_bueno11.EnumValue({ enum: SortBy, required: true }),
    fields: new import_bueno11.ArrayValue({
      each: new import_bueno11.RecordValue({
        values: {
          field: new import_bueno11.StringValue({ required: true }),
          direction: new import_bueno11.EnumValue({ enum: SortDirection }),
          displayName: new import_bueno11.StringValue()
        }
      })
    })
  }
});

// src/features/commerce/sort/sort-state.ts
function getCommerceSortInitialState() {
  return {
    appliedSort: buildRelevanceSortCriterion(),
    availableSorts: [buildRelevanceSortCriterion()]
  };
}

// src/features/commerce/parameters/parameters-selectors.ts
function activeParametersSelector(state) {
  return {
    ...getPage(
      state?.commercePagination,
      (s) => s.principal.page,
      getCommercePaginationInitialSlice().page
    ),
    ...getPerPage(
      state?.commercePagination,
      (s) => s.principal.perPage,
      getCommercePaginationInitialSlice().perPage
    ),
    ...getSortCriteria(
      state?.commerceSort,
      (s) => s.appliedSort,
      getCommerceSortInitialState().appliedSort
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "regular"),
      getSelectedValues,
      "f"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "regular"),
      getExcludedValues,
      "fExcluded"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "location"),
      getSelectedLocationValues,
      "lf"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "hierarchical"),
      getSelectedCategoryValues,
      "cf"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "dateRange"),
      getSelectedRangeValues,
      "df"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "dateRange"),
      getExcludedRangeValues,
      "dfExcluded"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "numericalRange"),
      getSelectedRangeValues,
      "nf"
    ),
    ...getFacets(
      state.commerceFacetSet,
      facetIsOfType(state, "numericalRange"),
      getExcludedRangeValues,
      "nfExcluded"
    ),
    ...getManualNumericFacet("selected", state.manualNumericFacetSet),
    ...getManualNumericFacet("excluded", state.manualNumericFacetSet)
  };
}
function getPage(section, pageSelector, initialState) {
  if (section === void 0) {
    return {};
  }
  const page = pageSelector(section);
  const shouldInclude = page !== initialState;
  return shouldInclude ? { page } : {};
}
function getPerPage(section, perPageSelector, initialState) {
  if (section === void 0) {
    return {};
  }
  const perPage = perPageSelector(section);
  const shouldInclude = perPage !== initialState;
  return shouldInclude ? { perPage } : {};
}
function getSelectedValues(request) {
  return request.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getExcludedValues(request) {
  return request.values.filter((fv) => fv.state === "excluded").map((fv) => fv.value);
}
function getSelectedLocationValues(request) {
  return request.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getSelectedRangeValues(request) {
  return request.values.filter(
    (fv) => fv.state === "selected"
  );
}
function getExcludedRangeValues(request) {
  return request.values.filter(
    (fv) => fv.state === "excluded"
  );
}
function getManualNumericFacet(state, section) {
  if (!section || state === "idle") {
    return {};
  }
  const manualNumericFacets = Object.entries(section).map(([facetId2, manualFacetRange]) => {
    if (manualFacetRange.manualRange === void 0 || manualFacetRange.manualRange.state !== state) {
      return;
    }
    return { [facetId2]: [manualFacetRange.manualRange] };
  }).filter((manualRange) => manualRange !== void 0).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return state === "selected" ? { mnf: manualNumericFacets } : { mnfExcluded: manualNumericFacets };
}
function getSelectedCategoryValues(request) {
  const categoryRequest = request;
  return findActiveValueAncestry(
    categoryRequest.values
  ).map((v) => v.value);
}
function facetIsOfType(state, type) {
  return (facetId2) => {
    return state.commerceFacetSet[facetId2].request.type === type;
  };
}

// src/utils/utils.ts
var randomID = (prepend, length = 5) => prepend + Math.random().toString(36).substring(2, 2 + length);
function isArray(value) {
  return Array.isArray(value);
}
function isEmptyString(str) {
  return str.trim() === "";
}
function fromEntries(values) {
  const newObject = {};
  for (const [key, value] of values) {
    newObject[key] = value;
  }
  return newObject;
}
function mapObject(obj, predicate) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key,
      predicate(value, key)
    ])
  );
}
function filterObject(obj, predicate) {
  return Object.fromEntries(
    Object.entries(obj).filter(
      ([key, value]) => predicate(value, key)
    )
  );
}
function clone(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (!value) {
    return value;
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (_) {
    return value;
  }
}
function createDeferredPromise() {
  let resolve = null;
  let reject = null;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return { promise, resolve, reject };
}
function createWaitForActionMiddleware(isDesiredAction) {
  const { promise, resolve } = createDeferredPromise();
  const middleware = () => (next) => (action) => {
    next(action);
    if (isDesiredAction(action)) {
      resolve(action);
    }
  };
  return { promise, middleware };
}
function isRecommendationActionPayload(action) {
  if (action === null || action === void 0) {
    return false;
  }
  if (typeof action === "object" && "meta" in action) {
    return action.meta?.arg?.slotId !== void 0;
  }
  return false;
}
function createWaitForActionMiddlewareForRecommendation(isDesiredAction, memo) {
  const { promise, resolve } = createDeferredPromise();
  let hasBeenResolved = false;
  const hasSlotBeenProcessed = (slotId) => memo.has(slotId);
  const middleware = () => (next) => (action) => {
    next(action);
    if (isDesiredAction(action) && !hasBeenResolved && isRecommendationActionPayload(action) && !hasSlotBeenProcessed(action.meta.arg.slotId)) {
      hasBeenResolved = true;
      memo.add(action.meta.arg.slotId);
      resolve(action);
    }
  };
  return { promise, middleware };
}
function debounce(func, wait, options = {}) {
  let timeoutId;
  return (...args) => {
    const shouldCallImmediately = options.isImmediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = void 0;
      if (!options.isImmediate) {
        func.apply(void 0, args);
      }
    }, wait);
    if (shouldCallImmediately) {
      return func.apply(void 0, args);
    }
  };
}

// src/features/search-parameters/search-parameter-serializer.ts
var import_bueno44 = require("@coveo/bueno");

// src/api/search/date/date-format.ts
var import_dayjs2 = __toESM(require("dayjs"), 1);
var import_customParseFormat = __toESM(require("dayjs/plugin/customParseFormat.js"), 1);
import_dayjs2.default.extend(import_customParseFormat.default);
var API_DATE_FORMAT = "YYYY/MM/DD@HH:mm:ss";
var API_DATE_MINIMUM = "1401-01-01";
function parseDate(date, format) {
  const parsedDate = (0, import_dayjs2.default)(date, format);
  if (!parsedDate.isValid() && !format) {
    return (0, import_dayjs2.default)(date, API_DATE_FORMAT);
  }
  return parsedDate;
}
function formatDateForSearchApi(date) {
  return date.format(API_DATE_FORMAT);
}
function isSearchApiDate(date) {
  return formatDateForSearchApi(parseDate(date)) === date;
}
function validateAbsoluteDate(date, dateFormat) {
  const dayJSDate = parseDate(date, dateFormat);
  if (!dayJSDate.isValid()) {
    const provideFormat = ". Please provide a date format string in the configuration options. See https://day.js.org/docs/en/parse/string-format for more information.";
    const withFormat = ` with the format "${dateFormat}"`;
    throw new Error(
      `Could not parse the provided date "${date}"${dateFormat ? withFormat : provideFormat}`
    );
  }
  assertDateAboveAPIMinimum(dayJSDate);
}
function assertDateAboveAPIMinimum(date) {
  if (date.isBefore(API_DATE_MINIMUM)) {
    throw new Error(
      `Date is before year 1401, which is unsupported by the API: ${date}`
    );
  }
}

// src/api/search/date/relative-date.ts
var import_bueno12 = require("@coveo/bueno");
var import_dayjs3 = __toESM(require("dayjs"), 1);
var import_quarterOfYear = __toESM(require("dayjs/plugin/quarterOfYear.js"), 1);
import_dayjs3.default.extend(import_quarterOfYear.default);
var validRelativeDatePeriods = ["past", "now", "next"];
var validRelativeDateUnits = [
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year"
];
var buildRelativeDateDefinition = (period) => {
  const isNow = period === "now";
  return {
    amount: new import_bueno12.NumberValue({ required: !isNow, min: 1 }),
    unit: new import_bueno12.StringValue({
      required: !isNow,
      constrainTo: validRelativeDateUnits
    }),
    period: new import_bueno12.StringValue({
      required: true,
      constrainTo: validRelativeDatePeriods
    })
  };
};
function validateRelativeDate(date) {
  if (typeof date === "string" && !isRelativeDateFormat(date)) {
    throw new Error(
      `The value "${date}" is not respecting the relative date format "period-amount-unit"`
    );
  }
  const relativeDate = typeof date === "string" ? parseRelativeDate(date) : date;
  new import_bueno12.Schema(buildRelativeDateDefinition(relativeDate.period)).validate(
    relativeDate
  );
  const dayJsDate = relativeToAbsoluteDate(relativeDate);
  const stringifiedDate = JSON.stringify(relativeDate);
  if (!dayJsDate.isValid()) {
    throw new Error(`Date is invalid: ${stringifiedDate}`);
  }
  assertDateAboveAPIMinimum(dayJsDate);
}
function serializeRelativeDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
    case "next":
      return `${period}-${amount}-${unit}`;
    case "now":
      return period;
  }
}
function relativeToAbsoluteDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
      return (0, import_dayjs3.default)().subtract(amount, unit);
    case "next":
      return (0, import_dayjs3.default)().add(amount, unit);
    case "now":
      return (0, import_dayjs3.default)();
  }
}
function formatRelativeDateForSearchApi(relativeDate) {
  return formatDateForSearchApi(
    relativeToAbsoluteDate(parseRelativeDate(relativeDate))
  );
}
function splitDate(date) {
  return date.toLocaleLowerCase().split("-");
}
function isRelativeDateFormat(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return true;
  }
  if (!validRelativeDatePeriods.includes(period)) {
    return false;
  }
  if (!validRelativeDateUnits.includes(unit)) {
    return false;
  }
  const intAmount = parseInt(amount);
  if (Number.isNaN(intAmount) || intAmount <= 0) {
    return false;
  }
  return true;
}
function isRelativeDate(date) {
  return !!date && typeof date === "object" && "period" in date;
}
function parseRelativeDate(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return {
      period: "now"
    };
  }
  return {
    period,
    amount: amount ? parseInt(amount) : void 0,
    unit: unit ? unit : void 0
  };
}
function deserializeRelativeDate(date) {
  validateRelativeDate(date);
  return parseRelativeDate(date);
}

// src/features/facets/facet-set/facet-set-analytics-actions.ts
var import_bueno16 = require("@coveo/bueno");

// src/features/analytics/analytics-utils.ts
var import_bueno15 = require("@coveo/bueno");
var import_toolkit10 = require("@reduxjs/toolkit");

// src/api/analytics/analytics-relay-client.ts
var import_relay = require("@coveo/relay");
var import_toolkit8 = require("@reduxjs/toolkit");

// src/utils/runtime.ts
function isBrowser() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}

// src/api/platform-client.ts
var import_exponential_backoff = require("exponential-backoff");

// src/utils/errors.ts
var loadReducerError = new Error("Failed to load reducers.");
var UnauthorizedTokenError = class extends Error {
  constructor() {
    super();
    this.name = "UnauthorizedTokenError";
    this.message = "The token being used to perform the request is unauthorized. It may be expired or invalid.";
  }
};
var DisconnectedError = class extends Error {
  constructor(url, statusCode) {
    super();
    __publicField(this, "statusCode");
    this.name = "Disconnected";
    this.message = `Client could not connect to the following URL: ${url}`;
    this.statusCode = statusCode ?? 0;
  }
};

// src/api/form-url-encoder.ts
function encodeAsFormUrl(obj) {
  const body = [];
  for (const property in obj) {
    const key = encodeURIComponent(property);
    const value = encodeURIComponent(obj[property]);
    body.push(`${key}=${value}`);
  }
  return body.join("&");
}
function canBeFormUrlEncoded(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (!obj) {
    return false;
  }
  return Object.values(obj).every(isPrimitive);
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}

// src/api/platform-client.ts
function isThrottled(status) {
  return status === 429;
}
var PlatformClient = class _PlatformClient {
  static async call(options) {
    const defaultRequestOptions = buildDefaultRequestOptions(options);
    const { logger } = options;
    const requestInfo = await _PlatformClient.preprocessRequest(
      defaultRequestOptions,
      options
    );
    logger.info(requestInfo, "Platform request");
    const { url, ...requestData } = requestInfo;
    const request = async () => {
      const response = await fetch(url, requestData);
      if (isThrottled(response.status)) {
        throw response;
      }
      return response;
    };
    try {
      const response = await (0, import_exponential_backoff.backOff)(request, {
        startingDelay: 100,
        timeMultiple: 2,
        maxDelay: 800,
        numOfAttempts: 4,
        jitter: "full",
        retry: async (e) => {
          const shouldRetry = e && isThrottled(e.status);
          if (shouldRetry) {
            logger.info("Platform retrying request");
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
          return shouldRetry;
        }
      });
      switch (response.status) {
        case 419:
        case 401:
          logger.info("Platform renewing token");
          throw new UnauthorizedTokenError();
        case 404:
          throw new DisconnectedError(url, response.status);
        default:
          logger.info({ response, requestInfo }, "Platform response");
          return response;
      }
    } catch (error) {
      if (error.message === "Failed to fetch") {
        return new DisconnectedError(url);
      }
      return error;
    }
  }
  static async preprocessRequest(defaultRequestOptions, options) {
    const { origin, preprocessRequest, logger, requestMetadata } = options;
    const { signal: _signal, ...withoutSignal } = defaultRequestOptions;
    const untaintedOutput = clone(withoutSignal);
    try {
      const processedRequest = await preprocessRequest(
        defaultRequestOptions,
        origin,
        requestMetadata
      );
      return {
        ...defaultRequestOptions,
        ...processedRequest
      };
    } catch (e) {
      logger.error(
        e,
        "Platform request preprocessing failed. Returning default request options."
      );
    }
    return untaintedOutput;
  }
};
function getOrganizationEndpoint(organizationId, environment = "prod", endpointType = "platform") {
  const environmentSuffix = environment === "prod" ? "" : environment;
  const endpointTypePart = endpointType === "platform" ? "" : `.${endpointType}`;
  return `https://${organizationId}${endpointTypePart}.org${environmentSuffix}.coveo.com`;
}
function getSearchApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(
    organizationId,
    environment
  );
  return `${organizationEndpoint}/rest/search/v2`;
}
function getAnalyticsNextApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(
    organizationId,
    environment,
    "analytics"
  );
  return `${organizationEndpoint}/rest/organizations/${organizationId}/events/v1`;
}
function buildDefaultRequestOptions(options) {
  const { url, method, requestParams, contentType, accessToken, signal } = options;
  const isMethodWithBody = options.method === "POST" || options.method === "PUT";
  const body = encodeBody(requestParams, contentType);
  return {
    url,
    method,
    headers: {
      "Content-Type": contentType,
      Authorization: `Bearer ${accessToken}`,
      ...options.headers
    },
    ...isMethodWithBody && { body },
    signal
  };
}
function encodeBody(body, contentType) {
  if (contentType === "application/x-www-form-urlencoded") {
    return canBeFormUrlEncoded(body) ? encodeAsFormUrl(body) : "";
  }
  return JSON.stringify(body);
}

// src/api/analytics/analytics-selectors.ts
var import_toolkit7 = require("@reduxjs/toolkit");
var getAnalyticsSource = (0, import_toolkit7.createSelector)(
  (state) => state.source,
  (source) => Object.entries(source).map(
    ([frameworkName, frameworkVersion]) => `${frameworkName}@${frameworkVersion}`
  ).concat(`@coveo/headless@${VERSION}`)
);

// src/api/analytics/analytics-relay-client.ts
var getRelayInstanceFromState = (0, import_toolkit8.createSelector)(
  (state) => state.configuration.organizationId,
  (state) => state.configuration.environment,
  (state) => state.configuration.accessToken,
  (state) => state.configuration.analytics,
  (state) => getAnalyticsSource(state.configuration.analytics),
  (_state, navigatorContextProvider) => navigatorContextProvider,
  (organizationId, platformEnvironment, token, { trackingId, apiBaseUrl, enabled }, source, navigatorContextProvider) => {
    const environment = getEnvironment(navigatorContextProvider);
    return (0, import_relay.createRelay)({
      mode: enabled ? "emit" : "disabled",
      url: apiBaseUrl ?? getAnalyticsNextApiBaseUrl(organizationId, platformEnvironment),
      token,
      trackingId: trackingId ?? null,
      source,
      environment
    });
  }
);
var noopRelayEnvironment = {
  generateUUID: () => "",
  getLocation: () => null,
  getReferrer: () => null,
  getUserAgent: () => null,
  send: () => {
  },
  storage: {
    getItem: () => null,
    setItem: () => {
    },
    removeItem: () => {
    }
  }
};
var getEnvironment = (customProvider) => {
  if (!customProvider) {
    return void 0;
  }
  const customContext = customProvider();
  const baseEnvironment = isBrowser() ? (0, import_relay.buildBrowserEnvironment)() : noopRelayEnvironment;
  return {
    ...baseEnvironment,
    generateUUID: () => customContext.clientId,
    getLocation: () => customContext.location,
    getReferrer: () => customContext.referrer,
    getUserAgent: () => customContext.userAgent
  };
};

// ../../node_modules/.pnpm/coveo.analytics@2.30.52_encoding@0.1.13_react-native@0.83.1_@babel+core@7.28.6_@types+react@19.2.7_react@19.2.3_/node_modules/coveo.analytics/dist/browser.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var EventType;
(function(EventType2) {
  EventType2["search"] = "search";
  EventType2["click"] = "click";
  EventType2["custom"] = "custom";
  EventType2["view"] = "view";
  EventType2["collect"] = "collect";
})(EventType || (EventType = {}));
function hasWindow() {
  return typeof window !== "undefined";
}
function hasNavigator() {
  return typeof navigator !== "undefined";
}
function hasDocument() {
  return typeof document !== "undefined";
}
function hasLocalStorage() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage() {
  return hasNavigator() && navigator.cookieEnabled;
}
var eventTypesForDefaultValues = [EventType.click, EventType.custom, EventType.search, EventType.view];
var addDefaultValues = (eventType, payload) => {
  return eventTypesForDefaultValues.indexOf(eventType) !== -1 ? Object.assign({ language: hasDocument() ? document.documentElement.lang : "unknown", userAgent: hasNavigator() ? navigator.userAgent : "unknown" }, payload) : payload;
};
var Cookie = class _Cookie {
  static set(name, value, expire) {
    var domain, expirationDate, domainParts, host;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    host = window.location.hostname;
    if (host.indexOf(".") === -1) {
      writeCookie(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    var cookiePrefix = name + "=";
    var cookieArray = document.cookie.split(";");
    for (var i = 0; i < cookieArray.length; i++) {
      var cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}
function getAvailableStorage() {
  if (hasLocalStorage()) {
    return localStorage;
  }
  if (hasCookieStorage()) {
    return new CookieStorage();
  }
  if (hasSessionStorage()) {
    return sessionStorage;
  }
  return new NullStorage();
}
var CookieStorage = class _CookieStorage2 {
  getItem(key) {
    return Cookie.get(`${_CookieStorage2.prefix}${key}`);
  }
  removeItem(key) {
    Cookie.erase(`${_CookieStorage2.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie.set(`${_CookieStorage2.prefix}${key}`, data, expire);
  }
};
CookieStorage.prefix = "coveo_";
var CookieAndLocalStorage = class {
  constructor() {
    this.cookieStorage = new CookieStorage();
  }
  getItem(key) {
    return localStorage.getItem(key) || this.cookieStorage.getItem(key);
  }
  removeItem(key) {
    this.cookieStorage.removeItem(key);
    localStorage.removeItem(key);
  }
  setItem(key, data) {
    localStorage.setItem(key, data);
    this.cookieStorage.setItem(key, data, 31556926e3);
  }
};
var NullStorage = class {
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, data) {
  }
};
var STORE_KEY = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE = 1e3 * 60;
var MAX_VALUE_SIZE = 75;
var HistoryStore = class {
  constructor(store) {
    this.store = store || getAvailableStorage();
  }
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    let currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory != null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  addElementAsync(elem) {
    return __awaiter(this, void 0, void 0, function* () {
      elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
      elem = this.cropQueryElement(this.stripEmptyQuery(elem));
      let currentHistory = yield this.getHistoryWithInternalTimeAsync();
      if (currentHistory != null) {
        if (this.isValidEntry(elem)) {
          this.setHistory([elem].concat(currentHistory));
        }
      } else {
        this.setHistory([elem]);
      }
    });
  }
  getHistory() {
    const history = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history));
  }
  getHistoryAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      const history = yield this.getHistoryWithInternalTimeAsync();
      return this.stripEmptyQueries(this.stripInternalTime(history));
    });
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  getHistoryWithInternalTimeAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const elements = yield this.store.getItem(STORE_KEY);
        if (elements) {
          return JSON.parse(elements);
        } else {
          return [];
        }
      } catch (e) {
        return [];
      }
    });
  }
  setHistory(history) {
    try {
      this.store.setItem(STORE_KEY, JSON.stringify(history.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    let currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE);
    }
    return part;
  }
  isValidEntry(elem) {
    let lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value == elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE;
    }
    return true;
  }
  stripInternalTime(history) {
    if (Array.isArray(history)) {
      return history.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history) {
    return history.map((part) => this.stripEmptyQuery(part));
  }
};
var enhanceViewEvent = (eventType, payload) => __awaiter(void 0, void 0, void 0, function* () {
  if (eventType === EventType.view) {
    yield addPageViewToHistory(payload.contentIdValue);
    return Object.assign({ location: window.location.toString(), referrer: document.referrer, title: document.title }, payload);
  }
  return payload;
});
var addPageViewToHistory = (pageViewValue) => __awaiter(void 0, void 0, void 0, function* () {
  const store = new HistoryStore();
  const historyElement = {
    name: "PageView",
    value: pageViewValue,
    time: (/* @__PURE__ */ new Date()).toISOString()
  };
  yield store.addElementAsync(historyElement);
});
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var v5 = v35("v5", 80, sha1);
var uuidv5 = v5;
var libVersion = "2.30.52";
var getFormattedLocation = (location) => `${location.protocol}//${location.hostname}${location.pathname.indexOf("/") === 0 ? location.pathname : `/${location.pathname}`}${location.search}`;
var BasePluginEventTypes = {
  pageview: "pageview",
  event: "event"
};
var Plugin = class {
  constructor({ client, uuidGenerator = v4 }) {
    this.client = client;
    this.uuidGenerator = uuidGenerator;
  }
};
var BasePlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
    this.actionData = {};
    this.pageViewId = uuidGenerator();
    this.nextPageViewId = this.pageViewId;
    this.currentLocation = getFormattedLocation(window.location);
    this.lastReferrer = hasDocument() ? document.referrer : "";
    this.addHooks();
  }
  getApi(name) {
    switch (name) {
      case "setAction":
        return this.setAction;
      default:
        return null;
    }
  }
  setAction(action, options) {
    this.action = action;
    this.actionData = options;
  }
  clearData() {
    this.clearPluginData();
    this.action = void 0;
    this.actionData = {};
  }
  getLocationInformation(eventType, payload) {
    return Object.assign({ hitType: eventType }, this.getNextValues(eventType, payload));
  }
  updateLocationInformation(eventType, payload) {
    this.updateLocationForNextPageView(eventType, payload);
  }
  getDefaultContextInformation(eventType) {
    const documentContext = {
      title: hasDocument() ? document.title : "",
      encoding: hasDocument() ? document.characterSet : "UTF-8"
    };
    const screenContext = {
      screenResolution: `${screen.width}x${screen.height}`,
      screenColor: `${screen.colorDepth}-bit`
    };
    const navigatorContext = {
      language: navigator.language,
      userAgent: navigator.userAgent
    };
    const eventContext = {
      time: Date.now(),
      eventId: this.uuidGenerator()
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, eventContext), screenContext), navigatorContext), documentContext);
  }
  updateLocationForNextPageView(eventType, payload) {
    const { pageViewId, referrer, location } = this.getNextValues(eventType, payload);
    this.lastReferrer = referrer;
    this.pageViewId = pageViewId;
    this.currentLocation = location;
    if (eventType === BasePluginEventTypes.pageview) {
      this.nextPageViewId = this.uuidGenerator();
      this.hasSentFirstPageView = true;
    }
  }
  getNextValues(eventType, payload) {
    return {
      pageViewId: eventType === BasePluginEventTypes.pageview ? this.nextPageViewId : this.pageViewId,
      referrer: eventType === BasePluginEventTypes.pageview && this.hasSentFirstPageView ? this.currentLocation : this.lastReferrer,
      location: eventType === BasePluginEventTypes.pageview ? this.getCurrentLocationFromPayload(payload) : this.currentLocation
    };
  }
  getCurrentLocationFromPayload(payload) {
    if (!!payload.page) {
      const removeStartingSlash = (page) => page.replace(/^\/?(.*)$/, "/$1");
      const extractHostnamePart = (location) => location.split("/").slice(0, 3).join("/");
      return `${extractHostnamePart(this.currentLocation)}${removeStartingSlash(payload.page)}`;
    } else {
      return getFormattedLocation(window.location);
    }
  }
};
var CoveoLinkParam = class _CoveoLinkParam {
  constructor(clientId, timestamp) {
    if (!validate(clientId))
      throw Error("Not a valid uuid");
    this.clientId = clientId;
    this.creationDate = Math.floor(timestamp / 1e3);
  }
  toString() {
    return this.clientId.replace(/-/g, "") + "." + this.creationDate.toString();
  }
  get expired() {
    const age = Math.floor(Date.now() / 1e3) - this.creationDate;
    return age < 0 || age > _CoveoLinkParam.expirationTime;
  }
  validate(referrerString, referrerList) {
    return !this.expired && this.matchReferrer(referrerString, referrerList);
  }
  matchReferrer(referrerString, referrerList) {
    try {
      const url = new URL(referrerString);
      return referrerList.some((value) => {
        const hostRegExp = new RegExp(value.replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*") + "$");
        return hostRegExp.test(url.host);
      });
    } catch (error) {
      return false;
    }
  }
  static fromString(input) {
    const parts = input.split(".");
    if (parts.length !== 2) {
      return null;
    }
    const [clientIdPart, creationDate] = parts;
    if (clientIdPart.length !== 32 || isNaN(parseInt(creationDate))) {
      return null;
    }
    const clientId = clientIdPart.substring(0, 8) + "-" + clientIdPart.substring(8, 12) + "-" + clientIdPart.substring(12, 16) + "-" + clientIdPart.substring(16, 20) + "-" + clientIdPart.substring(20, 32);
    if (validate(clientId)) {
      return new _CoveoLinkParam(clientId, Number.parseInt(creationDate) * 1e3);
    } else {
      return null;
    }
  }
};
CoveoLinkParam.cvo_cid = "cvo_cid";
CoveoLinkParam.expirationTime = 120;
var LinkPlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
  }
  getApi(name) {
    switch (name) {
      case "decorate":
        return this.decorate;
      case "acceptFrom":
        return this.acceptFrom;
      default:
        return null;
    }
  }
  decorate(urlString) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.client.getCurrentVisitorId) {
        throw new Error("Could not retrieve current clientId");
      }
      try {
        const url = new URL(urlString);
        const clientId = yield this.client.getCurrentVisitorId();
        url.searchParams.set(CoveoLinkParam.cvo_cid, new CoveoLinkParam(clientId, Date.now()).toString());
        return url.toString();
      } catch (error) {
        throw new Error("Invalid URL provided");
      }
    });
  }
  acceptFrom(acceptedReferrers) {
    this.client.setAcceptedLinkReferrers(acceptedReferrers);
  }
};
LinkPlugin.Id = "link";
var keysOf = Object.keys;
function isObject(o) {
  return o !== null && typeof o === "object" && !Array.isArray(o);
}
var UTF8_HIGH_BIT = 128;
var UTF8_HEADER_2 = 192;
var UTF8_HEADER_3 = 224;
var UTF8_HEADER_4 = 240;
function utf8ByteCountFromFirstByte(firstByte) {
  if ((firstByte & 248) === UTF8_HEADER_4) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_4) === UTF8_HEADER_3) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_3) === UTF8_HEADER_2) {
    return 2;
  }
  return 1;
}
function truncateUrl(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT) != UTF8_HIGH_BIT) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_2) != UTF8_HIGH_BIT) {
      if (limit - end >= utf8ByteCountFromFirstByte(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
var ticketKeysMapping = {
  id: "svc_ticket_id",
  subject: "svc_ticket_subject",
  description: "svc_ticket_description",
  category: "svc_ticket_category",
  productId: "svc_ticket_product_id",
  custom: "svc_ticket_custom"
};
var ticketKeysMappingValues = keysOf(ticketKeysMapping).map((key) => ticketKeysMapping[key]);
var ticketSubKeysMatchGroup = [...ticketKeysMappingValues].join("|");
var ticketKeyRegex = new RegExp(`^(${ticketSubKeysMatchGroup}$)`);
var serviceActionsKeysMapping = {
  svcAction: "svc_action",
  svcActionData: "svc_action_data"
};
var convertTicketToMeasurementProtocol = (ticket) => {
  return keysOf(ticket).filter((key) => ticket[key] !== void 0).reduce((mappedTicket, key) => {
    const newKey = ticketKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedTicket), { [newKey]: ticket[key] });
  }, {});
};
var isTicketKey = (key) => ticketKeyRegex.test(key);
var isServiceKey = [isTicketKey];
var productKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  price: "pr",
  quantity: "qt",
  coupon: "cc",
  position: "ps",
  group: "group"
};
var impressionKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  position: "ps",
  price: "pr",
  group: "group"
};
var productActionsKeysMapping = {
  action: "pa",
  list: "pal",
  listSource: "pls"
};
var transactionActionsKeysMapping = {
  id: "ti",
  revenue: "tr",
  tax: "tt",
  shipping: "ts",
  coupon: "tcc",
  affiliation: "ta",
  step: "cos",
  option: "col"
};
var coveoCommerceExtensionKeys = [
  "loyaltyCardId",
  "loyaltyTier",
  "thirdPartyPersona",
  "companyName",
  "favoriteStore",
  "storeName",
  "userIndustry",
  "userRole",
  "userDepartment",
  "businessUnit"
];
var quoteActionsKeysMapping = {
  id: "quoteId",
  affiliation: "quoteAffiliation"
};
var reviewActionsKeysMapping = {
  id: "reviewId",
  rating: "reviewRating",
  comment: "reviewComment"
};
var commerceActionKeysMappingPerAction = {
  add: productActionsKeysMapping,
  bookmark_add: productActionsKeysMapping,
  bookmark_remove: productActionsKeysMapping,
  click: productActionsKeysMapping,
  checkout: productActionsKeysMapping,
  checkout_option: productActionsKeysMapping,
  detail: productActionsKeysMapping,
  impression: productActionsKeysMapping,
  remove: productActionsKeysMapping,
  refund: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  purchase: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  quickview: productActionsKeysMapping,
  quote: Object.assign(Object.assign({}, productActionsKeysMapping), quoteActionsKeysMapping),
  review: Object.assign(Object.assign({}, productActionsKeysMapping), reviewActionsKeysMapping)
};
var productKeysMappingValues = keysOf(productKeysMapping).map((key) => productKeysMapping[key]);
var impressionKeysMappingValues = keysOf(impressionKeysMapping).map((key) => impressionKeysMapping[key]);
var productActionsKeysMappingValues = keysOf(productActionsKeysMapping).map((key) => productActionsKeysMapping[key]);
var transactionActionsKeysMappingValues = keysOf(transactionActionsKeysMapping).map((key) => transactionActionsKeysMapping[key]);
var reviewKeysMappingValues = keysOf(reviewActionsKeysMapping).map((key) => reviewActionsKeysMapping[key]);
var quoteKeysMappingValues = keysOf(quoteActionsKeysMapping).map((key) => quoteActionsKeysMapping[key]);
var productSubKeysMatchGroup = [...productKeysMappingValues, "custom"].join("|");
var impressionSubKeysMatchGroup = [...impressionKeysMappingValues, "custom"].join("|");
var productPrefixMatchGroup = "(pr[0-9]+)";
var impressionPrefixMatchGroup = "(il[0-9]+pi[0-9]+)";
var productKeyRegex = new RegExp(`^${productPrefixMatchGroup}(${productSubKeysMatchGroup})$`);
var impressionKeyRegex = new RegExp(`^(${impressionPrefixMatchGroup}(${impressionSubKeysMatchGroup}))|(il[0-9]+nm)$`);
var productActionsKeyRegex = new RegExp(`^(${productActionsKeysMappingValues.join("|")})$`);
var transactionActionsKeyRegex = new RegExp(`^(${transactionActionsKeysMappingValues.join("|")})$`);
var customProductKeyRegex = new RegExp(`^${productPrefixMatchGroup}custom$`);
var customImpressionKeyRegex = new RegExp(`^${impressionPrefixMatchGroup}custom$`);
var coveoCommerceExtensionKeysRegex = new RegExp(`^(${[...coveoCommerceExtensionKeys, ...reviewKeysMappingValues, ...quoteKeysMappingValues].join("|")})$`);
var isProductKey = (key) => productKeyRegex.test(key);
var isImpressionKey = (key) => impressionKeyRegex.test(key);
var isProductActionsKey = (key) => productActionsKeyRegex.test(key);
var isTransactionActionsKeyRegex = (key) => transactionActionsKeyRegex.test(key);
var isCoveoCommerceExtensionKey = (key) => coveoCommerceExtensionKeysRegex.test(key);
var isCommerceKey = [
  isImpressionKey,
  isProductKey,
  isProductActionsKey,
  isTransactionActionsKeyRegex,
  isCoveoCommerceExtensionKey
];
var isCustomCommerceKey = [customProductKeyRegex, customImpressionKeyRegex];
var globalParamKeysMapping = {
  anonymizeIp: "aip"
};
var eventKeysMapping = {
  eventCategory: "ec",
  eventAction: "ea",
  eventLabel: "el",
  eventValue: "ev",
  page: "dp",
  visitorId: "cid",
  clientId: "cid",
  userId: "uid",
  currencyCode: "cu"
};
var contextInformationMapping = {
  hitType: "t",
  pageViewId: "pid",
  encoding: "de",
  location: "dl",
  referrer: "dr",
  screenColor: "sd",
  screenResolution: "sr",
  title: "dt",
  userAgent: "ua",
  language: "ul",
  eventId: "z",
  time: "tm"
};
var coveoExtensionsKeys = [
  "contentId",
  "contentIdKey",
  "contentType",
  "searchHub",
  "tab",
  "searchUid",
  "permanentId",
  "contentLocale",
  "trackingId"
];
var baseMeasurementProtocolKeysMapping = Object.assign(Object.assign(Object.assign(Object.assign({}, globalParamKeysMapping), eventKeysMapping), contextInformationMapping), coveoExtensionsKeys.reduce((all, key) => Object.assign(Object.assign({}, all), { [key]: key }), {}));
var measurementProtocolKeysMapping = Object.assign(Object.assign({}, baseMeasurementProtocolKeysMapping), serviceActionsKeysMapping);
var convertKeysToMeasurementProtocol = (params) => {
  const keysMappingForAction = !!params.action && commerceActionKeysMappingPerAction[params.action] || {};
  return keysOf(params).reduce((mappedKeys, key) => {
    const newKey = keysMappingForAction[key] || measurementProtocolKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedKeys), { [newKey]: params[key] });
  }, {});
};
var measurementProtocolKeysMappingValues = keysOf(measurementProtocolKeysMapping).map((key) => measurementProtocolKeysMapping[key]);
var isKnownMeasurementProtocolKey = (key) => measurementProtocolKeysMappingValues.indexOf(key) !== -1;
var isCustomKey = (key) => key === "custom";
var isMeasurementProtocolKey = (key) => {
  return [...isCommerceKey, ...isServiceKey, isKnownMeasurementProtocolKey, isCustomKey].some((test) => test(key));
};
var convertCustomMeasurementProtocolKeys = (data) => {
  return keysOf(data).reduce((all, current) => {
    const match = getFirstCustomMeasurementProtocolKeyMatch(current);
    if (match) {
      return Object.assign(Object.assign({}, all), convertCustomObject(match, data[current]));
    } else {
      return Object.assign(Object.assign({}, all), { [current]: data[current] });
    }
  }, {});
};
var getFirstCustomMeasurementProtocolKeyMatch = (key) => {
  let matchedKey = void 0;
  [...isCustomCommerceKey].every((regex) => {
    var _a;
    matchedKey = (_a = regex.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
    return !Boolean(matchedKey);
  });
  return matchedKey;
};
var convertCustomObject = (prefix, customData) => {
  return keysOf(customData).reduce((allCustom, currentCustomKey) => Object.assign(Object.assign({}, allCustom), { [`${prefix}${currentCustomKey}`]: customData[currentCustomKey] }), {});
};
var AnalyticsBeaconClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, originalPayload) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isAvailable()) {
        throw new Error(`navigator.sendBeacon is not supported in this browser. Consider adding a polyfill like "sendbeacon-polyfill".`);
      }
      const { baseUrl, preprocessRequest } = this.opts;
      const paramsFragments = yield this.getQueryParamsForEventType(eventType);
      const { url, payload } = yield this.preProcessRequestAsPotentialJSONString(`${baseUrl}/analytics/${eventType}?${paramsFragments}`, originalPayload, preprocessRequest);
      const parsedRequestData = this.encodeForEventType(eventType, payload);
      const body = new Blob([parsedRequestData], {
        type: "application/x-www-form-urlencoded"
      });
      navigator.sendBeacon(url, body);
      return;
    });
  }
  isAvailable() {
    return "sendBeacon" in navigator;
  }
  deleteHttpCookieVisitorId() {
    return Promise.resolve();
  }
  preProcessRequestAsPotentialJSONString(originalURL, originalPayload, preprocessRequest) {
    return __awaiter(this, void 0, void 0, function* () {
      let returnedUrl = originalURL;
      let returnedPayload = originalPayload;
      if (preprocessRequest) {
        const processedRequest = yield preprocessRequest({ url: originalURL, body: JSON.stringify(originalPayload) }, "analyticsBeacon");
        const { url: processedURL, body: processedBody } = processedRequest;
        returnedUrl = processedURL || originalURL;
        try {
          returnedPayload = JSON.parse(processedBody);
        } catch (e) {
          console.error("Unable to process the request body as a JSON string", e);
        }
      }
      return {
        payload: returnedPayload,
        url: returnedUrl
      };
    });
  }
  encodeForEventType(eventType, payload) {
    return this.isEventTypeLegacy(eventType) ? this.encodeEventToJson(eventType, payload) : this.encodeEventToJson(eventType, payload, this.opts.token);
  }
  getQueryParamsForEventType(eventType) {
    return __awaiter(this, void 0, void 0, function* () {
      const { token, visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return [
        token && this.isEventTypeLegacy(eventType) ? `access_token=${token}` : "",
        visitorId ? `visitorId=${visitorId}` : "",
        "discardVisitInfo=true"
      ].filter((p) => !!p).join("&");
    });
  }
  isEventTypeLegacy(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  encodeEventToJson(eventType, payload, access_token) {
    let encoded = `${eventType}Event=${encodeURIComponent(JSON.stringify(payload))}`;
    if (access_token) {
      encoded = `access_token=${encodeURIComponent(access_token)}&${encoded}`;
    }
    return encoded;
  }
};
var NoopAnalyticsClient = class {
  sendEvent(_, __) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
};
var fetch$1 = globalThis.fetch;
var AnalyticsFetchClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl, visitorIdProvider, preprocessRequest } = this.opts;
      const visitorIdParam = this.shouldAppendVisitorId(eventType) ? yield this.getVisitorIdParam() : "";
      const defaultOptions = {
        url: `${baseUrl}/analytics/${eventType}${visitorIdParam}`,
        credentials: "include",
        mode: "cors",
        headers: this.getHeaders(),
        method: "POST",
        body: JSON.stringify(payload)
      };
      const _a = Object.assign(Object.assign({}, defaultOptions), preprocessRequest ? yield preprocessRequest(defaultOptions, "analyticsFetch") : {}), { url } = _a, fetchData = __rest(_a, ["url"]);
      let response;
      try {
        response = yield fetch$1(url, fetchData);
      } catch (error) {
        console.error("An error has occured when sending the event.", error);
        return;
      }
      if (response.ok) {
        const visit = yield response.json();
        if (visit.visitorId) {
          visitorIdProvider.setCurrentVisitorId(visit.visitorId);
        }
        return visit;
      } else {
        try {
          response.json();
        } catch (_b) {
        }
        console.error(`An error has occured when sending the "${eventType}" event.`, response, payload);
        throw new Error(`An error has occurred when sending the "${eventType}" event. Check the console logs for more details.`);
      }
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl } = this.opts;
      const url = `${baseUrl}/analytics/visit`;
      yield fetch$1(url, { headers: this.getHeaders(), method: "DELETE" });
    });
  }
  shouldAppendVisitorId(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  getVisitorIdParam() {
    return __awaiter(this, void 0, void 0, function* () {
      const { visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return visitorId ? `?visitor=${visitorId}` : "";
    });
  }
  getHeaders() {
    const { token } = this.opts;
    return Object.assign(Object.assign({}, token ? { Authorization: `Bearer ${token}` } : {}), { "Content-Type": `application/json` });
  }
};
var BrowserRuntime = class {
  constructor(clientOptions, getUnprocessedRequests) {
    if (hasLocalStorage() && hasCookieStorage()) {
      this.storage = new CookieAndLocalStorage();
    } else if (hasLocalStorage()) {
      this.storage = localStorage;
    } else {
      console.warn("BrowserRuntime detected no valid storage available.", this);
      this.storage = new NullStorage();
    }
    this.client = new AnalyticsFetchClient(clientOptions);
    this.beaconClient = new AnalyticsBeaconClient(clientOptions);
    window.addEventListener("beforeunload", () => {
      const requests = getUnprocessedRequests();
      for (let { eventType, payload } of requests) {
        this.beaconClient.sendEvent(eventType, payload);
      }
    });
  }
  getClientDependingOnEventType(eventType) {
    return eventType === "click" && this.beaconClient.isAvailable() ? this.beaconClient : this.client;
  }
};
var NodeJSRuntime = class {
  constructor(clientOptions, storage) {
    this.storage = storage || new NullStorage();
    this.client = new AnalyticsFetchClient(clientOptions);
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var NoopRuntime = class {
  constructor() {
    this.storage = new NullStorage();
    this.client = new NoopAnalyticsClient();
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var API_KEY_PREFIX = "xx";
var isApiKey = (token) => (token === null || token === void 0 ? void 0 : token.startsWith(API_KEY_PREFIX)) || false;
var ReactNativeRuntimeWarning = `
        We've detected you're using React Native but have not provided the corresponding runtime, 
        for an optimal experience please use the "coveo.analytics/react-native" subpackage.
        Follow the Readme on how to set it up: https://github.com/coveo/coveo.analytics.js#using-react-native
    `;
function isReactNative() {
  return typeof navigator != "undefined" && navigator.product == "ReactNative";
}
var doNotTrackValues = ["1", 1, "yes", true];
function doNotTrack() {
  const checks = [];
  if (hasWindow()) {
    checks.push(window.doNotTrack);
  }
  if (hasNavigator()) {
    checks.push(navigator.doNotTrack, navigator.msDoNotTrack, navigator.globalPrivacyControl);
  }
  return checks.some((value) => doNotTrackValues.indexOf(value) !== -1);
}
var Version = "v15";
var Endpoints = {
  default: "https://analytics.cloud.coveo.com/rest/ua",
  production: "https://analytics.cloud.coveo.com/rest/ua",
  hipaa: "https://analyticshipaa.cloud.coveo.com/rest/ua"
};
function buildBaseUrl(endpoint = Endpoints.default, apiVersion = Version, isCustomEndpoint = false) {
  endpoint = endpoint.replace(/\/$/, "");
  if (isCustomEndpoint) {
    return `${endpoint}/${apiVersion}`;
  }
  const hasUARestEndpoint = endpoint.endsWith("/rest") || endpoint.endsWith("/rest/ua");
  return `${endpoint}${hasUARestEndpoint ? "" : "/rest"}/${apiVersion}`;
}
var COVEO_NAMESPACE = "38824e1f-37f5-42d3-8372-a4b8fa9df946";
var CoveoAnalyticsClient = class {
  get defaultOptions() {
    return {
      endpoint: Endpoints.default,
      isCustomEndpoint: false,
      token: "",
      version: Version,
      beforeSendHooks: [],
      afterSendHooks: []
    };
  }
  get version() {
    return libVersion;
  }
  constructor(opts) {
    this.acceptedLinkReferrers = [];
    if (!opts) {
      throw new Error("You have to pass options to this constructor");
    }
    this.options = Object.assign(Object.assign({}, this.defaultOptions), opts);
    this.visitorId = "";
    this.bufferedRequests = [];
    this.beforeSendHooks = [enhanceViewEvent, addDefaultValues].concat(this.options.beforeSendHooks);
    this.afterSendHooks = this.options.afterSendHooks;
    this.eventTypeMapping = {};
    const clientsOptions = {
      baseUrl: this.baseUrl,
      token: this.options.token,
      visitorIdProvider: this,
      preprocessRequest: this.options.preprocessRequest
    };
    if (doNotTrack()) {
      this.runtime = new NoopRuntime();
    } else {
      this.runtime = this.options.runtimeEnvironment || this.initRuntime(clientsOptions);
    }
    this.addEventTypeMapping(EventType.view, { newEventType: EventType.view, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.click, { newEventType: EventType.click, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.custom, { newEventType: EventType.custom, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.search, { newEventType: EventType.search, addClientIdParameter: true });
  }
  initRuntime(clientsOptions) {
    if (hasWindow() && hasDocument()) {
      return new BrowserRuntime(clientsOptions, () => {
        const copy = [...this.bufferedRequests];
        this.bufferedRequests = [];
        return copy;
      });
    } else if (isReactNative()) {
      console.warn(ReactNativeRuntimeWarning);
    }
    return new NodeJSRuntime(clientsOptions);
  }
  get storage() {
    return this.runtime.storage;
  }
  determineVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return hasWindow() && this.extractClientIdFromLink(window.location.href) || (yield this.storage.getItem("visitorId")) || v4();
      } catch (err) {
        console.log("Could not get visitor ID from the current runtime environment storage. Using a random ID instead.", err);
        return v4();
      }
    });
  }
  getCurrentVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.visitorId) {
        const id2 = yield this.determineVisitorId();
        yield this.setCurrentVisitorId(id2);
      }
      return this.visitorId;
    });
  }
  setCurrentVisitorId(visitorId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.visitorId = visitorId;
      yield this.storage.setItem("visitorId", visitorId);
    });
  }
  setClientId(value, namespace) {
    return __awaiter(this, void 0, void 0, function* () {
      if (validate(value)) {
        this.setCurrentVisitorId(value.toLowerCase());
      } else {
        if (!namespace) {
          throw Error("Cannot generate uuid client id without a specific namespace string.");
        }
        this.setCurrentVisitorId(uuidv5(value, uuidv5(namespace, COVEO_NAMESPACE)));
      }
    });
  }
  getParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.resolveParameters(eventType, ...payload);
    });
  }
  getPayload(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      return yield this.resolvePayloadForParameters(eventType, parametersToSend);
    });
  }
  get currentVisitorId() {
    const visitorId = this.visitorId || this.storage.getItem("visitorId");
    if (typeof visitorId !== "string") {
      this.setCurrentVisitorId(v4());
    }
    return this.visitorId;
  }
  set currentVisitorId(visitorId) {
    this.visitorId = visitorId;
    this.storage.setItem("visitorId", visitorId);
  }
  extractClientIdFromLink(urlString) {
    if (doNotTrack()) {
      return null;
    }
    try {
      const linkParam = new URL(urlString).searchParams.get(CoveoLinkParam.cvo_cid);
      if (linkParam == null) {
        return null;
      }
      const linker = CoveoLinkParam.fromString(linkParam);
      if (!linker || !hasDocument() || !linker.validate(document.referrer, this.acceptedLinkReferrers)) {
        return null;
      }
      return linker.clientId;
    } catch (error) {
    }
    return null;
  }
  resolveParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { variableLengthArgumentsNames = [], addVisitorIdParameter = false, usesMeasurementProtocol = false, addClientIdParameter = false } = this.eventTypeMapping[eventType] || {};
      const processVariableArgumentNamesStep = (currentPayload) => variableLengthArgumentsNames.length > 0 ? this.parseVariableArgumentsPayload(variableLengthArgumentsNames, currentPayload) : currentPayload[0];
      const addVisitorIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, currentPayload), { visitorId: addVisitorIdParameter ? yield this.getCurrentVisitorId() : "" });
      });
      const addClientIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        if (addClientIdParameter) {
          return Object.assign(Object.assign({}, currentPayload), { clientId: yield this.getCurrentVisitorId() });
        }
        return currentPayload;
      });
      const setAnonymousUserStep = (currentPayload) => usesMeasurementProtocol ? this.ensureAnonymousUserWhenUsingApiKey(currentPayload) : currentPayload;
      const processBeforeSendHooksStep = (currentPayload) => this.beforeSendHooks.reduce((promisePayload, current) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield promisePayload;
        return yield current(eventType, payload2);
      }), currentPayload);
      const parametersToSend = yield [
        processVariableArgumentNamesStep,
        addVisitorIdStep,
        addClientIdStep,
        setAnonymousUserStep,
        processBeforeSendHooksStep
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield payloadPromise;
        return yield step(payload2);
      }), Promise.resolve(payload));
      return parametersToSend;
    });
  }
  resolvePayloadForParameters(eventType, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const { usesMeasurementProtocol = false } = this.eventTypeMapping[eventType] || {};
      const addTrackingIdStep = (currentPayload) => this.setTrackingIdIfTrackingIdNotPresent(currentPayload);
      const cleanPayloadStep = (currentPayload) => this.removeEmptyPayloadValues(currentPayload, eventType);
      const validateParams = (currentPayload) => this.validateParams(currentPayload, eventType);
      const processMeasurementProtocolConversionStep = (currentPayload) => usesMeasurementProtocol ? convertKeysToMeasurementProtocol(currentPayload) : currentPayload;
      const removeUnknownParameters = (currentPayload) => usesMeasurementProtocol ? this.removeUnknownParameters(currentPayload) : currentPayload;
      const processCustomParameters = (currentPayload) => usesMeasurementProtocol ? this.processCustomParameters(currentPayload) : this.mapCustomParametersToCustomData(currentPayload);
      const payloadToSend = yield [
        addTrackingIdStep,
        cleanPayloadStep,
        validateParams,
        processMeasurementProtocolConversionStep,
        removeUnknownParameters,
        processCustomParameters
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload = yield payloadPromise;
        return yield step(payload);
      }), Promise.resolve(parameters));
      return payloadToSend;
    });
  }
  makeEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { newEventType: eventTypeToSend = eventType } = this.eventTypeMapping[eventType] || {};
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      const payloadToSend = yield this.resolvePayloadForParameters(eventType, parametersToSend);
      return {
        eventType: eventTypeToSend,
        payload: payloadToSend,
        log: (remainingPayload) => __awaiter(this, void 0, void 0, function* () {
          this.bufferedRequests.push({
            eventType: eventTypeToSend,
            payload: Object.assign(Object.assign({}, payloadToSend), remainingPayload)
          });
          yield Promise.all(this.afterSendHooks.map((hook) => hook(eventType, Object.assign(Object.assign({}, parametersToSend), remainingPayload))));
          yield this.deferExecution();
          return yield this.sendFromBuffer();
        })
      };
    });
  }
  sendEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeEvent(eventType, ...payload)).log({});
    });
  }
  deferExecution() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  sendFromBuffer() {
    return __awaiter(this, void 0, void 0, function* () {
      const popped = this.bufferedRequests.shift();
      if (popped) {
        const { eventType, payload } = popped;
        return this.runtime.getClientDependingOnEventType(eventType).sendEvent(eventType, payload);
      }
    });
  }
  clear() {
    this.storage.removeItem("visitorId");
    const store = new HistoryStore();
    store.clear();
  }
  deleteHttpOnlyVisitorId() {
    this.runtime.client.deleteHttpCookieVisitorId();
  }
  makeSearchEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.search, request);
    });
  }
  sendSearchEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeSearchEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeClickEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.click, request);
    });
  }
  sendClickEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeClickEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeCustomEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.custom, request);
    });
  }
  sendCustomEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { lastSearchQueryUid } = _a, preparedRequest = __rest(_a, ["lastSearchQueryUid"]);
      return (yield this.makeCustomEvent(preparedRequest)).log({ lastSearchQueryUid });
    });
  }
  makeViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.view, request);
    });
  }
  sendViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeViewEvent(request)).log({});
    });
  }
  getVisit() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/visit`);
      const visit = yield response.json();
      this.visitorId = visit.visitorId;
      return visit;
    });
  }
  getHealth() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/monitoring/health`);
      return yield response.json();
    });
  }
  registerBeforeSendEventHook(hook) {
    this.beforeSendHooks.push(hook);
  }
  registerAfterSendEventHook(hook) {
    this.afterSendHooks.push(hook);
  }
  addEventTypeMapping(eventType, eventConfig) {
    this.eventTypeMapping[eventType] = eventConfig;
  }
  setAcceptedLinkReferrers(hosts) {
    if (Array.isArray(hosts) && hosts.every((host) => typeof host == "string"))
      this.acceptedLinkReferrers = hosts;
    else
      throw Error("Parameter should be an array of domain strings");
  }
  parseVariableArgumentsPayload(fieldsOrder, payload) {
    const parsedArguments = {};
    for (let i = 0, length = payload.length; i < length; i++) {
      const currentArgument = payload[i];
      if (typeof currentArgument === "string") {
        parsedArguments[fieldsOrder[i]] = currentArgument;
      } else if (typeof currentArgument === "object") {
        return Object.assign(Object.assign({}, parsedArguments), currentArgument);
      }
    }
    return parsedArguments;
  }
  isKeyAllowedEmpty(evtType, key) {
    const keysThatCanBeEmpty = {
      [EventType.search]: ["queryText"]
    };
    const match = keysThatCanBeEmpty[evtType] || [];
    return match.indexOf(key) !== -1;
  }
  removeEmptyPayloadValues(payload, eventType) {
    const isNotEmptyValue = (value) => typeof value !== "undefined" && value !== null && value !== "";
    return Object.keys(payload).filter((key) => this.isKeyAllowedEmpty(eventType, key) || isNotEmptyValue(payload[key])).reduce((newPayload, key) => Object.assign(Object.assign({}, newPayload), { [key]: payload[key] }), {});
  }
  removeUnknownParameters(payload) {
    const newPayload = Object.keys(payload).filter((key) => {
      if (isMeasurementProtocolKey(key)) {
        return true;
      } else {
        console.log(key, "is not processed by coveoua");
      }
    }).reduce((newPayload2, key) => Object.assign(Object.assign({}, newPayload2), { [key]: payload[key] }), {});
    return newPayload;
  }
  processCustomParameters(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    let lowercasedCustom = {};
    if (custom && isObject(custom)) {
      lowercasedCustom = this.lowercaseKeys(custom);
    }
    const newPayload = convertCustomMeasurementProtocolKeys(rest);
    return Object.assign(Object.assign({}, lowercasedCustom), newPayload);
  }
  mapCustomParametersToCustomData(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    if (custom && isObject(custom)) {
      const lowercasedCustom = this.lowercaseKeys(custom);
      return Object.assign(Object.assign({}, rest), { customData: Object.assign(Object.assign({}, lowercasedCustom), payload.customData) });
    } else {
      return payload;
    }
  }
  lowercaseKeys(custom) {
    const keys = Object.keys(custom);
    let result = {};
    keys.forEach((key) => {
      result[key.toLowerCase()] = custom[key];
    });
    return result;
  }
  validateParams(payload, eventType) {
    const { anonymizeIp } = payload, rest = __rest(payload, ["anonymizeIp"]);
    if (anonymizeIp !== void 0) {
      if (["0", "false", "undefined", "null", "{}", "[]", ""].indexOf(`${anonymizeIp}`.toLowerCase()) == -1) {
        rest.anonymizeIp = 1;
      }
    }
    if (eventType == EventType.view || eventType == EventType.click || eventType == EventType.search || eventType == EventType.custom) {
      rest.originLevel3 = this.limit(rest.originLevel3, 1024);
    }
    if (eventType == EventType.view) {
      rest.location = this.limit(rest.location, 1024);
    }
    if (eventType == "pageview" || eventType == "event") {
      rest.referrer = this.limit(rest.referrer, 2048);
      rest.location = this.limit(rest.location, 2048);
      rest.page = this.limit(rest.page, 2048);
    }
    return rest;
  }
  ensureAnonymousUserWhenUsingApiKey(payload) {
    const { userId } = payload, rest = __rest(payload, ["userId"]);
    if (isApiKey(this.options.token) && !userId) {
      rest["userId"] = "anonymous";
      return rest;
    } else {
      return payload;
    }
  }
  setTrackingIdIfTrackingIdNotPresent(payload) {
    const { trackingId } = payload, rest = __rest(payload, ["trackingId"]);
    if (trackingId) {
      return payload;
    }
    if (rest.hasOwnProperty("custom") && isObject(rest.custom)) {
      if (rest.custom.hasOwnProperty("context_website") || rest.custom.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.custom.context_website || rest.custom.siteName;
      }
    }
    if (rest.hasOwnProperty("customData") && isObject(rest.customData)) {
      if (rest.customData.hasOwnProperty("context_website") || rest.customData.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.customData.context_website || rest.customData.siteName;
      }
    }
    return rest;
  }
  limit(input, length) {
    return typeof input === "string" ? truncateUrl(input, length) : input;
  }
  get baseUrl() {
    return buildBaseUrl(this.options.endpoint, this.options.version, this.options.isCustomEndpoint);
  }
};
var InsightEvents;
(function(InsightEvents2) {
  InsightEvents2["contextChanged"] = "contextChanged";
  InsightEvents2["expandToFullUI"] = "expandToFullUI";
  InsightEvents2["openUserActions"] = "openUserActions";
  InsightEvents2["showPrecedingSessions"] = "showPrecedingSessions";
  InsightEvents2["showFollowingSessions"] = "showFollowingSessions";
  InsightEvents2["clickViewedDocument"] = "clickViewedDocument";
  InsightEvents2["clickPageView"] = "clickPageView";
  InsightEvents2["createArticle"] = "createArticle";
})(InsightEvents || (InsightEvents = {}));
var SearchPageEvents;
(function(SearchPageEvents3) {
  SearchPageEvents3["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents3["interfaceChange"] = "interfaceChange";
  SearchPageEvents3["didyoumeanAutomatic"] = "didyoumeanAutomatic";
  SearchPageEvents3["didyoumeanClick"] = "didyoumeanClick";
  SearchPageEvents3["resultsSort"] = "resultsSort";
  SearchPageEvents3["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents3["searchboxClear"] = "searchboxClear";
  SearchPageEvents3["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents3["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents3["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents3["documentQuickview"] = "documentQuickview";
  SearchPageEvents3["documentOpen"] = "documentOpen";
  SearchPageEvents3["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents3["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents3["searchFromLink"] = "searchFromLink";
  SearchPageEvents3["triggerNotify"] = "notify";
  SearchPageEvents3["triggerExecute"] = "execute";
  SearchPageEvents3["triggerQuery"] = "query";
  SearchPageEvents3["undoTriggerQuery"] = "undoQuery";
  SearchPageEvents3["triggerRedirect"] = "redirect";
  SearchPageEvents3["pagerResize"] = "pagerResize";
  SearchPageEvents3["pagerNumber"] = "pagerNumber";
  SearchPageEvents3["pagerNext"] = "pagerNext";
  SearchPageEvents3["pagerPrevious"] = "pagerPrevious";
  SearchPageEvents3["pagerScrolling"] = "pagerScrolling";
  SearchPageEvents3["staticFilterClearAll"] = "staticFilterClearAll";
  SearchPageEvents3["staticFilterSelect"] = "staticFilterSelect";
  SearchPageEvents3["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents3["facetClearAll"] = "facetClearAll";
  SearchPageEvents3["facetSearch"] = "facetSearch";
  SearchPageEvents3["facetSelect"] = "facetSelect";
  SearchPageEvents3["facetSelectAll"] = "facetSelectAll";
  SearchPageEvents3["facetDeselect"] = "facetDeselect";
  SearchPageEvents3["facetExclude"] = "facetExclude";
  SearchPageEvents3["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents3["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents3["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents3["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents3["queryError"] = "query";
  SearchPageEvents3["queryErrorBack"] = "errorBack";
  SearchPageEvents3["queryErrorClear"] = "errorClearQuery";
  SearchPageEvents3["queryErrorRetry"] = "errorRetry";
  SearchPageEvents3["recommendation"] = "recommendation";
  SearchPageEvents3["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents3["recommendationOpen"] = "recommendationOpen";
  SearchPageEvents3["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents3["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents3["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents3["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents3["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents3["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents3["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents3["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents3["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents3["showMoreSmartSnippetSuggestion"] = "showMoreSmartSnippetSuggestion";
  SearchPageEvents3["showLessSmartSnippetSuggestion"] = "showLessSmartSnippetSuggestion";
  SearchPageEvents3["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents3["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents3["openSmartSnippetInlineLink"] = "openSmartSnippetInlineLink";
  SearchPageEvents3["openSmartSnippetSuggestionInlineLink"] = "openSmartSnippetSuggestionInlineLink";
  SearchPageEvents3["recentQueryClick"] = "recentQueriesClick";
  SearchPageEvents3["clearRecentQueries"] = "clearRecentQueries";
  SearchPageEvents3["recentResultClick"] = "recentResultClick";
  SearchPageEvents3["clearRecentResults"] = "clearRecentResults";
  SearchPageEvents3["noResultsBack"] = "noResultsBack";
  SearchPageEvents3["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents3["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents3["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents3["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents3["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents3["caseAttach"] = "caseAttach";
  SearchPageEvents3["caseDetach"] = "caseDetach";
  SearchPageEvents3["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents3["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents3["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents3["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents3["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents3["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents3["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents3["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents3["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents3["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents3["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents3["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents3["rephraseGeneratedAnswer"] = "rephraseGeneratedAnswer";
  SearchPageEvents3["generatedAnswerFeedbackSubmitV2"] = "generatedAnswerFeedbackSubmitV2";
  SearchPageEvents3["generatedAnswerCitationClick"] = "generatedAnswerCitationClick";
  SearchPageEvents3["generatedAnswerCitationDocumentAttach"] = "generatedAnswerCitationDocumentAttach";
})(SearchPageEvents || (SearchPageEvents = {}));
var CustomEventsTypes = {
  [SearchPageEvents.triggerNotify]: "queryPipelineTriggers",
  [SearchPageEvents.triggerExecute]: "queryPipelineTriggers",
  [SearchPageEvents.triggerQuery]: "queryPipelineTriggers",
  [SearchPageEvents.triggerRedirect]: "queryPipelineTriggers",
  [SearchPageEvents.queryErrorBack]: "errors",
  [SearchPageEvents.queryErrorClear]: "errors",
  [SearchPageEvents.queryErrorRetry]: "errors",
  [SearchPageEvents.pagerNext]: "getMoreResults",
  [SearchPageEvents.pagerPrevious]: "getMoreResults",
  [SearchPageEvents.pagerNumber]: "getMoreResults",
  [SearchPageEvents.pagerResize]: "getMoreResults",
  [SearchPageEvents.pagerScrolling]: "getMoreResults",
  [SearchPageEvents.facetSearch]: "facet",
  [SearchPageEvents.facetShowLess]: "facet",
  [SearchPageEvents.facetShowMore]: "facet",
  [SearchPageEvents.recommendation]: "recommendation",
  [SearchPageEvents.likeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.dislikeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippet]: "smartSnippet",
  [SearchPageEvents.collapseSmartSnippet]: "smartSnippet",
  [SearchPageEvents.openSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.closeSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.sendSmartSnippetReason]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.collapseSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showMoreSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showLessSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.clearRecentQueries]: "recentQueries",
  [SearchPageEvents.recentResultClick]: "recentlyClickedDocuments",
  [SearchPageEvents.clearRecentResults]: "recentlyClickedDocuments",
  [SearchPageEvents.showLessFoldedResults]: "folding",
  [SearchPageEvents.caseDetach]: "case",
  [SearchPageEvents.likeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.dislikeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.openGeneratedAnswerSource]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerStreamEnd]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerSourceHover]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCopyToClipboard]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerHideAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerShowAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerExpand]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCollapse]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmit]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmitV2]: "generatedAnswer",
  [InsightEvents.expandToFullUI]: "interface",
  [InsightEvents.openUserActions]: "User Actions",
  [InsightEvents.showPrecedingSessions]: "User Actions",
  [InsightEvents.showFollowingSessions]: "User Actions",
  [InsightEvents.clickViewedDocument]: "User Actions",
  [InsightEvents.clickPageView]: "User Actions",
  [InsightEvents.createArticle]: "createArticle"
};
var NoopAnalytics = class {
  constructor() {
    this.runtime = new NoopRuntime();
    this.currentVisitorId = "";
  }
  getPayload() {
    return Promise.resolve();
  }
  getParameters() {
    return Promise.resolve();
  }
  makeEvent(eventType) {
    return Promise.resolve({ eventType, payload: null, log: () => Promise.resolve() });
  }
  sendEvent() {
    return Promise.resolve();
  }
  makeSearchEvent() {
    return this.makeEvent(EventType.search);
  }
  sendSearchEvent() {
    return Promise.resolve();
  }
  makeClickEvent() {
    return this.makeEvent(EventType.click);
  }
  sendClickEvent() {
    return Promise.resolve();
  }
  makeCustomEvent() {
    return this.makeEvent(EventType.custom);
  }
  sendCustomEvent() {
    return Promise.resolve();
  }
  makeViewEvent() {
    return this.makeEvent(EventType.view);
  }
  sendViewEvent() {
    return Promise.resolve();
  }
  getVisit() {
    return Promise.resolve({ id: "", visitorId: "" });
  }
  getHealth() {
    return Promise.resolve({ status: "" });
  }
  registerBeforeSendEventHook() {
  }
  registerAfterSendEventHook() {
  }
  addEventTypeMapping() {
  }
  get version() {
    return libVersion;
  }
};
function filterConsecutiveRepeatedValues(rawData) {
  let prev = "";
  return rawData.filter((value) => {
    const isDifferent = value !== prev;
    prev = value;
    return isDifferent;
  });
}
function removeSemicolons(rawData) {
  return rawData.map((value) => {
    return value.replace(/;/g, "");
  });
}
function getDataString(data) {
  const ANALYTICS_LENGTH_LIMIT = 256;
  const formattedData = data.join(";");
  if (formattedData.length <= ANALYTICS_LENGTH_LIMIT) {
    return formattedData;
  }
  return getDataString(data.slice(1));
}
var formatArrayForCoveoCustomData = (rawData) => {
  const dataWithoutSemicolons = removeSemicolons(rawData);
  const dataWithoutRepeatedValues = filterConsecutiveRepeatedValues(dataWithoutSemicolons);
  return getDataString(dataWithoutRepeatedValues);
};
function formatOmniboxMetadata(meta) {
  const partialQueries = typeof meta.partialQueries === "string" ? meta.partialQueries : formatArrayForCoveoCustomData(meta.partialQueries);
  const suggestions = typeof meta.suggestions === "string" ? meta.suggestions : formatArrayForCoveoCustomData(meta.suggestions);
  return Object.assign(Object.assign({}, meta), {
    partialQueries,
    suggestions
  });
}
var CoveoSearchPageClient = class {
  constructor(opts, provider) {
    this.opts = opts;
    this.provider = provider;
    const shouldDisableAnalytics = opts.enableAnalytics === false || doNotTrack();
    this.coveoAnalyticsClient = shouldDisableAnalytics ? new NoopAnalytics() : new CoveoAnalyticsClient(opts);
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.opts);
  }
  makeInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.interfaceLoad);
  }
  logInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.recommendationInterfaceLoad);
  }
  logRecommendationInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendation() {
    return this.makeCustomEvent(SearchPageEvents.recommendation);
  }
  logRecommendation() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendation()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.recommendationOpen, info, identifier);
  }
  logRecommendationOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterClearAll, meta);
  }
  logStaticFilterClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterSelect, meta);
  }
  logStaticFilterSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterDeselect, meta);
  }
  logStaticFilterDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFetchMoreResults() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling, { type: "getMoreResults" });
  }
  logFetchMoreResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFetchMoreResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeInterfaceChange(metadata) {
    return this.makeSearchEvent(SearchPageEvents.interfaceChange, metadata);
  }
  logInterfaceChange(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceChange(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanAutomatic() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanAutomatic);
  }
  logDidYouMeanAutomatic() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanAutomatic()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanClick() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanClick);
  }
  logDidYouMeanClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeResultsSort(metadata) {
    return this.makeSearchEvent(SearchPageEvents.resultsSort, metadata);
  }
  logResultsSort(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeResultsSort(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxSubmit() {
    return this.makeSearchEvent(SearchPageEvents.searchboxSubmit);
  }
  logSearchboxSubmit() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxSubmit()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxClear() {
    return this.makeSearchEvent(SearchPageEvents.searchboxClear);
  }
  logSearchboxClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxAsYouType() {
    return this.makeSearchEvent(SearchPageEvents.searchboxAsYouType);
  }
  logSearchboxAsYouType() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxAsYouType()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbFacet(metadata) {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbFacet, metadata);
  }
  logBreadcrumbFacet(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbFacet(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbResetAll() {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbResetAll);
  }
  logBreadcrumbResetAll() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbResetAll()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentQuickview(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentQuickview, info, identifier);
  }
  logDocumentQuickview(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentQuickview(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentOpen, info, identifier);
  }
  logDocumentOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxAnalytics(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxAnalytics, formatOmniboxMetadata(meta));
  }
  logOmniboxAnalytics(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxAnalytics(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxFromLink(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxFromLink, formatOmniboxMetadata(meta));
  }
  logOmniboxFromLink(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxFromLink(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchFromLink() {
    return this.makeSearchEvent(SearchPageEvents.searchFromLink);
  }
  logSearchFromLink() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchFromLink()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerNotify(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerNotify, meta);
  }
  logTriggerNotify(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerNotify(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerExecute(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerExecute, meta);
  }
  logTriggerExecute(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerExecute(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerQuery() {
    return this.makeCustomEvent(SearchPageEvents.triggerQuery, { query: this.provider.getSearchEventRequestPayload().queryText }, "queryPipelineTriggers");
  }
  logTriggerQuery() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerQuery()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeUndoTriggerQuery(meta) {
    return this.makeSearchEvent(SearchPageEvents.undoTriggerQuery, meta);
  }
  logUndoTriggerQuery(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeUndoTriggerQuery(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerRedirect(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerRedirect, Object.assign(Object.assign({}, meta), { query: this.provider.getSearchEventRequestPayload().queryText }));
  }
  logTriggerRedirect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerRedirect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerResize(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerResize, meta);
  }
  logPagerResize(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerResize(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNumber(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNumber, meta);
  }
  logPagerNumber(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNumber(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNext(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNext, meta);
  }
  logPagerNext(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNext(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerPrevious(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerPrevious, meta);
  }
  logPagerPrevious(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerPrevious(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerScrolling() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling);
  }
  logPagerScrolling() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerScrolling()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetClearAll, meta);
  }
  logFacetClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSearch(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSearch, meta);
  }
  logFacetSearch(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSearch(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelect, meta);
  }
  logFacetSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetDeselect, meta);
  }
  logFacetDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetExclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetExclude, meta);
  }
  logFacetExclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetExclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUnexclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUnexclude, meta);
  }
  logFacetUnexclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUnexclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelectAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelectAll, meta);
  }
  logFacetSelectAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelectAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUpdateSort(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUpdateSort, meta);
  }
  logFacetUpdateSort(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUpdateSort(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowMore(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowMore, meta);
  }
  logFacetShowMore(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowMore(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowLess(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowLess, meta);
  }
  logFacetShowLess(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowLess(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryError(meta) {
    return this.makeCustomEvent(SearchPageEvents.queryError, meta);
  }
  logQueryError(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryError(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorBack);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorBack);
        })
      };
    });
  }
  logQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorRetry);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorRetry);
        })
      };
    });
  }
  logQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorRetry()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorClear);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorClear);
        })
      };
    });
  }
  logQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeLikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.likeSmartSnippet);
  }
  logLikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.dislikeSmartSnippet);
  }
  logDislikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeExpandSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippet);
  }
  logExpandSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippet);
  }
  logCollapseSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.openSmartSnippetFeedbackModal);
  }
  logOpenSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCloseSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.closeSmartSnippetFeedbackModal);
  }
  logCloseSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCloseSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSmartSnippetFeedbackReason(reason, details) {
    return this.makeCustomEvent(SearchPageEvents.sendSmartSnippetReason, { reason, details });
  }
  logSmartSnippetFeedbackReason(reason, details) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSmartSnippetFeedbackReason(reason, details)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeExpandSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logExpandSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logCollapseSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showMoreSmartSnippetSuggestion, snippet);
  }
  logShowMoreSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showLessSmartSnippetSuggestion, snippet);
  }
  logShowLessSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSource(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSource, info, identifier);
  }
  logOpenSmartSnippetSource(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSource(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSuggestionSource(info, snippet) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionSource, info, { contentIDKey: snippet.documentId.contentIdKey, contentIDValue: snippet.documentId.contentIdValue }, snippet);
  }
  makeCopyToClipboard(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.copyToClipboard, info, identifier);
  }
  logCopyToClipboard(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCopyToClipboard(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  logOpenSmartSnippetSuggestionSource(info, snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionSource(info, snippet)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetInlineLink, info, { contentIDKey: identifierAndLink.contentIDKey, contentIDValue: identifierAndLink.contentIDValue }, identifierAndLink);
  }
  logOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetInlineLink(info, identifierAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionInlineLink, info, {
      contentIDKey: snippetAndLink.documentId.contentIdKey,
      contentIDValue: snippetAndLink.documentId.contentIdValue
    }, snippetAndLink);
  }
  logOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRecentQueryClick() {
    return this.makeSearchEvent(SearchPageEvents.recentQueryClick);
  }
  logRecentQueryClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentQueryClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentQueries() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentQueries);
  }
  logClearRecentQueries() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentQueries()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecentResultClick(info, identifier) {
    return this.makeCustomEvent(SearchPageEvents.recentResultClick, { info, identifier });
  }
  logRecentResultClick(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentResultClick(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentResults() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentResults);
  }
  logClearRecentResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeNoResultsBack() {
    return this.makeSearchEvent(SearchPageEvents.noResultsBack);
  }
  logNoResultsBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeNoResultsBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreFoldedResults(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.showMoreFoldedResults, info, identifier);
  }
  logShowMoreFoldedResults(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreFoldedResults(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessFoldedResults() {
    return this.makeCustomEvent(SearchPageEvents.showLessFoldedResults);
  }
  logShowLessFoldedResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessFoldedResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeEventDescription(preparedEvent, actionCause) {
    var _a;
    return { actionCause, customData: (_a = preparedEvent.payload) === null || _a === void 0 ? void 0 : _a.customData };
  }
  makeCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      this.coveoAnalyticsClient.getParameters;
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const request = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), { eventType, eventValue: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      return (yield this.makeCustomEvent(event, metadata, eventType)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const payload = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), {
        eventType,
        eventValue
      });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(payload);
      return {
        description: this.makeEventDescription(preparedEvent, eventValue),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCustomEventWithType(eventValue, eventType, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  logSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchEvent(event, metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.getBaseSearchEventRequest(event, metadata);
      const preparedEvent = yield this.coveoAnalyticsClient.makeSearchEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  makeClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { queryPipeline: this.provider.getPipeline(), actionCause: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeClickEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClickEvent(event, info, identifier, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  getBaseSearchEventRequest(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      return Object.assign(Object.assign(Object.assign({}, yield this.getBaseEventRequest(Object.assign(Object.assign({}, metadata), (_b = (_a = this.provider).getGeneratedAnswerMetadata) === null || _b === void 0 ? void 0 : _b.call(_a)))), this.provider.getSearchEventRequestPayload()), { queryPipeline: this.provider.getPipeline(), actionCause: event });
    });
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      return Object.assign(Object.assign(Object.assign({}, this.getOrigins()), this.getSplitTestRun()), { customData, language: this.provider.getLanguage(), facetState: this.provider.getFacetState ? this.provider.getFacetState() : [], anonymous: this.provider.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getOrigins() {
    var _a, _b;
    return {
      originContext: (_b = (_a = this.provider).getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: this.provider.getOriginLevel1(),
      originLevel2: this.provider.getOriginLevel2(),
      originLevel3: this.provider.getOriginLevel3()
    };
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getSplitTestRun() {
    const splitTestRunName = this.provider.getSplitTestRunName ? this.provider.getSplitTestRunName() : "";
    const splitTestRunVersion = this.provider.getSplitTestRunVersion ? this.provider.getSplitTestRunVersion() : "";
    return Object.assign(Object.assign({}, splitTestRunName && { splitTestRunName }), splitTestRunVersion && { splitTestRunVersion });
  }
  makeLikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.likeGeneratedAnswer, metadata);
  }
  logLikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.dislikeGeneratedAnswer, metadata);
  }
  logDislikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenGeneratedAnswerSource(metadata) {
    return this.makeCustomEvent(SearchPageEvents.openGeneratedAnswerSource, metadata);
  }
  logOpenGeneratedAnswerSource(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenGeneratedAnswerSource(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCitationClick(info, citation) {
    return this.makeClickEvent(SearchPageEvents.generatedAnswerCitationClick, Object.assign(Object.assign({}, info), { documentPosition: 1 }), { contentIDKey: citation.documentId.contentIdKey, contentIDValue: citation.documentId.contentIdValue }, citation);
  }
  logGeneratedAnswerCitationClick(info, citation) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCitationClick(info, citation)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerSourceHover(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerSourceHover, metadata);
  }
  logGeneratedAnswerSourceHover(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerSourceHover(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCopyToClipboard(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCopyToClipboard, metadata);
  }
  logGeneratedAnswerCopyToClipboard(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCopyToClipboard(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerHideAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerHideAnswers, metadata);
  }
  logGeneratedAnswerHideAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerHideAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerShowAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerShowAnswers, metadata);
  }
  logGeneratedAnswerShowAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerShowAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerExpand(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerExpand, metadata);
  }
  logGeneratedAnswerExpand(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerExpand(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerCollapse(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCollapse, metadata);
  }
  logGeneratedAnswerCollapse(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCollapse(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerFeedbackSubmit(meta) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmit, meta);
  }
  logGeneratedAnswerFeedbackSubmit(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmit(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerFeedbackSubmitV2(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmitV2, metadata);
  }
  logGeneratedAnswerFeedbackSubmitV2(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmitV2(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRephraseGeneratedAnswer(meta) {
    return this.makeSearchEvent(SearchPageEvents.rephraseGeneratedAnswer, meta);
  }
  logRephraseGeneratedAnswer(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRephraseGeneratedAnswer(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRetryGeneratedAnswer() {
    return this.makeSearchEvent(SearchPageEvents.retryGeneratedAnswer);
  }
  logRetryGeneratedAnswer() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRetryGeneratedAnswer()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerStreamEnd(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerStreamEnd, metadata);
  }
  logGeneratedAnswerStreamEnd(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerStreamEnd(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
};
var SVCPluginEventTypes = Object.assign({}, BasePluginEventTypes);
var allSVCEventTypes = Object.keys(SVCPluginEventTypes).map((key) => SVCPluginEventTypes[key]);
var SVCPlugin = class extends BasePlugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
    this.ticket = {};
  }
  getApi(name) {
    const superCall = super.getApi(name);
    if (superCall !== null)
      return superCall;
    switch (name) {
      case "setTicket":
        return this.setTicket;
      default:
        return null;
    }
  }
  addHooks() {
    this.addHooksForEvent();
    this.addHooksForPageView();
    this.addHooksForSVCEvents();
  }
  setTicket(ticket) {
    this.ticket = ticket;
  }
  clearPluginData() {
    this.ticket = {};
  }
  addHooksForSVCEvents() {
    this.client.registerBeforeSendEventHook((eventType, ...[payload]) => {
      return allSVCEventTypes.indexOf(eventType) !== -1 ? this.addSVCDataToPayload(eventType, payload) : payload;
    });
    this.client.registerAfterSendEventHook((eventType, ...[payload]) => {
      if (allSVCEventTypes.indexOf(eventType) !== -1) {
        this.updateLocationInformation(eventType, payload);
      }
      return payload;
    });
  }
  addHooksForPageView() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.pageview, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["page"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addHooksForEvent() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.event, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["eventCategory", "eventAction", "eventLabel", "eventValue"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addSVCDataToPayload(eventType, payload) {
    var _a;
    const svcPayload = Object.assign(Object.assign(Object.assign(Object.assign({}, this.getLocationInformation(eventType, payload)), this.getDefaultContextInformation(eventType)), this.action ? { svcAction: this.action } : {}), Object.keys((_a = this.actionData) !== null && _a !== void 0 ? _a : {}).length > 0 ? { svcActionData: this.actionData } : {});
    const ticketPayload = this.getTicketPayload();
    this.clearData();
    return Object.assign(Object.assign(Object.assign({}, ticketPayload), svcPayload), payload);
  }
  getTicketPayload() {
    return convertTicketToMeasurementProtocol(this.ticket);
  }
};
SVCPlugin.Id = "svc";
var CaseAssistEvents;
(function(CaseAssistEvents2) {
  CaseAssistEvents2["click"] = "click";
  CaseAssistEvents2["flowStart"] = "flowStart";
})(CaseAssistEvents || (CaseAssistEvents = {}));
var CaseAssistActions;
(function(CaseAssistActions2) {
  CaseAssistActions2["enterInterface"] = "ticket_create_start";
  CaseAssistActions2["fieldUpdate"] = "ticket_field_update";
  CaseAssistActions2["fieldSuggestionClick"] = "ticket_classification_click";
  CaseAssistActions2["documentSuggestionClick"] = "documentSuggestionClick";
  CaseAssistActions2["documentSuggestionQuickview"] = "documentSuggestionQuickview";
  CaseAssistActions2["suggestionRate"] = "suggestion_rate";
  CaseAssistActions2["nextCaseStep"] = "ticket_next_stage";
  CaseAssistActions2["caseCancelled"] = "ticket_cancel";
  CaseAssistActions2["caseSolved"] = "ticket_cancel";
  CaseAssistActions2["caseCreated"] = "ticket_create";
})(CaseAssistActions || (CaseAssistActions = {}));
var CaseCancelledReasons;
(function(CaseCancelledReasons2) {
  CaseCancelledReasons2["quit"] = "Quit";
  CaseCancelledReasons2["solved"] = "Solved";
})(CaseCancelledReasons || (CaseCancelledReasons = {}));
var CaseAssistClient = class {
  constructor(options, provider) {
    var _a;
    this.options = options;
    this.provider = provider;
    const analyticsEnabled = ((_a = options.enableAnalytics) !== null && _a !== void 0 ? _a : true) && !doNotTrack();
    this.coveoAnalyticsClient = analyticsEnabled ? new CoveoAnalyticsClient(options) : new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.options);
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  logEnterInterface(meta) {
    this.svc.setAction(CaseAssistActions.enterInterface);
    this.svc.setTicket(meta.ticket);
    return this.sendFlowStartEvent();
  }
  logUpdateCaseField(meta) {
    this.svc.setAction(CaseAssistActions.fieldUpdate, {
      fieldName: meta.fieldName
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectFieldSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.fieldSuggestionClick, meta.suggestion);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionClick, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logQuickviewDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionQuickview, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logRateDocumentSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.suggestionRate, Object.assign({ rate: meta.rating }, meta.suggestion));
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logMoveToNextCaseStep(meta) {
    this.svc.setAction(CaseAssistActions.nextCaseStep, {
      stage: meta === null || meta === void 0 ? void 0 : meta.stage
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCancelled(meta) {
    this.svc.setAction(CaseAssistActions.caseCancelled, {
      reason: CaseCancelledReasons.quit
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseSolved(meta) {
    this.svc.setAction(CaseAssistActions.caseSolved, {
      reason: CaseCancelledReasons.solved
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCreated(meta) {
    this.svc.setAction(CaseAssistActions.caseCreated);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  sendFlowStartEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.flowStart, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  sendClickEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.click, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const customData = Object.assign({}, metadata);
      return Object.assign(Object.assign({}, this.getOrigins()), { customData, language: (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getLanguage(), anonymous: (_b = this.provider) === null || _b === void 0 ? void 0 : _b.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getOrigins() {
    var _a, _b, _c, _d, _e;
    return {
      originContext: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: (_c = this.provider) === null || _c === void 0 ? void 0 : _c.getOriginLevel1(),
      originLevel2: (_d = this.provider) === null || _d === void 0 ? void 0 : _d.getOriginLevel2(),
      originLevel3: (_e = this.provider) === null || _e === void 0 ? void 0 : _e.getOriginLevel3()
    };
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const payload = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { searchQueryUid: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getSearchUID()) !== null && _b !== void 0 ? _b : "", actionCause: event });
      return this.coveoAnalyticsClient.sendClickEvent(payload);
    });
  }
};

// src/features/search-hub/search-hub-state.ts
var getSearchHubInitialState = () => "default";

// src/api/analytics/base-analytics.ts
var getLanguage = (state) => {
  const langKey = state.configuration.search.locale.split("-")[0];
  if (!langKey || langKey.length !== 2) {
    return "en";
  }
  return langKey;
};
var BaseAnalyticsProvider = class {
  constructor(getState) {
    this.getState = getState;
    __publicField(this, "state");
    this.state = getState();
  }
  getLanguage() {
    return getLanguage(this.state);
  }
  getBaseMetadata() {
    const { context, configuration: configuration2 } = this.state;
    const contextValues = context?.contextValues || {};
    const formattedObject = {};
    for (const [key, value] of Object.entries(contextValues)) {
      const formattedKey = `context_${key}`;
      formattedObject[formattedKey] = value;
    }
    if (configuration2.analytics.analyticsMode === "legacy") {
      formattedObject.coveoHeadlessVersion = VERSION;
    }
    return formattedObject;
  }
  getOriginContext() {
    return this.state.configuration.analytics.originContext;
  }
  getOriginLevel1() {
    return this.state.searchHub || getSearchHubInitialState();
  }
  getOriginLevel2() {
    return this.state.configuration.analytics.originLevel2;
  }
  getOriginLevel3() {
    return this.state.configuration.analytics.originLevel3;
  }
  getIsAnonymous() {
    return this.state.configuration.analytics.anonymous;
  }
};

// src/api/analytics/coveo-analytics-utils.ts
var getVisitorID = (options) => new CoveoAnalyticsClient(options).getCurrentVisitorId();
var wrapPreprocessRequest = (logger, preprocessRequest) => {
  return typeof preprocessRequest === "function" ? (...args) => {
    const untaintedOutput = clone(args[0]);
    try {
      return preprocessRequest.apply(preprocessRequest, args);
    } catch (e) {
      logger.error(
        e,
        "Error in analytics preprocessRequest. Returning original request."
      );
      return untaintedOutput;
    }
  } : void 0;
};
var wrapAnalyticsClientSendEventHook = (logger, hook) => {
  return (...args) => {
    const untaintedOutput = clone(args[1]);
    try {
      return hook.apply(hook, args);
    } catch (e) {
      logger.error(
        e,
        "Error in analytics hook. Returning original request."
      );
      return untaintedOutput;
    }
  };
};

// src/api/analytics/case-assist-analytics.ts
var CaseAssistAnalyticsProvider = class extends BaseAnalyticsProvider {
  getSearchUID() {
    return this.state.documentSuggestion?.status.lastResponseId ?? "";
  }
};
var configureCaseAssistAnalytics = ({
  logger,
  getState,
  analyticsClientMiddleware = (_, p) => p,
  preprocessRequest,
  provider = new CaseAssistAnalyticsProvider(getState)
}) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment,
    "analytics"
  );
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics3 = state.configuration.analytics.enabled;
  const client = new CaseAssistClient(
    {
      enableAnalytics: enableAnalytics3,
      token,
      endpoint,
      runtimeEnvironment,
      preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
      beforeSendHooks: [
        wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
        (type, payload) => {
          logger.info(
            {
              ...payload,
              type,
              endpoint,
              token
            },
            "Analytics request"
          );
          return payload;
        }
      ]
    },
    provider
  );
  if (!enableAnalytics3) {
    client.disable();
  }
  return client;
};

// src/features/facets/automatic-facet-set/automatic-facet-set-constants.ts
var DESIRED_COUNT_MINIMUM = 1;
var DESIRED_COUNT_MAXIMUM = 20;
var DESIRED_COUNT_DEFAULT = 5;
var NUMBER_OF_VALUE_MINIMUM = 1;
var NUMBER_OF_VALUE_DEFAULT = 8;

// src/features/facets/automatic-facet-set/automatic-facet-set-state.ts
function getAutomaticFacetSetInitialState() {
  return {
    desiredCount: DESIRED_COUNT_DEFAULT,
    numberOfValues: NUMBER_OF_VALUE_DEFAULT,
    set: {}
  };
}

// src/features/facets/category-facet-set/category-facet-set-selectors.ts
var categoryFacetRequestSelector = (state, id2) => {
  return state.categoryFacetSet[id2]?.request;
};
var categoryFacetRequestSelectedValuesSelector = (state, facetId2) => {
  const facetRequest = categoryFacetRequestSelector(state, facetId2);
  return findActiveValueAncestry(facetRequest?.currentValues ?? []);
};

// src/features/facets/category-facet-set/category-facet-set-state.ts
function getCategoryFacetSetInitialState() {
  return {};
}

// src/features/facets/range-facets/date-facet-set/date-facet-set-state.ts
function getDateFacetSetSliceInitialState(request) {
  return { request };
}
function getDateFacetSetInitialState() {
  return {};
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-set-state.ts
function getNumericFacetSetSliceInitialState(request) {
  return { request };
}
function getNumericFacetSetInitialState() {
  return {};
}

// src/features/facets/facet-set/facet-set-state.ts
function getFacetSetSliceInitialState(request) {
  return { request, hasBreadcrumbs: true };
}
function getFacetSetInitialState() {
  return {};
}

// src/features/facets/facet-set/facet-set-analytics-actions-utils.ts
function getStateNeededForFacetMetadata(s) {
  return {
    facetSet: s.facetSet ?? getFacetSetInitialState(),
    categoryFacetSet: s.categoryFacetSet ?? getCategoryFacetSetInitialState(),
    dateFacetSet: s.dateFacetSet ?? getDateFacetSetInitialState(),
    numericFacetSet: s.numericFacetSet ?? getNumericFacetSetInitialState(),
    automaticFacetSet: s.automaticFacetSet ?? getAutomaticFacetSetInitialState()
  };
}
var buildFacetStateMetadata = (state) => {
  const facetState = [];
  getFacetRequests(state).forEach((facetRequest, facetIndex) => {
    const facetType = getFacetType(state, facetRequest.facetId);
    const facetRequestAnalytics = mapFacetRequestToAnalytics(
      facetRequest,
      facetIndex + 1
    );
    if (isCategoryFacetRequest(facetRequest)) {
      const hasSelectedValue = !!categoryFacetRequestSelectedValuesSelector(
        state,
        facetRequest.facetId
      ).length;
      if (!hasSelectedValue) {
        return;
      }
      facetState.push({
        ...facetRequestAnalytics,
        ...mapCategoryFacetValueToAnalytics(state, facetRequest.facetId),
        facetType,
        state: "selected"
      });
      return;
    }
    facetRequest.currentValues.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(
        facetValue,
        facetValueIndex + 1,
        facetType
      );
      const facetDisplayValueAnalytics = isSpecificFacetRequest(facetRequest) ? mapFacetDisplayValueToAnalytics(facetValue) : mapRangeDisplayFacetValueToAnalytics(
        facetValue
      );
      facetState.push({
        ...facetRequestAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  getAutomaticFacets(state).forEach((facet, facetIndex) => {
    const facetAnalytics = mapAutomaticFacetToAnalytics(facet, facetIndex + 1);
    facet.values.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(
        facetValue,
        facetValueIndex + 1,
        "specific"
      );
      const facetDisplayValueAnalytics = mapFacetDisplayValueToAnalytics(facetValue);
      facetState.push({
        ...facetAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  return facetState;
};
var isSpecificFacetRequest = (request) => request.type === "specific";
var isCategoryFacetRequest = (request) => request.type === "hierarchical";
var getFacetRequests = (state) => {
  return [
    ...Object.values(state.facetSet),
    ...Object.values(state.categoryFacetSet),
    ...Object.values(state.dateFacetSet),
    ...Object.values(state.numericFacetSet)
  ].map((facet) => facet.request);
};
var getAutomaticFacets = (state) => {
  return [...Object.values(state.automaticFacetSet.set)].map(
    (facet) => facet.response
  );
};
var mapFacetValueToAnalytics = (facetValue, valuePosition, facetType) => {
  return {
    state: facetValue.state,
    valuePosition,
    facetType
  };
};
var mapRangeDisplayFacetValueToAnalytics = (facetValue) => {
  return {
    displayValue: `${facetValue.start}..${facetValue.end}`,
    value: `${facetValue.start}..${facetValue.end}`,
    start: facetValue.start,
    end: facetValue.end,
    endInclusive: facetValue.endInclusive
  };
};
var mapFacetDisplayValueToAnalytics = (facetValue) => {
  return {
    displayValue: facetValue.value,
    value: facetValue.value
  };
};
var getCategoryFacetSelectedValue = (state, facetId2) => {
  const selectedCategoryFacetValues = categoryFacetRequestSelectedValuesSelector(state, facetId2);
  return selectedCategoryFacetValues.map((selectedCategoryFacetValue) => selectedCategoryFacetValue.value).join(";");
};
var mapCategoryFacetValueToAnalytics = (state, facetId2) => {
  const valuePosition = 1;
  const value = getCategoryFacetSelectedValue(state, facetId2);
  return {
    value,
    valuePosition,
    displayValue: value
  };
};
var mapAutomaticFacetToAnalytics = (facet, facetPosition) => {
  return {
    title: getFacetTitle(facet.field, facet.field),
    field: facet.field,
    id: facet.field,
    facetPosition
  };
};
var mapFacetRequestToAnalytics = (request, facetPosition) => {
  return {
    title: getFacetTitle(request.field, request.facetId),
    field: request.field,
    id: request.facetId,
    facetPosition
  };
};
var getFacetTitle = (field2, facetId2) => {
  return `${field2}_${facetId2}`;
};
var getFacetRequest = (state, facetId2) => {
  return state.facetSet[facetId2]?.request || state.categoryFacetSet[facetId2]?.request || state.dateFacetSet[facetId2]?.request || state.numericFacetSet[facetId2]?.request || state.automaticFacetSet.set[facetId2]?.response;
};
var getFacetType = (state, facetId2) => {
  const facet = getFacetRequest(state, facetId2);
  return facet ? facet.type : "specific";
};

// src/features/generated-answer/generated-answer-selectors.ts
var import_bueno13 = require("@coveo/bueno");
var import_toolkit9 = require("@reduxjs/toolkit");

// src/features/configuration/configuration-selectors.ts
var selectLocale = (state) => state.configuration.search.locale;
var selectTimezone = (state) => state.configuration.search.timezone;
var selectAgentId = (state) => state.configuration?.knowledge?.agentId;

// src/features/generated-answer/generated-answer-selectors.ts
var generativeQuestionAnsweringIdSelector = (state) => {
  if (isGeneratedAnswerFeatureEnabledWithAnswerAPI(state) || isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
    return state.generatedAnswer?.answerId;
  }
  if (isSearchSection(state)) {
    return state.search?.response?.extendedResults?.generativeQuestionAnsweringId;
  }
  return void 0;
};
var isGeneratedAnswerFeatureEnabledWithAnswerAPI = (state) => "answer" in state && "generatedAnswer" in state && !(0, import_bueno13.isNullOrUndefined)(state.generatedAnswer?.answerConfigurationId);
var isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI = (state) => {
  const agentId = selectAgentId(state);
  return "answerGenerationApi" in state && "generatedAnswer" in state && typeof agentId === "string" && agentId.trim().length > 0;
};
var isSearchSection = (state) => "search" in state && state.search !== void 0 && typeof state.search === "object";
var selectFieldsToIncludeInCitation = (state) => state.generatedAnswer?.fieldsToIncludeInCitations;
var citationSourceSelector = (0, import_toolkit9.createSelector)(
  (state) => state.generatedAnswer?.citations,
  (_state, citationId) => citationId,
  (citations, citationId) => citations?.find(
    (citation) => citation.id === citationId
  )
);

// src/features/query/query-state.ts
var getQueryInitialState = () => ({
  q: "",
  enableQuerySyntax: false
});

// src/features/search/search-state.ts
function emptyQuestionAnswer() {
  return {
    answerSnippet: "",
    documentId: {
      contentIdKey: "",
      contentIdValue: ""
    },
    question: "",
    relatedQuestions: [],
    score: 0
  };
}
function getSearchInitialState() {
  return {
    response: {
      results: [],
      searchUid: "",
      totalCountFiltered: 0,
      facets: [],
      generateAutomaticFacets: { facets: [] },
      queryCorrections: [],
      triggers: [],
      questionAnswer: emptyQuestionAnswer(),
      pipeline: "",
      splitTestRun: "",
      termsToHighlight: {},
      phrasesToHighlight: {},
      extendedResults: {}
    },
    duration: 0,
    queryExecuted: "",
    error: null,
    automaticallyCorrected: false,
    isLoading: false,
    results: [],
    searchResponseId: "",
    requestId: "",
    questionAnswer: emptyQuestionAnswer(),
    extendedResults: {},
    searchAction: void 0
  };
}

// src/features/sort-criteria/criteria.ts
var import_bueno14 = require("@coveo/bueno");
var SortOrder = /* @__PURE__ */ ((SortOrder2) => {
  SortOrder2["Ascending"] = "ascending";
  SortOrder2["Descending"] = "descending";
  return SortOrder2;
})(SortOrder || {});
var SortBy2 = /* @__PURE__ */ ((SortBy3) => {
  SortBy3["Relevancy"] = "relevancy";
  SortBy3["QRE"] = "qre";
  SortBy3["Date"] = "date";
  SortBy3["Field"] = "field";
  SortBy3["NoSort"] = "nosort";
  return SortBy3;
})(SortBy2 || {});
var buildCriterionExpression = (criterion) => {
  if ((0, import_bueno14.isArray)(criterion)) {
    return criterion.map((c) => buildCriterionExpression(c)).join(",");
  }
  switch (criterion.by) {
    case "relevancy" /* Relevancy */:
    case "qre" /* QRE */:
    case "nosort" /* NoSort */:
      return criterion.by;
    case "date" /* Date */:
      return `date ${criterion.order}`;
    case "field" /* Field */:
      return `@${criterion.field} ${criterion.order}`;
    default:
      return "";
  }
};
var buildRelevanceSortCriterion2 = () => ({
  by: "relevancy" /* Relevancy */
});
var buildDateSortCriterion = (order) => ({
  by: "date" /* Date */,
  order
});
var buildFieldSortCriterion = (field2, order) => ({
  by: "field" /* Field */,
  order,
  field: field2
});
var buildQueryRankingExpressionSortCriterion = () => ({
  by: "qre" /* QRE */
});
var buildNoSortCriterion = () => ({ by: "nosort" /* NoSort */ });
var criterionDefinition = new import_bueno14.RecordValue({
  values: {
    by: new import_bueno14.EnumValue({ enum: SortBy2, required: true }),
    order: new import_bueno14.EnumValue({ enum: SortOrder }),
    field: new import_bueno14.StringValue()
  }
});

// src/features/sort-criteria/sort-criteria-state.ts
function getSortCriteriaInitialState() {
  return buildCriterionExpression(buildRelevanceSortCriterion2());
}

// src/api/analytics/coveo.analytics/cookie.ts
var Cookie2 = class _Cookie {
  static set(name, value, expire) {
    let domain, expirationDate, domainParts;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    const host = window.location.hostname;
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
    if (ipv4Regex.test(host) || ipv6Regex.test(host)) {
      writeCookie2(name, value, expirationDate);
    } else if (host.indexOf(".") === -1) {
      writeCookie2(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie2(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    const cookiePrefix = name + "=";
    const cookieArray = document.cookie.split(";");
    for (let i = 0; i < cookieArray.length; i++) {
      let cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie2(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}

// src/api/analytics/coveo.analytics/detector.ts
function hasNavigator2() {
  return typeof navigator !== "undefined";
}
function hasLocalStorage2() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage2() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage2() {
  return Boolean(hasNavigator2() && navigator.cookieEnabled);
}

// src/api/analytics/coveo.analytics/storage.ts
var preferredStorage = null;
function getAvailableStorage2() {
  if (preferredStorage) {
    return preferredStorage;
  }
  if (hasLocalStorage2()) {
    return localStorage;
  }
  if (hasCookieStorage2()) {
    return new CookieStorage2();
  }
  if (hasSessionStorage2()) {
    return sessionStorage;
  }
  return new NullStorage2();
}
var _CookieStorage = class _CookieStorage {
  getItem(key) {
    return Cookie2.get(`${_CookieStorage.prefix}${key}`);
  }
  removeItem(key) {
    Cookie2.erase(`${_CookieStorage.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie2.set(`${_CookieStorage.prefix}${key}`, data, expire);
  }
};
__publicField(_CookieStorage, "prefix", "coveo_");
var CookieStorage2 = _CookieStorage;
var NullStorage2 = class {
  getItem(_key) {
    return null;
  }
  removeItem(_key) {
  }
  setItem(_key, _data) {
  }
};

// src/api/analytics/coveo.analytics/history-store.ts
var STORE_KEY2 = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS2 = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE2 = 1e3 * 60;
var MAX_VALUE_SIZE2 = 75;
var _HistoryStore = class _HistoryStore {
  constructor(store) {
    __publicField(this, "store");
    this.store = store || getAvailableStorage2();
  }
  static getInstance(store) {
    if (!_HistoryStore.instance) {
      _HistoryStore.instance = new _HistoryStore(store);
    }
    return _HistoryStore.instance;
  }
  /**
   * @deprecated Synchronous method is deprecated, use addElementAsync instead. This method will NOT work with react-native.
   */
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  async addElementAsync(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = await this.getHistoryWithInternalTimeAsync();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  /**
   * @deprecated Synchronous method is deprecated, use getHistoryAsync instead. This method will NOT work with react-native.
   */
  getHistory() {
    const history = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history));
  }
  async getHistoryAsync() {
    const history = await this.getHistoryWithInternalTimeAsync();
    return this.stripEmptyQueries(this.stripInternalTime(history));
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY2);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  async getHistoryWithInternalTimeAsync() {
    try {
      const elements = await this.store.getItem(STORE_KEY2);
      if (elements) {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  setHistory(history) {
    try {
      this.store.setItem(
        STORE_KEY2,
        JSON.stringify(history.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS2))
      );
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY2);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    const currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort(
        (first, second) => {
          return (second.internalTime || 0) - (first.internalTime || 0);
        }
      );
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE2);
    }
    return part;
  }
  isValidEntry(elem) {
    const lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value === elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE2;
    }
    return true;
  }
  stripInternalTime(history) {
    if (Array.isArray(history)) {
      return history.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history) {
    return history.map((part) => this.stripEmptyQuery(part));
  }
};
__publicField(_HistoryStore, "instance", null);
var HistoryStore2 = _HistoryStore;
var history_store_default = HistoryStore2;

// src/api/analytics/search-analytics.ts
var _SearchAnalyticsProvider = class _SearchAnalyticsProvider extends BaseAnalyticsProvider {
  constructor() {
    super(...arguments);
    __publicField(this, "getFacetRequest", (id2) => {
      return this.state.facetSet?.[id2]?.request || this.state.categoryFacetSet?.[id2]?.request || this.state.dateFacetSet?.[id2]?.request || this.state.numericFacetSet?.[id2]?.request || this.state.automaticFacetSet?.set[id2]?.response;
    });
  }
  getFacetState() {
    return buildFacetStateMetadata(
      getStateNeededForFacetMetadata(this.getState())
    );
  }
  getPipeline() {
    return this.state.pipeline || this.state.search?.response.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
  }
  getSearchEventRequestPayload() {
    return {
      queryText: this.queryText,
      responseTime: this.responseTime,
      results: this.resultURIs,
      numberOfResults: this.numberOfResults
    };
  }
  getSearchUID() {
    const newState = this.getState();
    return newState.search?.searchResponseId || newState.search?.response.searchUid || getSearchInitialState().response.searchUid;
  }
  getSplitTestRunName() {
    return this.state.search?.response.splitTestRun;
  }
  getSplitTestRunVersion() {
    const hasSplitTestRun = !!this.getSplitTestRunName();
    const effectivePipelineWithSplitTestRun = this.state.search?.response.pipeline || this.state.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
    return hasSplitTestRun ? effectivePipelineWithSplitTestRun : void 0;
  }
  getBaseMetadata() {
    const state = this.getState();
    const baseObject = super.getBaseMetadata();
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (generativeQuestionAnsweringId) {
      baseObject.generativeQuestionAnsweringId = generativeQuestionAnsweringId;
    }
    return baseObject;
  }
  getFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetValue,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetClearAllMetadata(facetId2) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetUpdateSortMetadata(facetId2, criteria) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      criteria,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getRangeBreadcrumbFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetRangeEnd: facetValue.end,
      facetRangeEndInclusive: facetValue.endInclusive,
      facetRangeStart: facetValue.start,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getResultSortMetadata() {
    return {
      ...this.getBaseMetadata(),
      resultsSortBy: this.state.sortCriteria ?? getSortCriteriaInitialState()
    };
  }
  getStaticFilterToggleMetadata(staticFilterId, staticFilterValue) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId,
      staticFilterValue
    };
  }
  getStaticFilterClearAllMetadata(staticFilterId) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId
    };
  }
  getUndoTriggerQueryMetadata(undoneQuery) {
    return {
      ...this.getBaseMetadata(),
      undoneQuery
    };
  }
  getCategoryBreadcrumbFacetMetadata(categoryFacetId, categoryFacetPath) {
    const facetRequest = this.getFacetRequest(categoryFacetId);
    const categoryFacetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      categoryFacetId,
      categoryFacetField,
      categoryFacetPath,
      categoryFacetTitle: `${categoryFacetField}_${categoryFacetId}`
    };
  }
  getOmniboxAnalyticsMetadata(id2, suggestion) {
    const querySuggest = this.state.querySuggest?.[id2];
    const suggestions = querySuggest.completions.map(
      (completion) => completion.expression
    );
    const lastIndex = querySuggest.partialQueries.length - 1;
    const partialQuery = querySuggest.partialQueries[lastIndex] || "";
    const querySuggestResponseId = querySuggest.responseId;
    return {
      ...this.getBaseMetadata(),
      suggestionRanking: suggestions.indexOf(suggestion),
      partialQuery,
      partialQueries: querySuggest.partialQueries.length > 0 ? querySuggest.partialQueries : "",
      suggestions: suggestions.length > 0 ? suggestions : "",
      querySuggestResponseId
    };
  }
  getInterfaceChangeMetadata() {
    return {
      ...this.getBaseMetadata(),
      interfaceChangeTo: this.state.configuration.analytics.originLevel2
    };
  }
  getOmniboxFromLinkMetadata(metadata) {
    return {
      ...this.getBaseMetadata(),
      ...metadata
    };
  }
  getGeneratedAnswerMetadata() {
    const state = this.getState();
    const formattedObject = {};
    if (state.generatedAnswer?.isVisible !== void 0) {
      formattedObject.showGeneratedAnswer = state.generatedAnswer.isVisible;
    }
    return formattedObject;
  }
  get resultURIs() {
    return this.results?.map((r) => ({
      documentUri: r.uri,
      documentUriHash: r.raw.urihash
    }));
  }
  get results() {
    return this.state.search?.response.results;
  }
  get queryText() {
    return this.state.query?.q || getQueryInitialState().q;
  }
  get responseTime() {
    return this.state.search?.duration || getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.state.search?.response.totalCountFiltered || getSearchInitialState().response.totalCountFiltered;
  }
};
__publicField(_SearchAnalyticsProvider, "fallbackPipelineName", "default");
var SearchAnalyticsProvider = _SearchAnalyticsProvider;
var configureLegacyAnalytics = ({
  logger,
  getState,
  analyticsClientMiddleware = (_, p) => p,
  preprocessRequest,
  provider
}) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment,
    "analytics"
  );
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics3 = state.configuration.analytics.enabled;
  const client = new CoveoSearchPageClient(
    {
      token,
      endpoint,
      runtimeEnvironment,
      preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
      beforeSendHooks: [
        wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
        (type, payload) => {
          logger.info(
            {
              ...payload,
              type,
              endpoint,
              token
            },
            "Analytics request"
          );
          return payload;
        }
      ]
    },
    provider
  );
  if (!enableAnalytics3) {
    client.disable();
  }
  return client;
};
var getPageID = () => {
  const actions2 = history_store_default.getInstance().getHistory();
  const lastPageView = actions2.reverse().find((action) => {
    return action.name === "PageView" && action.value;
  });
  if (!lastPageView) {
    return "";
  }
  return lastPageView.value;
};

// src/features/pipeline/pipeline-state.ts
var getPipelineInitialState = () => "";

// src/features/analytics/analytics-utils.ts
function makeBasicNewSearchAnalyticsAction(actionCause, getState) {
  return {
    ...new SearchAnalyticsProvider(getState).getBaseMetadata(),
    actionCause,
    type: actionCause
  };
}
function makeInstantlyCallable(action) {
  return Object.assign(action, { instantlyCallable: true });
}
function makePreparableAnalyticsAction(prefix, buildEvent) {
  const createAnalyticsAction = (body) => makeInstantlyCallable(
    (0, import_toolkit10.createAsyncThunk)(prefix, body)
  );
  const rootAction = createAnalyticsAction(async (_, { getState, extra }) => {
    const { analyticsClientMiddleware, preprocessRequest, logger } = extra;
    return await (await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    })).log({ state: getState(), extra });
  });
  const prepare = async ({
    getState,
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  }) => {
    const { description, log } = await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    });
    return {
      description,
      action: createAnalyticsAction(
        async (_, { getState: getNewState, extra: newExtra }) => {
          return await log({ state: getNewState(), extra: newExtra });
        }
      )
    };
  };
  Object.assign(rootAction, {
    prepare
  });
  return rootAction;
}
var makeAnalyticsActionFactory = (configurator, legacyGetBuilderConverter, providerClass) => {
  function makeAnalyticsAction2(...params) {
    const options = params.length === 1 ? {
      ...params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(
        params[0].__legacy__getBuilder
      ),
      analyticsConfigurator: configurator,
      providerClass
    } : {
      prefix: params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[1]),
      __legacy__provider: params[2],
      analyticsConfigurator: configurator,
      providerClass
    };
    return internalMakeAnalyticsAction(options);
  }
  return makeAnalyticsAction2;
};
var shouldSendLegacyEvent = (state) => state.configuration.analytics.analyticsMode === "legacy";
var shouldSendNextEvent = (state) => state.configuration.analytics.analyticsMode === "next";
var internalMakeAnalyticsAction = ({
  prefix,
  __legacy__getBuilder,
  __legacy__provider,
  analyticsPayloadBuilder,
  analyticsType,
  analyticsConfigurator,
  providerClass
}) => {
  __legacy__provider ?? (__legacy__provider = (getState) => new providerClass(getState));
  return makePreparableAnalyticsAction(
    prefix,
    async ({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    }) => {
      const loggers = [];
      const analyticsAction = {
        log: async ({ state: state2 }) => {
          for (const log of loggers) {
            await log(state2);
          }
        }
      };
      const state = getState();
      const client = analyticsConfigurator({
        getState,
        logger,
        analyticsClientMiddleware,
        preprocessRequest,
        provider: __legacy__provider(getState)
      });
      const builder = await __legacy__getBuilder(client, getState());
      analyticsAction.description = builder?.description;
      loggers.push(async (state2) => {
        if (shouldSendLegacyEvent(state2)) {
          await logLegacyEvent(
            builder,
            __legacy__provider,
            state2,
            logger,
            client.coveoAnalyticsClient
          );
        }
      });
      const { emit } = getRelayInstanceFromState(state);
      loggers.push(async (state2) => {
        if (shouldSendNextEvent(state2) && analyticsType && analyticsPayloadBuilder) {
          const payload = analyticsPayloadBuilder(state2);
          await logNextEvent(emit, analyticsType, payload);
        }
      });
      return analyticsAction;
    }
  );
};
async function logLegacyEvent(builder, __legacy__provider, state, logger, client) {
  __legacy__provider(() => state);
  const response = await builder?.log({
    searchUID: __legacy__provider(() => state).getSearchUID()
  });
  logger.info({ client, response }, "Analytics response");
}
var fromLogToLegacyBuilderFactory = (actionCause) => {
  const fromLogToLegacyBuilder = (log) => {
    return (client, state) => Promise.resolve({
      description: { actionCause },
      log: async (_metadata) => {
        log(client, state);
      }
    });
  };
  return fromLogToLegacyBuilder;
};
var makeAnalyticsAction = makeAnalyticsActionFactory(
  (options) => configureLegacyAnalytics({
    ...options,
    provider: options.provider || new SearchAnalyticsProvider(options.getState)
  }),
  (original) => original,
  SearchAnalyticsProvider
);
var makeCaseAssistAnalyticsAction = makeAnalyticsActionFactory(
  configureCaseAssistAnalytics,
  fromLogToLegacyBuilderFactory("caseAssist"),
  CaseAssistAnalyticsProvider
);
var rawPartialDefinition = {
  urihash: new import_bueno15.StringValue(),
  sourcetype: new import_bueno15.StringValue(),
  permanentid: new import_bueno15.StringValue()
};
var resultPartialDefinition = {
  uniqueId: requiredNonEmptyString,
  raw: new import_bueno15.RecordValue({ values: rawPartialDefinition }),
  title: requiredNonEmptyString,
  uri: requiredNonEmptyString,
  clickUri: requiredNonEmptyString,
  rankingModifier: new import_bueno15.StringValue({ required: false, emptyAllowed: true })
};
async function logNextEvent(emitEvent, type, payload) {
  await emitEvent(type, payload);
  return;
}

// src/features/facets/generic/facet-actions-validation.ts
var facetIdDefinition = requiredNonEmptyString;

// src/features/search/search-actions.ts
var import_bueno29 = require("@coveo/bueno");
var import_toolkit21 = require("@reduxjs/toolkit");

// src/features/breadcrumb/breadcrumb-actions.ts
var import_toolkit11 = require("@reduxjs/toolkit");
var deselectAllBreadcrumbs = (0, import_toolkit11.createAction)("breadcrumb/deselectAll");
var deselectAllNonBreadcrumbs = (0, import_toolkit11.createAction)(
  "breadcrumb/deselectAllNonBreadcrumbs"
);

// src/features/facets/generic/facet-actions.ts
var import_bueno17 = require("@coveo/bueno");
var import_toolkit12 = require("@reduxjs/toolkit");
var updateFacetAutoSelection = (0, import_toolkit12.createAction)(
  "facet/updateFacetAutoSelection",
  (payload) => validatePayload(payload, {
    allow: new import_bueno17.BooleanValue({ required: true })
  })
);

// src/api/analytics/instant-result-analytics.ts
var InstantResultsAnalyticsProvider = class extends SearchAnalyticsProvider {
  constructor(getState) {
    super(getState);
    this.getState = getState;
  }
  get activeInstantResultQuery() {
    const state = this.getState().instantResults;
    for (const id2 in state) {
      for (const query2 in state[id2].cache) {
        if (state[id2].cache[query2].isActive) {
          return state[id2].q;
        }
      }
    }
    return null;
  }
  get activeInstantResultCache() {
    const state = this.getState().instantResults;
    for (const id2 in state) {
      for (const query2 in state[id2].cache) {
        if (state[id2].cache[query2].isActive) {
          return state[id2].cache[query2];
        }
      }
    }
    return null;
  }
  get results() {
    return this.activeInstantResultCache?.results;
  }
  get queryText() {
    return this.activeInstantResultQuery ?? getQueryInitialState().q;
  }
  get responseTime() {
    return this.activeInstantResultCache?.duration ?? getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.activeInstantResultCache?.totalCountFiltered ?? getSearchInitialState().response.totalCountFiltered;
  }
  getSearchUID() {
    const searchUid = this.activeInstantResultCache?.searchUid;
    return searchUid || super.getSearchUID();
  }
};

// src/features/instant-results/instant-result-analytics-actions.ts
var logInstantResultsSearch = () => makeAnalyticsAction(
  "analytics/instantResult/searchboxAsYouType",
  (client) => client.makeSearchboxAsYouType(),
  (getState) => new InstantResultsAnalyticsProvider(getState)
);
var searchboxAsYouType = () => ({
  actionCause: "searchboxAsYouType" /* searchboxAsYouType */
});

// src/features/instant-results/instant-results-actions.ts
var import_toolkit13 = require("@reduxjs/toolkit");
var instantResultsRegisterDefinition = {
  id: requiredNonEmptyString
};
var instantResultsQueryDefinition = {
  ...instantResultsRegisterDefinition,
  q: requiredEmptyAllowedString
};
var registerInstantResults = (0, import_toolkit13.createAction)(
  "instantResults/register",
  (payload) => validatePayload(payload, instantResultsRegisterDefinition)
);
var updateInstantResultsQuery = (0, import_toolkit13.createAction)(
  "instantResults/updateQuery",
  (payload) => validatePayload(payload, instantResultsQueryDefinition)
);
var clearExpiredResults = (0, import_toolkit13.createAction)(
  "instantResults/clearExpired",
  (payload) => validatePayload(payload, instantResultsRegisterDefinition)
);

// src/features/pagination/pagination-actions.ts
var import_bueno18 = require("@coveo/bueno");
var import_toolkit14 = require("@reduxjs/toolkit");
var numberValue = new import_bueno18.NumberValue({ required: true, min: 0 });
var registerNumberOfResults = (0, import_toolkit14.createAction)(
  "pagination/registerNumberOfResults",
  (payload) => validatePayload(payload, numberValue)
);
var updateNumberOfResults = (0, import_toolkit14.createAction)(
  "pagination/updateNumberOfResults",
  (payload) => validatePayload(payload, numberValue)
);
var registerPage = (0, import_toolkit14.createAction)(
  "pagination/registerPage",
  (payload) => validatePayload(payload, numberValue)
);
var updatePage = (0, import_toolkit14.createAction)(
  "pagination/updatePage",
  (payload) => validatePayload(payload, numberValue)
);
var nextPage = (0, import_toolkit14.createAction)("pagination/nextPage");
var previousPage = (0, import_toolkit14.createAction)("pagination/previousPage");

// src/features/query/query-actions.ts
var import_bueno19 = require("@coveo/bueno");
var import_toolkit15 = require("@reduxjs/toolkit");
var updateQuery = (0, import_toolkit15.createAction)(
  "query/updateQuery",
  (payload) => validatePayload(payload, {
    q: new import_bueno19.StringValue(),
    enableQuerySyntax: new import_bueno19.BooleanValue()
  })
);

// src/features/search-and-folding/search-and-folding-request.ts
var import_bueno20 = require("@coveo/bueno");

// src/features/configuration/analytics-params.ts
var fromAnalyticsStateToAnalyticsParams = (s, navigatorContext, eventDescription) => {
  return {
    analytics: {
      clientId: navigatorContext.clientId,
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: navigatorContext.referrer,
      documentLocation: navigatorContext.location,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause
      },
      ...eventDescription && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.deviceId && { deviceId: s.deviceId },
      ...s.trackingId && { trackingId: s.trackingId },
      ...{
        capture: navigatorContext.capture ?? navigatorContext.clientId !== ""
      },
      ...{ source: getAnalyticsSource(s) }
    }
  };
};

// src/features/search-and-folding/search-and-folding-request.ts
var buildSearchAndFoldingLoadCollectionRequest = (state, navigatorContext, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: navigatorContext.referrer,
    timezone: state.configuration.search.timezone,
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && fromAnalyticsStateToAnalyticsParams(
      state.configuration.analytics,
      navigatorContext,
      eventDescription
    ),
    ...state.excerptLength && !(0, import_bueno20.isNullOrUndefined)(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/search/legacy/search-actions.ts
var import_bueno27 = require("@coveo/bueno");
var import_toolkit19 = require("@reduxjs/toolkit");

// src/features/search-and-folding/legacy/search-and-folding-request.ts
var import_bueno21 = require("@coveo/bueno");

// src/features/configuration/legacy-analytics-params.ts
var fromAnalyticsStateToAnalyticsParams2 = async (s, eventDescription) => {
  const isNextAnalytics = s.analyticsMode === "next";
  return {
    analytics: {
      clientId: await getVisitorID(s),
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: s.originLevel3,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause,
        customData: eventDescription.customData
      },
      ...eventDescription && !isNextAnalytics && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.documentLocation && { documentLocation: s.documentLocation },
      ...s.deviceId && { deviceId: s.deviceId },
      ...getPageID() && { pageId: getPageID() },
      ...isNextAnalytics && s.trackingId && { trackingId: s.trackingId },
      ...{ capture: isNextAnalytics },
      ...isNextAnalytics && { source: getAnalyticsSource(s) }
    }
  };
};

// src/features/search-and-folding/legacy/search-and-folding-request.ts
var buildSearchAndFoldingLoadCollectionRequest2 = async (state, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: state.configuration.analytics.originLevel3,
    timezone: state.configuration.search.timezone,
    ...state.configuration.analytics.enabled && {
      actionsHistory: history_store_default.getInstance().getHistory()
    },
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && await fromAnalyticsStateToAnalyticsParams2(
      state.configuration.analytics,
      eventDescription
    ),
    ...state.excerptLength && !(0, import_bueno21.isNullOrUndefined)(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/advanced-search-queries/advanced-search-queries-state.ts
var getAdvancedSearchQueriesInitialState = () => ({
  cq: "",
  cqWasSet: false,
  aq: "",
  aqWasSet: false,
  lq: "",
  lqWasSet: false,
  dq: "",
  dqWasSet: false,
  defaultFilters: {
    cq: "",
    aq: "",
    lq: "",
    dq: ""
  }
});

// src/features/search/search-analytics-actions.ts
var logFetchMoreResults = () => makeAnalyticsAction(
  "search/logFetchMoreResults",
  (client) => client.makeFetchMoreResults()
);
var logQueryError = (error) => makeAnalyticsAction(
  "search/queryError",
  (client, state) => client.makeQueryError({
    query: state.query?.q || getQueryInitialState().q,
    aq: state.advancedSearchQueries?.aq || getAdvancedSearchQueriesInitialState().aq,
    cq: state.advancedSearchQueries?.cq || getAdvancedSearchQueriesInitialState().cq,
    dq: state.advancedSearchQueries?.dq || getAdvancedSearchQueriesInitialState().dq,
    errorType: error.type,
    errorMessage: error.message
  })
);

// src/features/facets/range-facets/date-facet-set/interfaces/request.ts
function isDateFacetRequest(request) {
  return request.type === "dateRange";
}

// src/features/search/search-mappings.ts
function formatStartFacetValue(value) {
  return `start${value}`;
}
function formatEndFacetValue(value) {
  return `end${value}`;
}
var initialSearchMappings = () => ({
  dateFacetValueMap: {}
});
function mapDateRangeRequest(value, facetId2, mappings) {
  let start = value.start;
  let end = value.end;
  if (isRelativeDateFormat(start)) {
    start = formatRelativeDateForSearchApi(start);
    mappings.dateFacetValueMap[facetId2][formatStartFacetValue(start)] = value.start;
  }
  if (isRelativeDateFormat(end)) {
    end = formatRelativeDateForSearchApi(end);
    mappings.dateFacetValueMap[facetId2][formatEndFacetValue(end)] = value.end;
  }
  return { ...value, start, end };
}
function mapFacetRequest(facetRequest, mappings) {
  if (isDateFacetRequest(facetRequest)) {
    const { facetId: facetId2, currentValues } = facetRequest;
    mappings.dateFacetValueMap[facetId2] = {};
    return {
      ...facetRequest,
      currentValues: currentValues.map(
        (value) => mapDateRangeRequest(value, facetId2, mappings)
      )
    };
  }
  return facetRequest;
}
function mapSearchRequest(searchRequest) {
  const mappings = initialSearchMappings();
  const request = {
    ...searchRequest,
    facets: searchRequest.facets?.map(
      (facetRequest) => mapFacetRequest(facetRequest, mappings)
    )
  };
  return { request, mappings };
}
function mapDateRangeResponse(value, facetId2, mappings) {
  return {
    ...value,
    start: mappings.dateFacetValueMap[facetId2][formatStartFacetValue(value.start)] || value.start,
    end: mappings.dateFacetValueMap[facetId2][formatEndFacetValue(value.end)] || value.end
  };
}
function isDateFacetResponse(facetResponse, mappings) {
  return facetResponse.facetId in mappings.dateFacetValueMap;
}
function mapFacetResponse(facetResponse, mappings) {
  if (isDateFacetResponse(facetResponse, mappings)) {
    return {
      ...facetResponse,
      values: facetResponse.values.map(
        (value) => mapDateRangeResponse(value, facetResponse.facetId, mappings)
      )
    };
  }
  return facetResponse;
}
function mapSearchResponse(response, mappings) {
  if ("success" in response) {
    const success = {
      ...response.success,
      facets: response.success.facets?.map(
        (facetResponse) => mapFacetResponse(facetResponse, mappings)
      )
    };
    return { success };
  }
  return response;
}

// src/features/search/legacy/search-actions-thunk-processor.ts
var import_bueno26 = require("@coveo/bueno");

// src/api/search/search-api-client.ts
var import_bueno22 = require("@coveo/bueno");

// src/api/search/search-api-error-response.ts
function buildDisconnectedError(error) {
  return {
    statusCode: error.statusCode,
    type: error.name,
    message: error.message
  };
}
function buildIgnoredAbortedError(error) {
  return {
    statusCode: error.code,
    type: error.name,
    message: error.message,
    ignored: true
  };
}
function buildAPIResponseFromErrorOrThrow(error, disableAbortWarning) {
  if (disableAbortWarning && error.name === "AbortError") {
    return {
      error: buildIgnoredAbortedError(error)
    };
  }
  if (error instanceof DisconnectedError) {
    return { error: buildDisconnectedError(error) };
  }
  throw error;
}

// src/api/search/search-api-client.ts
var isSuccessResponse = (r) => {
  return r.success !== void 0;
};
var isErrorResponse = (r) => {
  return r.error !== void 0;
};

// src/features/did-you-mean/did-you-mean-actions.ts
var import_bueno23 = require("@coveo/bueno");
var import_toolkit16 = require("@reduxjs/toolkit");
var enableDidYouMean = (0, import_toolkit16.createAction)("didYouMean/enable");
var disableDidYouMean = (0, import_toolkit16.createAction)("didYouMean/disable");
var disableAutomaticQueryCorrection = (0, import_toolkit16.createAction)(
  "didYouMean/automaticCorrections/disable"
);
var enableAutomaticQueryCorrection = (0, import_toolkit16.createAction)(
  "didYouMean/automaticCorrections/enable"
);
var applyDidYouMeanCorrection = (0, import_toolkit16.createAction)(
  "didYouMean/correction",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setCorrectionMode = (0, import_toolkit16.createAction)(
  "didYouMean/automaticCorrections/mode",
  (payload) => validatePayload(
    payload,
    new import_bueno23.StringValue({
      constrainTo: ["next", "legacy"],
      emptyAllowed: false,
      required: true
    })
  )
);

// src/features/did-you-mean/did-you-mean-analytics-actions.ts
var logDidYouMeanAutomatic = () => makeAnalyticsAction(
  "analytics/didyoumean/automatic",
  (client) => client.makeDidYouMeanAutomatic()
);
var didYouMeanAutomatic = () => ({
  actionCause: "didYouMeanAutomatic" /* didYouMeanAutomatic */
});

// src/features/history/history-actions.ts
var import_toolkit17 = require("@reduxjs/toolkit");
var undo = (0, import_toolkit17.createAction)("history/undo");
var redo = (0, import_toolkit17.createAction)("history/redo");
var snapshot = (0, import_toolkit17.createAction)("history/snapshot");
var back = (0, import_toolkit17.createAsyncThunk)("history/back", async (_, { dispatch }) => {
  dispatch(undo());
  await dispatch(change());
});
var forward = (0, import_toolkit17.createAsyncThunk)(
  "history/forward",
  async (_, { dispatch }) => {
    dispatch(redo());
    await dispatch(change());
  }
);
var change = (0, import_toolkit17.createAsyncThunk)(
  "history/change",
  async (_, { getState }) => {
    const s = getState();
    return s.history.present;
  }
);

// src/features/context/context-state.ts
function getContextInitialState2() {
  return {
    contextValues: {}
  };
}

// src/features/debug/debug-state.ts
var getDebugInitialState = () => false;

// src/features/dictionary-field-context/dictionary-field-context-state.ts
function getDictionaryFieldContextInitialState() {
  return {
    contextValues: {}
  };
}

// src/features/facet-options/facet-options-state.ts
function getFacetOptionsSliceInitialState() {
  return { enabled: true, tabs: {} };
}
function getFacetOptionsInitialState() {
  return {
    freezeFacetOrder: false,
    facets: {}
  };
}

// src/features/facets/facet-order/facet-order-state.ts
function getFacetOrderInitialState() {
  return [];
}

// src/features/pagination/pagination-state.ts
function getPaginationInitialState() {
  return {
    firstResult: 0,
    defaultNumberOfResults: 10,
    numberOfResults: 10,
    totalCountFiltered: 0
  };
}

// src/features/query-set/query-set-state.ts
function getQuerySetInitialState() {
  return {};
}

// src/features/static-filter-set/static-filter-set-state.ts
function getStaticFilterSetInitialState() {
  return {};
}

// src/features/tab-set/tab-set-state.ts
function getTabSetInitialState() {
  return {};
}

// src/features/history/history-state.ts
function extractHistory(state) {
  return {
    context: state.context || getContextInitialState2(),
    dictionaryFieldContext: state.dictionaryFieldContext || getDictionaryFieldContextInitialState(),
    facetSet: state.facetSet || getFacetSetInitialState(),
    numericFacetSet: state.numericFacetSet || getNumericFacetSetInitialState(),
    dateFacetSet: state.dateFacetSet || getDateFacetSetInitialState(),
    categoryFacetSet: state.categoryFacetSet || getCategoryFacetSetInitialState(),
    automaticFacetSet: state.automaticFacetSet ?? getAutomaticFacetSetInitialState(),
    pagination: state.pagination || getPaginationInitialState(),
    query: state.query || getQueryInitialState(),
    tabSet: state.tabSet || getTabSetInitialState(),
    advancedSearchQueries: state.advancedSearchQueries || getAdvancedSearchQueriesInitialState(),
    staticFilterSet: state.staticFilterSet || getStaticFilterSetInitialState(),
    querySet: state.querySet || getQuerySetInitialState(),
    sortCriteria: state.sortCriteria || getSortCriteriaInitialState(),
    pipeline: state.pipeline || getPipelineInitialState(),
    searchHub: state.searchHub || getSearchHubInitialState(),
    facetOptions: state.facetOptions || getFacetOptionsInitialState(),
    facetOrder: state.facetOrder ?? getFacetOrderInitialState(),
    debug: state.debug ?? getDebugInitialState()
  };
}

// src/features/triggers/trigger-analytics-actions.ts
var import_bueno24 = require("@coveo/bueno");
var logUndoTriggerQueryPayloadDefinition = new import_bueno24.RecordValue({
  values: {
    undoneQuery: requiredEmptyAllowedString
  },
  options: { required: true }
});
var logTriggerQuery = () => makeAnalyticsAction("analytics/trigger/query", (client, state) => {
  if (state.triggers?.queryModification.newQuery) {
    return client.makeTriggerQuery();
  }
  return null;
});

// src/features/triggers/triggers-actions.ts
var import_bueno25 = require("@coveo/bueno");
var import_toolkit18 = require("@reduxjs/toolkit");
var updateIgnoreQueryTrigger = (0, import_toolkit18.createAction)(
  "trigger/query/ignore",
  (q) => validatePayload(q, new import_bueno25.StringValue({ emptyAllowed: true, required: true }))
);
var applyQueryTriggerModification = (0, import_toolkit18.createAction)(
  "trigger/query/modification",
  (payload) => validatePayload(
    payload,
    new import_bueno25.RecordValue({
      values: { originalQuery: nonEmptyString, modification: nonEmptyString }
    })
  )
);

// src/features/facets/generic/interfaces/generic-facet-request.ts
function getFacetRequests2(state) {
  return Object.values(state).map(
    (slice) => slice.request
  );
}

// src/utils/facet-utils.ts
function sortFacets(facets, sortOrder) {
  const payloadMap = {};
  facets.forEach((f2) => {
    payloadMap[f2.facetId] = f2;
  });
  const sortedFacets = [];
  sortOrder.forEach((facetId2) => {
    if (facetId2 in payloadMap) {
      sortedFacets.push(payloadMap[facetId2]);
      delete payloadMap[facetId2];
    }
  });
  const remainingFacets = Object.values(payloadMap);
  return [...sortedFacets, ...remainingFacets];
}
function getRangeFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    if (request.generateAutomaticRanges && !hasActiveValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
var sortCriteriaMap = {
  alphanumericDescending: { type: "alphanumeric", order: "descending" },
  alphanumericNaturalDescending: {
    type: "alphanumericNatural",
    order: "descending"
  }
};
function getSpecificFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getAllFacets(state) {
  return [
    ...getSpecificFacetRequests(state.facetSet ?? {}),
    ...getRangeFacetRequests(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getAllEnabledFacets(state) {
  return getAllFacets(state).filter(
    ({ facetId: facetId2 }) => state.facetOptions?.facets[facetId2]?.enabled ?? true
  );
}
function getFacets2(state) {
  return sortFacets(getAllEnabledFacets(state), state.facetOrder ?? []);
}

// src/features/pagination/pagination-constants.ts
var minimumPage = 1;
var maximumNumberOfResultsFromIndex = 5e3;

// src/features/search/legacy/search-request.ts
var buildSearchRequest = async (state, eventDescription) => {
  const cq = buildConstantQuery(state);
  const facets = getFacets2(state);
  const automaticFacets = getAutomaticFacets2(state);
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest2(state, eventDescription);
  const getNumberOfResultsWithinIndexLimit2 = () => {
    if (!state.pagination) {
      return void 0;
    }
    const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
    if (isOverIndexLimit) {
      return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
    }
    return state.pagination.numberOfResults;
  };
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit2(),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getAutomaticFacets2(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function buildConstantQuery(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find(
    (tab) => tab.isActive
  );
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = getStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}
function getStaticFilterExpressions(state) {
  const filters = Object.values(state.staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter(
      (value) => value.state === "selected" && !!value.expression.trim()
    );
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
}

// src/features/search/legacy/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    const startedAt = Date.now();
    const response = mapSearchResponse(
      await this.extra.apiClient.search(request, options),
      mappings
    );
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !(0, import_bueno26.isNullOrUndefined)(queryCorrection) && !(0, import_bueno26.isNullOrUndefined)(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(
      originalFetchedResponse
    );
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    this.analyticsAction?.()(
      this.dispatch,
      () => this.getStateAfterResponse(
        originalFetchedResponse.queryExecuted,
        originalFetchedResponse.duration,
        state,
        successResponse
      ),
      this.extra
    );
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    if (this.analyticsAction) {
      await this.dispatch(this.analyticsAction);
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery,
      analyticsAction: logTriggerQuery()
    };
  }
  getStateAfterResponse(query2, duration, previousState, response) {
    return {
      ...previousState,
      query: {
        q: query2,
        enableQuerySyntax: previousState.query?.enableQuerySyntax ?? getQueryInitialState().enableQuerySyntax
      },
      search: {
        ...getSearchInitialState(),
        duration,
        response,
        results: response.results
      }
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery(),
      analyticsAction: this.analyticsAction
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest(this.getState()),
      { origin: "mainSearch" }
    );
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(
      applyQueryTriggerModification({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest(this.getState()),
      { origin: "mainSearch" }
    );
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get analyticsAction() {
    return this.config.analyticsAction;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// src/features/search/legacy/search-actions.ts
var executeSearch = (0, import_toolkit19.createAsyncThunk)("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  return await legacyExecuteSearch(state, config, searchAction);
});
var fetchPage = (0, import_toolkit19.createAsyncThunk)("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchPage(state, config, searchAction);
});
var fetchMoreResults = (0, import_toolkit19.createAsyncThunk)("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  return await legacyFetchMoreResults(config, state);
});
var fetchFacetValues = (0, import_toolkit19.createAsyncThunk)(
  "search/fetchFacetValues",
  async (searchAction, config) => {
    const state = config.getState();
    return await legacyFetchFacetValues(config, searchAction, state);
  }
);
var fetchInstantResults = (0, import_toolkit19.createAsyncThunk)(
  "search/fetchInstantResults",
  async (payload, config) => {
    return legacyFetchInstantResults(payload, config);
  }
);
var buildFetchMoreRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest = async (state, q, numberOfResults) => {
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest2(state);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory = (state) => {
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
async function legacyFetchInstantResults(payload, config) {
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new import_bueno27.NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new import_bueno27.NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const state = config.getState();
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: logInstantResultsSearch() }, (modification) => {
    config.dispatch(
      updateInstantResultsQuery({ q: modification, id: payload.id })
    );
  });
  const request = await buildInstantResultSearchRequest(
    state,
    q,
    maxResultsPerQuery
  );
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      analyticsAction: processed.analyticsAction,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
}
async function legacyFetchPage(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: searchAction
  });
  const request = await buildSearchRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchMoreResults(config, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await logFetchMoreResults().prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: logFetchMoreResults()
  });
  const request = await buildFetchMoreRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchFacetValues(config, searchAction, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const request = await buildFetchFacetValuesRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
}
async function legacyExecuteSearch(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const request = await buildSearchRequest(state, eventDescription);
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}

// src/features/search/search-actions-thunk-processor.ts
var import_bueno28 = require("@coveo/bueno");

// src/features/static-filter-set/static-filter-set-selectors.ts
var import_toolkit20 = require("@reduxjs/toolkit");
var selectStaticFilterExpressions = (0, import_toolkit20.createSelector)(
  (state) => state.staticFilterSet,
  (staticFilterSet) => {
    const filters = Object.values(staticFilterSet || {});
    return filters.map((filter) => {
      const selected = filter.values.filter(
        (value) => value.state === "selected" && !!value.expression.trim()
      );
      const expression = selected.map((value) => value.expression).join(" OR ");
      return selected.length > 1 ? `(${expression})` : expression;
    });
  }
);

// src/features/search/search-request.ts
var buildSearchRequest2 = async (state, navigatorContext, eventDescription) => {
  const cq = buildConstantQuery2(state);
  const facets = getFacets3(state);
  const automaticFacets = getAutomaticFacets3(state);
  const sharedWithFoldingRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest2(
    state,
    eventDescription
  ) : buildSearchAndFoldingLoadCollectionRequest(
    state,
    navigatorContext,
    eventDescription
  );
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getNumberOfResultsWithinIndexLimit(state) {
  if (!state.pagination) {
    return void 0;
  }
  const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
  if (isOverIndexLimit) {
    return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
  }
  return state.pagination.numberOfResults;
}
function getFacets3(state) {
  return sortFacets(getAllEnabledFacets2(state), state.facetOrder ?? []);
}
function getAutomaticFacets3(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest2).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest2(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function getAllEnabledFacets2(state) {
  return getAllFacets2(state).filter(
    ({ facetId: facetId2 }) => state.facetOptions?.facets[facetId2]?.enabled ?? true
  );
}
function getAllFacets2(state) {
  return [
    ...getSpecificFacetRequests2(state.facetSet ?? {}),
    ...getRangeFacetRequests2(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests2(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getSpecificFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getRangeFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    const hasPreviousStateValues = currentValues.some(
      (value) => value.previousState
    );
    if (request.generateAutomaticRanges && !hasActiveValues && !hasPreviousStateValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
function buildConstantQuery2(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find(
    (tab) => tab.isActive
  );
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = selectStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}

// src/features/search/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor2 = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    const startedAt = Date.now();
    const response = mapSearchResponse(
      await this.extra.apiClient.search(request, options),
      mappings
    );
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !(0, import_bueno28.isNullOrUndefined)(queryCorrection) && !(0, import_bueno28.isNullOrUndefined)(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(
      originalFetchedResponse
    );
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery()
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const state = this.getState();
    const { actionCause } = didYouMeanAutomatic();
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest2(state, this.extra.navigatorContext, {
        actionCause
      }),
      { origin: "mainSearch" }
    );
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(
      applyQueryTriggerModification({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest2(this.getState(), this.extra.navigatorContext),
      { origin: "mainSearch" }
    );
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// src/features/search/search-actions.ts
var prepareForSearchWithQuery = (0, import_toolkit21.createAsyncThunk)("search/prepareForSearchWithQuery", (payload, thunk) => {
  const { dispatch } = thunk;
  validatePayload(payload, {
    q: new import_bueno29.StringValue(),
    enableQuerySyntax: new import_bueno29.BooleanValue(),
    clearFilters: new import_bueno29.BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deselectAllBreadcrumbs());
    dispatch(deselectAllNonBreadcrumbs());
  }
  dispatch(updateFacetAutoSelection({ allow: true }));
  dispatch(
    updateQuery({ q: payload.q, enableQuerySyntax: payload.enableQuerySyntax })
  );
  dispatch(updatePage(1));
});
var updateSearchAction = (0, import_toolkit21.createAction)(
  "search/updateSearchAction"
);
var executeSearch2 = (0, import_toolkit21.createAsyncThunk)(
  "search/executeSearch",
  async (searchAction, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyExecuteSearch(state, config, searchAction.legacy);
    }
    addEntryInActionsHistory2(state);
    const analyticsAction = searchAction.next ? buildSearchReduxAction(searchAction.next) : void 0;
    const request = await buildSearchRequest2(
      state,
      config.extra.navigatorContext,
      analyticsAction
    );
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: analyticsAction ?? {} });
    const fetched = await processor.fetchFromAPI(request, {
      origin: "mainSearch"
    });
    return await processor.process(fetched);
  }
);
var fetchPage2 = (0, import_toolkit21.createAsyncThunk)("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  addEntryInActionsHistory2(state);
  if (state.configuration.analytics.analyticsMode === "legacy" || !searchAction.next) {
    return legacyFetchPage(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction: searchAction.next
  });
  const request = await buildSearchRequest2(
    state,
    config.extra.navigatorContext,
    searchAction.next
  );
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchMoreResults2 = (0, import_toolkit21.createAsyncThunk)("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchMoreResults(config, state);
  }
  const analyticsAction = makeBasicNewSearchAnalyticsAction(
    "browseResults" /* browseResults */,
    config.getState
  );
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction
  });
  const request = await buildFetchMoreRequest2(
    state,
    config.extra.navigatorContext,
    analyticsAction
  );
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchFacetValues2 = (0, import_toolkit21.createAsyncThunk)(
  "search/fetchFacetValues",
  async (searchAction, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyExecuteSearch(state, config, searchAction.legacy);
    }
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: {} });
    const request = await buildFetchFacetValuesRequest2(
      state,
      config.extra.navigatorContext
    );
    const fetched = await processor.fetchFromAPI(request, {
      origin: "facetValues"
    });
    return await processor.process(fetched);
  }
);
var fetchInstantResults2 = (0, import_toolkit21.createAsyncThunk)(
  "search/fetchInstantResults",
  async (payload, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyFetchInstantResults(payload, config);
    }
    validatePayload(payload, {
      id: requiredNonEmptyString,
      q: requiredNonEmptyString,
      maxResultsPerQuery: new import_bueno29.NumberValue({
        required: true,
        min: 1
      }),
      cacheTimeout: new import_bueno29.NumberValue()
    });
    const { q, maxResultsPerQuery } = payload;
    const analyticsAction = buildSearchReduxAction(searchboxAsYouType());
    const request = await buildInstantResultSearchRequest2(
      state,
      config.extra.navigatorContext,
      q,
      maxResultsPerQuery,
      analyticsAction
    );
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction }, (modification) => {
      config.dispatch(
        updateInstantResultsQuery({ q: modification, id: payload.id })
      );
    });
    const fetched = await processor.fetchFromAPI(request, {
      origin: "instantResults",
      disableAbortWarning: true
    });
    const processed = await processor.process(fetched);
    if ("response" in processed) {
      return {
        results: processed.response.results,
        searchUid: processed.response.searchUid,
        totalCountFiltered: processed.response.totalCountFiltered,
        duration: processed.duration
      };
    }
    return processed;
  }
);
var buildFetchMoreRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(
    state,
    navigatorContext,
    eventDescription
  );
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest2 = async (state, navigatorContext, q, numberOfResults, eventDescription) => {
  const sharedWithFoldingRequest = buildSearchAndFoldingLoadCollectionRequest(
    state,
    navigatorContext,
    eventDescription
  );
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(
    state,
    navigatorContext,
    eventDescription
  );
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory2 = (state) => {
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
var buildSearchReduxAction = (action) => ({
  actionCause: action.actionCause,
  type: action.actionCause
});

// src/features/facet-options/facet-options-slice.ts
var import_toolkit28 = require("@reduxjs/toolkit");

// src/features/facets/category-facet-set/category-facet-set-actions.ts
var import_bueno31 = require("@coveo/bueno");
var import_toolkit22 = require("@reduxjs/toolkit");

// src/features/facets/category-facet-set/category-facet-validate-payload.ts
var import_bueno30 = require("@coveo/bueno");
var categoryFacetValueDefinition = {
  state: new import_bueno30.Value({ required: true }),
  numberOfResults: new import_bueno30.NumberValue({ required: true, min: 0 }),
  value: new import_bueno30.StringValue({ required: true, emptyAllowed: true }),
  path: new import_bueno30.ArrayValue({ required: true, each: requiredNonEmptyString }),
  moreValuesAvailable: new import_bueno30.BooleanValue({ required: false })
};
function validateCategoryFacetValue(payload) {
  payload.children.forEach((child) => {
    validateCategoryFacetValue(child);
  });
  validatePayloadAndThrow(
    {
      state: payload.state,
      numberOfResults: payload.numberOfResults,
      value: payload.value,
      path: payload.path,
      moreValuesAvailable: payload.moreValuesAvailable
    },
    categoryFacetValueDefinition
  );
}

// src/features/facets/category-facet-set/category-facet-set-actions.ts
var categoryFacetPayloadDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new import_bueno31.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno31.ArrayValue({ each: new import_bueno31.StringValue() }),
      excluded: new import_bueno31.ArrayValue({ each: new import_bueno31.StringValue() })
    }
  }),
  activeTab: new import_bueno31.StringValue({ required: false }),
  delimitingCharacter: new import_bueno31.StringValue({ required: false, emptyAllowed: true }),
  filterFacetCount: new import_bueno31.BooleanValue({ required: false }),
  injectionDepth: new import_bueno31.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno31.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno31.Value({ required: false }),
  basePath: new import_bueno31.ArrayValue({ required: false, each: requiredNonEmptyString }),
  filterByBasePath: new import_bueno31.BooleanValue({ required: false })
};
var registerCategoryFacet = (0, import_toolkit22.createAction)(
  "categoryFacet/register",
  (payload) => validatePayload(payload, categoryFacetPayloadDefinition)
);
var toggleSelectCategoryFacetValue = (0, import_toolkit22.createAction)(
  "categoryFacet/toggleSelectValue",
  (payload) => {
    try {
      validatePayloadAndThrow(payload.facetId, requiredNonEmptyString);
      validateCategoryFacetValue(payload.selection);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var deselectAllCategoryFacetValues = (0, import_toolkit22.createAction)(
  "categoryFacet/deselectAll",
  (payload) => validatePayload(payload, categoryFacetPayloadDefinition.facetId)
);
var updateCategoryFacetNumberOfValues = (0, import_toolkit22.createAction)(
  "categoryFacet/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: categoryFacetPayloadDefinition.facetId,
    numberOfValues: categoryFacetPayloadDefinition.numberOfValues
  })
);
var updateCategoryFacetSortCriterion = (0, import_toolkit22.createAction)(
  "categoryFacet/updateSortCriterion",
  (payload) => validatePayload(payload, {
    facetId: categoryFacetPayloadDefinition.facetId,
    criterion: new import_bueno31.Value()
  })
);
var updateCategoryFacetBasePath = (0, import_toolkit22.createAction)(
  "categoryFacet/updateBasePath",
  (payload) => validatePayload(payload, {
    facetId: categoryFacetPayloadDefinition.facetId,
    basePath: new import_bueno31.ArrayValue({ each: requiredNonEmptyString })
  })
);

// src/features/facets/facet-set/facet-set-actions.ts
var import_bueno34 = require("@coveo/bueno");
var import_toolkit23 = require("@reduxjs/toolkit");

// src/controllers/core/facets/_common/facet-option-definitions.ts
var import_bueno32 = require("@coveo/bueno");
var facetId = new import_bueno32.StringValue({
  regex: /^[a-zA-Z0-9-_]+$/
});
var field = new import_bueno32.StringValue({ required: true });
var basePath = new import_bueno32.ArrayValue({
  each: new import_bueno32.StringValue()
});
var delimitingCharacter = new import_bueno32.StringValue();
var filterByBasePath = new import_bueno32.BooleanValue();
var filterFacetCount = new import_bueno32.BooleanValue();
var injectionDepth = new import_bueno32.NumberValue({ min: 0 });
var numberOfValues = new import_bueno32.NumberValue({ min: 1 });
var generateAutomaticRanges = new import_bueno32.BooleanValue({
  required: true
});
var captions = new import_bueno32.RecordValue();
var query = new import_bueno32.StringValue();
var facetSearchOptionDefinitions = {
  captions,
  numberOfValues,
  query
};
var facetSearch = new import_bueno32.RecordValue({
  values: facetSearchOptionDefinitions
});
var allowedValues = new import_bueno32.RecordValue({
  options: { required: false },
  values: {
    type: new import_bueno32.StringValue({
      constrainTo: ["simple"],
      emptyAllowed: false,
      required: true
    }),
    values: new import_bueno32.ArrayValue({
      required: true,
      max: 25,
      each: new import_bueno32.StringValue({ emptyAllowed: false, required: true })
    })
  }
});
var hasBreadcrumbs = new import_bueno32.BooleanValue();
var customSort = new import_bueno32.ArrayValue({
  min: 1,
  max: 25,
  required: false,
  each: new import_bueno32.StringValue({ emptyAllowed: false, required: true })
});

// src/features/facets/facet-set/facet-set-validate-payload.ts
var import_bueno33 = require("@coveo/bueno");
var facetValueDefinition = {
  value: requiredNonEmptyString,
  numberOfResults: new import_bueno33.NumberValue({ min: 0 }),
  state: requiredNonEmptyString
};

// src/features/facets/facet-set/facet-set-actions.ts
var facetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: new import_bueno34.StringValue({ required: true, emptyAllowed: true }),
  tabs: new import_bueno34.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno34.ArrayValue({ each: new import_bueno34.StringValue() }),
      excluded: new import_bueno34.ArrayValue({ each: new import_bueno34.StringValue() })
    }
  }),
  activeTab: new import_bueno34.StringValue({ required: false }),
  filterFacetCount: new import_bueno34.BooleanValue({ required: false }),
  injectionDepth: new import_bueno34.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno34.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno34.Value({ required: false }),
  resultsMustMatch: new import_bueno34.Value({ required: false }),
  allowedValues,
  customSort
};
var registerFacet = (0, import_toolkit23.createAction)(
  "facet/register",
  (payload) => validatePayload(payload, facetRegistrationOptionsDefinition)
);
var toggleSelectFacetValue = (0, import_toolkit23.createAction)(
  "facet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno34.RecordValue({ values: facetValueDefinition })
  })
);
var toggleExcludeFacetValue = (0, import_toolkit23.createAction)(
  "facet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno34.RecordValue({ values: facetValueDefinition })
  })
);
var deselectAllFacetValues = (0, import_toolkit23.createAction)(
  "facet/deselectAll",
  (payload) => validatePayload(payload, facetIdDefinition)
);
var updateFacetSortCriterion = (0, import_toolkit23.createAction)(
  "facet/updateSortCriterion",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new import_bueno34.Value({ required: true })
  })
);
var updateFacetNumberOfValues = (0, import_toolkit23.createAction)(
  "facet/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    numberOfValues: new import_bueno34.NumberValue({ required: true, min: 1 })
  })
);
var updateFacetIsFieldExpanded = (0, import_toolkit23.createAction)(
  "facet/updateIsFieldExpanded",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    isFieldExpanded: new import_bueno34.BooleanValue({ required: true })
  })
);
var updateFreezeCurrentValues = (0, import_toolkit23.createAction)(
  "facet/updateFreezeCurrentValues",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    freezeCurrentValues: new import_bueno34.BooleanValue({ required: true })
  })
);

// src/features/facets/range-facets/date-facet-set/date-facet-actions.ts
var import_bueno37 = require("@coveo/bueno");
var import_toolkit25 = require("@reduxjs/toolkit");

// src/controllers/core/facets/range-facet/date-facet/date-range.ts
function buildDateRange(config) {
  const start = buildDate(config.start, config);
  const end = buildDate(config.end, config);
  const endInclusive = config.endInclusive ?? false;
  const state = config.state ?? "idle";
  return {
    start,
    end,
    endInclusive,
    state
  };
}
function buildDate(rawDate, options) {
  const { dateFormat } = options;
  if (isRelativeDate(rawDate)) {
    validateRelativeDate(rawDate);
    return serializeRelativeDate(rawDate);
  }
  if (typeof rawDate === "string" && isRelativeDateFormat(rawDate)) {
    validateRelativeDate(rawDate);
    return rawDate;
  }
  validateAbsoluteDate(rawDate, dateFormat);
  return formatDateForSearchApi(parseDate(rawDate, dateFormat));
}

// src/features/facets/range-facets/generic/range-facet-actions.ts
var import_bueno35 = require("@coveo/bueno");
var import_toolkit24 = require("@reduxjs/toolkit");
var updateRangeFacetSortCriterion = (0, import_toolkit24.createAction)(
  "rangeFacet/updateSortCriterion",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new import_bueno35.Value({ required: true })
  })
);

// src/features/facets/range-facets/generic/range-facet-validate-payload.ts
var import_bueno36 = require("@coveo/bueno");
var numericFacetValueDefinition = {
  state: requiredNonEmptyString,
  start: new import_bueno36.NumberValue({ required: true }),
  end: new import_bueno36.NumberValue({ required: true }),
  endInclusive: new import_bueno36.BooleanValue({ required: true }),
  numberOfResults: new import_bueno36.NumberValue({ required: true, min: 0 })
};
var dateFacetValueDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new import_bueno36.BooleanValue({ required: true }),
  state: requiredNonEmptyString,
  numberOfResults: new import_bueno36.NumberValue({ required: true, min: 0 })
};
var rangeFacetSelectionPayloadDefinition = (selection) => ({
  facetId: facetIdDefinition,
  selection: typeof selection.start === "string" ? new import_bueno36.RecordValue({ values: dateFacetValueDefinition }) : new import_bueno36.RecordValue({ values: numericFacetValueDefinition })
});

// src/features/facets/range-facets/date-facet-set/date-facet-actions.ts
var dateRangeRequestDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new import_bueno37.BooleanValue({ required: true }),
  state: requiredNonEmptyString
};
var dateFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new import_bueno37.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno37.ArrayValue({ each: new import_bueno37.StringValue() }),
      excluded: new import_bueno37.ArrayValue({ each: new import_bueno37.StringValue() })
    }
  }),
  activeTab: new import_bueno37.StringValue({ required: false }),
  currentValues: new import_bueno37.ArrayValue({
    required: false,
    each: new import_bueno37.RecordValue({ values: dateRangeRequestDefinition })
  }),
  generateAutomaticRanges: new import_bueno37.BooleanValue({ required: true }),
  filterFacetCount: new import_bueno37.BooleanValue({ required: false }),
  injectionDepth: new import_bueno37.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno37.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno37.Value({ required: false }),
  rangeAlgorithm: new import_bueno37.Value({ required: false })
};
function getAbsoluteDate(date) {
  return isRelativeDateFormat(date) ? formatRelativeDateForSearchApi(date) : date;
}
function validateManualDateRanges(options) {
  if (!options.currentValues) {
    return;
  }
  options.currentValues.forEach((value) => {
    const { start, end } = buildDateRange(value);
    if (parseDate(getAbsoluteDate(start)).isAfter(parseDate(getAbsoluteDate(end)))) {
      throw new Error(
        `The start value is greater than the end value for the date range ${value.start} to ${value.end}`
      );
    }
  });
}
var registerDateFacet = (0, import_toolkit25.createAction)(
  "dateFacet/register",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, dateFacetRegistrationOptionsDefinition);
      validateManualDateRanges(payload);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var toggleSelectDateFacetValue = (0, import_toolkit25.createAction)(
  "dateFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno37.RecordValue({ values: dateFacetValueDefinition })
  })
);
var toggleExcludeDateFacetValue = (0, import_toolkit25.createAction)(
  "dateFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno37.RecordValue({ values: dateFacetValueDefinition })
  })
);
var updateDateFacetValues = (0, import_toolkit25.createAction)(
  "dateFacet/updateFacetValues",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, {
        facetId: facetIdDefinition,
        values: new import_bueno37.ArrayValue({
          each: new import_bueno37.RecordValue({ values: dateFacetValueDefinition })
        })
      });
      validateManualDateRanges({ currentValues: payload.values });
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var updateDateFacetSortCriterion = updateRangeFacetSortCriterion;
var deselectAllDateFacetValues = deselectAllFacetValues;

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-actions.ts
var import_bueno38 = require("@coveo/bueno");
var import_toolkit26 = require("@reduxjs/toolkit");
var numericFacetRequestDefinition = {
  state: requiredNonEmptyString,
  start: new import_bueno38.NumberValue({ required: true }),
  end: new import_bueno38.NumberValue({ required: true }),
  endInclusive: new import_bueno38.BooleanValue({ required: true })
};
var numericFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new import_bueno38.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno38.ArrayValue({ each: new import_bueno38.StringValue() }),
      excluded: new import_bueno38.ArrayValue({ each: new import_bueno38.StringValue() })
    }
  }),
  activeTab: new import_bueno38.StringValue({ required: false }),
  currentValues: new import_bueno38.ArrayValue({
    required: false,
    each: new import_bueno38.RecordValue({ values: numericFacetRequestDefinition })
  }),
  generateAutomaticRanges: new import_bueno38.BooleanValue({ required: true }),
  filterFacetCount: new import_bueno38.BooleanValue({ required: false }),
  injectionDepth: new import_bueno38.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno38.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno38.Value({ required: false }),
  rangeAlgorithm: new import_bueno38.Value({ required: false })
};
function validateManualNumericRanges(options) {
  if (!options.currentValues) {
    return;
  }
  options.currentValues.forEach(({ start, end }) => {
    if (start > end) {
      throw new Error(
        `The start value is greater than the end value for the numeric range ${start} to ${end}`
      );
    }
  });
}
var registerNumericFacet = (0, import_toolkit26.createAction)(
  "numericFacet/register",
  (payload) => {
    try {
      validatePayload(payload, numericFacetRegistrationOptionsDefinition);
      validateManualNumericRanges(payload);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var toggleSelectNumericFacetValue = (0, import_toolkit26.createAction)(
  "numericFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno38.RecordValue({ values: numericFacetValueDefinition })
  })
);
var toggleExcludeNumericFacetValue = (0, import_toolkit26.createAction)(
  "numericFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno38.RecordValue({ values: numericFacetValueDefinition })
  })
);
var updateNumericFacetValues = (0, import_toolkit26.createAction)(
  "numericFacet/updateFacetValues",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, {
        facetId: facetIdDefinition,
        values: new import_bueno38.ArrayValue({
          each: new import_bueno38.RecordValue({ values: numericFacetValueDefinition })
        })
      });
      validateManualNumericRanges({ currentValues: payload.values });
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var updateNumericFacetSortCriterion = updateRangeFacetSortCriterion;
var deselectAllNumericFacetValues = deselectAllFacetValues;

// src/features/facet-options/facet-options-actions.ts
var import_bueno39 = require("@coveo/bueno");
var import_toolkit27 = require("@reduxjs/toolkit");
var updateFacetOptions = (0, import_toolkit27.createAction)(
  "facetOptions/update",
  (payload = { freezeFacetOrder: true }) => validatePayload(payload, {
    freezeFacetOrder: new import_bueno39.BooleanValue({ required: false })
  })
);
var enableFacet = (0, import_toolkit27.createAction)(
  "facetOptions/facet/enable",
  (payload) => validatePayload(payload, facetIdDefinition)
);
var disableFacet = (0, import_toolkit27.createAction)(
  "facetOptions/facet/disable",
  (payload) => validatePayload(payload, facetIdDefinition)
);

// src/features/facet-options/facet-options-slice.ts
var facetOptionsReducer = (0, import_toolkit28.createReducer)(
  getFacetOptionsInitialState(),
  (builder) => {
    builder.addCase(updateFacetOptions, (state, action) => {
      return { ...state, ...action.payload };
    }).addCase(executeSearch2.fulfilled, (state) => {
      state.freezeFacetOrder = false;
    }).addCase(executeSearch2.rejected, (state) => {
      state.freezeFacetOrder = false;
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.facetOptions ?? state
    ).addCase(registerCategoryFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(registerFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(registerDateFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(registerNumericFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(enableFacet, (state, action) => {
      state.facets[action.payload].enabled = true;
    }).addCase(disableFacet, (state, action) => {
      state.facets[action.payload].enabled = false;
    }).addCase(restoreSearchParameters, (state, action) => {
      [
        ...Object.keys(action.payload.f ?? {}),
        ...Object.keys(action.payload.fExcluded ?? {}),
        ...Object.keys(action.payload.cf ?? {}),
        ...Object.keys(action.payload.nf ?? {}),
        ...Object.keys(action.payload.df ?? {})
      ].forEach((facetId2) => {
        if (!(facetId2 in state)) {
          state.facets[facetId2] = getFacetOptionsSliceInitialState();
        }
        state.facets[facetId2].enabled = true;
      });
    });
  }
);
function handleRegisterFacetTabs(tabs, state, facetId2) {
  const newFacetState = {
    ...getFacetOptionsSliceInitialState(),
    tabs: tabs ?? {}
  };
  state.facets[facetId2] = newFacetState;
}

// src/features/facets/range-facets/date-facet-set/date-facet-controller-actions.ts
var import_bueno40 = require("@coveo/bueno");
var import_toolkit30 = require("@reduxjs/toolkit");

// src/features/facets/range-facets/generic/range-facet-controller-actions.ts
var import_toolkit29 = require("@reduxjs/toolkit");
var executeToggleRangeFacetSelect = (0, import_toolkit29.createAction)(
  "rangeFacet/executeToggleSelect",
  (payload) => validatePayload(
    payload,
    rangeFacetSelectionPayloadDefinition(payload.selection)
  )
);
var executeToggleRangeFacetExclude = (0, import_toolkit29.createAction)(
  "rangeFacet/executeToggleExclude",
  (payload) => validatePayload(
    payload,
    rangeFacetSelectionPayloadDefinition(payload.selection)
  )
);

// src/features/facets/range-facets/date-facet-set/date-facet-controller-actions.ts
var definition = {
  facetId: facetIdDefinition,
  selection: new import_bueno40.RecordValue({ values: dateFacetValueDefinition })
};
var executeToggleDateFacetSelect = (0, import_toolkit30.createAsyncThunk)(
  "dateFacet/executeToggleSelect",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition);
    dispatch(toggleSelectDateFacetValue(payload));
    dispatch(executeToggleRangeFacetSelect(payload));
    dispatch(updateFacetOptions());
  }
);
var executeToggleDateFacetExclude = (0, import_toolkit30.createAsyncThunk)(
  "dateFacet/executeToggleExclude",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition);
    dispatch(toggleExcludeDateFacetValue(payload));
    dispatch(executeToggleRangeFacetExclude(payload));
    dispatch(updateFacetOptions());
  }
);

// src/features/facets/range-facets/date-facet-set/date-facet-set-slice.ts
var import_toolkit31 = require("@reduxjs/toolkit");

// src/features/facets/generic/facet-reducer-helpers.ts
function handleFacetSortCriterionUpdate(state, payload) {
  const { facetId: facetId2, criterion } = payload;
  const facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.sortCriteria = criterion;
}
function handleFacetDeselectAll(facetRequest) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetRequest.currentValues.map((value) => ({
    ...value,
    ...{ previousState: value.state !== "idle" ? value.state : void 0 },
    state: "idle"
  }));
  facetRequest.preventAutoSelect = true;
}
function handleFacetUpdateNumberOfValues(facetRequest, numberOfValues2) {
  if (!facetRequest) {
    return;
  }
  facetRequest.numberOfValues = numberOfValues2;
}

// src/features/facets/range-facets/generic/range-facet-reducers.ts
var defaultRangeFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "ascending",
  rangeAlgorithm: "even",
  resultsMustMatch: "atLeastOneValue"
};
function registerRangeFacet(state, slice) {
  const { request } = slice;
  const { facetId: facetId2 } = request;
  if (facetId2 in state) {
    return;
  }
  const numberOfValues2 = calculateNumberOfValues(request);
  request.numberOfValues = numberOfValues2;
  state[facetId2] = slice;
}
function updateRangeValues(state, facetId2, values) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  request.currentValues = values;
  request.numberOfValues = calculateNumberOfValues(request);
}
function toggleSelectRangeValue(state, facetId2, selection) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isSelected = value.state === "selected";
  value.previousState = value.state;
  value.state = isSelected ? "idle" : "selected";
  request.preventAutoSelect = true;
}
function toggleExcludeRangeValue(state, facetId2, selection) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isExcluded = value.state === "excluded";
  value.previousState = value.state;
  value.state = isExcluded ? "idle" : "excluded";
  request.preventAutoSelect = true;
}
function handleRangeFacetDeselectAll(state, facetId2) {
  const facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues.forEach((request) => {
    if (request.state !== "idle") {
      request.previousState = request.state;
    }
    request.state = "idle";
  });
}
function handleRangeFacetSearchParameterRestoration(state, rangeFacets) {
  Object.entries(state).forEach(([facetId2, { request }]) => {
    const rangesToSelect = rangeFacets[facetId2] || [];
    request.currentValues.forEach((range) => {
      const found = !!findRange(rangesToSelect, range);
      if (found) {
        range.state = "selected";
      }
      return range;
    });
    const missingRanges = rangesToSelect.filter(
      (range) => !findRange(request.currentValues, range)
    );
    const currentValues = request.currentValues;
    currentValues.push(...missingRanges);
    request.numberOfValues = Math.max(
      request.numberOfValues,
      currentValues.length
    );
  });
}
function onRangeFacetRequestFulfilled(state, facets, convert) {
  facets.forEach((facetResponse) => {
    const id2 = facetResponse.facetId;
    const facetRequest = state[id2]?.request;
    if (!facetRequest) {
      return;
    }
    const values = convert(facetResponse.values);
    facetRequest.currentValues = values;
    facetRequest.preventAutoSelect = false;
  });
}
function findRange(values, value) {
  const { start, end } = value;
  return values.find((range) => range.start === start && range.end === end);
}
function findExactRangeValue(values, value) {
  const { start, end, endInclusive } = value;
  return values.find(
    (range) => range.start === start && range.end === end && range.endInclusive === endInclusive
  );
}
function calculateNumberOfValues(request) {
  const { generateAutomaticRanges: generateAutomaticRanges2, currentValues, numberOfValues: numberOfValues2 } = request;
  return generateAutomaticRanges2 ? Math.max(numberOfValues2, currentValues.length) : currentValues.length;
}

// src/features/facets/range-facets/date-facet-set/date-facet-set-slice.ts
var dateFacetSetReducer = (0, import_toolkit31.createReducer)(
  getDateFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerDateFacet, (state, action) => {
      const { payload } = action;
      const request = buildDateFacetRequest(payload);
      registerRangeFacet(state, getDateFacetSetSliceInitialState(request));
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.dateFacetSet ?? state
    ).addCase(restoreSearchParameters, (state, action) => {
      const df = action.payload.df || {};
      handleRangeFacetSearchParameterRestoration(state, df);
    }).addCase(toggleSelectDateFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleSelectRangeValue(state, facetId2, selection);
    }).addCase(toggleExcludeDateFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleExcludeRangeValue(state, facetId2, selection);
    }).addCase(updateDateFacetValues, (state, action) => {
      const { facetId: facetId2, values } = action.payload;
      updateRangeValues(state, facetId2, values);
    }).addCase(deselectAllDateFacetValues, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.keys(state).forEach((facetId2) => {
        handleRangeFacetDeselectAll(state, facetId2);
      });
    }).addCase(updateDateFacetSortCriterion, (state, action) => {
      handleFacetSortCriterionUpdate(state, action.payload);
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      onRangeFacetRequestFulfilled(state, facets, convertToDateRangeRequests);
    }).addCase(disableFacet, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    });
  }
);
function buildDateFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "dateRange",
    ...config
  };
}
function convertToDateRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}

// src/features/search/search-slice.ts
var import_toolkit33 = require("@reduxjs/toolkit");

// src/features/error/error-actions.ts
var import_toolkit32 = require("@reduxjs/toolkit");
var setError = (0, import_toolkit32.createAction)("app/setError");

// src/features/search/search-slice.ts
function handleRejectedSearch(state, action) {
  const error = action.payload ?? null;
  if (error) {
    state.response = getSearchInitialState().response;
    state.results = [];
    state.questionAnswer = emptyQuestionAnswer();
  }
  state.error = error;
  state.isLoading = false;
}
function handleFulfilledSearch(state, action) {
  state.error = null;
  state.response = action.payload.response;
  state.queryExecuted = action.payload.queryExecuted;
  state.duration = action.payload.duration;
  state.isLoading = false;
}
function handleFulfilledNewSearch(state, action) {
  handleFulfilledSearch(state, action);
  state.results = action.payload.response.results.map((result) => ({
    ...result,
    searchUid: action.payload.response.searchUid
  }));
  state.searchResponseId = action.payload.response.searchUid;
  state.questionAnswer = action.payload.response.questionAnswer;
  state.extendedResults = action.payload.response.extendedResults;
}
function handlePendingSearch(state, action) {
  state.isLoading = true;
  state.searchAction = action.meta.arg.next;
  state.requestId = action.meta.requestId;
}
function handlePendingFetchMoreResults(state, action) {
  state.isLoading = true;
  state.searchAction = { actionCause: "browseResults" /* browseResults */ };
  state.requestId = action.meta.requestId;
}
var searchReducer = (0, import_toolkit33.createReducer)(
  getSearchInitialState(),
  (builder) => {
    builder.addCase(
      executeSearch2.rejected,
      (state, action) => handleRejectedSearch(state, action)
    );
    builder.addCase(
      fetchMoreResults2.rejected,
      (state, action) => handleRejectedSearch(state, action)
    );
    builder.addCase(
      fetchPage2.rejected,
      (state, action) => handleRejectedSearch(state, action)
    );
    builder.addCase(executeSearch2.fulfilled, (state, action) => {
      handleFulfilledNewSearch(state, action);
    });
    builder.addCase(fetchMoreResults2.fulfilled, (state, action) => {
      handleFulfilledSearch(state, action);
      state.results = [
        ...state.results,
        ...action.payload.response.results.map((result) => ({
          ...result,
          searchUid: action.payload.response.searchUid
        }))
      ];
    });
    builder.addCase(fetchPage2.fulfilled, (state, action) => {
      handleFulfilledSearch(state, action);
      state.results = [
        ...action.payload.response.results.map((result) => ({
          ...result,
          searchUid: action.payload.response.searchUid
        }))
      ];
    });
    builder.addCase(fetchFacetValues2.fulfilled, (state, action) => {
      state.response.facets = action.payload.response.facets;
      state.response.searchUid = action.payload.response.searchUid;
    });
    builder.addCase(executeSearch2.pending, handlePendingSearch);
    builder.addCase(fetchMoreResults2.pending, handlePendingFetchMoreResults);
    builder.addCase(fetchPage2.pending, handlePendingSearch);
    builder.addCase(updateSearchAction, (state, action) => {
      state.searchAction = action.payload;
    });
    builder.addCase(setError, (state, action) => {
      state.error = action.payload;
      state.isLoading = false;
    });
  }
);

// src/features/tab-set/tab-set-selectors.ts
var import_toolkit34 = require("@reduxjs/toolkit");
var selectActiveTab = (0, import_toolkit34.createSelector)(
  (state) => state,
  (tabSetState) => {
    if (!tabSetState) {
      return "";
    }
    for (const tabId in tabSetState) {
      if (tabSetState[tabId].isActive) {
        return tabSetState[tabId].id;
      }
    }
    return "";
  }
);
var selectActiveTabExpression = (0, import_toolkit34.createSelector)(
  (state) => state,
  (tabSetState) => {
    const activeTabId = selectActiveTab(tabSetState);
    return activeTabId && tabSetState ? tabSetState[activeTabId].expression : "";
  }
);

// src/features/facet-options/facet-options-selectors.ts
var selectFacetOptions = (state) => {
  const { freezeFacetOrder } = state.facetOptions ?? {};
  return freezeFacetOrder !== void 0 ? { freezeFacetOrder } : void 0;
};

// src/controllers/controller/headless-controller.ts
function buildController(engine) {
  let prevState;
  const listeners = /* @__PURE__ */ new Map();
  const hasNoListeners = () => listeners.size === 0;
  const hasStateChanged = (currentState) => {
    try {
      const stringifiedState = JSON.stringify(currentState);
      const hasChanged = prevState !== stringifiedState;
      prevState = stringifiedState;
      return hasChanged;
    } catch (e) {
      console.warn(
        'Could not detect if state has changed, check the controller "get state method"',
        e
      );
      return true;
    }
  };
  return {
    subscribe(listener) {
      listener();
      const symbol = Symbol();
      let unsubscribe;
      if (hasNoListeners()) {
        prevState = JSON.stringify(this.state);
        unsubscribe = engine.subscribe(() => {
          if (hasStateChanged(this.state)) {
            listeners.forEach((listener2) => listener2());
          }
        });
      }
      listeners.set(symbol, listener);
      return () => {
        listeners.delete(symbol);
        if (hasNoListeners()) {
          unsubscribe?.();
        }
      };
    },
    get state() {
      return {};
    }
  };
}

// src/controllers/core/facets/range-facet/date-facet/headless-date-facet-options.ts
var import_bueno41 = require("@coveo/bueno");

// src/features/facets/facet-api/value.ts
var facetValueStates = [
  "idle",
  "selected",
  "excluded"
];

// src/features/facets/range-facets/generic/interfaces/request.ts
var rangeFacetSortCriteria = [
  "ascending",
  "descending"
];
var rangeFacetRangeAlgorithm = [
  "even",
  "equiprobable"
];

// src/controllers/core/facets/range-facet/date-facet/headless-date-facet-options.ts
var dateRangeRequestDefinition2 = {
  start: new import_bueno41.StringValue(),
  end: new import_bueno41.StringValue(),
  endInclusive: new import_bueno41.BooleanValue(),
  state: new import_bueno41.StringValue({ constrainTo: facetValueStates })
};
var dateFacetOptionsSchema = new import_bueno41.Schema({
  facetId,
  field,
  tabs: new import_bueno41.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno41.ArrayValue({ each: new import_bueno41.StringValue() }),
      excluded: new import_bueno41.ArrayValue({ each: new import_bueno41.StringValue() })
    }
  }),
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new import_bueno41.ArrayValue({
    each: new import_bueno41.RecordValue({ values: dateRangeRequestDefinition2 })
  }),
  sortCriteria: new import_bueno41.StringValue({ constrainTo: rangeFacetSortCriteria }),
  rangeAlgorithm: new import_bueno41.StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-set-slice.ts
var import_toolkit35 = require("@reduxjs/toolkit");
var numericFacetSetReducer = (0, import_toolkit35.createReducer)(
  getNumericFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerNumericFacet, (state, action) => {
      const { payload } = action;
      const request = buildNumericFacetRequest(payload);
      registerRangeFacet(state, getNumericFacetSetSliceInitialState(request));
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.numericFacetSet ?? state
    ).addCase(restoreSearchParameters, (state, action) => {
      const nf = action.payload.nf || {};
      handleRangeFacetSearchParameterRestoration(state, nf);
    }).addCase(toggleSelectNumericFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleSelectRangeValue(state, facetId2, selection);
    }).addCase(toggleExcludeNumericFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleExcludeRangeValue(state, facetId2, selection);
    }).addCase(updateNumericFacetValues, (state, action) => {
      const { facetId: facetId2, values } = action.payload;
      updateRangeValues(state, facetId2, values);
    }).addCase(deselectAllNumericFacetValues, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.keys(state).forEach((facetId2) => {
        handleRangeFacetDeselectAll(state, facetId2);
      });
    }).addCase(updateNumericFacetSortCriterion, (state, action) => {
      handleFacetSortCriterionUpdate(state, action.payload);
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      onRangeFacetRequestFulfilled(
        state,
        facets,
        convertToNumericRangeRequests
      );
    }).addCase(disableFacet, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    });
  }
);
function buildNumericFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "numericalRange",
    ...config
  };
}
function convertToNumericRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-controller-actions.ts
var import_bueno42 = require("@coveo/bueno");
var import_toolkit36 = require("@reduxjs/toolkit");
var definition2 = {
  facetId: facetIdDefinition,
  selection: new import_bueno42.RecordValue({ values: numericFacetValueDefinition })
};
var executeToggleNumericFacetSelect = (0, import_toolkit36.createAsyncThunk)(
  "numericFacet/executeToggleSelect",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition2);
    dispatch(toggleSelectNumericFacetValue(payload));
    dispatch(executeToggleRangeFacetSelect(payload));
    dispatch(updateFacetOptions());
  }
);
var executeToggleNumericFacetExclude = (0, import_toolkit36.createAsyncThunk)(
  "numericFacet/executeToggleExclude",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition2);
    dispatch(toggleExcludeNumericFacetValue(payload));
    dispatch(executeToggleRangeFacetExclude(payload));
    dispatch(updateFacetOptions());
  }
);

// src/controllers/core/facets/range-facet/numeric-facet/headless-numeric-facet-options.ts
var import_bueno43 = require("@coveo/bueno");

// src/features/facets/facet-api/request.ts
var facetResultsMustMatch = [
  "allValues",
  "atLeastOneValue"
];

// src/controllers/core/facets/range-facet/numeric-facet/headless-numeric-facet-options.ts
var numericRangeRequestDefinition = {
  start: new import_bueno43.NumberValue(),
  end: new import_bueno43.NumberValue(),
  endInclusive: new import_bueno43.BooleanValue(),
  state: new import_bueno43.StringValue({ constrainTo: facetValueStates })
};
var numericFacetOptionsSchema = new import_bueno43.Schema({
  facetId,
  tabs: new import_bueno43.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno43.ArrayValue({ each: new import_bueno43.StringValue() }),
      excluded: new import_bueno43.ArrayValue({ each: new import_bueno43.StringValue() })
    }
  }),
  field,
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new import_bueno43.ArrayValue({
    each: new import_bueno43.RecordValue({ values: numericRangeRequestDefinition })
  }),
  sortCriteria: new import_bueno43.StringValue({ constrainTo: rangeFacetSortCriteria }),
  resultsMustMatch: new import_bueno43.StringValue({ constrainTo: facetResultsMustMatch }),
  rangeAlgorithm: new import_bueno43.StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});

// src/controllers/core/facets/range-facet/numeric-facet/numeric-range.ts
function buildNumericRange(config) {
  return {
    endInclusive: false,
    state: "idle",
    ...config
  };
}

// src/features/search-parameters/search-parameter-serializer.ts
var rangeDelimiterExclusive = "..";
var rangeDelimiterInclusive = "...";
var facetSearchParamRegex = /^(f|fExcluded|cf|nf|df|sf|af|mnf)-(.+)$/;
var supportedFacetParameters = {
  f: true,
  fExcluded: true,
  cf: true,
  sf: true,
  af: true,
  nf: true,
  df: true,
  mnf: true
};
var delimiter = "&";
var equal = "=";
function keyHasObjectValue(key) {
  return key in supportedFacetParameters;
}
function isRangeFacetKey(key) {
  const supportedRangeFacetParameters = {
    nf: true,
    df: true,
    mnf: true
  };
  const isRangeFacet = key in supportedRangeFacetParameters;
  return keyHasObjectValue(key) && isRangeFacet;
}
var serialize = (pairSerializer) => (obj) => {
  return Object.entries(obj).map(pairSerializer).filter((str) => str).join(delimiter);
};
function serializeSpecialCharacters(key, val) {
  return `${key}${equal}${encodeURIComponent(
    val
  )}`;
}
function isFacetObject(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isValidValue = (v) => typeof v === "string";
  return allEntriesAreValid(obj, isValidValue);
}
function isRangeFacetObject(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isRangeValue = (v) => isObject2(v) && "start" in v && "end" in v;
  return allEntriesAreValid(obj, isRangeValue);
}
function isObject2(obj) {
  return !!(obj && typeof obj === "object");
}
function allEntriesAreValid(obj, isValidValue) {
  const invalidEntries = Object.entries(obj).filter((entry) => {
    const values = entry[1];
    return !Array.isArray(values) || !values.every(isValidValue);
  });
  return invalidEntries.length === 0;
}
function serializeFacets(key, facets) {
  return Object.entries(facets).map(
    ([facetId2, values]) => `${key}-${facetId2}${equal}${values.map((value) => encodeURIComponent(value)).join(",")}`
  ).join(delimiter);
}
function serializeRangeFacets(key, facets) {
  return Object.entries(facets).map(([facetId2, ranges]) => {
    const value = ranges.map(
      ({ start, end, endInclusive }) => `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`
    ).join(",");
    return `${key}-${facetId2}${equal}${value}`;
  }).join(delimiter);
}
function splitOnFirstEqual(str) {
  const [first, ...rest] = str.split(equal);
  const second = rest.join(equal);
  return [first, second];
}
function preprocessObjectPairs(pair, regex = facetSearchParamRegex) {
  const [key, val] = pair;
  const result = regex.exec(key);
  if (!result) {
    return pair;
  }
  const paramKey = result[1];
  const id2 = result[2];
  const values = val.split(",");
  const processedValues = processObjectValues(paramKey, values);
  const obj = { [id2]: processedValues };
  return [paramKey, JSON.stringify(obj)];
}
function processObjectValues(key, values) {
  if (key === "nf" || key === "mnf") {
    return buildNumericRanges(values, "selected");
  }
  if (key === "df") {
    return buildDateRanges(values, "selected");
  }
  return values;
}
function buildNumericRanges(ranges, state) {
  const numericRanges = [];
  for (const range of ranges) {
    const { startAsString, endAsString, isEndInclusive } = splitRangeValueAsStringByDelimiter(range);
    const start = parseFloat(startAsString);
    const end = parseFloat(endAsString);
    if (!Number.isFinite(start) || !Number.isFinite(end)) {
      continue;
    }
    numericRanges.push(
      buildNumericRange({ start, end, state, endInclusive: isEndInclusive })
    );
  }
  return numericRanges;
}
function isValidDateRangeValue(date) {
  try {
    if (isSearchApiDate(date)) {
      validateAbsoluteDate(date, API_DATE_FORMAT);
      return true;
    }
    if (isRelativeDateFormat(date)) {
      validateRelativeDate(date);
      return true;
    }
    return false;
  } catch (_) {
    return false;
  }
}
function buildDateRanges(ranges, state) {
  const dateRanges = [];
  for (const range of ranges) {
    const { isEndInclusive, startAsString, endAsString } = splitRangeValueAsStringByDelimiter(range);
    if (!isValidDateRangeValue(startAsString) || !isValidDateRangeValue(endAsString)) {
      continue;
    }
    dateRanges.push(
      buildDateRange({
        start: startAsString,
        end: endAsString,
        state,
        endInclusive: isEndInclusive
      })
    );
  }
  return dateRanges;
}
function castUnknownObject(value) {
  const jsonParsed = JSON.parse(value);
  const ret = {};
  Object.entries(jsonParsed).forEach((entry) => {
    const [id2, values] = entry;
    ret[id2] = values.map((v) => (0, import_bueno44.isString)(v) ? decodeURIComponent(v) : v);
  });
  return ret;
}
function splitRangeValueAsStringByDelimiter(str) {
  const isEndInclusive = str.indexOf(rangeDelimiterInclusive) !== -1;
  const [startAsString, endAsString] = str.split(
    isEndInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive
  );
  return {
    isEndInclusive,
    startAsString,
    endAsString
  };
}

// src/features/commerce/parameters/parameters-serializer.ts
var sortFieldAndDirectionSeparator = " ";
var sortFieldsJoiner = ",";
var commerceFacetsRegex = /^(f|fExcluded|cf|nf|nfExcluded|df|dfExcluded|mnf|mnfExcluded|lf)-(.+)$/;
var searchSerializer = {
  serialize: serialize2,
  deserialize
};
var productListingSerializer = {
  serialize: serialize2,
  deserialize
};
var supportedFacetParameters2 = {
  f: true,
  fExcluded: true,
  lf: true,
  cf: true,
  nf: true,
  nfExcluded: true,
  df: true,
  dfExcluded: true,
  mnf: true,
  mnfExcluded: true
};
function serialize2(parameters) {
  return sanitizeNumericFacetParams(serialize(serializePair)(parameters));
}
function serializePair(pair) {
  const [key, val] = pair;
  if (!isValidKey(key)) {
    return "";
  }
  if (key === "sortCriteria") {
    return isSortCriteriaObject(val) ? serializeSortCriteria(key, val) : "";
  }
  if (keyHasObjectValue2(key) && !isRangeFacetKey(key)) {
    return isFacetObject(val) ? serializeFacets(key, val) : "";
  }
  if (key === "nf" || key === "df" || key === "mnf") {
    return isRangeFacetObject(val) ? serializeRangeFacets(key, val) : "";
  }
  if (val !== void 0) {
    return serializeSpecialCharacters(key, val);
  }
  return "";
}
function serializeSortCriteria(key, val) {
  return serializeSpecialCharacters(key, buildCriterionExpression2(val));
}
function buildCriterionExpression2(criterion) {
  if (!criterion) {
    return "";
  }
  if (criterion.by === "relevance" /* Relevance */) {
    return "relevance";
  }
  return criterion.fields.map(
    (field2) => `${field2.name}${sortFieldAndDirectionSeparator}${field2.direction}`
  ).join(sortFieldsJoiner);
}
function isValidKey(key) {
  return isValidBasicKey(key) || keyHasObjectValue2(key);
}
function isSortCriteriaObject(obj) {
  if (!isObject2(obj) || !("by" in obj)) {
    return false;
  }
  if (obj.by === "relevance") {
    return true;
  }
  if (obj.by === "fields" && "fields" in obj && isArray(obj.fields)) {
    return obj.fields.every((field2) => {
      return isObject2(field2) && "name" in field2 && typeof field2.name === "string" && ("direction" in field2 && (field2.direction === "asc" /* Ascending */ || field2.direction === "desc" /* Descending */) || !("direction" in field2));
    });
  }
  return false;
}
function isValidBasicKey(key) {
  const supportedBasicParameters = {
    q: true,
    sortCriteria: true,
    page: true,
    perPage: true
  };
  return key in supportedBasicParameters;
}
function deserialize(fragment) {
  const parts = fragment.split(delimiter);
  const keyValuePairs = parts.map(splitOnFirstEqual).map((parts2) => preprocessObjectPairs(parts2, commerceFacetsRegex)).filter(isValidPair).map(cast);
  return keyValuePairs.reduce((acc, pair) => {
    const [key, val] = pair;
    if (keyHasObjectValue2(key)) {
      const mergedValues = { ...acc[key], ...val };
      return { ...acc, [key]: mergedValues };
    }
    if (key === "sortCriteria") {
      const sortCriteria = deserializeSortCriteria(val);
      return { ...acc, [key]: sortCriteria };
    }
    return { ...acc, [key]: val };
  }, {});
}
function keyHasObjectValue2(key) {
  return key in supportedFacetParameters2;
}
function isValidPair(pair) {
  const validKey = isValidKey(pair[0]);
  const lengthOfTwo = pair.length === 2;
  return validKey && lengthOfTwo;
}
function cast(pair) {
  const [key, value] = pair;
  if (key === "page" || key === "perPage") {
    return [key, parseInt(value)];
  }
  if (keyHasObjectValue2(key)) {
    return [key, castUnknownObject(value)];
  }
  return [key, decodeURIComponent(value)];
}
function deserializeSortCriteria(value) {
  if (value === "relevance") {
    return buildRelevanceSortCriterion();
  }
  const criteria = value.split(sortFieldsJoiner);
  if (!criteria.length) {
    return void 0;
  }
  return criteria.reduce((acc, joinedFieldAndDirection) => {
    const fieldAndDirection = joinedFieldAndDirection.trim().split(sortFieldAndDirectionSeparator);
    if (fieldAndDirection.length !== 2) {
      return acc;
    }
    const field2 = fieldAndDirection[0].toLowerCase();
    const direction = fieldAndDirection[1].toLowerCase();
    acc.fields.push({ name: field2, direction });
    return acc;
  }, buildFieldsSortCriterion([]));
}
var isManualNumericFacet = (param) => param.startsWith("mnf-");
var isNumericFacet = (param) => param.startsWith("nf-") || isManualNumericFacet(param);
function sanitizeNumericFacetParams(params) {
  const seenNumericFacets = /* @__PURE__ */ new Set();
  const dedupedNumericFacets = /* @__PURE__ */ new Set();
  const sanitized = [];
  for (const param of params.split(delimiter)) {
    if (!isNumericFacet(param)) {
      sanitized.push(param);
      continue;
    }
    const normalizedParam = param.replace(/^mnf-/, "nf-");
    if (!seenNumericFacets.has(normalizedParam)) {
      seenNumericFacets.add(normalizedParam);
      dedupedNumericFacets.add(param);
      continue;
    }
    if (isManualNumericFacet(param)) {
      dedupedNumericFacets.delete(normalizedParam);
      dedupedNumericFacets.add(param);
    }
  }
  sanitized.push(...dedupedNumericFacets);
  return sanitized.join(delimiter);
}

// src/features/commerce/product-listing/product-listing-actions.ts
var import_bueno46 = require("@coveo/bueno");
var import_toolkit38 = require("@reduxjs/toolkit");

// src/api/commerce/commerce-metadata.ts
var TRACKING_ID_IN_PATH_METHODS = [
  "badges"
];

// src/api/commerce/common/request.ts
var getRequestOptions = (req, path) => {
  return {
    ...baseRequest(req, path),
    requestParams: prepareRequestParams(req)
  };
};
var prepareRequestParams = (req) => {
  const {
    trackingId,
    clientId,
    context,
    language,
    country,
    currency,
    page,
    perPage,
    facets,
    sort
  } = req;
  return {
    trackingId,
    clientId,
    context,
    language,
    country,
    currency,
    page,
    perPage,
    facets,
    sort
  };
};
var baseRequest = (req, path) => {
  const { url, trackingId, accessToken } = req;
  const baseUrl = buildUrlWithTrackingIdInPath(url, trackingId, path);
  return {
    accessToken,
    method: "POST",
    contentType: "application/json",
    url: baseUrl,
    origin: "commerceApiFetch",
    requestMetadata: { method: path }
  };
};
var buildUrlWithTrackingIdInPath = (baseUrl, trackingId, path) => {
  if (trackingId && TRACKING_ID_IN_PATH_METHODS.includes(path)) {
    return `${baseUrl}/tracking-ids/${trackingId}/${path}`;
  }
  return `${baseUrl}/${path}`;
};

// src/api/commerce/product-enrichment/product-enrichment-request.ts
var buildProductEnrichmentBadgesRequest = (req) => {
  return {
    ...baseRequest(req, "badges"),
    requestParams: prepareProductEnrichmentRequestParams(req)
  };
};
var prepareProductEnrichmentRequestParams = (req) => {
  const { language, country, currency, placementIds, context, clientId } = req;
  return {
    language,
    country,
    currency,
    placementIds,
    context,
    ...clientId && { clientId }
  };
};

// src/api/commerce/recommendations/recommendations-request.ts
var buildRecommendationsRequest = (req, path) => {
  return {
    ...baseRequest(req, path),
    requestParams: prepareRecommendationsRequestParams(req)
  };
};
var prepareRecommendationsRequestParams = (req) => {
  const {
    slotId,
    trackingId,
    clientId,
    context,
    language,
    country,
    currency,
    page,
    perPage
  } = req;
  return {
    slotId,
    trackingId,
    clientId,
    context,
    language,
    country,
    currency,
    page,
    perPage
  };
};

// src/api/commerce/search/plan/plan-request.ts
var getPlanRequestOptions = (req) => {
  return {
    ...baseRequest(req, "search/redirect"),
    requestParams: prepareRequestParams2(req)
  };
};
var prepareRequestParams2 = (req) => {
  const { trackingId, query: query2, clientId, context, language, country, currency } = req;
  return {
    trackingId,
    query: query2,
    clientId,
    context,
    language,
    country,
    currency
  };
};

// src/api/commerce/search/query-suggest/query-suggest-request.ts
var getQuerySuggestRequestOptions = (req) => {
  return {
    ...baseRequest(req, "search/querySuggest"),
    requestParams: prepareRequestParams3(req)
  };
};
var prepareRequestParams3 = (req) => {
  const { trackingId, query: query2, clientId, context, language, country, currency } = req;
  return {
    trackingId,
    query: query2,
    clientId,
    context,
    language,
    country,
    currency
  };
};

// src/api/commerce/commerce-api-client.ts
var isErrorResponse2 = (r) => {
  return r.error !== void 0;
};
var CommerceAPIClient = class {
  constructor(options) {
    this.options = options;
  }
  async getProductListing(req) {
    const requestOptions = getRequestOptions(req, "listing");
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        enableResults: Boolean(req?.enableResults)
      },
      ...this.options
    });
  }
  async search(req) {
    const requestOptions = getRequestOptions(req, "search");
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req?.query,
        enableResults: Boolean(req?.enableResults)
      },
      ...this.options
    });
  }
  async getRecommendations(req) {
    return this.query({
      ...buildRecommendationsRequest(req, "recommendations"),
      ...this.options
    });
  }
  async productSuggestions(req) {
    const requestOptions = getRequestOptions(req, "search/productSuggest");
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req?.query
      },
      ...this.options
    });
  }
  async querySuggest(req) {
    const requestOptions = getQuerySuggestRequestOptions(req);
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req?.query
      },
      ...this.options
    });
  }
  async facetSearch(req, type) {
    const requestOptions = getRequestOptions(req, "facet");
    return this.query({
      ...requestOptions,
      url: `${requestOptions.url}?type=${type}`,
      requestParams: {
        ...requestOptions.requestParams,
        facetId: req?.facetId,
        facetQuery: req?.facetQuery,
        query: req?.query,
        numberOfValues: req?.numberOfValues
      },
      ...this.options
    });
  }
  async getBadges(req) {
    return this.query({
      ...buildProductEnrichmentBadgesRequest(req),
      ...this.options
    });
  }
  async plan(req) {
    const requestOptions = getPlanRequestOptions(req);
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req?.query
      },
      ...this.options
    });
  }
  async query(options) {
    const response = await PlatformClient.call(options);
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    return response.ok ? { success: body } : { error: body };
  }
};
function getCommerceApiBaseUrl(organizationId, environment = "prod") {
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  return `${platformEndpoint}/rest/organizations/${organizationId}/commerce/v2`;
}

// src/features/commerce/context/cart/cart-state.ts
var getCartInitialState = () => ({
  cartItems: [],
  cart: {},
  purchasedItems: [],
  purchased: {}
});
var getProductsFromCartState = (state) => getProductsFromCart(state.cartItems, state.cart);
var getProductsFromCartPurchasedState = (state) => getProductsFromCart(state.purchasedItems, state.purchased);
function getProductsFromCart(items, itemMap) {
  const productsMap = items.reduce(
    (acc, key) => {
      const { productId, quantity } = itemMap[key];
      if (!(productId in acc)) {
        acc[productId] = {
          productId,
          quantity: 0
        };
      }
      acc[productId].quantity += quantity;
      return acc;
    },
    {}
  );
  return [...Object.values(productsMap)];
}

// src/features/commerce/common/base-commerce-api-request-builder.ts
var buildBaseCommerceAPIRequest = (state, navigatorContext) => {
  const { view, location, custom, ...restOfContext } = state.commerceContext;
  return {
    accessToken: state.configuration.accessToken,
    url: state.configuration.commerce.apiBaseUrl ?? getCommerceApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    organizationId: state.configuration.organizationId,
    trackingId: state.configuration.analytics.trackingId,
    ...restOfContext,
    ...state.configuration.analytics.enabled ? { clientId: navigatorContext.clientId } : {},
    context: {
      user: {
        ...location,
        ...navigatorContext.userAgent ? { userAgent: navigatorContext.userAgent } : {}
      },
      view: {
        ...view,
        ...navigatorContext.referrer ? { referrer: navigatorContext.referrer } : {}
      },
      capture: navigatorContext.capture ?? (state.configuration.analytics.enabled && navigatorContext.clientId !== ""),
      cart: getProductsFromCartState(state.cart),
      source: getAnalyticsSource(state.configuration.analytics),
      ...custom ? { custom } : {}
    }
  };
};

// src/features/commerce/common/paginated-commerce-api-request-builder.ts
var buildPaginatedCommerceAPIRequest = (state, navigatorContext, slotId) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    ...effectivePagination(state, slotId)
  };
};
var effectivePagination = (state, slotId) => {
  const effectiveSlice = slotId ? state.commercePagination?.recommendations[slotId] : state.commercePagination?.principal;
  return effectiveSlice && {
    page: effectiveSlice.page,
    ...effectiveSlice.perPage && {
      perPage: effectiveSlice.perPage
    }
  };
};

// src/features/commerce/common/filterable-commerce-api-request-builder.ts
var buildFilterableCommerceAPIRequest = (state, navigatorContext) => {
  return {
    ...buildPaginatedCommerceAPIRequest(state, navigatorContext),
    facets: [...getFacets4(state)],
    ...state.commerceSort && {
      sort: getSort(state.commerceSort.appliedSort)
    }
  };
};
function getFacets4(state) {
  if (!state.facetOrder || !state.commerceFacetSet) {
    return [];
  }
  return state.facetOrder.filter((facetId2) => state.commerceFacetSet?.[facetId2]).map((facetId2) => {
    return state.manualNumericFacetSet?.[facetId2]?.manualRange ? {
      facetId: facetId2,
      field: facetId2,
      numberOfValues: 1,
      isFieldExpanded: false,
      preventAutoSelect: true,
      type: "numericalRange",
      values: [state.manualNumericFacetSet[facetId2].manualRange],
      initialNumberOfValues: 1
    } : state.commerceFacetSet[facetId2].request;
  }).filter((facet) => facet && facet.values.length > 0);
}
function getSort(appliedSort) {
  if (appliedSort.by === "relevance" /* Relevance */) {
    return {
      sortCriteria: "relevance" /* Relevance */
    };
  } else {
    return {
      sortCriteria: "fields" /* Fields */,
      fields: appliedSort.fields.map(({ name, direction }) => ({
        field: name,
        direction
      }))
    };
  }
}

// src/features/commerce/product-listing/product-listing-selectors.ts
var import_bueno45 = require("@coveo/bueno");
var import_toolkit37 = require("@reduxjs/toolkit");
var responseIdSelector = (state) => state.productListing.responseId;
var requestIdSelector = (state) => state.productListing.requestId;
var numberOfProductsSelector = (state) => state.productListing?.results.length || state.productListing?.products.length || 0;
var moreProductsAvailableSelector = (0, import_toolkit37.createSelector)(
  (state) => ({
    total: totalEntriesPrincipalSelector(state),
    current: numberOfProductsSelector(state)
  }),
  ({ current, total }) => current < total
);
var isLoadingSelector = (state) => {
  const isLoading = state.productListing?.isLoading;
  return (0, import_bueno45.isNullOrUndefined)(isLoading) ? false : isLoading;
};
var errorSelector = (state) => state.productListing?.error ?? null;

// src/features/commerce/product-listing/product-listing-actions.ts
var fetchProductListing = (0, import_toolkit38.createAsyncThunk)(
  "commerce/productListing/fetch",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
    const fetched = await apiClient.getProductListing({
      ...request,
      enableResults: Boolean(payload?.enableResults)
    });
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var fetchMoreProducts = (0, import_toolkit38.createAsyncThunk)(
  "commerce/productListing/fetchMoreProducts",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const moreProductsAvailable = moreProductsAvailableSelector(state);
    if (!moreProductsAvailable) {
      return null;
    }
    const perPage = perPagePrincipalSelector(state);
    const numberOfProducts = numberOfProductsSelector(state);
    const nextPageToRequest = numberOfProducts / perPage;
    const fetched = await apiClient.getProductListing({
      ...buildFilterableCommerceAPIRequest(state, navigatorContext),
      enableResults: Boolean(payload?.enableResults),
      page: nextPageToRequest
    });
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var promoteChildToParentDefinition = {
  child: new import_bueno46.RecordValue({
    options: { required: true },
    values: {
      permanentid: new import_bueno46.StringValue({ required: true })
    }
  })
};
var promoteChildToParent = (0, import_toolkit38.createAction)(
  "commerce/productListing/promoteChildToParent",
  (payload) => validatePayload(payload, promoteChildToParentDefinition)
);

// src/features/commerce/product-listing/product-listing-slice.ts
var import_toolkit39 = require("@reduxjs/toolkit");

// src/api/commerce/common/result.ts
var ResultType = /* @__PURE__ */ ((ResultType2) => {
  ResultType2["CHILD_PRODUCT"] = "childProduct";
  ResultType2["PRODUCT"] = "product";
  ResultType2["SPOTLIGHT"] = "spotlight";
  return ResultType2;
})(ResultType || {});

// src/features/commerce/product-listing/product-listing-state.ts
var getProductListingInitialState = () => ({
  error: null,
  isLoading: false,
  requestId: "",
  responseId: "",
  facets: [],
  products: [],
  results: []
});

// src/features/commerce/product-listing/product-listing-slice.ts
var productListingReducer = (0, import_toolkit39.createReducer)(
  getProductListingInitialState(),
  (builder) => {
    builder.addCase(fetchProductListing.rejected, (state, action) => {
      handleError(state, action.payload);
    }).addCase(fetchMoreProducts.rejected, (state, action) => {
      handleError(state, action.payload);
    }).addCase(fetchProductListing.fulfilled, (state, action) => {
      const paginationOffset = getPaginationOffset(action.payload);
      handleFulfilled(state, action.payload.response);
      state.products = mapPreprocessedProducts(
        action.payload.response.products,
        paginationOffset,
        action.payload.response.responseId
      );
      state.results = mapPreprocessedResults(
        action.payload.response.results,
        paginationOffset,
        action.payload.response.responseId
      );
    }).addCase(fetchMoreProducts.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      const paginationOffset = getPaginationOffset(action.payload);
      handleFulfilled(state, action.payload.response);
      state.products = state.products.concat(
        mapPreprocessedProducts(
          action.payload.response.products,
          paginationOffset,
          action.payload.response.responseId
        )
      );
      state.results = state.results.concat(
        mapPreprocessedResults(
          action.payload.response.results,
          paginationOffset,
          action.payload.response.responseId
        )
      );
    }).addCase(fetchProductListing.pending, (state, action) => {
      handlePending(state, action.meta.requestId);
    }).addCase(fetchMoreProducts.pending, (state, action) => {
      handlePending(state, action.meta.requestId);
    }).addCase(promoteChildToParent, (state, action) => {
      const productsOrResults = state.results.length > 0 ? state.results : state.products;
      let childToPromote;
      const currentParentIndex = productsOrResults.findIndex((result) => {
        if (result.resultType === "spotlight" /* SPOTLIGHT */) {
          return false;
        }
        childToPromote = result.children.find(
          (child) => child.permanentid === action.payload.child.permanentid
        );
        return !!childToPromote;
      });
      const currentParent = productsOrResults[currentParentIndex];
      if (currentParentIndex === -1 || childToPromote === void 0 || currentParent.resultType === "spotlight" /* SPOTLIGHT */) {
        return;
      }
      const responseId = currentParent.responseId;
      const position = currentParent.position;
      const { children, totalNumberOfChildren } = currentParent;
      const newParent = {
        ...childToPromote,
        resultType: "product" /* PRODUCT */,
        children,
        totalNumberOfChildren,
        position,
        responseId
      };
      productsOrResults.splice(currentParentIndex, 1, newParent);
    }).addCase(setView, () => getProductListingInitialState()).addCase(setContext, () => getProductListingInitialState()).addCase(setError, (state, action) => {
      handleError(state, action.payload);
    });
  }
);
function handleError(state, error) {
  state.error = error || null;
  state.isLoading = false;
}
function handleFulfilled(state, response) {
  state.error = null;
  state.facets = response.facets;
  state.responseId = response.responseId;
  state.isLoading = false;
}
function handlePending(state, requestId) {
  state.isLoading = true;
  state.requestId = requestId;
}
function getPaginationOffset(payload) {
  const pagination = payload.response.pagination;
  return pagination.page * pagination.perPage;
}
function mapPreprocessedProducts(products, paginationOffset, responseId) {
  return products.map(
    (product, index) => preprocessProduct(product, paginationOffset + index + 1, responseId)
  );
}
function mapPreprocessedResults(results, paginationOffset, responseId) {
  return results.map(
    (result, index) => preprocessResult(result, paginationOffset + index + 1, responseId)
  );
}
function preprocessResult(result, position, responseId) {
  if (result.resultType === "spotlight" /* SPOTLIGHT */) {
    return preprocessSpotlightContent(result, position, responseId);
  }
  return preprocessProduct(result, position, responseId);
}
function preprocessProduct(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some(
    (child) => child.permanentid === product.permanentid
  );
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const {
    children,
    totalNumberOfChildren: _totalNumberOfChildren,
    ...restOfProduct
  } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}
function preprocessSpotlightContent(spotlight, position, responseId) {
  return {
    ...spotlight,
    position,
    responseId
  };
}

// src/features/commerce/product-listing-parameters/product-listing-parameters-actions.ts
var import_toolkit40 = require("@reduxjs/toolkit");
var restoreProductListingParameters = (0, import_toolkit40.createAction)(
  "commerce/productListingParameters/restore",
  (payload) => validatePayload(payload, parametersDefinition)
);

// src/features/commerce/did-you-mean/did-you-mean-slice.ts
var import_toolkit47 = require("@reduxjs/toolkit");

// src/features/did-you-mean/did-you-mean-state.ts
var emptyNextCorrection = () => ({
  correctedQuery: "",
  corrections: [],
  originalQuery: ""
});

// src/features/commerce/search/search-actions.ts
var import_bueno53 = require("@coveo/bueno");
var import_toolkit46 = require("@reduxjs/toolkit");

// src/features/commerce/facets/core-facet/core-facet-actions.ts
var import_bueno47 = require("@coveo/bueno");
var import_toolkit41 = require("@reduxjs/toolkit");
var updateCoreFacetNumberOfValues = (0, import_toolkit41.createAction)(
  "commerce/facets/core/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    numberOfValues: new import_bueno47.NumberValue({ required: true, min: 1 })
  })
);
var updateCoreFacetIsFieldExpanded = (0, import_toolkit41.createAction)(
  "commerce/facets/core/updateIsFieldExpanded",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    isFieldExpanded: new import_bueno47.BooleanValue({ required: true })
  })
);
var clearAllCoreFacets = (0, import_toolkit41.createAction)("commerce/facets/core/clearAll");
var deleteAllCoreFacets = (0, import_toolkit41.createAction)(
  "commerce/facets/core/deleteAll"
);
var deselectAllValuesInCoreFacet = (0, import_toolkit41.createAction)(
  "commerce/facets/core/deselectAllValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString
  })
);
var updateCoreFacetFreezeCurrentValues = (0, import_toolkit41.createAction)(
  "commerce/facets/core/updateFreezeCurrentValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    freezeCurrentValues: new import_bueno47.BooleanValue({ required: true })
  })
);
var updateAutoSelectionForAllCoreFacets = (0, import_toolkit41.createAction)(
  "commerce/facets/core/updateAutoSelectionForAll",
  (payload) => validatePayload(payload, {
    allow: new import_bueno47.BooleanValue({ required: true })
  })
);

// src/features/commerce/pagination/pagination-actions.ts
var import_bueno48 = require("@coveo/bueno");
var import_toolkit42 = require("@reduxjs/toolkit");
var slotIdDefinition = {
  slotId: nonRequiredEmptyAllowedString
};
var setPageSizeDefinition = {
  ...slotIdDefinition,
  pageSize: new import_bueno48.NumberValue({ required: true, min: 0 })
};
var setPageSize = (0, import_toolkit42.createAction)(
  "commerce/pagination/setPageSize",
  (payload) => validatePayload(payload, setPageSizeDefinition)
);
var selectPageDefinition = {
  ...slotIdDefinition,
  page: new import_bueno48.NumberValue({ required: true, min: 0 })
};
var selectPage = (0, import_toolkit42.createAction)(
  "commerce/pagination/selectPage",
  (payload) => validatePayload(payload, selectPageDefinition)
);
var nextPage2 = (0, import_toolkit42.createAction)(
  "commerce/pagination/nextPage",
  (payload) => validatePayload(payload, slotIdDefinition)
);
var previousPage2 = (0, import_toolkit42.createAction)(
  "commerce/pagination/previousPage",
  (payload) => validatePayload(payload, slotIdDefinition)
);
var registerRecommendationsSlotPagination = (0, import_toolkit42.createAction)(
  "commerce/pagination/registerRecommendationsSlot",
  (payload) => validatePayload(payload, {
    slotId: requiredNonEmptyString
  })
);

// src/features/commerce/query/query-actions.ts
var import_bueno49 = require("@coveo/bueno");
var import_toolkit43 = require("@reduxjs/toolkit");
var updateQuery2 = (0, import_toolkit43.createAction)(
  "commerce/query/update",
  (payload) => validatePayload(payload, {
    query: new import_bueno49.StringValue()
  })
);

// src/features/commerce/search/search-actions-thunk-processor.ts
var import_bueno52 = require("@coveo/bueno");

// src/features/commerce/triggers/triggers-actions.ts
var import_bueno50 = require("@coveo/bueno");
var import_toolkit44 = require("@reduxjs/toolkit");
var updateIgnoreQueryTrigger2 = (0, import_toolkit44.createAction)(
  "commerce/triggers/query/updateIgnore",
  (payload) => validatePayload(payload, {
    q: new import_bueno50.StringValue({ emptyAllowed: true, required: true })
  })
);
var applyQueryTriggerModification2 = (0, import_toolkit44.createAction)(
  "commerce/triggers/query/applyModification",
  (payload) => validatePayload(
    payload,
    new import_bueno50.RecordValue({
      values: { originalQuery: nonEmptyString, modification: nonEmptyString }
    })
  )
);

// src/features/commerce/search/search-selectors.ts
var import_bueno51 = require("@coveo/bueno");
var import_toolkit45 = require("@reduxjs/toolkit");

// src/features/commerce/query/query-state.ts
var getCommerceQueryInitialState = () => ({
  query: ""
});

// src/features/commerce/search/search-selectors.ts
var responseIdSelector2 = (state) => state.commerceSearch.responseId;
var requestIdSelector2 = (state) => state.commerceSearch.requestId;
var numberOfProductsSelector2 = (state) => state.commerceSearch?.products.length || 0;
var moreProductsAvailableSelector2 = (0, import_toolkit45.createSelector)(
  (state) => ({
    total: totalEntriesPrincipalSelector(state),
    current: numberOfProductsSelector2(state)
  }),
  ({ current, total }) => current < total
);
var isLoadingSelector2 = (state) => {
  const isLoading = state.commerceSearch?.isLoading;
  return (0, import_bueno51.isNullOrUndefined)(isLoading) ? false : isLoading;
};
var errorSelector2 = (state) => state.commerceSearch?.error ?? null;
var querySelector = (state) => state.commerceQuery?.query ?? "";
var queryExecutedSelector = (state) => state.commerceSearch?.queryExecuted;
var queryExecutedFromResponseSelector = (state, response) => {
  if (!(0, import_bueno51.isNullOrUndefined)(response.queryCorrection?.correctedQuery)) {
    return response.queryCorrection.correctedQuery;
  }
  return querySelector(state);
};
var activeParametersSelector2 = (state) => {
  return {
    ...getQ(
      state?.commerceQuery,
      (s) => s.query,
      getCommerceQueryInitialState().query
    ),
    ...activeParametersSelector(state)
  };
};
function enrichedSummarySelector(state) {
  return {
    query: queryExecutedSelector(state) || ""
  };
}

// src/features/commerce/search/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor3 = class {
  constructor(config) {
    this.config = config;
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  async fetchFromAPI(request) {
    const startedAt = Date.now();
    const response = await this.extra.apiClient.search(request);
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().commerceQuery.query || "";
    return {
      response,
      duration,
      queryExecuted,
      requestExecuted: request,
      enableResults: Boolean(
        "enableResults" in request && request.enableResults
      )
    };
  }
  processSuccessResponse(fetched) {
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      originalQuery: this.getCurrentQuery()
    };
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse2(fetched.response)) {
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { queryCorrection } = successResponse;
    const shouldExecuteQueryCorrection = !(0, import_bueno52.isNullOrUndefined)(queryCorrection) && !(0, import_bueno52.isNullOrUndefined)(queryCorrection.correctedQuery);
    if (!shouldExecuteQueryCorrection) {
      return null;
    }
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery ?? "");
    return {
      ...fetched,
      response: {
        ...successResponse
      },
      queryExecuted: queryExecutedFromResponseSelector(state, successResponse),
      originalQuery: originalQuery ?? ""
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger2({ q: "" }));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(
      correctedQuery,
      fetched.enableResults
    );
    if (isErrorResponse2(retried.response)) {
      return this.rejectWithValue(retried.response.error);
    }
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      originalQuery
    };
  }
  async automaticallyRetryQueryWithTriggerModification(modified, enableResults) {
    this.dispatch(
      applyQueryTriggerModification2({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI({
      ...buildFilterableCommerceAPIRequest(
        this.getState(),
        this.navigatorContext
      ),
      query: modified,
      enableResults: Boolean(enableResults)
    });
    return fetched;
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
  getState() {
    return this.config.getState();
  }
  get navigatorContext() {
    return this.config.extra.navigatorContext;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.commerceQuery.query !== void 0 ? state.commerceQuery.query : "";
  }
  getSuccessResponse(fetched) {
    if (isErrorResponse2(fetched.response)) {
      return null;
    }
    return fetched.response.success;
  }
  get extra() {
    return this.config.extra;
  }
  onUpdateQueryForCorrection(modification) {
    this.dispatch(updateQuery2({ query: modification }));
  }
};

// src/features/commerce/search/search-actions.ts
var executeSearch3 = (0, import_toolkit46.createAsyncThunk)("commerce/search/executeSearch", async (payload = {}, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const query2 = querySelector(state);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    enableResults: Boolean(payload?.enableResults)
  });
  return processor.process(fetchedResponse);
});
var fetchMoreProducts2 = (0, import_toolkit46.createAsyncThunk)("commerce/search/fetchMoreProducts", async (payload = {}, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const moreProductsAvailable = moreProductsAvailableSelector2(state);
  if (!moreProductsAvailable) {
    return null;
  }
  const perPage = perPagePrincipalSelector(state);
  const numberOfProducts = numberOfProductsSelector2(state);
  const nextPageToRequest = numberOfProducts / perPage;
  const query2 = querySelector(state);
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    page: nextPageToRequest,
    enableResults: Boolean(payload?.enableResults)
  });
  return processor.process(fetchedResponse);
});
var prepareForSearchWithQuery2 = (0, import_toolkit46.createAsyncThunk)("commerce/search/prepareForSearchWithQuery", (payload, thunk) => {
  const { dispatch } = thunk;
  validatePayload(payload, {
    query: new import_bueno53.StringValue(),
    clearFilters: new import_bueno53.BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deleteAllCoreFacets());
  }
  dispatch(updateAutoSelectionForAllCoreFacets({ allow: true }));
  dispatch(
    updateQuery2({
      query: payload.query
    })
  );
  dispatch(selectPage({ page: 0 }));
});
var fetchInstantProducts = (0, import_toolkit46.createAsyncThunk)(
  "commerce/search/fetchInstantProducts",
  async (payload, { getState, rejectWithValue, extra }) => {
    const state = getState();
    const { apiClient, navigatorContext } = extra;
    const { q } = payload;
    const fetched = await apiClient.productSuggestions({
      ...buildBaseCommerceAPIRequest(state, navigatorContext),
      query: q
    });
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: { ...fetched.success, products: fetched.success.products }
    };
  }
);
var promoteChildToParentDefinition2 = {
  child: new import_bueno53.RecordValue({
    options: { required: true },
    values: {
      permanentid: new import_bueno53.StringValue({ required: true })
    }
  })
};
var promoteChildToParent2 = (0, import_toolkit46.createAction)(
  "commerce/search/promoteChildToParent",
  (payload) => validatePayload(payload, promoteChildToParentDefinition2)
);

// src/features/commerce/did-you-mean/did-you-mean-state.ts
function getDidYouMeanInitialState() {
  return {
    wasCorrectedTo: "",
    queryCorrection: emptyNextCorrection(),
    originalQuery: ""
  };
}

// src/features/commerce/did-you-mean/did-you-mean-slice.ts
var didYouMeanReducer = (0, import_toolkit47.createReducer)(
  getDidYouMeanInitialState(),
  (builder) => {
    builder.addCase(executeSearch3.pending, (state) => {
      state.queryCorrection = emptyNextCorrection();
      state.wasCorrectedTo = "";
    }).addCase(executeSearch3.fulfilled, (state, action) => {
      const { queryCorrection } = action.payload.response;
      state.originalQuery = action.payload.originalQuery;
      state.wasCorrectedTo = queryCorrection?.correctedQuery ?? "";
      state.queryCorrection = {
        correctedQuery: queryCorrection?.correctedQuery ?? queryCorrection?.corrections[0]?.correctedQuery ?? "",
        wordCorrections: queryCorrection?.corrections[0]?.wordCorrections ?? []
      };
    });
  }
);

// src/controllers/commerce/search/did-you-mean/headless-did-you-mean.ts
function buildDidYouMean(engine) {
  if (!loadDidYouMeanReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine[stateKey].didYouMean;
  return {
    ...controller,
    applyCorrection() {
      engine.dispatch(
        updateQuery2({ query: this.state.queryCorrection.correctedQuery })
      );
      engine.dispatch(executeSearch3());
    },
    get state() {
      const state = getState();
      return {
        originalQuery: state.originalQuery,
        wasCorrectedTo: state.wasCorrectedTo,
        queryCorrection: state.queryCorrection,
        hasQueryCorrection: state.queryCorrection.correctedQuery !== "",
        wasAutomaticallyCorrected: state.wasCorrectedTo !== ""
      };
    }
  };
}
function loadDidYouMeanReducers(engine) {
  engine.addReducers({
    didYouMean: didYouMeanReducer
  });
  return true;
}

// src/controllers/commerce/core/breadcrumb-manager/headless-core-breadcrumb-manager.ts
var import_toolkit61 = require("@reduxjs/toolkit");

// src/features/commerce/facets/date-facet/date-facet-actions.ts
var import_bueno54 = require("@coveo/bueno");
var import_toolkit48 = require("@reduxjs/toolkit");
var toggleSelectDateFacetValue2 = (0, import_toolkit48.createAction)(
  "commerce/facets/dateFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno54.RecordValue({ values: dateFacetValueDefinition })
  })
);
var toggleExcludeDateFacetValue2 = (0, import_toolkit48.createAction)(
  "commerce/facets/dateFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno54.RecordValue({ values: dateFacetValueDefinition })
  })
);
var updateDateFacetValues2 = (0, import_toolkit48.createAction)(
  "commerce/facets/dateFacet/updateValues",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, {
        facetId: requiredNonEmptyString,
        values: new import_bueno54.ArrayValue({
          each: new import_bueno54.RecordValue({ values: dateFacetValueDefinition })
        })
      });
      validateManualDateRanges({ currentValues: payload.values });
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);

// src/features/commerce/facets/facet-set/facet-set-slice.ts
var import_toolkit59 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/category/category-facet-search-actions.ts
var import_bueno56 = require("@coveo/bueno");
var import_toolkit49 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/generic/generic-facet-search-validate-payload.ts
var import_bueno55 = require("@coveo/bueno");
var facetSearchOptionsDefinition = {
  facetId: facetIdDefinition,
  captions: new import_bueno55.RecordValue({ options: { required: false } }),
  numberOfValues: new import_bueno55.NumberValue({ required: false, min: 1 }),
  query: new import_bueno55.StringValue({ required: false, emptyAllowed: true })
};

// src/features/facets/facet-search-set/category/category-facet-search-actions.ts
var categoryFacetSearchResultDefinition = {
  path: new import_bueno56.ArrayValue({
    required: true,
    each: requiredNonEmptyString
  }),
  displayValue: requiredEmptyAllowedString,
  rawValue: requiredEmptyAllowedString,
  count: new import_bueno56.NumberValue({ required: true, min: 0 })
};
var selectCategoryFacetSearchResult = (0, import_toolkit49.createAction)(
  "categoryFacet/selectSearchResult",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    value: new import_bueno56.RecordValue({ values: categoryFacetSearchResultDefinition })
  })
);
var registerCategoryFacetSearch = (0, import_toolkit49.createAction)(
  "categoryFacetSearch/register",
  (payload) => validatePayload(payload, facetSearchOptionsDefinition)
);

// src/features/facets/facet-search-set/specific/specific-facet-search-actions.ts
var import_bueno57 = require("@coveo/bueno");
var import_toolkit50 = require("@reduxjs/toolkit");
var selectFacetSearchResultPayloadDefinition = {
  facetId: facetIdDefinition,
  value: new import_bueno57.RecordValue({
    values: {
      displayValue: requiredEmptyAllowedString,
      rawValue: requiredEmptyAllowedString,
      count: new import_bueno57.NumberValue({ required: true, min: 0 })
    }
  })
};
var registerFacetSearch = (0, import_toolkit50.createAction)(
  "facetSearch/register",
  (payload) => validatePayload(payload, facetSearchOptionsDefinition)
);
var updateFacetSearch = (0, import_toolkit50.createAction)(
  "facetSearch/update",
  (payload) => validatePayload(payload, facetSearchOptionsDefinition)
);
var selectFacetSearchResult = (0, import_toolkit50.createAction)(
  "facetSearch/toggleSelectValue",
  (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition)
);
var excludeFacetSearchResult = (0, import_toolkit50.createAction)(
  "facetSearch/toggleExcludeValue",
  (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition)
);

// src/features/facets/facet-set/facet-set-slice.ts
var import_toolkit51 = require("@reduxjs/toolkit");
var facetSetReducer = (0, import_toolkit51.createReducer)(
  getFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerFacet, (state, action) => {
      const { facetId: facetId2 } = action.payload;
      if (facetId2 in state) {
        return;
      }
      state[facetId2] = getFacetSetSliceInitialState(
        buildFacetRequest(action.payload)
      );
    }).addCase(change.fulfilled, (_, action) => {
      if (!action.payload) {
        return;
      }
      if (Object.keys(action.payload.facetSet).length === 0) {
        return;
      }
      return action.payload.facetSet;
    }).addCase(restoreSearchParameters, (state, action) => {
      const f2 = action.payload.f || {};
      const fExcluded = action.payload.fExcluded || {};
      const facetIds = Object.keys(state);
      facetIds.forEach((id2) => {
        const { request } = state[id2];
        const selectedValues = f2[id2] || [];
        const excludedValues = fExcluded[id2] || [];
        const activeValueCount = selectedValues.length + excludedValues.length;
        const idleValues = request.currentValues.filter(
          (facetValue) => !selectedValues.includes(facetValue.value) && !excludedValues.includes(facetValue.value)
        );
        request.currentValues = [
          ...selectedValues.map(buildSelectedFacetValueRequest),
          ...excludedValues.map(buildExcludedFacetValueRequest),
          ...idleValues.map(restoreFacetValueToIdleState)
        ];
        request.preventAutoSelect = activeValueCount > 0;
        request.numberOfValues = Math.max(
          activeValueCount,
          request.numberOfValues
        );
      });
    }).addCase(toggleSelectFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.currentValues.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue(facetRequest, selection);
        return;
      }
      const isSelected = existingValue.state === "selected";
      existingValue.previousState = existingValue.state;
      existingValue.state = isSelected ? "idle" : "selected";
      facetRequest.freezeCurrentValues = true;
    }).addCase(toggleExcludeFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.currentValues.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue(facetRequest, selection);
        return;
      }
      const isExcluded = existingValue.state === "excluded";
      existingValue.previousState = existingValue.state;
      existingValue.state = isExcluded ? "idle" : "excluded";
      facetRequest.freezeCurrentValues = true;
    }).addCase(updateFreezeCurrentValues, (state, action) => {
      const { facetId: facetId2, freezeCurrentValues } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.freezeCurrentValues = freezeCurrentValues;
    }).addCase(deselectAllFacetValues, (state, action) => {
      handleFacetDeselectAll(state[action.payload]?.request);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.values(state).filter((slice) => slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
    }).addCase(deselectAllNonBreadcrumbs, (state) => {
      Object.values(state).filter((slice) => !slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
    }).addCase(
      updateFacetAutoSelection,
      (state, action) => Object.values(state).forEach((slice) => {
        slice.request.preventAutoSelect = !action.payload.allow;
      })
    ).addCase(updateFacetSortCriterion, (state, action) => {
      handleFacetSortCriterionUpdate(state, action.payload);
    }).addCase(updateFacetNumberOfValues, (state, action) => {
      const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
      handleFacetUpdateNumberOfValues(
        state[facetId2]?.request,
        numberOfValues2
      );
    }).addCase(updateFacetIsFieldExpanded, (state, action) => {
      const { facetId: facetId2, isFieldExpanded } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.isFieldExpanded = isFieldExpanded;
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      facets.forEach(
        (facetResponse) => mutateStateFromFacetResponse(
          state[facetResponse.facetId]?.request,
          facetResponse
        )
      );
    }).addCase(fetchFacetValues2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      facets.forEach(
        (facetResponse) => mutateStateFromFacetResponse(
          state[facetResponse.facetId]?.request,
          facetResponse
        )
      );
    }).addCase(selectFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      const { rawValue } = value;
      const { currentValues } = facetRequest;
      const matchingValue = currentValues.find((v) => v.value === rawValue);
      if (matchingValue) {
        matchingValue.state = "selected";
        return;
      }
      const searchResultValue = buildSelectedFacetValueRequest(rawValue);
      insertNewValue(facetRequest, searchResultValue);
      facetRequest.freezeCurrentValues = true;
      facetRequest.preventAutoSelect = true;
    }).addCase(excludeFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      const { rawValue } = value;
      const { currentValues } = facetRequest;
      const matchingValue = currentValues.find((v) => v.value === rawValue);
      if (matchingValue) {
        matchingValue.state = "excluded";
        return;
      }
      const searchResultValue = buildExcludedFacetValueRequest(rawValue);
      insertNewValue(facetRequest, searchResultValue);
      facetRequest.freezeCurrentValues = true;
      facetRequest.preventAutoSelect = true;
    }).addCase(disableFacet, (state, action) => {
      if (!(action.payload in state)) {
        return;
      }
      const { request } = state[action.payload];
      handleFacetDeselectAll(request);
    });
  }
);
function insertNewValue(facetRequest, facetValue) {
  const { currentValues } = facetRequest;
  const firstIdleIndex = currentValues.findIndex((v) => v.state === "idle");
  const indexToInsertAt = firstIdleIndex === -1 ? currentValues.length : firstIdleIndex;
  facetRequest.currentValues.splice(indexToInsertAt, 0, facetValue);
  if (firstIdleIndex > -1) {
    facetRequest.currentValues.pop();
  }
  facetRequest.numberOfValues = facetRequest.currentValues.length;
}
function mutateStateFromFacetResponse(facetRequest, facetResponse) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetResponse.values.map(
    convertFacetValueToRequest
  );
  facetRequest.freezeCurrentValues = false;
  facetRequest.preventAutoSelect = false;
}
var defaultFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "automatic",
  resultsMustMatch: "atLeastOneValue"
};
function buildFacetRequest(config) {
  return {
    ...defaultFacetOptions,
    type: "specific",
    currentValues: [],
    freezeCurrentValues: false,
    isFieldExpanded: false,
    preventAutoSelect: false,
    ...config
  };
}
function convertFacetValueToRequest(facetValue) {
  const { value, state } = facetValue;
  return { value, state };
}
function buildSelectedFacetValueRequest(value) {
  return { value, state: "selected" };
}
function buildExcludedFacetValueRequest(value) {
  return { value, state: "excluded" };
}
function restoreFacetValueToIdleState(facetValue) {
  return { ...facetValue, state: "idle" };
}

// src/features/commerce/query-suggest/query-suggest-actions.ts
var import_bueno58 = require("@coveo/bueno");
var import_toolkit52 = require("@reduxjs/toolkit");

// src/features/commerce/query-suggest/query-suggest-request-builder.ts
var buildQuerySuggestRequest = (id2, state, navigatorContext) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    query: state.querySet[id2]
  };
};

// src/features/commerce/query-suggest/query-suggest-actions.ts
var clearQuerySuggest = (0, import_toolkit52.createAction)(
  "commerce/querySuggest/clear",
  (payload) => validatePayload(payload, { id: requiredNonEmptyString })
);
var fetchQuerySuggestions = (0, import_toolkit52.createAsyncThunk)(
  "commerce/querySuggest/fetch",
  async (payload, {
    getState,
    rejectWithValue,
    extra: { apiClient, validatePayload: validatePayload2, navigatorContext }
  }) => {
    validatePayload2(payload, {
      id: requiredNonEmptyString
    });
    const state = getState();
    const request = buildQuerySuggestRequest(
      payload.id,
      state,
      navigatorContext
    );
    const response = await apiClient.querySuggest(request);
    if (isErrorResponse2(response)) {
      return rejectWithValue(response.error);
    }
    return {
      id: payload.id,
      query: request.query,
      ...response.success
    };
  }
);
var registerQuerySuggest = (0, import_toolkit52.createAction)(
  "commerce/querySuggest/register",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    count: new import_bueno58.NumberValue({ min: 0 })
  })
);
var selectQuerySuggestion = (0, import_toolkit52.createAction)(
  "commerce/querySuggest/selectSuggestion",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    expression: requiredEmptyAllowedString
  })
);

// src/features/commerce/search-parameters/search-parameters-actions.ts
var import_toolkit53 = require("@reduxjs/toolkit");

// src/features/commerce/search-parameters/search-parameters-schema.ts
var import_bueno59 = require("@coveo/bueno");
var searchParametersDefinition2 = {
  q: new import_bueno59.StringValue(),
  ...parametersDefinition
};

// src/features/commerce/search-parameters/search-parameters-actions.ts
var restoreSearchParameters2 = (0, import_toolkit53.createAction)(
  "commerce/searchParameters/restore",
  (payload) => validatePayload(payload, searchParametersDefinition2)
);

// src/features/commerce/facets/category-facet/category-facet-actions.ts
var import_bueno60 = require("@coveo/bueno");
var import_toolkit54 = require("@reduxjs/toolkit");
var updateCategoryFacetNumberOfValues2 = (0, import_toolkit54.createAction)(
  "commerce/facets/categoryFacet/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    numberOfValues: new import_bueno60.NumberValue({ required: false, min: 1 })
  })
);
var toggleSelectCategoryFacetValue2 = (0, import_toolkit54.createAction)(
  "commerce/facets/categoryFacet/toggleSelectValue",
  (payload) => {
    try {
      validatePayloadAndThrow(payload.facetId, requiredNonEmptyString);
      validateCategoryFacetValue(payload.selection);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);

// src/features/commerce/facets/facet-search-set/commerce-facet-search-actions.ts
var import_toolkit55 = require("@reduxjs/toolkit");

// src/features/commerce/facets/facet-search-set/category/commerce-category-facet-search-request-builder.ts
var buildCategoryFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  const baseFacetQuery = state.categoryFacetSearchSet[facetId2].options.query;
  const facetQuery = `*${baseFacetQuery}*`;
  const categoryFacet = state.commerceFacetSet[getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2)]?.request;
  const path = categoryFacet && isCategoryFacetRequest2(categoryFacet) ? categoryFacet && getPathToSelectedCategoryFacetItem(categoryFacet) : [];
  const ignorePaths = path.length ? [path] : [];
  const query2 = isFieldSuggestionsRequest ? baseFacetQuery : state.commerceQuery?.query;
  const numberOfValues2 = state.categoryFacetSearchSet[facetId2].options.numberOfValues;
  const {
    url,
    accessToken,
    organizationId,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    ...restOfCommerceAPIRequest
  } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    ignorePaths,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};
function isCategoryFacetRequest2(request) {
  return request.type === "hierarchical";
}
var getPathToSelectedCategoryFacetItem = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.values[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};

// src/features/commerce/facets/facet-search-set/regular/commerce-regular-facet-search-request-builder.ts
var buildFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  const baseFacetQuery = state.facetSearchSet[facetId2].options.query;
  const numberOfValues2 = state.facetSearchSet[facetId2].options.numberOfValues;
  const facetQuery = `*${baseFacetQuery}*`;
  const query2 = !isFieldSuggestionsRequest ? state.commerceQuery?.query : baseFacetQuery;
  const {
    url,
    accessToken,
    organizationId,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    ...restOfCommerceAPIRequest
  } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};

// src/features/commerce/facets/facet-search-set/commerce-facet-search-actions.ts
var getExecuteFacetSearchThunkPayloadCreator = (isFieldSuggestionsRequest) => async ({ facetId: facetId2, facetSearchType }, { getState, extra: { validatePayload: validatePayload2, navigatorContext, apiClient } }) => {
  const state = getState();
  validatePayload2(facetId2, requiredNonEmptyString);
  const req = isRegularFacetSearchState(state, facetId2) || isRegularFieldSuggestionsState(state, facetId2) ? buildFacetSearchRequest(
    facetId2,
    state,
    isFieldSuggestionsRequest,
    navigatorContext
  ) : buildCategoryFacetSearchRequest(
    facetId2,
    state,
    isFieldSuggestionsRequest,
    navigatorContext
  );
  const response = await apiClient.facetSearch(req, facetSearchType);
  return { facetId: facetId2, response };
};
var executeCommerceFacetSearch = (0, import_toolkit55.createAsyncThunk)(
  "commerce/facetSearch/executeSearch",
  getExecuteFacetSearchThunkPayloadCreator(false)
);
var executeCommerceFieldSuggest = (0, import_toolkit55.createAsyncThunk)(
  "commerce/facetSearch/facetFieldSuggest",
  getExecuteFacetSearchThunkPayloadCreator(true)
);
var isRegularFacetSearchState = (s, facetId2) => {
  return "facetSearchSet" in s && s.facetSearchSet[facetId2] !== void 0 && s.commerceFacetSet[facetId2] !== void 0;
};
var isRegularFieldSuggestionsState = (s, facetId2) => {
  if (!("fieldSuggestionsOrder" in s)) {
    return false;
  }
  return s.fieldSuggestionsOrder.some(
    (facet) => facet.facetId === facetId2 && facet.type === "regular"
  );
};
var commerceFieldSuggestionNamespace = "field_suggestion:";
function getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2.slice(commerceFieldSuggestionNamespace.length) : facetId2;
}
function getFacetIdWithCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2 : `${commerceFieldSuggestionNamespace}${facetId2}`;
}

// src/features/commerce/facets/location-facet/location-facet-actions.ts
var import_bueno61 = require("@coveo/bueno");
var import_toolkit56 = require("@reduxjs/toolkit");
var toggleSelectLocationFacetValue = (0, import_toolkit56.createAction)(
  "commerce/facets/locationFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno61.RecordValue({ values: facetValueDefinition })
  })
);

// src/features/commerce/facets/numeric-facet/numeric-facet-actions.ts
var import_bueno62 = require("@coveo/bueno");
var import_toolkit57 = require("@reduxjs/toolkit");
var toggleSelectNumericFacetValue2 = (0, import_toolkit57.createAction)(
  "commerce/facets/numericFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno62.RecordValue({
      values: numericFacetValueDefinition2
    })
  })
);
var toggleExcludeNumericFacetValue2 = (0, import_toolkit57.createAction)(
  "commerce/facets/numericFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno62.RecordValue({
      values: numericFacetValueDefinition2
    })
  })
);
var updateNumericFacetValues2 = (0, import_toolkit57.createAction)(
  "commerce/facets/numericFacet/updateValues",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, {
        facetId: requiredNonEmptyString,
        values: new import_bueno62.ArrayValue({
          each: new import_bueno62.RecordValue({ values: numericFacetValueDefinition2 })
        })
      });
      validateManualNumericRanges({ currentValues: payload.values });
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var updateManualNumericFacetRange = (0, import_toolkit57.createAction)(
  "commerce/facets/numericFacet/updateManualRange",
  (payload) => validatePayloadAndThrow(payload, {
    facetId: requiredNonEmptyString,
    ...numericFacetValueDefinition2
  })
);
var numericFacetValueDefinition2 = {
  state: new import_bueno62.StringValue({
    required: true,
    constrainTo: ["idle", "selected", "excluded"]
  }),
  start: new import_bueno62.NumberValue({ required: true }),
  end: new import_bueno62.NumberValue({ required: true }),
  endInclusive: new import_bueno62.BooleanValue({ required: true })
};

// src/features/commerce/facets/regular-facet/regular-facet-actions.ts
var import_bueno63 = require("@coveo/bueno");
var import_toolkit58 = require("@reduxjs/toolkit");
var toggleExcludeFacetValue2 = (0, import_toolkit58.createAction)(
  "commerce/facets/regularFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno63.RecordValue({ values: facetValueDefinition })
  })
);
var toggleSelectFacetValue2 = (0, import_toolkit58.createAction)(
  "commerce/facets/regularFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    selection: new import_bueno63.RecordValue({ values: facetValueDefinition })
  })
);

// src/features/commerce/facets/facet-set/facet-set-reducers.ts
function restoreFromParameters(state, action) {
  for (const facetId2 of Object.keys(state)) {
    delete state[facetId2];
  }
  if (action.payload.f) {
    restoreFacets(state, action.payload.f, "regular");
  }
  if (action.payload.lf) {
    restoreFacets(state, action.payload.lf, "location");
  }
  if (action.payload.nf) {
    restoreRangeFacets(state, action.payload.nf, "numericalRange");
  }
  if (action.payload.mnf) {
    restoreManualRangeFacets(state, action.payload.mnf);
  }
  if (action.payload.df) {
    restoreRangeFacets(state, action.payload.df, "dateRange");
  }
  if (action.payload.cf) {
    restoreCategoryFacets(state, action.payload.cf);
  }
}
function restoreFacets(state, parameterFacets, type) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, values] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type,
        values: values.map((value) => {
          const facetValue = {
            ...restoreFacetValue(),
            value
          };
          switch (type) {
            case "regular":
              return facetValue;
            case "location":
              return facetValue;
          }
        })
      }
    };
  }
}
function restoreRangeFacets(state, parameterFacets, type) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, values] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type,
        values: values.map((value) => {
          const rangeValue = {
            start: value.start,
            end: value.end,
            endInclusive: value.endInclusive,
            ...restoreFacetValue()
          };
          switch (type) {
            case "dateRange":
              return rangeValue;
            case "numericalRange":
              return rangeValue;
          }
        })
      }
    };
  }
}
function restoreManualRangeFacets(state, parameterFacets) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, values] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type: "numericalRange",
        interval: "continuous",
        values: values.map(
          (value) => ({
            start: value.start,
            end: value.end,
            endInclusive: value.endInclusive,
            ...restoreFacetValue()
          })
        )
      }
    };
  }
}
function restoreCategoryFacets(state, parameterFacets) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, path] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type: "hierarchical",
        values: [],
        // eslint-disable-next-line @cspell/spellchecker
        // TODO CAPI-966: Remove delimitingCharacter
        delimitingCharacter: "|",
        // In the CAPI, the default retrieveCount is 5, while the default
        // numberOfValues is 8. We explicitly set retrieveCount to 8 when
        // restoring category facets to ensure a consistent show more / show
        // less behavior, given that the retrieveCount is not returned in the
        // API response.
        retrieveCount: 8
      }
    };
    selectPath(state[facetId2].request, path);
  }
}
function restoreFacet(facetId2) {
  return {
    facetId: facetId2,
    field: facetId2,
    isFieldExpanded: false,
    preventAutoSelect: false
  };
}
function restoreFacetValue() {
  return {
    state: "selected",
    isAutoSelected: false,
    isSuggested: false,
    moreValuesAvailable: true
  };
}
function buildSelectedFacetValueRequest2(rawValue) {
  return { state: "selected", value: rawValue };
}
function selectPath(request, path, initialNumberOfValues) {
  request.values = buildCurrentValuesFromPath(path);
  request.numberOfValues = initialNumberOfValues;
  request.preventAutoSelect = true;
}
function buildCurrentValuesFromPath(path) {
  if (!path.length) {
    return [];
  }
  const root = buildCategoryFacetValueRequest(path[0]);
  let curr = root;
  const [_first, ...rest] = path;
  for (const segment of rest) {
    const next = buildCategoryFacetValueRequest(segment);
    curr.children.push(next);
    curr = next;
  }
  curr.state = "selected";
  return [root];
}
function buildCategoryFacetValueRequest(value) {
  return {
    children: [],
    state: "idle",
    value
  };
}

// src/features/commerce/facets/facet-set/facet-set-state.ts
function getCommerceFacetSetInitialState() {
  return {};
}

// src/features/commerce/facets/facet-set/facet-set-slice.ts
var commerceFacetSetReducer = (0, import_toolkit59.createReducer)(
  getCommerceFacetSetInitialState(),
  (builder) => {
    builder.addCase(fetchProductListing.fulfilled, handleQueryFulfilled).addCase(executeSearch3.fulfilled, handleQueryFulfilled).addCase(
      executeCommerceFieldSuggest.fulfilled,
      (state, action) => handleFieldSuggestionsFulfilled(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(action.payload.facetId)
      )
    ).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
      if (!action.payload.fieldSuggestionsFacets) {
        return;
      }
      for (const { facetId: facetId2 } of action.payload.fieldSuggestionsFacets) {
        handleFieldSuggestionsFulfilled(
          state,
          getFacetIdWithCommerceFieldSuggestionNamespace(facetId2)
        );
      }
    }).addCase(toggleSelectFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.values.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "select");
      facetRequest.freezeCurrentValues = true;
    }).addCase(toggleSelectLocationFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureLocationFacetRequest(facetRequest)) {
        return;
      }
      const existingValue = facetRequest.values.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "select");
    }).addCase(toggleSelectNumericFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureNumericFacetRequest(facetRequest)) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = findExactRangeValue(
        facetRequest.values,
        selection
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "select");
      facetRequest.numberOfValues = facetRequest.initialNumberOfValues;
      if (facetRequest.interval === "continuous" && existingValue.state === "idle") {
        facetRequest.values = [];
        return;
      }
    }).addCase(toggleSelectDateFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureDateFacetRequest(facetRequest)) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = findExactRangeValue(
        facetRequest.values,
        selection
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "select");
    }).addCase(toggleSelectCategoryFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const request = state[facetId2]?.request;
      if (!ensureCategoryFacetRequest(request)) {
        return;
      }
      const { path } = selection;
      const pathToSelection = path.slice(0, path.length - 1);
      const children = ensurePathAndReturnChildren(request, pathToSelection);
      let selectedValue = children.find(
        (value) => value.value === selection.value
      );
      if (!selectedValue) {
        selectedValue = buildCategoryFacetValueRequest(selection.value);
        children.push(selectedValue);
      }
      selectedValue.state = selectedValue.state === "idle" ? "selected" : "idle";
      if (selectedValue.state === "selected") {
        request.numberOfValues = request.initialNumberOfValues;
        request.retrieveCount = request.initialNumberOfValues;
      }
    }).addCase(toggleExcludeFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.values.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "exclude");
      facetRequest.freezeCurrentValues = true;
    }).addCase(toggleExcludeNumericFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureNumericFacetRequest(facetRequest)) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = findExactRangeValue(
        facetRequest.values,
        selection
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "exclude");
      facetRequest.numberOfValues = facetRequest.initialNumberOfValues;
      if (facetRequest.interval === "continuous" && existingValue.state === "idle") {
        facetRequest.values = [];
        return;
      }
    }).addCase(toggleExcludeDateFacetValue2, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureDateFacetRequest(facetRequest)) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = findExactRangeValue(
        facetRequest.values,
        selection
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, selection);
        return;
      }
      updateExistingFacetValueState(existingValue, "exclude");
      facetRequest.numberOfValues = facetRequest.initialNumberOfValues;
    }).addCase(updateCategoryFacetNumberOfValues2, (state, action) => {
      const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
      const request = state[facetId2]?.request;
      if (!ensureCategoryFacetRequest(request)) {
        return;
      }
      handleCategoryFacetUpdateNumberOfValues(request, numberOfValues2);
    }).addCase(selectFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
        return;
      }
      const { rawValue } = value;
      facetRequest.freezeCurrentValues = true;
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.values.find(
        (v) => v.value === rawValue
      );
      if (!existingValue) {
        insertNewValue2(
          facetRequest,
          buildSelectedFacetValueRequest2(rawValue)
        );
        return;
      }
      updateExistingFacetValueState(existingValue, "select");
    }).addCase(excludeFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
        return;
      }
      const { rawValue } = value;
      facetRequest.freezeCurrentValues = true;
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.values.find(
        (v) => v.value === rawValue
      );
      if (!existingValue) {
        insertNewValue2(facetRequest, { state: "excluded", value: rawValue });
        return;
      }
      updateExistingFacetValueState(existingValue, "exclude");
    }).addCase(selectCategoryFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const request = state[facetId2]?.request;
      if (!ensureCategoryFacetRequest(request)) {
        return;
      }
      const path = [...value.path, value.rawValue];
      selectPath(request, path, request.initialNumberOfValues);
    }).addCase(updateNumericFacetValues2, (state, action) => {
      const { facetId: facetId2, values } = action.payload;
      const request = state[facetId2]?.request;
      if (!request || !ensureNumericFacetRequest(request)) {
        return;
      }
      request.values = values;
      request.numberOfValues = values.length;
    }).addCase(updateDateFacetValues2, (state, action) => {
      const { facetId: facetId2, values } = action.payload;
      const request = state[facetId2]?.request;
      if (!request || !ensureDateFacetRequest(request)) {
        return;
      }
      request.values = convertToDateRangeRequests(values);
      request.numberOfValues = values.length;
    }).addCase(updateCoreFacetNumberOfValues, (state, action) => {
      const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.numberOfValues = numberOfValues2;
    }).addCase(updateCoreFacetIsFieldExpanded, (state, action) => {
      const { facetId: facetId2, isFieldExpanded } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.isFieldExpanded = isFieldExpanded;
    }).addCase(
      updateAutoSelectionForAllCoreFacets,
      (state, action) => Object.values(state).forEach((slice) => {
        slice.request.preventAutoSelect = !action.payload.allow;
      })
    ).addCase(updateCoreFacetFreezeCurrentValues, (state, action) => {
      const { facetId: facetId2, freezeCurrentValues } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.freezeCurrentValues = freezeCurrentValues;
    }).addCase(deselectAllValuesInCoreFacet, (state, action) => {
      const { facetId: facetId2 } = action.payload;
      const request = state[facetId2]?.request;
      if (!request) {
        return;
      }
      handleDeselectAllFacetValues(request);
    }).addCase(updateManualNumericFacetRange, (state, action) => {
      const { facetId: facetId2 } = action.payload;
      const request = state[facetId2]?.request;
      if (!request) {
        return;
      }
      handleDeselectAllFacetValues(request);
    }).addCase(clearAllCoreFacets, setAllFacetValuesToIdle).addCase(deleteAllCoreFacets, clearAllFacetValues).addCase(setContext, clearAllFacetValues).addCase(setView, clearAllFacetValues).addCase(restoreSearchParameters2, restoreFromParameters).addCase(restoreProductListingParameters, restoreFromParameters);
  }
);
function ensureRegularFacetRequest(facetRequest) {
  return facetRequest.type === "regular";
}
function ensureLocationFacetRequest(facetRequest) {
  return facetRequest.type === "location";
}
function ensureNumericFacetRequest(facetRequest) {
  return facetRequest.type === "numericalRange";
}
function ensureDateFacetRequest(facetRequest) {
  return facetRequest.type === "dateRange";
}
function ensureCategoryFacetRequest(facetRequest) {
  return facetRequest?.type === "hierarchical";
}
function handleQueryFulfilled(state, action) {
  const existingFacets = new Set(Object.keys(state));
  const facets = action.payload.response.facets;
  for (const facetResponse of facets) {
    updateStateFromFacetResponse(state, facetResponse, existingFacets);
  }
  for (const facetId2 of existingFacets) {
    delete state[facetId2];
  }
}
function handleFieldSuggestionsFulfilled(state, facetId2) {
  let facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    state[facetId2] = { request: {} };
    facetRequest = state[facetId2].request;
    facetRequest.initialNumberOfValues = 10;
    facetRequest.values = [];
  }
}
function handleDeselectAllFacetValues(request) {
  const resetValues = () => {
    request.values.forEach((value) => {
      value.state = "idle";
    });
  };
  switch (request.type) {
    case "hierarchical":
      request.initialNumberOfValues = void 0;
      request.numberOfValues = void 0;
      request.values = [];
      request.preventAutoSelect = true;
      break;
    case "numericalRange":
      request.numberOfValues = request.initialNumberOfValues;
      resetValues();
      break;
    default:
      resetValues();
      break;
  }
}
function ensurePathAndReturnChildren(request, path) {
  let children = request.values;
  for (const segment of path) {
    let parent = children[0];
    const missingParent = !parent;
    if (missingParent || segment !== parent.value) {
      parent = buildCategoryFacetValueRequest(segment);
      children.length = 0;
      children.push(parent);
    }
    parent.state = "idle";
    children = parent.children;
  }
  return children;
}
function updateExistingFacetValueState(existingFacetValue, toggleAction) {
  switch (existingFacetValue.state) {
    case "idle":
      existingFacetValue.state = toggleAction === "exclude" ? "excluded" : "selected";
      break;
    case "excluded":
      existingFacetValue.state = toggleAction === "exclude" ? "idle" : "selected";
      break;
    case "selected":
      existingFacetValue.state = toggleAction === "exclude" ? "excluded" : "idle";
      break;
    default:
      break;
  }
}
function updateStateFromFacetResponse(state, facetResponse, facetsToRemove) {
  const facetId2 = facetResponse.facetId ?? facetResponse.field;
  let facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    state[facetId2] = { request: {} };
    facetRequest = state[facetId2].request;
  } else {
    facetsToRemove.delete(facetId2);
  }
  if (facetRequest.initialNumberOfValues === void 0) {
    facetRequest.initialNumberOfValues = facetResponse.numberOfValues;
  }
  facetRequest.facetId = facetId2;
  facetRequest.displayName = facetResponse.displayName;
  facetRequest.numberOfValues = facetResponse.numberOfValues;
  facetRequest.field = facetResponse.field;
  facetRequest.type = facetResponse.type;
  facetRequest.values = getFacetRequestValuesFromFacetResponse(facetResponse) ?? [];
  facetRequest.freezeCurrentValues = false;
  facetRequest.preventAutoSelect = false;
  if (facetResponse.type === "hierarchical" && ensureCategoryFacetRequest(facetRequest)) {
    facetRequest.delimitingCharacter = facetResponse.delimitingCharacter;
  } else if (facetResponse.type === "numericalRange") {
    facetRequest.interval = facetResponse.interval;
    if (facetResponse.domain) {
      facetRequest.domain = {
        min: facetResponse.domain.min,
        max: facetResponse.domain.max,
        increment: facetResponse.domain.increment
      };
    }
  }
}
function getFacetRequestValuesFromFacetResponse(facetResponse) {
  switch (facetResponse.type) {
    case "numericalRange":
      return convertToNumericRangeRequests(facetResponse.values);
    case "dateRange":
      return convertToDateRangeRequests(facetResponse.values);
    case "hierarchical":
      return facetResponse.values.map(convertCategoryFacetValueToRequest);
    case "regular":
      return facetResponse.values.map(convertFacetValueToRequest);
    case "location":
      return facetResponse.values.map(convertLocationFacetValueToRequest);
    default:
      return;
  }
}
function convertCategoryFacetValueToRequest(responseValue) {
  const children = responseValue.children.map(
    convertCategoryFacetValueToRequest
  );
  const { state, value } = responseValue;
  return {
    children,
    state,
    value
  };
}
function convertLocationFacetValueToRequest(facetValue) {
  const { value, state } = facetValue;
  return { value, state };
}
function insertNewValue2(facetRequest, facetValue) {
  const { values } = facetRequest;
  const firstIdleIndex = values.findIndex((v) => v.state === "idle");
  const indexToInsertAt = firstIdleIndex === -1 ? values.length : firstIdleIndex;
  facetRequest.values.splice(indexToInsertAt, 0, facetValue);
  if (firstIdleIndex > -1) {
    facetRequest.values.pop();
  }
  facetRequest.numberOfValues = facetRequest.values.length;
}
function setAllFacetValuesToIdle(state) {
  Object.values(state).forEach(
    (facet) => handleDeselectAllFacetValues(facet.request)
  );
}
function clearAllFacetValues(state) {
  Object.values(state).forEach((facet) => {
    facet.request.values = [];
  });
}
function handleCategoryFacetUpdateNumberOfValues(facetRequest, numberOfValues2) {
  facetRequest.numberOfValues = numberOfValues2;
  facetRequest.retrieveCount = numberOfValues2;
}

// src/features/facets/facet-order/facet-order-slice.ts
var import_toolkit60 = require("@reduxjs/toolkit");
var facetOrderReducer = (0, import_toolkit60.createReducer)(
  getFacetOrderInitialState(),
  (builder) => {
    builder.addCase(executeSearch2.fulfilled, handleQueryFulfilled2).addCase(fetchProductListing.fulfilled, handleQueryFulfilled2).addCase(executeSearch3.fulfilled, handleQueryFulfilled2).addCase(restoreSearchParameters2, handleRestoreParameters).addCase(restoreProductListingParameters, handleRestoreParameters).addCase(change.fulfilled, (state, action) => {
      return action.payload?.facetOrder ?? state;
    }).addCase(setView, () => getFacetOrderInitialState()).addCase(setContext, () => getFacetOrderInitialState());
  }
);
function handleQueryFulfilled2(_, action) {
  return action.payload.response.facets.map(
    (facet) => facet.facetId
  );
}
function handleRestoreParameters(_, action) {
  return [
    ...Object.keys(action.payload.f ?? {}),
    ...Object.keys(action.payload.lf ?? {}),
    ...Object.keys(action.payload.nf ?? {}),
    ...Object.keys(action.payload.df ?? {}),
    ...Object.keys(action.payload.cf ?? {}),
    ...Object.keys(action.payload.mnf ?? {})
  ];
}

// src/controllers/commerce/core/breadcrumb-manager/headless-core-breadcrumb-manager.ts
var actions = {
  regular: {
    toggleSelectActionCreator: toggleSelectFacetValue2,
    toggleExcludeActionCreator: toggleExcludeFacetValue2
  },
  numericalRange: {
    toggleSelectActionCreator: toggleSelectNumericFacetValue2,
    toggleExcludeActionCreator: toggleExcludeNumericFacetValue2
  },
  dateRange: {
    toggleSelectActionCreator: toggleSelectDateFacetValue2,
    toggleExcludeActionCreator: toggleExcludeDateFacetValue2
  },
  location: {
    toggleSelectActionCreator: toggleSelectLocationFacetValue
  },
  hierarchical: {
    toggleSelectActionCreator: deselectAllValuesInCoreFacet
  }
};
function buildCoreBreadcrumbManager(engine, options) {
  if (!loadCommerceBreadcrumbManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const createBreadcrumb = (facet) => ({
    facetId: facet.facetId,
    facetDisplayName: facet.displayName,
    field: facet.field,
    type: facet.type,
    values: facet.type === "hierarchical" ? getValuesForCategoryFacet(facet) : getValuesForNonCategoryFacet(facet)
  });
  const getValuesForNonCategoryFacet = (facet) => {
    return facet.values.filter((value) => value.state !== "idle").map((selection) => ({
      value: selection,
      deselect: () => {
        if (selection.state === "selected") {
          dispatch(
            actions[facet.type].toggleSelectActionCreator({
              facetId: facet.facetId,
              selection
            })
          );
          if (facet.type !== "location") {
            dispatch(
              updateCoreFacetFreezeCurrentValues({
                facetId: facet.facetId,
                freezeCurrentValues: false
              })
            );
          }
          dispatch(options.fetchProductsActionCreator());
        } else if (selection.state === "excluded" && facet.type !== "location") {
          dispatch(
            actions[facet.type].toggleExcludeActionCreator({
              facetId: facet.facetId,
              selection
            })
          );
          dispatch(
            updateCoreFacetFreezeCurrentValues({
              facetId: facet.facetId,
              freezeCurrentValues: false
            })
          );
          dispatch(options.fetchProductsActionCreator());
        }
      }
    }));
  };
  const getValuesForCategoryFacet = (facet) => {
    const ancestry = findActiveValueAncestry(facet.values);
    const activeValue = ancestry.length > 0 ? ancestry[ancestry.length - 1] : void 0;
    if (activeValue === void 0) {
      return [];
    }
    return [
      {
        value: activeValue,
        deselect: () => {
          dispatch(
            actions.hierarchical.toggleSelectActionCreator({
              facetId: facet.facetId
            })
          );
          dispatch(options.fetchProductsActionCreator());
        }
      }
    ];
  };
  const hasActiveValue = (facet) => {
    if (!facet) {
      return false;
    }
    if (facet.values.length === 0) {
      return false;
    }
    if (facet.type === "hierarchical") {
      return findActiveValueAncestry(facet.values).length > 0;
    }
    return facet.values.some((value) => value.state !== "idle");
  };
  const commerceFacetSelector = (0, import_toolkit61.createSelector)(
    (state) => state.facetOrder,
    (facetOrder) => {
      const breadcrumbs = facetOrder.flatMap((facetId2) => {
        const facet = options.facetResponseSelector(engine[stateKey], facetId2);
        if (hasActiveValue(facet)) {
          return [createBreadcrumb(facet)];
        }
        return [];
      });
      return {
        facetBreadcrumbs: breadcrumbs,
        hasBreadcrumbs: breadcrumbs.length > 0
      };
    }
  );
  return {
    ...controller,
    deselectAll: () => {
      dispatch(clearAllCoreFacets());
      dispatch(options.fetchProductsActionCreator());
    },
    get state() {
      return commerceFacetSelector(engine[stateKey]);
    }
  };
}
function loadCommerceBreadcrumbManagerReducers(engine) {
  engine.addReducers({ facetOrder: facetOrderReducer, commerceFacetSet: commerceFacetSetReducer });
  return true;
}

// src/features/commerce/facets/facet-set/facet-set-selector.ts
var import_toolkit62 = require("@reduxjs/toolkit");
var facetRequestSelector = (0, import_toolkit62.createSelector)(
  (state, facetId2) => ({
    facetRequestSelector: state.commerceFacetSet[facetId2]
  }),
  ({ facetRequestSelector: facetRequestSelector2 }) => {
    return facetRequestSelector2?.request;
  }
);

// src/features/facets/facet-search-set/category/category-facet-search-state-selector.ts
var import_toolkit63 = require("@reduxjs/toolkit");
var categoryFacetSearchStateSelector = (0, import_toolkit63.createSelector)(
  (state, facetId2) => ({
    facetSearchSelector: state.categoryFacetSearchSet[facetId2]
  }),
  ({ facetSearchSelector }) => {
    return facetSearchSelector;
  }
);

// src/controllers/commerce/core/facets/headless-core-commerce-facet.ts
function buildCoreCommerceFacet(engine, props) {
  if (!loadCommerceFacetReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const controller = buildController(engine);
  const facetId2 = props.options.facetId;
  const getEngineState = () => engine[stateKey];
  const getRequest = () => facetRequestSelector(getEngineState(), facetId2);
  const getResponse = () => props.options.facetResponseSelector(getEngineState(), facetId2);
  const getIsLoading = () => props.options.isFacetLoadingResponseSelector(getEngineState());
  const getNumberOfActiveValues = () => {
    return getRequest()?.values?.filter((v) => v.state !== "idle").length ?? 0;
  };
  return {
    ...controller,
    toggleSelect: (selection) => {
      dispatch(
        props.options.toggleSelectActionCreator({
          selection,
          facetId: facetId2
        })
      );
      dispatch(props.options.fetchProductsActionCreator());
    },
    toggleExclude: (selection) => {
      if (!props.options.toggleExcludeActionCreator) {
        engine.logger.warn(
          "No toggle exclude action creator provided; calling #toggleExclude had no effect."
        );
        return;
      }
      dispatch(props.options.toggleExcludeActionCreator({ selection, facetId: facetId2 }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllValuesInCoreFacet({ facetId: facetId2 }));
      }
      this.toggleSelect(selection);
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleExclude: function(selection) {
      if (!props.options.toggleExcludeActionCreator) {
        engine.logger.warn(
          "No toggle exclude action creator provided; calling #toggleSingleExclude had no effect."
        );
        return;
      }
      if (selection.state === "idle") {
        dispatch(deselectAllValuesInCoreFacet({ facetId: facetId2 }));
      }
      this.toggleExclude(selection);
    },
    isValueSelected: (value) => {
      return value.state === "selected";
    },
    isValueExcluded: (value) => {
      return value.state === "excluded";
    },
    deselectAll() {
      dispatch(deselectAllValuesInCoreFacet({ facetId: facetId2 }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    showMoreValues() {
      const numberInState = getRequest()?.numberOfValues ?? 0;
      const initialNumberOfValues = getRequest()?.initialNumberOfValues ?? 1;
      const numberToNextMultipleOfConfigured = initialNumberOfValues - numberInState % initialNumberOfValues;
      const numberOfValues2 = numberInState + numberToNextMultipleOfConfigured;
      dispatch(updateCoreFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(
        updateCoreFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: true })
      );
      dispatch(props.options.fetchProductsActionCreator());
    },
    showLessValues() {
      const initialNumberOfValues = getRequest()?.initialNumberOfValues ?? 1;
      const newNumberOfValues = Math.max(
        initialNumberOfValues,
        getNumberOfActiveValues()
      );
      dispatch(
        updateCoreFacetNumberOfValues({
          facetId: facetId2,
          numberOfValues: newNumberOfValues
        })
      );
      dispatch(
        updateCoreFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: false })
      );
      dispatch(props.options.fetchProductsActionCreator());
    },
    get state() {
      return getCoreFacetState(
        facetId2,
        getRequest(),
        getResponse(),
        getIsLoading()
      );
    }
  };
}
function loadCommerceFacetReducers(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return true;
}
var canShowLessValues = (request) => {
  return !!request && request.values.length > (request.initialNumberOfValues ?? 1) && request.values.some((v) => v.state === "idle");
};
var getCoreFacetState = (facetId2, request, response, isLoading) => {
  return {
    canShowLessValues: canShowLessValues(request),
    canShowMoreValues: response?.moreValuesAvailable ?? false,
    displayName: response?.displayName ?? "",
    facetId: facetId2,
    field: response?.field ?? "",
    hasActiveValues: !response || response.type === "hierarchical" ? false : response.values.some((v) => v.state !== "idle"),
    isLoading,
    type: response?.type ?? "regular",
    values: response?.values ? response.values : []
  };
};

// src/features/facets/facet-search-set/category/category-facet-search-set-slice.ts
var import_toolkit65 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/facet-search-reducer-helpers.ts
function handleFacetSearchRegistration(state, payload, buildEmptyResponse3) {
  const { facetId: facetId2 } = payload;
  if (state[facetId2]) {
    return;
  }
  const isLoading = false;
  const options = { ...defaultFacetSearchOptions, ...payload };
  const response = buildEmptyResponse3();
  state[facetId2] = {
    options,
    isLoading,
    response,
    initialNumberOfValues: options.numberOfValues,
    requestId: ""
  };
}
function handleFacetSearchUpdate(state, payload) {
  const { facetId: facetId2, ...rest } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.options = { ...search.options, ...rest };
}
function handleFacetSearchPending(state, facetId2, requestId) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = requestId;
  search.isLoading = true;
}
function handleFacetSearchRejected(state, facetId2) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.isLoading = false;
}
function handleFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  search.response = response;
}
function handleCommerceFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFacetFieldSuggestionsFulfilled(state, payload, requestId, buildEmptyResponse3) {
  const { facetId: facetId2, response } = payload;
  const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(facetId2);
  let search = state[namespacedFacetId];
  if (!search) {
    handleFacetSearchRegistration(
      state,
      { facetId: namespacedFacetId },
      buildEmptyResponse3
    );
    search = state[namespacedFacetId];
  } else if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(state, payload, requestId, buildEmptyResponse3) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    if (fieldSuggestionFacet.facetId in state || fieldSuggestionFacet.type !== "regular") {
      continue;
    }
    state[fieldSuggestionFacet.facetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse3(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(state, payload, requestId, buildEmptyResponse3) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(
      fieldSuggestionFacet.facetId
    );
    if (namespacedFacetId in state || fieldSuggestionFacet.type !== "hierarchical") {
      continue;
    }
    state[namespacedFacetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse3(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleFacetSearchClear(state, payload, buildEmptyResponse3) {
  const { facetId: facetId2 } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = "";
  search.isLoading = false;
  search.response = buildEmptyResponse3();
  search.options.numberOfValues = search.initialNumberOfValues;
  search.options.query = defaultFacetSearchOptions.query;
}
function handleFacetSearchSetClear(state, buildEmptyResponse3) {
  Object.keys(state).forEach(
    (facetId2) => handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse3)
  );
}
var defaultFacetSearchOptions = {
  captions: {},
  numberOfValues: 10,
  query: ""
};

// src/features/facets/facet-search-set/generic/generic-facet-search-actions.ts
var import_toolkit64 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/category/category-facet-search-request-builder.ts
var buildCategoryFacetSearchRequest2 = async (id2, state, navigatorContext, isFieldSuggestionsRequest) => {
  const options = state.categoryFacetSearchSet[id2].options;
  const categoryFacet = state.categoryFacetSet[id2].request;
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = options;
  const { field: field2, delimitingCharacter: delimitingCharacter2, basePath: basePath2, filterFacetCount: filterFacetCount2 } = categoryFacet;
  const path = getPathToSelectedCategoryFacetItem2(categoryFacet);
  const ignorePaths = path.length ? [path] : [];
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    basePath: basePath2,
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    delimitingCharacter: delimitingCharacter2,
    ignorePaths,
    filterFacetCount: filterFacetCount2,
    type: "hierarchical",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest2(state, navigatorContext)).request
    }
  };
};
var getPathToSelectedCategoryFacetItem2 = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.currentValues[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};

// src/features/facets/facet-search-set/specific/specific-facet-search-request-builder.ts
var buildSpecificFacetSearchRequest = async (id2, state, navigatorContext, isFieldSuggestionsRequest) => {
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = state.facetSearchSet[id2].options;
  const { field: field2, currentValues, filterFacetCount: filterFacetCount2 } = state.facetSet[id2].request;
  const ignoreValues = currentValues.filter((v) => v.state !== "idle").map((facetValue) => facetValue.value);
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    ignoreValues,
    filterFacetCount: filterFacetCount2,
    type: "specific",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest2(state, navigatorContext)).request
    }
  };
};

// src/features/facets/facet-search-set/generic/generic-facet-search-actions.ts
var getExecuteFacetSearchThunkPayloadCreator2 = (isFieldSuggestionsRequest) => async (facetId2, { getState, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  const state = getState();
  let req;
  validatePayload2(facetId2, requiredNonEmptyString);
  if (isSpecificFacetSearchState(state, facetId2)) {
    req = await buildSpecificFacetSearchRequest(
      facetId2,
      state,
      navigatorContext,
      isFieldSuggestionsRequest
    );
  } else {
    req = await buildCategoryFacetSearchRequest2(
      facetId2,
      state,
      navigatorContext,
      isFieldSuggestionsRequest
    );
  }
  const response = await apiClient.facetSearch(req);
  return { facetId: facetId2, response };
};
var executeFacetSearch = (0, import_toolkit64.createAsyncThunk)("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator2(false));
var executeFieldSuggest = (0, import_toolkit64.createAsyncThunk)("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator2(true));
var clearFacetSearch = (0, import_toolkit64.createAction)(
  "facetSearch/clearResults",
  (payload) => validatePayload(payload, { facetId: facetIdDefinition })
);
var isSpecificFacetSearchState = (s, facetId2) => {
  return s.facetSearchSet !== void 0 && s.facetSet !== void 0 && s.facetSet[facetId2] !== void 0;
};

// src/features/facets/facet-search-set/category/category-facet-search-set-state.ts
function getCategoryFacetSearchSetInitialState() {
  return {};
}

// src/features/facets/facet-search-set/category/category-facet-search-set-slice.ts
var categoryFacetSearchSetReducer = (0, import_toolkit65.createReducer)(
  getCategoryFacetSearchSetInitialState(),
  (builder) => {
    builder.addCase(registerCategoryFacetSearch, (state, action) => {
      const payload = action.payload;
      handleFacetSearchRegistration(state, payload, buildEmptyResponse);
    }).addCase(updateFacetSearch, (state, action) => {
      handleFacetSearchUpdate(state, action.payload);
    }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeFacetSearch.pending, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(facetId2)
      );
    }).addCase(executeFacetSearch.rejected, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
      handleCommerceFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
      handleCommerceFacetFieldSuggestionsFulfilled(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse
      );
    }).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
      handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse
      );
    }).addCase(executeFacetSearch.fulfilled, (state, action) => {
      handleFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(clearFacetSearch, (state, { payload: { facetId: facetId2 } }) => {
      handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse);
    }).addCase(
      fetchProductListing.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse)
    ).addCase(
      executeSearch3.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse)
    ).addCase(executeSearch2.fulfilled, (state) => {
      handleFacetSearchSetClear(state, buildEmptyResponse);
    });
  }
);
function buildEmptyResponse() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}

// src/controllers/core/facets/facet-search/facet-search.ts
function buildGenericFacetSearch(engine, props) {
  const dispatch = engine.dispatch;
  const {
    options,
    getFacetSearch,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  } = props;
  const { facetId: facetId2 } = options;
  return {
    /** Updates the facet search query.
     * @param text The new query.
     */
    updateText(text) {
      dispatch(
        updateFacetSearch({
          facetId: facetId2,
          query: text,
          numberOfValues: getFacetSearch().initialNumberOfValues
        })
      );
    },
    /** Increases number of results returned by numberOfResults */
    showMoreResults() {
      const { initialNumberOfValues, options: options2 } = getFacetSearch();
      dispatch(
        updateFacetSearch({
          facetId: facetId2,
          numberOfValues: options2.numberOfValues + initialNumberOfValues
        })
      );
      dispatch(
        props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2)
      );
    },
    /** Executes a facet search to update the values.*/
    search() {
      dispatch(
        props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2)
      );
    },
    /** Resets the query and empties the values. */
    clear() {
      dispatch(clearFacetSearch({ facetId: facetId2 }));
    },
    /**
     * Updates the facet value captions.
     * @param captions - A dictionary that maps index field values to facet value display names.
     */
    updateCaptions(captions2) {
      dispatch(
        updateFacetSearch({
          facetId: facetId2,
          captions: captions2
        })
      );
    },
    get state() {
      const { response, isLoading, options: options2 } = getFacetSearch();
      const { query: query2 } = options2;
      const values = response.values;
      return {
        ...response,
        values,
        isLoading,
        query: query2
      };
    }
  };
}

// src/controllers/core/facets/facet-search/category/headless-category-facet-search.ts
function buildCoreCategoryFacetSearch(engine, props) {
  const { dispatch } = engine;
  const options = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => "state" in engine ? engine.state.categoryFacetSearchSet[facetId2] : engine[stateKey].categoryFacetSearchSet[facetId2];
  dispatch(registerCategoryFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: props.executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator: props.executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    select(value) {
      dispatch(
        selectCategoryFacetSearchResult({
          facetId: facetId2,
          value
        })
      );
      props.select(value);
    },
    get state() {
      return genericFacetSearch.state;
    }
  };
}

// src/controllers/commerce/core/facets/category/headless-commerce-category-facet-search.ts
function buildCategoryFacetSearch(engine, props) {
  if (!loadCategoryFacetSearchReducers(engine)) {
    throw loadReducerError;
  }
  const {
    state: _state,
    updateCaptions: _updateCaptions,
    ...restOfFacetSearch
  } = buildCoreCategoryFacetSearch(engine, {
    ...props,
    executeFacetSearchActionCreator: (facetId2) => executeCommerceFacetSearch({
      facetId: facetId2,
      facetSearchType: props.options.type
    }),
    executeFieldSuggestActionCreator: (facetId2) => executeCommerceFieldSuggest({
      facetId: facetId2,
      facetSearchType: props.options.type
    })
  });
  return restOfFacetSearch;
}
function loadCategoryFacetSearchReducers(engine) {
  engine.addReducers({ categoryFacetSearchSet: categoryFacetSearchSetReducer });
  return true;
}

// src/controllers/commerce/core/facets/category/headless-commerce-category-facet.ts
function buildCategoryFacet(engine, options) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options,
      toggleSelectActionCreator: toggleSelectCategoryFacetValue2
    }
  });
  const { deselectAll, isValueSelected, subscribe, toggleSelect } = coreController;
  const { dispatch } = engine;
  const { facetId: facetId2 } = options;
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: { facetId: facetId2, ...options.facetSearch },
    select: () => {
      dispatch(options.fetchProductsActionCreator());
    },
    isForFieldSuggestions: false
  });
  const getRequest = () => facetRequestSelector(engine[stateKey], facetId2);
  const findSelectedValueChildren = (values) => {
    const selectedValue = values.find((value) => value.state === "selected");
    if (selectedValue) {
      return selectedValue.children;
    }
    for (const value of values) {
      if (value.children.length > 0) {
        const result = findSelectedValueChildren(value.children);
        if (result !== value.children) {
          return result;
        }
      }
    }
    return values;
  };
  return {
    deselectAll,
    isValueSelected,
    subscribe,
    toggleSelect,
    showMoreValues() {
      const { initialNumberOfValues, values, numberOfValues: numberOfValues2 } = getRequest();
      const currentLevelValues = findSelectedValueChildren(values);
      if (!initialNumberOfValues && !numberOfValues2) {
        return;
      }
      const newNumberOfValues = currentLevelValues.length + (initialNumberOfValues ?? numberOfValues2);
      dispatch(
        updateCategoryFacetNumberOfValues2({
          facetId: facetId2,
          numberOfValues: newNumberOfValues
        })
      );
      dispatch(options.fetchProductsActionCreator());
    },
    showLessValues() {
      const request = getRequest();
      const numberOfValues2 = request.initialNumberOfValues ?? 1;
      dispatch(
        updateCategoryFacetNumberOfValues2({
          facetId: facetId2,
          numberOfValues: numberOfValues2
        })
      );
      dispatch(options.fetchProductsActionCreator());
    },
    facetSearch: facetSearch2,
    get state() {
      return getCategoryFacetState(
        coreController.state,
        categoryFacetSearchStateSelector(engine[stateKey], facetId2),
        getRequest()
      );
    },
    type: "hierarchical"
  };
}
var getCategoryFacetState = (coreState, facetSearchSelector, request) => {
  const { values } = coreState;
  const selectedValueAncestry = findActiveValueAncestry(values);
  const activeValue = selectedValueAncestry.length ? selectedValueAncestry[selectedValueAncestry.length - 1] : void 0;
  const initialNumberOfValues = request?.initialNumberOfValues;
  const canShowLessValues2 = !!initialNumberOfValues && (activeValue ? initialNumberOfValues < activeValue.children.length : initialNumberOfValues < (request.numberOfValues ?? coreState.values.length));
  const canShowMoreValues = activeValue ? activeValue.moreValuesAvailable : coreState.canShowMoreValues;
  return {
    ...coreState,
    activeValue,
    canShowLessValues: canShowLessValues2,
    canShowMoreValues,
    facetSearch: {
      isLoading: facetSearchSelector?.isLoading ?? false,
      moreValuesAvailable: facetSearchSelector?.response.moreValuesAvailable ?? false,
      query: facetSearchSelector?.options.query ?? "",
      values: facetSearchSelector?.response.values ?? []
    },
    hasActiveValues: !!activeValue,
    selectedValueAncestry,
    type: "hierarchical",
    values
  };
};

// src/controllers/commerce/core/facets/date/headless-commerce-date-facet.ts
function buildCommerceDateFacet(engine, options) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options,
      toggleSelectActionCreator: toggleSelectDateFacetValue2,
      toggleExcludeActionCreator: toggleExcludeDateFacetValue2
    }
  });
  const { dispatch } = engine;
  const { facetId: facetId2, fetchProductsActionCreator } = options;
  return {
    ...coreController,
    setRanges(ranges) {
      dispatch(
        updateDateFacetValues2({
          facetId: facetId2,
          values: ranges.map((range) => ({ ...range, numberOfResults: 0 }))
        })
      );
      dispatch(fetchProductsActionCreator());
    },
    get state() {
      return getDateFacetState(coreController.state);
    },
    type: "dateRange"
  };
}
var getDateFacetState = (coreState) => {
  return {
    ...coreState,
    type: "dateRange"
  };
};

// src/controllers/commerce/core/facets/generator/headless-commerce-facet-generator.ts
var import_toolkit66 = require("@reduxjs/toolkit");
function buildFacetGenerator(engine, options) {
  if (!loadCommerceFacetGeneratorReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const createFacetControllers = (0, import_toolkit66.createSelector)(
    [
      (state) => state.facetOrder,
      (state) => state.commerceFacetSet
    ],
    (facetOrder, commerceFacetSet) => facetOrder.map(
      (facetId2) => createFacetController(commerceFacetSet, facetId2)
    )
  );
  const createFacetController = (0, import_toolkit66.createSelector)(
    (commerceFacetSet, facetId2) => ({
      facetId: facetId2,
      type: commerceFacetSet[facetId2].request.type
    }),
    ({ type, facetId: facetId2 }) => {
      switch (type) {
        case "dateRange":
          return options.buildDateFacet(engine, { facetId: facetId2 });
        case "hierarchical":
          return options.buildCategoryFacet(engine, { facetId: facetId2 });
        case "numericalRange":
          return options.buildNumericFacet(engine, { facetId: facetId2 });
        case "regular":
          return options.buildRegularFacet(engine, { facetId: facetId2 });
        case "location":
          return options.buildLocationFacet(engine, { facetId: facetId2 });
      }
    }
  );
  return {
    ...controller,
    deselectAll: () => {
      dispatch(clearAllCoreFacets());
      dispatch(options.fetchProductsActionCreator());
    },
    get facets() {
      return createFacetControllers(engine[stateKey]);
    },
    get state() {
      return engine[stateKey].facetOrder;
    }
  };
}
function loadCommerceFacetGeneratorReducers(engine) {
  engine.addReducers({ facetOrder: facetOrderReducer, commerceFacetSet: commerceFacetSetReducer });
  return true;
}

// src/controllers/commerce/core/facets/location/headless-commerce-location-facet.ts
function buildCommerceLocationFacet(engine, options) {
  const {
    toggleSingleExclude: _toggleSingleExclude,
    toggleExclude: _toggleExclude,
    isValueExcluded: _isValueExcluded,
    ...coreController
  } = buildCoreCommerceFacet(engine, {
    options: {
      ...options,
      toggleSelectActionCreator: toggleSelectLocationFacetValue
    }
  });
  return {
    ...coreController,
    get state() {
      return getLocationFacetState(coreController.state);
    },
    type: "location"
  };
}
var getLocationFacetState = (coreState) => {
  return {
    ...coreState,
    type: "location"
  };
};

// src/features/commerce/facets/numeric-facet/manual-numeric-facet-selectors.ts
var manualNumericFacetSelector = (state, facetId2) => state.manualNumericFacetSet[facetId2]?.manualRange;

// src/features/commerce/facets/numeric-facet/manual-numeric-facet-slice.ts
var import_toolkit67 = require("@reduxjs/toolkit");

// src/features/commerce/facets/numeric-facet/manual-numeric-facet-state.ts
function getManualNumericFacetInitialState() {
  return {};
}

// src/features/commerce/facets/numeric-facet/manual-numeric-facet-slice.ts
var manualNumericFacetReducer = (0, import_toolkit67.createReducer)(
  getManualNumericFacetInitialState(),
  (builder) => builder.addCase(updateManualNumericFacetRange, (state, action) => {
    const { facetId: facetId2, ...manualRange } = action.payload;
    state[facetId2] = { manualRange };
  }).addCase(toggleExcludeNumericFacetValue2, (state, action) => {
    clearManualRange(state, action.payload.facetId);
  }).addCase(toggleSelectNumericFacetValue2, (state, action) => {
    clearManualRange(state, action.payload.facetId);
  }).addCase(deselectAllValuesInCoreFacet, (state, action) => {
    clearManualRange(state, action.payload.facetId);
  }).addCase(restoreSearchParameters2, (state, action) => {
    restoreParameters(state, action.payload.mnf);
  }).addCase(restoreProductListingParameters, (state, action) => {
    restoreParameters(state, action.payload.mnf);
  }).addCase(clearAllCoreFacets, (state) => {
    for (const facetId2 of Object.keys(state)) {
      clearManualRange(state, facetId2);
    }
  })
);
var clearManualRange = (state, facetId2) => {
  if (state[facetId2]) {
    state[facetId2] = { manualRange: void 0 };
  }
};
var restoreParameters = (state, payload) => {
  for (const facetId2 of Object.keys(state)) {
    delete state[facetId2];
  }
  if (payload) {
    Object.entries(payload).forEach(([facetId2, manualRange]) => {
      const range = manualRange[0];
      state[facetId2] = { manualRange: range };
    });
  }
};

// src/controllers/commerce/core/facets/numeric/headless-commerce-numeric-facet.ts
function buildCommerceNumericFacet(engine, options) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options,
      toggleSelectActionCreator: toggleSelectNumericFacetValue2,
      toggleExcludeActionCreator: toggleExcludeNumericFacetValue2
    }
  });
  if (!loadCommerceNumericFacetReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const { facetId: facetId2, fetchProductsActionCreator } = options;
  return {
    ...coreController,
    // Only one range stored, so last will override the previous ones
    setRanges(ranges) {
      ranges.forEach((range) => {
        dispatch(updateManualNumericFacetRange({ facetId: facetId2, ...range }));
      });
      dispatch(fetchProductsActionCreator());
    },
    get state() {
      const response = options.facetResponseSelector(engine[stateKey], facetId2);
      return getNumericFacetState(
        coreController.state,
        response?.type === "numericalRange" ? response : void 0,
        manualNumericFacetSelector(engine[stateKey], facetId2)
      );
    },
    type: "numericalRange"
  };
}
function loadCommerceNumericFacetReducers(engine) {
  engine.addReducers({ manualNumericFacetSet: manualNumericFacetReducer });
  return true;
}
var getNumericFacetState = (coreState, facetResponseSelector3, manualFacetRangeSelector) => {
  const response = facetResponseSelector3?.type === "numericalRange" ? facetResponseSelector3 : void 0;
  return {
    ...coreState,
    ...response?.domain && {
      domain: {
        min: response.domain.min,
        max: response.domain.max
      }
    },
    ...manualFacetRangeSelector && { manualRange: manualFacetRangeSelector },
    type: "numericalRange"
  };
};

// src/features/facets/facet-search-set/specific/specific-facet-search-state-selector.ts
var import_toolkit68 = require("@reduxjs/toolkit");
var specificFacetSearchStateSelector = (0, import_toolkit68.createSelector)(
  (state, facetId2) => ({
    facetSearchSelector: state.facetSearchSet[facetId2]
  }),
  ({ facetSearchSelector }) => {
    return facetSearchSelector;
  }
);

// src/features/facets/facet-search-set/specific/specific-facet-search-set-slice.ts
var import_toolkit69 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/specific/specific-facet-search-set-state.ts
function getFacetSearchSetInitialState() {
  return {};
}

// src/features/facets/facet-search-set/specific/specific-facet-search-set-slice.ts
var specificFacetSearchSetReducer = (0, import_toolkit69.createReducer)(
  getFacetSearchSetInitialState(),
  (builder) => {
    builder.addCase(registerFacetSearch, (state, action) => {
      const payload = action.payload;
      handleFacetSearchRegistration(state, payload, buildEmptyResponse2);
    }).addCase(updateFacetSearch, (state, action) => {
      handleFacetSearchUpdate(state, action.payload);
    }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(facetId2),
        action.meta.requestId
      );
    }).addCase(executeFacetSearch.pending, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(facetId2)
      );
    }).addCase(executeFacetSearch.rejected, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
      handleCommerceFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
      handleCommerceFacetFieldSuggestionsFulfilled(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse2
      );
    }).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
      handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse2
      );
    }).addCase(executeFacetSearch.fulfilled, (state, action) => {
      handleFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(clearFacetSearch, (state, { payload }) => {
      handleFacetSearchClear(state, payload, buildEmptyResponse2);
    }).addCase(executeSearch2.fulfilled, (state) => {
      handleFacetSearchSetClear(state, buildEmptyResponse2);
    }).addCase(
      fetchProductListing.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)
    ).addCase(
      executeSearch3.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)
    ).addCase(
      setView,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)
    );
  }
);
function buildEmptyResponse2() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}

// src/controllers/core/facets/facet-search/specific/headless-facet-search.ts
function buildFacetSearch(engine, props) {
  const { dispatch } = engine;
  const {
    options,
    select: propsSelect,
    exclude: propsExclude,
    isForFieldSuggestions,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  } = props;
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => "state" in engine ? engine.state.facetSearchSet[facetId2] : engine[stateKey].facetSearchSet[facetId2];
  dispatch(registerFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    /**
     * Selects the provided value.
     * @param result A single specificFacetSearchResult object
     */
    select(value) {
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value.
     * @param result A single specificFacetSearchResult object
     */
    exclude(value) {
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    /**
     * Selects the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleSelect(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleExclude(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    get state() {
      const { values } = genericFacetSearch.state;
      return {
        ...genericFacetSearch.state,
        values: values.map(({ count, displayValue, rawValue }) => ({
          count,
          displayValue,
          rawValue
        }))
      };
    }
  };
}

// src/controllers/commerce/core/facets/regular/headless-commerce-regular-facet-search.ts
function buildRegularFacetSearch(engine, props) {
  if (!loadRegularFacetSearchReducers(engine)) {
    throw loadReducerError;
  }
  const {
    state: _state,
    updateCaptions: _updateCaptions,
    ...restOfFacetSearch
  } = buildFacetSearch(engine, {
    ...props,
    executeFacetSearchActionCreator: (facetId2) => executeCommerceFacetSearch({
      facetId: facetId2,
      facetSearchType: props.options.type
    }),
    executeFieldSuggestActionCreator: (facetId2) => executeCommerceFieldSuggest({
      facetId: facetId2,
      facetSearchType: props.options.type
    })
  });
  return {
    ...restOfFacetSearch
  };
}
function loadRegularFacetSearchReducers(engine) {
  engine.addReducers({ facetSearchSet: specificFacetSearchSetReducer });
  return true;
}

// src/controllers/commerce/core/facets/regular/headless-commerce-regular-facet.ts
function buildCommerceRegularFacet(engine, options) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options,
      toggleSelectActionCreator: toggleSelectFacetValue2,
      toggleExcludeActionCreator: toggleExcludeFacetValue2
    }
  });
  const getFacetId = () => coreController.state.facetId;
  const { dispatch } = engine;
  const facetSearch2 = buildRegularFacetSearch(engine, {
    options: { facetId: getFacetId(), ...options.facetSearch },
    select: () => {
      dispatch(options.fetchProductsActionCreator());
    },
    exclude: () => {
      dispatch(options.fetchProductsActionCreator());
    },
    isForFieldSuggestions: false
  });
  return {
    ...coreController,
    facetSearch: facetSearch2,
    get state() {
      return getRegularFacetState(
        coreController.state,
        specificFacetSearchStateSelector(engine[stateKey], getFacetId())
      );
    },
    type: "regular"
  };
}
var getRegularFacetState = (coreState, facetSearchSelector) => {
  return {
    ...coreState,
    facetSearch: {
      isLoading: facetSearchSelector?.isLoading ?? false,
      moreValuesAvailable: facetSearchSelector?.response.moreValuesAvailable ?? false,
      query: facetSearchSelector?.options.query ?? "",
      values: facetSearchSelector?.response.values ?? []
    },
    type: "regular"
  };
};

// src/features/commerce/product/product-actions.ts
var import_toolkit70 = require("@reduxjs/toolkit");

// src/features/commerce/context/context-selector.ts
function getCurrency(state) {
  return state.currency;
}

// src/features/commerce/product/product-actions.ts
var productView = (0, import_toolkit70.createAsyncThunk)("commerce/product/view", async (payload, { extra, getState }) => {
  const { relay } = extra;
  const currency = getCurrency(getState().commerceContext);
  const relayPayload = { currency, product: payload };
  relay.emit("ec.productView", relayPayload);
});
var productClick = (0, import_toolkit70.createAsyncThunk)(
  "commerce/product/click",
  async (payload, { extra, getState }) => {
    const { relay } = extra;
    const currency = getCurrency(getState().commerceContext);
    const relayPayload = { currency, ...payload };
    relay.emit("ec.productClick", relayPayload);
  }
);

// src/controllers/core/interactive-result/headless-core-interactive-result.ts
function buildInteractiveResultCore(engine, props, action) {
  if (!loadInteractiveResultCoreReducers(engine)) {
    throw loadReducerError;
  }
  const defaultDelay = 1e3;
  const options = {
    selectionDelay: defaultDelay,
    debounceWait: defaultDelay,
    ...props.options
  };
  let longPressTimer;
  return {
    select: debounce(action, options.debounceWait, { isImmediate: true }),
    beginDelayedSelect() {
      longPressTimer = setTimeout(action, options.selectionDelay);
    },
    cancelPendingSelect() {
      longPressTimer && clearTimeout(longPressTimer);
    }
  };
}
function loadInteractiveResultCoreReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}

// src/controllers/commerce/core/interactive-product/headless-core-interactive-product.ts
function buildCoreInteractiveProduct(engine, props) {
  let wasOpened = false;
  const getWarningMessage = () => {
    const messageSegment = (property, lookupFields, fallback) => `- Could not retrieve '${property}' analytics property from field${lookupFields.length > 1 ? "s" : ""} '${lookupFields.join("', '")}'; fell back to ${fallback}.`;
    const warnings = [];
    const { ec_name, ec_promo_price, ec_price, ec_product_id } = props.options.product;
    if (!ec_name) {
      warnings.push(messageSegment("name", ["ec_gender"], "permanentid"));
    }
    if (!ec_promo_price && !ec_price) {
      warnings.push(
        messageSegment("price", ["ec_promo_price", "ec_price"], "NaN")
      );
    }
    if (!ec_product_id) {
      warnings.push(
        messageSegment("productId", ["ec_product_id"], "permanentid")
      );
    }
    if (warnings.length === 0) {
      return;
    }
    return `Some required analytics properties could not be retrieved from the expected fields for product with permanentid '${props.options.product.permanentid}':

${warnings.join("\n")}

Review the configuration of the above 'ec_'-prefixed fields in your index, and make sure they contain the correct metadata.`;
  };
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(
      productClick({
        product: {
          name: props.options.product.ec_name ?? props.options.product.permanentid,
          price: props.options.product.ec_promo_price ?? props.options.product.ec_price ?? NaN,
          productId: props.options.product.ec_product_id ?? props.options.product.permanentid
        },
        position: props.options.product.position,
        responseId: props.options.product.responseId ?? props.responseIdSelector(engine[stateKey])
      })
    );
  };
  return {
    ...buildInteractiveResultCore(engine, props, logAnalyticsIfNeverOpened),
    warningMessage: getWarningMessage()
  };
}

// src/features/commerce/spotlight-content/spotlight-content-actions.ts
var import_toolkit71 = require("@reduxjs/toolkit");
var spotlightContentClick = (0, import_toolkit71.createAsyncThunk)(
  "commerce/spotlight-content/click",
  async (payload, { extra }) => {
    const { relay } = extra;
    const relayPayload = {
      responseId: payload.responseId,
      position: payload.position,
      itemMetadata: {
        uniqueFieldName: "id",
        uniqueFieldValue: payload.id,
        url: payload.desktopImage
      }
    };
    relay.emit("itemClick", relayPayload);
  }
);

// src/controllers/commerce/core/interactive-spotlight-content/headless-core-interactive-spotlight-content.ts
function buildCoreInteractiveSpotlightContent(engine, props) {
  let wasOpened = false;
  const getWarningMessage = () => {
    const { id: id2, desktopImage } = props.options.spotlightContent;
    const warnings = [];
    if (!id2) {
      warnings.push(
        "- Could not retrieve 'id' property from spotlight content; this is required for analytics."
      );
    }
    if (!desktopImage) {
      warnings.push(
        "- Could not retrieve 'desktopImage' property from spotlight content; this is required for analytics."
      );
    }
    if (warnings.length === 0) {
      return;
    }
    return `Some required analytics properties could not be retrieved from the spotlight content with id '${id2}':

${warnings.join("\n")}

Review the configuration to ensure the spotlight content contains the correct metadata.`;
  };
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(
      spotlightContentClick({
        id: props.options.spotlightContent.id,
        desktopImage: props.options.spotlightContent.desktopImage,
        position: props.options.spotlightContent.position,
        responseId: props.options.spotlightContent.responseId ?? props.responseIdSelector(engine[stateKey])
      })
    );
  };
  return {
    ...buildInteractiveResultCore(engine, props, logAnalyticsIfNeverOpened),
    warningMessage: getWarningMessage()
  };
}

// src/controllers/commerce/core/pagination/headless-core-commerce-pagination.ts
var import_bueno68 = require("@coveo/bueno");
var import_toolkit76 = require("@reduxjs/toolkit");

// src/features/commerce/pagination/pagination-slice.ts
var import_toolkit75 = require("@reduxjs/toolkit");

// src/features/commerce/recommendations/recommendations-actions.ts
var import_bueno66 = require("@coveo/bueno");
var import_toolkit73 = require("@reduxjs/toolkit");

// src/features/commerce/recommendations/recommendations.ts
var import_bueno64 = require("@coveo/bueno");
var recommendationsSlotDefinition = {
  slotId: requiredNonEmptyString,
  productId: new import_bueno64.StringValue({ required: false, emptyAllowed: false })
};
var recommendationsOptionsSchema = new import_bueno64.Schema(
  recommendationsSlotDefinition
);

// src/features/commerce/recommendations/recommendations-selectors.ts
var import_bueno65 = require("@coveo/bueno");
var import_toolkit72 = require("@reduxjs/toolkit");
var numberOfRecommendationsSelector = (state, slotId) => state.recommendations ? state.recommendations[slotId]?.products.length || 0 : 0;
var moreRecommendationsAvailableSelector = (0, import_toolkit72.createSelector)(
  (state, slotId) => ({
    total: totalEntriesRecommendationSelector(state, slotId),
    current: numberOfRecommendationsSelector(state, slotId)
  }),
  ({ current, total }) => current < total
);
var isLoadingSelector3 = (state, slotId) => {
  const isLoading = state.recommendations ? state.recommendations[slotId]?.isLoading : false;
  return (0, import_bueno65.isNullOrUndefined)(isLoading) ? false : isLoading;
};

// src/features/commerce/recommendations/recommendations-actions.ts
var buildRecommendationCommerceAPIRequest = (slotId, state, navigatorContext, productId) => {
  const commerceAPIRequest = buildPaginatedCommerceAPIRequest(
    state,
    navigatorContext,
    slotId
  );
  return {
    ...commerceAPIRequest,
    context: {
      ...commerceAPIRequest.context,
      ...productId ? { product: { productId } } : {},
      purchased: getProductsFromCartPurchasedState(state.cart)
    },
    slotId
  };
};
var fetchRecommendations = (0, import_toolkit73.createAsyncThunk)(
  "commerce/recommendations/fetch",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const { slotId, productId } = payload;
    const request = buildRecommendationCommerceAPIRequest(
      slotId,
      getState(),
      navigatorContext,
      productId
    );
    const fetched = await apiClient.getRecommendations(request);
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var fetchMoreRecommendations = (0, import_toolkit73.createAsyncThunk)(
  "commerce/recommendations/fetchMore",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const slotId = payload.slotId;
    const state = getState();
    const moreRecommendationsAvailable = moreRecommendationsAvailableSelector(
      state,
      slotId
    );
    if (!moreRecommendationsAvailable === false) {
      return null;
    }
    const perPage = perPageRecommendationSelector(state, slotId);
    const numberOfProducts = numberOfRecommendationsSelector(state, slotId);
    const nextPageToRequest = numberOfProducts / perPage;
    const request = {
      ...buildRecommendationCommerceAPIRequest(slotId, state, navigatorContext),
      page: nextPageToRequest
    };
    const fetched = await apiClient.getRecommendations(request);
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var registerRecommendationsSlot = (0, import_toolkit73.createAction)(
  "commerce/recommendations/registerSlot",
  (payload) => validatePayload(payload, recommendationsSlotDefinition)
);
var promoteChildToParentDefinition3 = {
  child: new import_bueno66.RecordValue({
    options: { required: true },
    values: {
      permanentid: new import_bueno66.StringValue({ required: true })
    }
  }),
  ...recommendationsSlotDefinition
};
var promoteChildToParent3 = (0, import_toolkit73.createAction)(
  "commerce/recommendations/promoteChildToParent",
  (payload) => validatePayload(payload, promoteChildToParentDefinition3)
);

// src/features/commerce/sort/sort-actions.ts
var import_bueno67 = require("@coveo/bueno");
var import_toolkit74 = require("@reduxjs/toolkit");
var applySort = (0, import_toolkit74.createAction)(
  "commerce/sort/apply",
  (payload) => validatePayload(payload, {
    by: new import_bueno67.EnumValue({
      enum: SortBy,
      required: true
    })
  })
);

// src/features/commerce/pagination/pagination-slice.ts
var paginationReducer = (0, import_toolkit75.createReducer)(
  getCommercePaginationInitialState(),
  (builder) => {
    builder.addCase(nextPage2, (state, action) => {
      const slice = getEffectiveSlice(state, action.payload?.slotId);
      if (!slice) {
        return;
      }
      if (slice.page < slice.totalPages - 1) {
        ++slice.page;
      }
    }).addCase(previousPage2, (state, action) => {
      const slice = getEffectiveSlice(state, action.payload?.slotId);
      if (!slice) {
        return;
      }
      if (slice.page > 0) {
        --slice.page;
      }
    }).addCase(selectPage, (state, action) => {
      const slice = getEffectiveSlice(state, action.payload.slotId);
      if (!slice) {
        return;
      }
      if (action.payload.page >= 0 && action.payload.page < slice.totalPages) {
        slice.page = action.payload.page;
      }
    }).addCase(setPageSize, (state, action) => {
      const slice = getEffectiveSlice(state, action.payload.slotId);
      if (!slice) {
        return;
      }
      slice.page = 0;
      slice.perPage = action.payload.pageSize;
    }).addCase(fetchProductListing.fulfilled, (state, action) => {
      state.principal = action.payload.response.pagination;
    }).addCase(executeSearch3.fulfilled, (state, action) => {
      state.principal = action.payload.response.pagination;
    }).addCase(fetchRecommendations.fulfilled, (state, action) => {
      state.recommendations[action.meta.arg.slotId] = action.payload.response.pagination;
    }).addCase(registerRecommendationsSlotPagination, (state, action) => {
      const slotId = action.payload.slotId;
      if (slotId in state.recommendations) {
        return;
      }
      state.recommendations[slotId] = getCommercePaginationInitialSlice();
    }).addCase(clearAllCoreFacets, handlePaginationReset).addCase(deselectAllValuesInCoreFacet, handlePaginationReset).addCase(toggleSelectFacetValue2, handlePaginationReset).addCase(toggleExcludeFacetValue2, handlePaginationReset).addCase(toggleSelectLocationFacetValue, handlePaginationReset).addCase(toggleSelectNumericFacetValue2, handlePaginationReset).addCase(toggleExcludeNumericFacetValue2, handlePaginationReset).addCase(toggleSelectDateFacetValue2, handlePaginationReset).addCase(toggleExcludeDateFacetValue2, handlePaginationReset).addCase(toggleSelectCategoryFacetValue2, handlePaginationReset).addCase(applySort, handlePaginationReset).addCase(setContext, handlePaginationReset).addCase(setView, handlePaginationReset).addCase(restoreSearchParameters2, handleRestoreParameters2).addCase(restoreProductListingParameters, handleRestoreParameters2);
  }
);
function getEffectiveSlice(state, solutionTypeId) {
  return solutionTypeId ? state.recommendations[solutionTypeId] : state.principal;
}
function handlePaginationReset(state) {
  state.principal.page = getCommercePaginationInitialSlice().page;
}
function handleRestoreParameters2(state, action) {
  if (action.payload.page) {
    state.principal.page = action.payload.page;
  } else {
    state.principal.page = getCommercePaginationInitialSlice().page;
  }
  if (action.payload.perPage) {
    state.principal.perPage = action.payload.perPage;
  }
}

// src/controllers/commerce/core/pagination/headless-core-commerce-pagination.ts
var optionsSchema = new import_bueno68.Schema({
  pageSize: new import_bueno68.NumberValue({ min: 1, max: 1e3, required: false })
});
function buildCorePagination(engine, props) {
  if (!loadPaginationReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  validateOptions(engine, optionsSchema, props.options, "buildCorePagination");
  const slotId = props.options?.slotId;
  if (props.options?.pageSize) {
    dispatch(
      setPageSize({
        slotId,
        pageSize: props.options.pageSize
      })
    );
  }
  if (slotId) {
    dispatch(registerRecommendationsSlotPagination({ slotId }));
  }
  const paginationSelector = (0, import_toolkit76.createSelector)(
    (state) => slotId ? state.commercePagination.recommendations[slotId] : state.commercePagination.principal,
    ({ perPage, ...rest }) => ({
      pageSize: perPage ?? 0,
      ...rest
    })
  );
  return {
    ...controller,
    get state() {
      return paginationSelector(engine[stateKey]);
    },
    selectPage(page) {
      dispatch(
        selectPage({
          slotId,
          page
        })
      );
      dispatch(props.fetchProductsActionCreator());
    },
    nextPage() {
      dispatch(nextPage2({ slotId }));
      dispatch(props.fetchProductsActionCreator());
    },
    previousPage() {
      dispatch(previousPage2({ slotId }));
      dispatch(props.fetchProductsActionCreator());
    },
    setPageSize(pageSize) {
      dispatch(setPageSize({ slotId, pageSize }));
      dispatch(props.fetchProductsActionCreator());
    },
    fetchMoreProducts() {
      dispatch(props.fetchMoreProductsActionCreator());
    }
  };
}
function loadPaginationReducers(engine) {
  engine.addReducers({
    commercePagination: paginationReducer
  });
  return true;
}

// src/controllers/commerce/core/parameter-manager/headless-core-parameter-manager.ts
var import_bueno69 = require("@coveo/bueno");

// src/features/commerce/parameters/parameters-slice.ts
var import_toolkit77 = require("@reduxjs/toolkit");

// src/features/commerce/parameters/parameters-state.ts
function getCommerceParametersInitialState() {
  return {};
}

// src/features/commerce/parameters/parameters-slice.ts
var parametersReducer = (0, import_toolkit77.createReducer)(
  getCommerceParametersInitialState(),
  (builder) => {
    builder.addCase(
      nextPage2,
      (state, action) => handleNextPage(state, action.payload)
    ).addCase(
      previousPage2,
      (state, action) => handlePreviousPage(state, action.payload)
    ).addCase(
      selectPage,
      (state, action) => handleSelectPage(state, action.payload)
    ).addCase(
      setPageSize,
      (state, action) => handleSetPageSize(state, action.payload)
    ).addCase(
      applySort,
      (state, action) => handleApplySort(state, action.payload)
    ).addCase(
      updateQuery2,
      (state, action) => handleUpdateQuery(state, action.payload)
    ).addCase(clearAllCoreFacets, (state) => handleClearAllCoreFacets(state)).addCase(deleteAllCoreFacets, (state) => handleClearAllCoreFacets(state)).addCase(
      deselectAllValuesInCoreFacet,
      (state, action) => handleDeselectAllValuesInCoreFacet(state, action.payload)
    ).addCase(
      toggleSelectCategoryFacetValue2,
      (state, action) => handleToggleCategoryFacetValue(state, action.payload)
    ).addCase(
      selectCategoryFacetSearchResult,
      (state, action) => handleSelectCategoryFacetSearchResult(state, action)
    ).addCase(
      toggleSelectFacetValue2,
      (state, action) => handleToggleSelectFacetValue(state, action.payload)
    ).addCase(
      toggleExcludeFacetValue2,
      (state, action) => handleToggleExcludeFacetValue(state, action.payload)
    ).addCase(
      selectFacetSearchResult,
      (state, action) => handleSelectFacetSearchResult(state, action)
    ).addCase(
      excludeFacetSearchResult,
      (state, action) => handleExcludeFacetSearchResult(state, action)
    ).addCase(
      toggleSelectNumericFacetValue2,
      (state, action) => handleToggleSelectNumericFacetValue(state, action.payload)
    ).addCase(
      toggleExcludeNumericFacetValue2,
      (state, action) => handleToggleExcludeNumericFacetValue(state, action.payload)
    ).addCase(
      updateManualNumericFacetRange,
      (state, action) => handleUpdateManualNumericFacetRange(state, action.payload)
    ).addCase(
      toggleSelectDateFacetValue2,
      (state, action) => handleToggleSelectDateFacetValue(state, action.payload)
    ).addCase(
      toggleExcludeDateFacetValue2,
      (state, action) => handleToggleExcludeDateFacetValue(state, action.payload)
    ).addCase(
      toggleSelectLocationFacetValue,
      (state, action) => handleToggleSelectLocationFacetValue(state, action.payload)
    ).addCase(setView, getCommerceParametersInitialState).addCase(restoreProductListingParameters, (state, action) => {
      state = action.payload;
      return state;
    }).addCase(restoreSearchParameters2, (state, action) => {
      state = action.payload;
      return state;
    });
  }
);
var handleNextPage = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  if (state.page !== void 0) {
    state.page++;
    return;
  }
  state.page = 1;
};
var handlePreviousPage = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  if (state.page !== void 0 && state.page > 1) {
    state.page--;
    return;
  }
  state.page = void 0;
};
var handleSelectPage = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  state.page = payload.page > 0 ? payload.page : void 0;
};
var handleSetPageSize = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  state.page = void 0;
  if (payload.pageSize === 0) {
    state.perPage = void 0;
    return;
  }
  state.perPage = payload.pageSize;
};
var handleApplySort = (state, payload) => {
  state.page = void 0;
  state.sortCriteria = payload;
};
var handleUpdateQuery = (state, payload) => {
  state.page = void 0;
  const { query: query2 } = payload;
  if (query2 === void 0 || query2.trim() === "") {
    state.q = void 0;
    return;
  }
  state.q = query2;
};
var handleClearAllCoreFacets = (state) => {
  state.page = void 0;
  state.cf = void 0;
  state.df = void 0;
  state.dfExcluded = void 0;
  state.lf = void 0;
  state.mnf = void 0;
  state.mnfExcluded = void 0;
  state.nf = void 0;
  state.nfExcluded = void 0;
  state.f = void 0;
  state.fExcluded = void 0;
};
var handleDeselectAllValuesInCoreFacet = (state, payload) => {
  const { facetId: facetId2 } = payload;
  state.page = void 0;
  if (state.cf) {
    delete state.cf[facetId2];
    Object.keys(state.cf).length === 0 && delete state.cf;
  }
  if (state.df) {
    delete state.df[facetId2];
    Object.keys(state.df).length === 0 && delete state.df;
  }
  if (state.dfExcluded) {
    delete state.dfExcluded[facetId2];
    Object.keys(state.dfExcluded).length === 0 && delete state.dfExcluded;
  }
  if (state.lf) {
    delete state.lf[facetId2];
    Object.keys(state.lf).length === 0 && delete state.lf;
  }
  if (state.mnf) {
    delete state.mnf[facetId2];
    Object.keys(state.mnf).length === 0 && delete state.mnf;
  }
  if (state.mnfExcluded) {
    delete state.mnfExcluded[facetId2];
    Object.keys(state.mnfExcluded).length === 0 && delete state.mnfExcluded;
  }
  if (state.nf) {
    delete state.nf[facetId2];
    Object.keys(state.nf).length === 0 && delete state.nf;
  }
  if (state.nfExcluded) {
    delete state.nfExcluded[facetId2];
    Object.keys(state.nfExcluded).length === 0 && delete state.nfExcluded;
  }
  if (state.f) {
    delete state.f[facetId2];
    Object.keys(state.f).length === 0 && delete state.f;
  }
  if (state.fExcluded) {
    delete state.fExcluded[facetId2];
    Object.keys(state.fExcluded).length === 0 && delete state.fExcluded;
  }
};
var handleToggleCategoryFacetValue = (state, payload) => {
  state.page = void 0;
  if (payload.selection.state === "selected") {
    state.cf ?? (state.cf = {});
    delete state.cf[payload.facetId];
    if (Object.keys(state.cf).length === 0) {
      state.cf = void 0;
    }
    return;
  }
  state.cf ?? (state.cf = {});
  state.cf[payload.facetId] = payload.selection.path;
};
var handleSelectCategoryFacetSearchResult = (state, action) => {
  const payload = action.payload;
  state.page = void 0;
  state.cf ?? (state.cf = {});
  state.cf[payload.facetId] = [...payload.value.path, payload.value.rawValue];
};
var handleToggleSelectFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRegularValue(
    state,
    "fExcluded",
    state.fExcluded,
    payload.facetId,
    payload.selection.value
  );
  switch (payload.selection.state) {
    case "selected":
      unsetRegularValue(
        state,
        "f",
        state.f,
        payload.facetId,
        payload.selection.value
      );
      break;
    case "excluded":
    case "idle":
      state.f ?? (state.f = {});
      state.f[payload.facetId] = [
        ...state.f[payload.facetId] ?? [],
        payload.selection.value
      ];
      break;
  }
};
var handleSelectFacetSearchResult = (state, action) => {
  const payload = action.payload;
  state.page = void 0;
  unsetRegularValue(
    state,
    "fExcluded",
    state.fExcluded,
    payload.facetId,
    payload.value.rawValue
  );
  state.f ?? (state.f = {});
  state.f[payload.facetId] = [
    ...state.f[payload.facetId] ?? [],
    payload.value.rawValue
  ];
};
var handleToggleExcludeFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRegularValue(
    state,
    "f",
    state.f,
    payload.facetId,
    payload.selection.value
  );
  switch (payload.selection.state) {
    case "excluded":
      unsetRegularValue(
        state,
        "fExcluded",
        state.fExcluded,
        payload.facetId,
        payload.selection.value
      );
      break;
    case "selected":
    case "idle":
      state.fExcluded ?? (state.fExcluded = {});
      state.fExcluded[payload.facetId] = [
        ...state.fExcluded[payload.facetId] ?? [],
        payload.selection.value
      ];
      break;
  }
};
var handleExcludeFacetSearchResult = (state, action) => {
  const payload = action.payload;
  state.page = void 0;
  unsetRegularValue(
    state,
    "f",
    state.f,
    payload.facetId,
    payload.value.rawValue
  );
  state.fExcluded ?? (state.fExcluded = {});
  state.fExcluded[payload.facetId] = [
    ...state.fExcluded[payload.facetId] ?? [],
    payload.value.rawValue
  ];
};
var handleToggleSelectNumericFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload.selection);
  unsetRangeValue(
    state,
    "mnfExcluded",
    state.mnfExcluded,
    payload.facetId,
    payload.selection
  );
  unsetRangeValue(
    state,
    "nfExcluded",
    state.nfExcluded,
    payload.facetId,
    payload.selection
  );
  switch (payload.selection.state) {
    case "selected":
      unsetRangeValue(
        state,
        "nf",
        state.nf,
        payload.facetId,
        payload.selection
      );
      break;
    case "excluded":
    case "idle":
      state.nf ?? (state.nf = {});
      state.nf[payload.facetId] = [
        ...state.nf[payload.facetId] ?? [],
        payload.selection
      ];
      break;
    default:
      break;
  }
};
var handleToggleExcludeNumericFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload.selection);
  unsetRangeValue(
    state,
    "mnfExcluded",
    state.mnfExcluded,
    payload.facetId,
    payload.selection
  );
  unsetRangeValue(state, "nf", state.nf, payload.facetId, payload.selection);
  switch (payload.selection.state) {
    case "excluded":
      unsetRangeValue(
        state,
        "nfExcluded",
        state.nfExcluded,
        payload.facetId,
        payload.selection
      );
      break;
    case "selected":
    case "idle":
      state.nfExcluded ?? (state.nfExcluded = {});
      state.nfExcluded[payload.facetId] = [
        ...state.nfExcluded[payload.facetId] ?? [],
        payload.selection
      ];
      break;
    default:
      break;
  }
};
var handleUpdateManualNumericFacetRange = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "nf", state.nf, payload.facetId, payload);
  unsetRangeValue(
    state,
    "nfExcluded",
    state.nfExcluded,
    payload.facetId,
    payload
  );
  const { facetId: _facetId, ...restOfPayload } = payload;
  switch (payload.state) {
    case "idle":
      unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload);
      unsetRangeValue(
        state,
        "mnfExcluded",
        state.mnfExcluded,
        payload.facetId,
        payload
      );
      break;
    case "excluded":
      unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload);
      state.mnfExcluded ?? (state.mnfExcluded = {});
      state.mnfExcluded[payload.facetId] = [restOfPayload];
      break;
    case "selected":
      unsetRangeValue(
        state,
        "mnfExcluded",
        state.mnfExcluded,
        payload.facetId,
        payload
      );
      state.mnf ?? (state.mnf = {});
      state.mnf[payload.facetId] = [restOfPayload];
      break;
    default:
      break;
  }
};
var handleToggleSelectDateFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(
    state,
    "dfExcluded",
    state.dfExcluded,
    payload.facetId,
    payload.selection
  );
  const { numberOfResults: _numberOfResults, ...restOfPayload } = payload.selection;
  switch (payload.selection.state) {
    case "selected":
      unsetRangeValue(
        state,
        "df",
        state.df,
        payload.facetId,
        payload.selection
      );
      break;
    case "excluded":
    case "idle":
      state.df ?? (state.df = {});
      state.df[payload.facetId] = [
        ...state.df[payload.facetId] ?? [],
        restOfPayload
      ];
      break;
    default:
      break;
  }
};
var handleToggleExcludeDateFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "df", state.df, payload.facetId, payload.selection);
  const { numberOfResults: _numberOfResults, ...restOfPayload } = payload.selection;
  switch (payload.selection.state) {
    case "excluded":
      unsetRangeValue(
        state,
        "dfExcluded",
        state.dfExcluded,
        payload.facetId,
        payload.selection
      );
      break;
    case "selected":
    case "idle":
      state.dfExcluded ?? (state.dfExcluded = {});
      state.dfExcluded[payload.facetId] = [
        ...state.dfExcluded[payload.facetId] ?? [],
        restOfPayload
      ];
      break;
    default:
      break;
  }
};
var handleToggleSelectLocationFacetValue = (state, payload) => {
  state.page = void 0;
  switch (payload.selection.state) {
    case "selected":
      unsetRegularValue(
        state,
        "lf",
        state.lf,
        payload.facetId,
        payload.selection.value
      );
      break;
    case "excluded":
    case "idle":
      state.lf ?? (state.lf = {});
      state.lf[payload.facetId] = [
        ...state.lf[payload.facetId] ?? [],
        payload.selection.value
      ];
      break;
  }
};
var unsetRegularValue = (state, stateKey2, stateParameter, facetId2, selection) => {
  if (stateParameter !== void 0 && stateParameter[facetId2] !== void 0) {
    stateParameter[facetId2] = stateParameter[facetId2].filter(
      (value) => value !== selection
    );
    if (stateParameter[facetId2].length === 0) {
      delete stateParameter[facetId2];
    }
    if (Object.keys(stateParameter).length === 0) {
      state[stateKey2] = void 0;
    }
  }
};
var unsetRangeValue = (state, stateKey2, stateParameter, facetId2, selection) => {
  if (stateParameter !== void 0 && stateParameter[facetId2] !== void 0) {
    const filtered = stateParameter[facetId2].filter(
      (value) => value.start !== selection.start || value.end !== selection.end || value.endInclusive !== selection.endInclusive
    );
    stateParameter[facetId2] = filtered;
    if (stateParameter[facetId2].length === 0) {
      delete stateParameter[facetId2];
    }
    if (Object.keys(stateParameter).length === 0) {
      state[stateKey2] = void 0;
    }
  }
};

// src/utils/compare-utils.ts
var import_fast_equals = require("fast-equals");
function arrayEqual(firstArray, secondArray, isEqual = (first, second) => first === second) {
  return firstArray.length === secondArray.length && firstArray.findIndex((val, i) => !isEqual(secondArray[i], val)) === -1;
}
function checkUnionEquality(set1, set2) {
  const unionSet = /* @__PURE__ */ new Set([...set1, ...set2]);
  return unionSet.size === set1.size && unionSet.size === set2.size;
}
function arrayEqualAnyOrder(firstArray, secondArray) {
  if (firstArray.length !== secondArray.length) {
    return false;
  }
  return firstArray.every(
    (firstVal) => secondArray.findIndex(
      (secondVal) => deepEqualAnyOrder(firstVal, secondVal)
    ) !== -1
  );
}
var arrayEqualStrictlyDifferentOrder = (firstArray, secondArray) => {
  const set1 = new Set(firstArray);
  const set2 = new Set(secondArray);
  if (set1.size !== set2.size) {
    return false;
  }
  if (set1.size === 1) {
    return firstArray[0] === secondArray[0];
  }
  if (checkUnionEquality(set1, set2)) {
    const arr1 = [...set1];
    const arr2 = [...set2];
    return !arr1.every((value, idx) => arr2[idx] === value);
  }
  return false;
};
var deepEqualAnyOrder = (0, import_fast_equals.createCustomEqual)({
  createCustomConfig: (config) => {
    return {
      ...config,
      areArraysEqual: arrayEqualAnyOrder
    };
  }
});

// src/controllers/commerce/core/parameter-manager/headless-core-parameter-manager.ts
var initialStateSchema = (parametersDefinition2) => new import_bueno69.Schema({
  parameters: new import_bueno69.RecordValue({
    options: { required: true },
    values: parametersDefinition2
  })
});
function buildCoreParameterManager(engine, props) {
  if (props.excludeDefaultParameters && !loadParameterManagerReducers(engine)) {
    throw loadReducerError;
  }
  const parametersSelector = (state) => state.commerceParameters;
  const { dispatch } = engine;
  const controller = buildController(engine);
  if (props.initialState) {
    validateInitialState(
      engine,
      initialStateSchema(props.parametersDefinition),
      props.initialState,
      "buildCoreParameterManager"
    );
    dispatch(props.restoreActionCreator(props.initialState.parameters));
  }
  return {
    ...controller,
    synchronize(parameters) {
      const activeParams = props.activeParametersSelector(engine[stateKey]);
      if (Object.keys(parameters).length > 0 && deepEqualAnyOrder(activeParams, parameters)) {
        return;
      }
      dispatch(props.restoreActionCreator(parameters));
      dispatch(props.fetchProductsActionCreator());
    },
    get state() {
      return {
        parameters: props.excludeDefaultParameters ? parametersSelector(engine[stateKey]) : props.activeParametersSelector(engine[stateKey])
      };
    }
  };
}
function loadParameterManagerReducers(engine) {
  engine.addReducers({
    commerceParameters: parametersReducer
  });
  return true;
}

// src/controllers/commerce/core/sort/headless-core-commerce-sort.ts
var import_bueno70 = require("@coveo/bueno");

// src/features/commerce/sort/sort-slice.ts
var import_toolkit78 = require("@reduxjs/toolkit");
var sortReducer = (0, import_toolkit78.createReducer)(
  getCommerceSortInitialState(),
  (builder) => {
    builder.addCase(applySort, (state, action) => {
      state.appliedSort = action.payload;
    }).addCase(fetchProductListing.fulfilled, handleFetchFulfilled).addCase(executeSearch3.fulfilled, handleFetchFulfilled).addCase(setContext, getCommerceSortInitialState).addCase(setView, getCommerceSortInitialState).addCase(restoreSearchParameters2, handleRestoreParameters3).addCase(restoreProductListingParameters, handleRestoreParameters3);
  }
);
function handleFetchFulfilled(state, action) {
  const response = action.payload.response;
  state.appliedSort = mapResponseSortToStateSort(response.sort.appliedSort);
  state.availableSorts = response.sort.availableSorts.map(
    mapResponseSortToStateSort
  );
}
var mapResponseSortToStateSort = (sort) => {
  if (sort.sortCriteria === "relevance" /* Relevance */) {
    return buildRelevanceSortCriterion();
  }
  return {
    by: "fields" /* Fields */,
    fields: (sort.fields || []).map(({ field: field2, direction, displayName }) => ({
      name: field2,
      direction,
      displayName
    }))
  };
};
function handleRestoreParameters3(state, action) {
  if (action.payload.sortCriteria) {
    state.appliedSort = action.payload.sortCriteria;
    return;
  }
  state.appliedSort = getCommerceSortInitialState().appliedSort;
}

// src/controllers/commerce/core/sort/headless-core-commerce-sort.ts
function validateSortInitialState(engine, state) {
  if (!state) {
    return;
  }
  const schema = new import_bueno70.Schema({
    criterion: sortCriterionDefinition
  });
  validateInitialState(engine, schema, state, "buildSort");
}
function buildCoreSort(engine, props) {
  if (!loadSortReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const controller = buildController(engine);
  validateSortInitialState(engine, props.initialState);
  const criterion = props.initialState?.criterion;
  if (criterion) {
    dispatch(applySort(criterion));
  }
  return {
    ...controller,
    get state() {
      return engine[stateKey].commerceSort;
    },
    sortBy(criterion2) {
      dispatch(applySort(criterion2));
      dispatch(props.fetchProductsActionCreator());
    },
    isSortedBy(criterion2) {
      return JSON.stringify(this.state.appliedSort) === JSON.stringify(criterion2);
    },
    isAvailable(criterion2) {
      return this.state.availableSorts.some(
        (availableCriterion) => JSON.stringify(availableCriterion) === JSON.stringify(criterion2)
      );
    }
  };
}
function loadSortReducers(engine) {
  engine.addReducers({ commerceSort: sortReducer });
  return true;
}

// src/controllers/commerce/core/summary/headless-core-summary.ts
var buildCoreSummary = (engine, props) => {
  const controller = buildController(engine);
  const {
    options: {
      numberOfProductsSelector: numberOfProductsSelector3,
      responseIdSelector: responseIdSelector3,
      isLoadingSelector: isLoadingSelector4,
      errorSelector: errorSelector3,
      pageSelector,
      perPageSelector,
      totalEntriesSelector,
      enrichSummary
    }
  } = props;
  const getState = () => engine[stateKey];
  const page = () => pageSelector(getState());
  const perPage = () => perPageSelector(getState());
  const totalNumberOfProducts = () => totalEntriesSelector(getState());
  const firstSearchExecuted = () => !!responseIdSelector3(getState());
  const hasProducts = () => firstSearchExecuted() && totalNumberOfProducts() > 0;
  const firstProduct = () => hasProducts() ? page() * perPage() + 1 : 0;
  const lastProduct = () => hasProducts() ? firstProduct() + (numberOfProductsSelector3(getState()) - 1) : 0;
  return {
    ...controller,
    get state() {
      return {
        firstRequestExecuted: firstSearchExecuted(),
        firstProduct: firstProduct(),
        lastProduct: lastProduct(),
        totalNumberOfProducts: totalNumberOfProducts(),
        hasProducts: hasProducts(),
        isLoading: isLoadingSelector4(getState()),
        hasError: errorSelector3(getState()) !== null,
        ...enrichSummary ? enrichSummary(getState()) : {}
      };
    }
  };
};

// src/controllers/url-manager/headless-url-manager.ts
var import_bueno73 = require("@coveo/bueno");

// src/features/pagination/pagination-slice.ts
var import_toolkit80 = require("@reduxjs/toolkit");

// src/features/facets/automatic-facet-set/automatic-facet-set-actions.ts
var import_bueno71 = require("@coveo/bueno");
var import_toolkit79 = require("@reduxjs/toolkit");
var numberOfValuesDefinition = new import_bueno71.NumberValue({
  min: NUMBER_OF_VALUE_MINIMUM,
  default: NUMBER_OF_VALUE_DEFAULT,
  required: false
});
var desiredCountDefinition = new import_bueno71.NumberValue({
  min: DESIRED_COUNT_MINIMUM,
  max: DESIRED_COUNT_MAXIMUM,
  default: DESIRED_COUNT_DEFAULT,
  required: false
});
var optionsSchema2 = {
  desiredCount: desiredCountDefinition,
  numberOfValues: numberOfValuesDefinition
};
var setOptions = (0, import_toolkit79.createAction)(
  "automaticFacet/setOptions",
  (payload) => validatePayload(payload, optionsSchema2)
);
var deselectAllAutomaticFacetValues = (0, import_toolkit79.createAction)(
  "automaticFacet/deselectAll",
  (payload) => validatePayload(payload, facetIdDefinition)
);
var fieldDefinition = requiredNonEmptyString;
var toggleSelectAutomaticFacetValue = (0, import_toolkit79.createAction)(
  "automaticFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    field: fieldDefinition,
    selection: new import_bueno71.RecordValue({ values: facetValueDefinition })
  })
);

// src/features/pagination/pagination-slice.ts
var paginationReducer2 = (0, import_toolkit80.createReducer)(
  getPaginationInitialState(),
  (builder) => {
    builder.addCase(registerNumberOfResults, (state, action) => {
      const page = determineCurrentPage(state);
      const newNumberOfResults = action.payload;
      state.defaultNumberOfResults = state.numberOfResults = newNumberOfResults;
      state.firstResult = calculateFirstResult(page, newNumberOfResults);
    }).addCase(updateNumberOfResults, (state, action) => {
      state.numberOfResults = action.payload;
      state.firstResult = 0;
    }).addCase(updateActiveTab, (state) => {
      state.firstResult = 0;
    }).addCase(registerPage, (state, action) => {
      const page = action.payload;
      state.firstResult = calculateFirstResult(page, state.numberOfResults);
    }).addCase(updatePage, (state, action) => {
      const page = action.payload;
      state.firstResult = calculateFirstResult(page, state.numberOfResults);
    }).addCase(previousPage, (state) => {
      const page = determineCurrentPage(state);
      const previousPage3 = Math.max(page - 1, minimumPage);
      state.firstResult = calculateFirstResult(
        previousPage3,
        state.numberOfResults
      );
    }).addCase(nextPage, (state) => {
      const page = determineCurrentPage(state);
      const maxPage = determineMaxPage(state);
      const nextPage3 = Math.min(page + 1, maxPage);
      state.firstResult = calculateFirstResult(
        nextPage3,
        state.numberOfResults
      );
    }).addCase(change.fulfilled, (state, action) => {
      if (action.payload) {
        state.numberOfResults = action.payload.pagination.numberOfResults;
        state.firstResult = action.payload.pagination.firstResult;
      }
    }).addCase(restoreSearchParameters, (state, action) => {
      state.firstResult = action.payload.firstResult ?? state.firstResult;
      state.numberOfResults = action.payload.numberOfResults ?? state.defaultNumberOfResults;
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const { response } = action.payload;
      state.totalCountFiltered = response.totalCountFiltered;
    }).addCase(fetchPage2.fulfilled, (state, action) => {
      const { response } = action.payload;
      state.totalCountFiltered = response.totalCountFiltered;
    }).addCase(deselectAllFacetValues, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleExcludeDateFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleExcludeFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleExcludeNumericFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(excludeFacetSearchResult, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleSelectFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(deselectAllCategoryFacetValues, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleSelectCategoryFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(selectCategoryFacetSearchResult, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleSelectDateFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleSelectNumericFacetValue, (state) => {
      handlePaginationReset2(state);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      handlePaginationReset2(state);
    }).addCase(updateDateFacetValues, (state) => {
      handlePaginationReset2(state);
    }).addCase(updateNumericFacetValues, (state) => {
      handlePaginationReset2(state);
    }).addCase(selectFacetSearchResult, (state) => {
      handlePaginationReset2(state);
    }).addCase(toggleSelectAutomaticFacetValue, (state) => {
      handlePaginationReset2(state);
    });
  }
);
function handlePaginationReset2(state) {
  state.firstResult = getPaginationInitialState().firstResult;
}
function determineCurrentPage(state) {
  const { firstResult, numberOfResults } = state;
  return calculatePage(firstResult, numberOfResults);
}
function determineMaxPage(state) {
  const { totalCountFiltered, numberOfResults } = state;
  return calculateMaxPage(totalCountFiltered, numberOfResults);
}
function calculateFirstResult(page, numberOfResults) {
  return (page - 1) * numberOfResults;
}
function calculatePage(firstResult, numberOfResults) {
  return Math.round(firstResult / numberOfResults) + 1;
}
function calculateMaxPage(totalCountFiltered, numberOfResults) {
  const totalCount = Math.min(
    totalCountFiltered,
    maximumNumberOfResultsFromIndex
  );
  return Math.ceil(totalCount / numberOfResults);
}

// src/controllers/core/search-parameter-manager/headless-core-search-parameter-manager.ts
var import_bueno72 = require("@coveo/bueno");
var initialStateSchema2 = new import_bueno72.Schema({
  parameters: new import_bueno72.RecordValue({
    options: { required: true },
    values: searchParametersDefinition
  })
});

// src/controllers/url-manager/headless-url-manager.ts
var initialStateSchema3 = new import_bueno73.Schema({
  fragment: new import_bueno73.StringValue()
});

// src/controllers/commerce/core/url-manager/headless-core-url-manager.ts
function buildCoreUrlManager(engine, props) {
  let lastRequestId;
  function updateLastRequestId() {
    lastRequestId = props.requestIdSelector(engine[stateKey]);
  }
  function hasRequestIdChanged() {
    return lastRequestId !== props.requestIdSelector(engine[stateKey]);
  }
  validateInitialState(
    engine,
    initialStateSchema3,
    props.initialState,
    "buildUrlManager"
  );
  const controller = buildController(engine);
  let previousFragment = props.initialState.fragment;
  updateLastRequestId();
  const parameterManager = props.parameterManagerBuilder(engine, {
    initialState: {
      parameters: props.serializer.deserialize(previousFragment)
    },
    excludeDefaultParameters: props.excludeDefaultParameters ?? false
  });
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const newFragment = this.state.fragment;
        if (!areFragmentsEquivalent(
          props.serializer.deserialize,
          previousFragment,
          newFragment
        ) && hasRequestIdChanged()) {
          previousFragment = newFragment;
          listener();
        }
        updateLastRequestId();
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        fragment: props.serializer.serialize(parameterManager.state.parameters)
      };
    },
    synchronize(fragment) {
      previousFragment = fragment;
      const parameters = props.serializer.deserialize(fragment);
      parameterManager.synchronize(parameters);
    }
  };
}
function areFragmentsEquivalent(deserialize3, fragment1, fragment2) {
  if (fragment1 === fragment2) {
    return true;
  }
  const params1 = deserialize3(fragment1);
  const params2 = deserialize3(fragment2);
  return deepEqualAnyOrder(params1, params2);
}

// src/controllers/commerce/core/sub-controller/headless-sub-controller.ts
function buildSearchSubControllers(engine, subControllerProps) {
  return {
    ...buildSearchAndListingsSubControllers(engine, {
      ...subControllerProps,
      facetSearchType: "SEARCH"
    }),
    didYouMean() {
      return buildDidYouMean(engine);
    }
  };
}
function buildProductListingSubControllers(engine, subControllerProps) {
  return {
    ...buildSearchAndListingsSubControllers(engine, {
      ...subControllerProps,
      facetSearchType: "LISTING"
    })
  };
}
function buildSearchAndListingsSubControllers(engine, subControllerProps) {
  const {
    fetchProductsActionCreator,
    facetResponseSelector: facetResponseSelector3,
    isFacetLoadingResponseSelector: isFacetLoadingResponseSelector4,
    requestIdSelector: requestIdSelector3,
    serializer,
    parametersDefinition: parametersDefinition2,
    activeParametersSelector: activeParametersSelector3,
    restoreActionCreator,
    facetSearchType,
    responseIdSelector: responseIdSelector3
  } = subControllerProps;
  return {
    ...buildBaseSubControllers(engine, subControllerProps),
    sort(props) {
      return buildCoreSort(engine, {
        ...props,
        fetchProductsActionCreator
      });
    },
    facetGenerator() {
      const commonOptions = {
        fetchProductsActionCreator,
        facetResponseSelector: facetResponseSelector3,
        isFacetLoadingResponseSelector: isFacetLoadingResponseSelector4,
        facetSearch: { type: facetSearchType }
      };
      return buildFacetGenerator(engine, {
        buildRegularFacet: (_engine, options) => buildCommerceRegularFacet(engine, { ...options, ...commonOptions }),
        buildNumericFacet: (_engine, options) => buildCommerceNumericFacet(engine, { ...options, ...commonOptions }),
        buildDateFacet: (_engine, options) => buildCommerceDateFacet(engine, { ...options, ...commonOptions }),
        buildCategoryFacet: (_engine, options) => buildCategoryFacet(engine, { ...options, ...commonOptions }),
        buildLocationFacet: (_engine, options) => buildCommerceLocationFacet(engine, { ...options, ...commonOptions }),
        fetchProductsActionCreator
      });
    },
    breadcrumbManager() {
      return buildCoreBreadcrumbManager(engine, {
        facetResponseSelector: facetResponseSelector3,
        fetchProductsActionCreator
      });
    },
    urlManager(props) {
      return buildCoreUrlManager(engine, {
        ...props,
        requestIdSelector: requestIdSelector3,
        parameterManagerBuilder: (_engine, props2) => this.parameterManager(props2),
        serializer
      });
    },
    parameterManager(props) {
      return buildCoreParameterManager(engine, {
        ...props,
        parametersDefinition: parametersDefinition2,
        activeParametersSelector: activeParametersSelector3,
        restoreActionCreator,
        fetchProductsActionCreator
      });
    },
    interactiveSpotlightContent(props) {
      return buildCoreInteractiveSpotlightContent(engine, {
        ...props,
        responseIdSelector: responseIdSelector3
      });
    }
  };
}
function buildBaseSubControllers(engine, subControllerProps) {
  const {
    responseIdSelector: responseIdSelector3,
    isLoadingSelector: isLoadingSelector4,
    errorSelector: errorSelector3,
    numberOfProductsSelector: numberOfProductsSelector3,
    fetchProductsActionCreator,
    fetchMoreProductsActionCreator,
    slotId,
    pageSelector,
    perPageSelector,
    totalEntriesSelector,
    enrichSummary
  } = subControllerProps;
  return {
    interactiveProduct(props) {
      return buildCoreInteractiveProduct(engine, {
        ...props,
        responseIdSelector: responseIdSelector3
      });
    },
    pagination(props) {
      return buildCorePagination(engine, {
        ...props,
        options: {
          ...props?.options,
          slotId
        },
        fetchProductsActionCreator,
        fetchMoreProductsActionCreator
      });
    },
    summary() {
      return buildCoreSummary(engine, {
        options: {
          responseIdSelector: responseIdSelector3,
          isLoadingSelector: isLoadingSelector4,
          errorSelector: errorSelector3,
          numberOfProductsSelector: numberOfProductsSelector3,
          pageSelector,
          perPageSelector,
          totalEntriesSelector,
          enrichSummary
        }
      });
    }
  };
}

// src/controllers/commerce/product-listing/facets/headless-product-listing-facet-options.ts
var import_toolkit81 = require("@reduxjs/toolkit");
var facetResponseSelector = (0, import_toolkit81.createSelector)(
  (state, facetId2) => ({ state, facetId: facetId2 }),
  ({ state, facetId: facetId2 }) => {
    const facetResponse = state.productListing.facets.find(
      (facetResponse2) => facetResponse2.facetId === facetId2
    );
    if (facetResponse && facetResponse.facetId in state.commerceFacetSet) {
      return facetResponse;
    }
    return void 0;
  }
);
var isFacetLoadingResponseSelector2 = (0, import_toolkit81.createSelector)(
  (state) => ({ state }),
  ({ state }) => state.productListing.isLoading
);

// src/controllers/commerce/product-listing/headless-product-listing.ts
function buildProductListing(engine, { enableResults = false } = {
  enableResults: false
}) {
  if (!loadBaseProductListingReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const subControllers = buildProductListingSubControllers(engine, {
    responseIdSelector,
    fetchProductsActionCreator: () => fetchProductListing({ enableResults }),
    fetchMoreProductsActionCreator: () => fetchMoreProducts({ enableResults }),
    facetResponseSelector,
    isFacetLoadingResponseSelector: isFacetLoadingResponseSelector2,
    requestIdSelector,
    serializer: productListingSerializer,
    parametersDefinition,
    activeParametersSelector,
    restoreActionCreator: restoreProductListingParameters,
    isLoadingSelector,
    errorSelector,
    pageSelector: pagePrincipalSelector,
    perPageSelector: perPagePrincipalSelector,
    totalEntriesSelector: totalEntriesPrincipalSelector,
    numberOfProductsSelector
  });
  return {
    ...controller,
    ...subControllers,
    get state() {
      const { products, results, error, isLoading, responseId } = getState().productListing;
      return {
        products,
        results,
        error,
        isLoading,
        responseId
      };
    },
    promoteChildToParent(child) {
      dispatch(promoteChildToParent({ child }));
    },
    refresh: () => dispatch(fetchProductListing({ enableResults })),
    executeFirstRequest() {
      const firstRequestExecuted = responseIdSelector(getState()) !== "";
      if (firstRequestExecuted) {
        return;
      }
      dispatch(fetchProductListing({ enableResults }));
    }
  };
}
function loadBaseProductListingReducers(engine) {
  engine.addReducers({ productListing: productListingReducer, commerceContext: contextReducer, configuration });
  return true;
}

// src/features/commerce/query/query-slice.ts
var import_toolkit82 = require("@reduxjs/toolkit");
var queryReducer = (0, import_toolkit82.createReducer)(
  getCommerceQueryInitialState(),
  (builder) => {
    builder.addCase(updateQuery2, (state, action) => ({
      ...state,
      ...action.payload
    })).addCase(restoreSearchParameters2, (state, action) => {
      state.query = action.payload.q ?? "";
    }).addCase(selectQuerySuggestion, (state, action) => {
      state.query = action.payload.expression;
    });
  }
);

// src/features/commerce/search/search-slice.ts
var import_toolkit83 = require("@reduxjs/toolkit");

// src/features/commerce/search/search-state.ts
var getCommerceSearchInitialState = () => ({
  error: null,
  isLoading: false,
  requestId: "",
  responseId: "",
  products: [],
  results: [],
  facets: [],
  queryExecuted: ""
});

// src/features/commerce/search/search-slice.ts
var commerceSearchReducer = (0, import_toolkit83.createReducer)(
  getCommerceSearchInitialState(),
  (builder) => {
    builder.addCase(executeSearch3.rejected, (state, action) => {
      handleError2(state, action.payload);
    }).addCase(fetchMoreProducts2.rejected, (state, action) => {
      handleError2(state, action.payload);
    }).addCase(executeSearch3.fulfilled, (state, action) => {
      const paginationOffset = getPaginationOffset2(action.payload);
      handleFulfilled2(
        state,
        action.payload.response,
        action.payload.queryExecuted
      );
      state.products = action.payload.response.products.map(
        (product, index) => preprocessProduct2(
          product,
          paginationOffset + index + 1,
          action.payload.response.responseId
        )
      );
      state.results = mapPreprocessedResults2(
        action.payload.response.results,
        paginationOffset,
        action.payload.response.responseId
      );
    }).addCase(fetchMoreProducts2.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      const paginationOffset = getPaginationOffset2(action.payload);
      handleFulfilled2(
        state,
        action.payload.response,
        action.payload.queryExecuted
      );
      state.products = state.products.concat(
        action.payload.response.products.map(
          (product, index) => preprocessProduct2(
            product,
            paginationOffset + index + 1,
            action.payload?.response.responseId
          )
        )
      );
      state.results = state.results.concat(
        mapPreprocessedResults2(
          action.payload.response.results,
          paginationOffset,
          action.payload.response.responseId
        )
      );
    }).addCase(executeSearch3.pending, (state, action) => {
      handlePending2(state, action.meta.requestId);
    }).addCase(fetchMoreProducts2.pending, (state, action) => {
      handlePending2(state, action.meta.requestId);
    }).addCase(promoteChildToParent2, (state, action) => {
      const productsOrResults = state.results.length > 0 ? state.results : state.products;
      let childToPromote;
      const currentParentIndex = productsOrResults.findIndex((result) => {
        if (result.resultType === "spotlight" /* SPOTLIGHT */) {
          return false;
        }
        childToPromote = result.children.find(
          (child) => child.permanentid === action.payload.child.permanentid
        );
        return !!childToPromote;
      });
      const currentParent = productsOrResults[currentParentIndex];
      if (currentParentIndex === -1 || childToPromote === void 0 || currentParent.resultType === "spotlight" /* SPOTLIGHT */) {
        return;
      }
      const responseId = currentParent.responseId;
      const position = currentParent.position;
      const { children, totalNumberOfChildren } = currentParent;
      const newParent = {
        ...childToPromote,
        resultType: "product" /* PRODUCT */,
        children,
        totalNumberOfChildren,
        position,
        responseId
      };
      productsOrResults.splice(currentParentIndex, 1, newParent);
    }).addCase(setView, () => getCommerceSearchInitialState()).addCase(setContext, () => getCommerceSearchInitialState()).addCase(setError, (state, action) => {
      state.error = action.payload;
      state.isLoading = false;
    });
  }
);
function handleError2(state, error) {
  state.error = error || null;
  state.isLoading = false;
}
function handlePending2(state, requestId) {
  state.isLoading = true;
  state.requestId = requestId;
}
function handleFulfilled2(state, response, query2) {
  state.error = null;
  state.facets = response.facets;
  state.responseId = response.responseId;
  state.isLoading = false;
  state.queryExecuted = query2 ?? "";
}
function getPaginationOffset2(payload) {
  const pagination = payload.response.pagination;
  return pagination.page * pagination.perPage;
}
function preprocessProduct2(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some(
    (child) => child.permanentid === product.permanentid
  );
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const {
    children,
    totalNumberOfChildren: _totalNumberOfChildren,
    ...restOfProduct
  } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}
function mapPreprocessedResults2(results, paginationOffset, responseId) {
  return results.map(
    (result, index) => preprocessResult2(result, paginationOffset + index + 1, responseId)
  );
}
function preprocessResult2(result, position, responseId) {
  if (result.resultType === "spotlight" /* SPOTLIGHT */) {
    return preprocessSpotlightContent2(result, position, responseId);
  }
  return preprocessProduct2(result, position, responseId);
}
function preprocessSpotlightContent2(spotlight, position, responseId) {
  return {
    ...spotlight,
    position,
    responseId
  };
}

// src/controllers/commerce/search/facets/headless-search-facet-options.ts
var import_toolkit84 = require("@reduxjs/toolkit");
var facetResponseSelector2 = (0, import_toolkit84.createSelector)(
  (state, facetId2) => ({ state, facetId: facetId2 }),
  ({ state, facetId: facetId2 }) => {
    const facetResponse = state.commerceSearch.facets.find(
      (facetResponse2) => facetResponse2.facetId === facetId2
    );
    if (facetResponse && facetResponse.facetId in state.commerceFacetSet) {
      return facetResponse;
    }
    return void 0;
  }
);
var isFacetLoadingResponseSelector3 = (0, import_toolkit84.createSelector)(
  (state) => ({ state }),
  ({ state }) => state.commerceSearch.isLoading
);

// src/controllers/commerce/search/headless-search.ts
function buildSearch(engine, { enableResults = false } = { enableResults: false }) {
  if (!loadBaseSearchReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const subControllers = buildSearchSubControllers(engine, {
    responseIdSelector: responseIdSelector2,
    fetchProductsActionCreator: () => executeSearch3({ enableResults }),
    fetchMoreProductsActionCreator: () => fetchMoreProducts2({ enableResults }),
    facetResponseSelector: facetResponseSelector2,
    isFacetLoadingResponseSelector: isFacetLoadingResponseSelector3,
    requestIdSelector: requestIdSelector2,
    serializer: searchSerializer,
    parametersDefinition: searchParametersDefinition2,
    restoreActionCreator: restoreSearchParameters2,
    activeParametersSelector: activeParametersSelector2,
    isLoadingSelector: isLoadingSelector2,
    errorSelector: errorSelector2,
    pageSelector: pagePrincipalSelector,
    perPageSelector: perPagePrincipalSelector,
    totalEntriesSelector: totalEntriesPrincipalSelector,
    numberOfProductsSelector: numberOfProductsSelector2,
    enrichSummary: enrichedSummarySelector
  });
  return {
    ...controller,
    ...subControllers,
    get state() {
      const { products, results, error, isLoading, responseId } = getState().commerceSearch;
      return {
        products,
        results,
        error,
        isLoading,
        responseId
      };
    },
    promoteChildToParent(child) {
      dispatch(promoteChildToParent2({ child }));
    },
    executeFirstSearch() {
      const firstSearchExecuted = responseIdSelector2(getState()) !== "";
      if (firstSearchExecuted) {
        return;
      }
      dispatch(executeSearch3({ enableResults }));
    }
  };
}
function loadBaseSearchReducers(engine) {
  engine.addReducers({
    commerceContext: contextReducer,
    configuration,
    commerceSearch: commerceSearchReducer,
    commerceQuery: queryReducer
  });
  return true;
}

// src/ssr/commerce/types/controller-constants.ts
var SolutionType = /* @__PURE__ */ ((SolutionType2) => {
  SolutionType2["search"] = "search";
  SolutionType2["listing"] = "listing";
  SolutionType2["standalone"] = "standalone";
  SolutionType2["recommendation"] = "recommendation";
  return SolutionType2;
})(SolutionType || {});
var recommendationOptionKey = "recommendation-internal-options";
var recommendationInternalOptionKey = Symbol.for(
  recommendationOptionKey
);

// src/ssr/common/errors.ts
var InvalidControllerDefinition = class extends Error {
  constructor() {
    super();
    this.name = "InvalidControllerDefinition";
    this.message = `A controller must be defined for at least one solution type: ${Object.keys(
      SolutionType
    ).map((s) => s.toLowerCase()).join(", ")}`;
  }
};
var MissingControllerProps = class extends Error {
  constructor(controller) {
    super();
    this.name = "MissingControllerProps";
    this.message = `${controller} props are required but were undefined. Ensure they are included when calling \`fetchStaticState\` or \`hydrateStaticState\`.`;
  }
};
var MultipleRecommendationError = class extends Error {
  constructor(slotId) {
    super();
    this.name = "MultipleRecommendationError";
    this.message = `Multiple recommendation controllers found for the same slotId: ${slotId}. Only one recommendation controller per slotId is supported.`;
  }
};

// src/ssr/commerce/controller-utils.ts
function hasKindProperty(controller) {
  return "_kind" in controller;
}
function createStaticState({
  searchActions,
  controllers
}) {
  return {
    controllers: mapObject(controllers, (controller) => ({
      state: clone(controller.state),
      ...hasKindProperty(controller) && { _kind: controller._kind }
    })),
    searchActions: searchActions.map((action) => clone(action))
  };
}
function buildControllerFromDefinition({
  definition: definition3,
  engine,
  solutionType,
  props
}) {
  return "build" in definition3 ? definition3.build(engine, solutionType) : definition3.buildWithProps(engine, props, solutionType);
}
function buildControllerDefinitions({
  definitionsMap,
  engine,
  solutionType,
  propsMap
}) {
  const controllerMap = mapObject(definitionsMap, (definition3, key) => {
    const unavailableInSolutionType = () => !(solutionType in definition3) || solutionType in definition3 && definition3[solutionType] === false;
    const props = propsMap?.[key];
    if (unavailableInSolutionType()) {
      return null;
    }
    return buildControllerFromDefinition({
      definition: definition3,
      engine,
      solutionType,
      props
    });
  });
  return filterObject(
    controllerMap,
    (value) => value !== null
  );
}
function ensureAtLeastOneSolutionType(options) {
  if (options?.listing === false && options?.search === false) {
    throw new InvalidControllerDefinition();
  }
}

// src/ssr/commerce/controllers/breadcrumb-manager/headless-core-breadcrumb-manager.ssr.ts
function defineBreadcrumbManager(options) {
  ensureAtLeastOneSolutionType(options);
  return {
    listing: true,
    search: true,
    ...options,
    build: (engine, solutionType) => solutionType === "listing" /* listing */ ? buildProductListing(engine).breadcrumbManager() : buildSearch(engine).breadcrumbManager()
  };
}

// src/features/commerce/context/cart/cart-actions.ts
var import_toolkit86 = require("@reduxjs/toolkit");

// src/features/commerce/context/cart/cart-selector.ts
var import_toolkit85 = require("@reduxjs/toolkit");
var getECPurchasePayload = (transaction, state) => ({
  currency: getCurrency(state.commerceContext),
  products: productQuantitySelector(state.cart),
  transaction
});
var getECCartActionPayload = (cartActionDetails, state) => ({
  currency: getCurrency(state.commerceContext),
  ...cartActionDetails
});
var itemsSelector = (0, import_toolkit85.createSelector)(
  (cartState) => cartState.cart,
  (cartState) => cartState.cartItems,
  (cart, cartItems) => cartItems.map((key) => cart[key])
);
var productQuantitySelector = (0, import_toolkit85.createSelector)(
  itemsSelector,
  (items) => items.map(({ quantity, ...product }) => ({
    quantity,
    product
  }))
);

// src/features/commerce/context/cart/cart-actions.ts
var setItems = (0, import_toolkit86.createAction)(
  "commerce/cart/setItems",
  (payload) => validatePayload(payload, setItemsPayloadDefinition)
);
var updateItemQuantity = (0, import_toolkit86.createAction)(
  "commerce/cart/updateItemQuantity",
  (payload) => validatePayload(payload, itemPayloadDefinition)
);
var purchase = (0, import_toolkit86.createAction)("commerce/cart/purchase");
var emitPurchaseEvent = (0, import_toolkit86.createAsyncThunk)(
  "commerce/cart/emit/purchaseEvent",
  async (payload, { extra, getState }) => {
    const relayPayload = getECPurchasePayload(payload, getState());
    const { relay } = extra;
    relay.emit("ec.purchase", relayPayload);
  }
);
var emitCartActionEvent = (0, import_toolkit86.createAsyncThunk)(
  "commerce/cart/emit/cartActionEvent",
  async (payload, { extra, getState }) => {
    const relayPayload = getECCartActionPayload(payload, getState());
    const { relay } = extra;
    relay.emit("ec.cartAction", relayPayload);
  }
);

// src/features/commerce/context/cart/cart-slice.ts
var import_toolkit87 = require("@reduxjs/toolkit");
var cartReducer = (0, import_toolkit87.createReducer)(
  getCartInitialState(),
  (builder) => {
    builder.addCase(setItems, (state, { payload }) => {
      const { cart, cartItems } = payload.reduce((acc, item) => {
        const key = createCartKey(item);
        return {
          cartItems: [...acc.cartItems, key],
          cart: {
            ...acc.cart,
            [key]: item
          },
          purchasedItems: [],
          purchased: {}
        };
      }, getCartInitialState());
      setItemsInState(state, cartItems, cart);
    }).addCase(updateItemQuantity, (state, { payload }) => {
      const key = createCartKey(payload);
      if (!(key in state.cart)) {
        createItemInCart(payload, state);
        return;
      }
      if (payload.quantity <= 0) {
        deleteProductFromCart(payload, state);
        return;
      }
      state.cart[key] = payload;
      return;
    }).addCase(purchase, (state) => {
      setItemsAsPurchased(state);
      const { cart, cartItems } = getCartInitialState();
      setItemsInState(state, cartItems, cart);
    });
  }
);
function setItemsInState(state, cartItems, cart) {
  state.cartItems = cartItems;
  state.cart = cart;
}
function createItemInCart(item, state) {
  if (item.quantity <= 0) {
    return;
  }
  const key = createCartKey(item);
  state.cartItems = [...state.cartItems, key];
  state.cart[key] = item;
}
function deleteProductFromCart(item, state) {
  const key = createCartKey(item);
  state.cartItems = state.cartItems.filter((cartKey) => cartKey !== key);
  delete state.cart[key];
}
function setItemsAsPurchased(state) {
  for (const key of state.cartItems) {
    if (key in state.purchased) {
      state.purchased[key].quantity += state.cart[key].quantity;
      continue;
    }
    state.purchasedItems = [...state.purchasedItems, key];
    state.purchased[key] = state.cart[key];
  }
}

// src/controllers/commerce/context/cart/headless-cart-selectors.ts
var import_toolkit88 = require("@reduxjs/toolkit");
function itemSelector(cartState, item) {
  return cartState.cart[createCartKey(item)];
}
var totalQuantitySelector = (0, import_toolkit88.createSelector)(
  itemsSelector,
  (items) => items.reduce((prev, cur) => prev + cur.quantity, 0)
);
var totalPriceSelector = (0, import_toolkit88.createSelector)(
  itemsSelector,
  (items) => items.reduce((prev, cur) => prev + cur.price * cur.quantity, 0)
);

// src/controllers/commerce/context/cart/headless-cart.ts
function buildCart(engine, props = {}) {
  if (!loadBaseCartReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const controller = buildController(engine);
  const getState = () => engine[stateKey].cart;
  const initialState = {
    ...props.initialState
  };
  validateInitialState(engine, cartSchema, initialState, "buildCart");
  if (initialState.items !== void 0) {
    dispatch(setItems(initialState.items));
  }
  function isNewQuantityDifferent(currentItem, prevItem) {
    return prevItem ? prevItem.quantity !== currentItem.quantity : true;
  }
  function getCartAction(currentItem, prevItem) {
    const isCurrentQuantityGreater = !prevItem || currentItem.quantity > prevItem.quantity;
    return isCurrentQuantityGreater ? "add" : "remove";
  }
  function isEqual(currentItem, prevItem) {
    return prevItem ? currentItem.name === prevItem.name && currentItem.price === prevItem.price && currentItem.quantity === prevItem.quantity : false;
  }
  function createEcCartActionPayload(currentItem, prevItem) {
    const { quantity: currentQuantity, ...product } = currentItem;
    const action = getCartAction(currentItem, prevItem);
    const quantity = !prevItem ? currentQuantity : Math.abs(currentQuantity - prevItem.quantity);
    return {
      action,
      quantity,
      product
    };
  }
  return {
    ...controller,
    empty: function() {
      for (const item of itemsSelector(getState())) {
        this.updateItemQuantity({ ...item, quantity: 0 });
      }
    },
    purchase(transaction) {
      dispatch(emitPurchaseEvent(transaction));
      dispatch(purchase());
    },
    updateItemQuantity(item) {
      const prevItem = itemSelector(getState(), item);
      const doesNotNeedUpdate = !prevItem && item.quantity <= 0;
      if (doesNotNeedUpdate || isEqual(item, prevItem)) {
        return;
      }
      if (isNewQuantityDifferent(item, prevItem)) {
        dispatch(
          emitCartActionEvent(createEcCartActionPayload(item, prevItem))
        );
      }
      dispatch(updateItemQuantity(item));
    },
    get state() {
      const cartState = getState();
      return {
        items: itemsSelector(cartState),
        totalQuantity: totalQuantitySelector(cartState),
        totalPrice: totalPriceSelector(cartState)
      };
    }
  };
}
function createCartKey(item) {
  return `${item.productId},${item.name},${item.price}`;
}
function loadBaseCartReducers(engine) {
  engine.addReducers({ cart: cartReducer });
  return true;
}

// src/ssr/commerce/types/kind.ts
var Kind = /* @__PURE__ */ ((Kind2) => {
  Kind2["Cart"] = "CART";
  Kind2["Context"] = "CONTEXT";
  Kind2["ParameterManager"] = "PARAMETER_MANAGER";
  Kind2["Recommendations"] = "RECOMMENDATIONS";
  Kind2["ProductEnrichment"] = "PRODUCT_ENRICHMENT";
  return Kind2;
})(Kind || {});
function createControllerWithKind(controller, kind) {
  const copy = Object.defineProperties(
    {},
    Object.getOwnPropertyDescriptors(controller)
  );
  Object.defineProperty(copy, "_kind", {
    value: kind
  });
  return copy;
}

// src/ssr/commerce/controllers/cart/headless-cart.ssr.ts
function defineCart() {
  return {
    listing: true,
    search: true,
    standalone: true,
    recommendation: true,
    buildWithProps: (engine, props) => {
      if (props === void 0) {
        throw new MissingControllerProps("CART" /* Cart */);
      }
      const controller = buildCart(engine, { initialState: props.initialState });
      return createControllerWithKind(controller, "CART" /* Cart */);
    }
  };
}

// src/controllers/commerce/context/headless-context.ts
function buildContext(engine, props = {}) {
  if (!loadBaseContextReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  if (props.options) {
    validateOptions(engine, contextSchema, props.options, "buildContext");
    dispatch(setContext(props.options));
  }
  return {
    ...controller,
    get state() {
      return getState().commerceContext;
    },
    setLanguage: (language) => dispatch(
      setContext({
        ...getState().commerceContext,
        language
      })
    ),
    setCountry: (country) => dispatch(
      setContext({
        ...getState().commerceContext,
        country
      })
    ),
    setCurrency: (currency) => dispatch(
      setContext({
        ...getState().commerceContext,
        currency
      })
    ),
    setView: (view) => dispatch(setView(view)),
    setLocation: (location) => dispatch(setLocation(location)),
    setCustom: (custom) => dispatch(setCustom(custom))
  };
}
function loadBaseContextReducers(engine) {
  engine.addReducers({ commerceContext: contextReducer });
  return true;
}

// src/ssr/commerce/controllers/context/headless-context.ssr.ts
function defineContext() {
  return {
    listing: true,
    search: true,
    standalone: true,
    recommendation: true,
    buildWithProps: (engine, props) => {
      if (props === void 0) {
        throw new MissingControllerProps("CONTEXT" /* Context */);
      }
      const controller = buildContext(engine, { options: props });
      return createControllerWithKind(controller, "CONTEXT" /* Context */);
    }
  };
}

// src/ssr/commerce/controllers/did-you-mean/headless-did-you-mean.ssr.ts
function defineDidYouMean() {
  return {
    search: true,
    build: (engine) => buildSearch(engine).didYouMean()
  };
}

// src/controllers/commerce/filter-suggestions/headless-filter-suggestions-generator.ts
var import_toolkit92 = require("@reduxjs/toolkit");

// src/features/commerce/facets/field-suggestions-order/field-suggestions-order-slice.ts
var import_toolkit89 = require("@reduxjs/toolkit");

// src/features/commerce/facets/field-suggestions-order/field-suggestions-order-state.ts
function getFieldSuggestionsOrderInitialState() {
  return [];
}

// src/features/commerce/facets/field-suggestions-order/field-suggestions-order-slice.ts
var fieldSuggestionsOrderReducer = (0, import_toolkit89.createReducer)(
  getFieldSuggestionsOrderInitialState(),
  (builder) => {
    builder.addCase(fetchQuerySuggestions.fulfilled, (_, action) => {
      return action.payload.fieldSuggestionsFacets ?? [];
    });
  }
);

// src/controllers/commerce/filter-suggestions/headless-category-filter-suggestions.ts
var import_toolkit90 = require("@reduxjs/toolkit");
function buildCategoryFilterSuggestions(engine, options) {
  if (!loadCategoryFilterSuggestionsReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(
    options.facetId
  );
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: {
      facetId: namespacedFacetId,
      ...options.facetSearch
    },
    select: () => {
    },
    isForFieldSuggestions: true
  });
  const getState = () => engine[stateKey];
  const controller = buildController(engine);
  const facetForFieldSuggestionsSelector = (0, import_toolkit90.createSelector)(
    (state) => state.fieldSuggestionsOrder,
    (facets) => facets.find((facet) => facet.facetId === options.facetId)
  );
  const facetSearchStateSelector = (0, import_toolkit90.createSelector)(
    (state) => state.categoryFacetSearchSet[namespacedFacetId],
    (facetSearch3) => ({
      isLoading: facetSearch3.isLoading,
      moreValuesAvailable: facetSearch3.response.moreValuesAvailable,
      query: facetSearch3.options.query,
      values: facetSearch3.response.values
    })
  );
  const { clear } = facetSearch2;
  return {
    ...controller,
    clear,
    updateQuery: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    getSearchParameters: (value) => searchSerializer.serialize({
      q: facetSearchStateSelector(getState()).query,
      cf: { [options.facetId]: [...value.path, value.rawValue] }
    }),
    select: (value) => {
      dispatch(clearAllCoreFacets());
      dispatch(
        selectCategoryFacetSearchResult({ facetId: options.facetId, value })
      );
      dispatch(
        updateQuery2({
          query: engine[stateKey].categoryFacetSearchSet[namespacedFacetId].options.query
        })
      );
      dispatch(options.fetchProductsActionCreator());
    },
    get state() {
      const { displayName, field: field2, facetId: facetId2 } = facetForFieldSuggestionsSelector(
        getState()
      );
      return {
        displayName,
        field: field2,
        facetId: facetId2,
        ...facetSearchStateSelector(getState())
      };
    },
    type: "hierarchical"
  };
}
function loadCategoryFilterSuggestionsReducers(engine) {
  engine.addReducers({
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    commerceFacetSet: commerceFacetSetReducer,
    commerceQuery: queryReducer,
    fieldSuggestionsOrder: fieldSuggestionsOrderReducer
  });
  return true;
}

// src/controllers/commerce/filter-suggestions/headless-filter-suggestions.ts
var import_toolkit91 = require("@reduxjs/toolkit");
function buildFilterSuggestions(engine, options) {
  if (!loadFilterSuggestionsReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(
    options.facetId
  );
  const facetSearch2 = buildRegularFacetSearch(engine, {
    options: { facetId: namespacedFacetId, ...options.facetSearch },
    select: () => {
    },
    exclude: () => {
    },
    isForFieldSuggestions: true
  });
  const getState = () => engine[stateKey];
  const controller = buildController(engine);
  const facetForFieldSuggestionsSelector = (0, import_toolkit91.createSelector)(
    (state) => state.fieldSuggestionsOrder,
    (facets) => facets.find((facet) => facet.facetId === options.facetId)
  );
  const facetSearchStateSelector = (0, import_toolkit91.createSelector)(
    (state) => state.facetSearchSet[namespacedFacetId],
    (facetSearch3) => ({
      isLoading: facetSearch3.isLoading,
      moreValuesAvailable: facetSearch3.response.moreValuesAvailable,
      query: facetSearch3.options.query,
      values: facetSearch3.response.values
    })
  );
  const { clear } = facetSearch2;
  return {
    ...controller,
    clear,
    updateQuery: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    getSearchParameters: (value) => searchSerializer.serialize({
      q: facetSearchStateSelector(getState()).query,
      f: { [options.facetId]: [value.rawValue] }
    }),
    select: (value) => {
      dispatch(clearAllCoreFacets());
      dispatch(selectFacetSearchResult({ facetId: options.facetId, value }));
      dispatch(
        updateQuery2({
          query: engine[stateKey].facetSearchSet[namespacedFacetId].options.query
        })
      );
      dispatch(options.fetchProductsActionCreator());
    },
    get state() {
      const { displayName, field: field2, facetId: facetId2 } = facetForFieldSuggestionsSelector(
        getState()
      );
      return {
        displayName,
        field: field2,
        facetId: facetId2,
        ...facetSearchStateSelector(getState())
      };
    },
    type: "regular"
  };
}
function loadFilterSuggestionsReducers(engine) {
  engine.addReducers({
    commerceFacetSet: commerceFacetSetReducer,
    commerceQuery: queryReducer,
    facetSearchSet: specificFacetSearchSetReducer,
    fieldSuggestionsOrder: fieldSuggestionsOrderReducer
  });
  return true;
}

// src/controllers/commerce/filter-suggestions/headless-filter-suggestions-generator.ts
function buildFilterSuggestionsGenerator(engine) {
  if (!loadFilterSuggestionsGeneratorReducers(engine)) {
    throw loadReducerError;
  }
  const commonOptions = {
    fetchProductsActionCreator: executeSearch3,
    facetResponseSelector: facetResponseSelector2,
    isFacetLoadingResponseSelector: isFacetLoadingResponseSelector3,
    facetSearch: { type: "SEARCH" }
  };
  const controller = buildController(engine);
  const createFacetedSearchControllers = (0, import_toolkit92.createSelector)(
    (state) => state.fieldSuggestionsOrder,
    (facetOrder) => facetOrder.map(({ type, facetId: facetId2 }) => {
      switch (type) {
        case "hierarchical":
          return buildCategoryFilterSuggestions(engine, {
            facetId: facetId2,
            ...commonOptions
          });
        default:
          return buildFilterSuggestions(engine, { facetId: facetId2, ...commonOptions });
      }
    })
  );
  return {
    ...controller,
    get filterSuggestions() {
      return createFacetedSearchControllers(engine[stateKey]);
    },
    get state() {
      return engine[stateKey].fieldSuggestionsOrder;
    }
  };
}
function loadFilterSuggestionsGeneratorReducers(engine) {
  engine.addReducers({
    fieldSuggestionsOrder: fieldSuggestionsOrderReducer
  });
  return true;
}

// src/ssr/commerce/controllers/filter-suggestions/headless-filter-suggestions-generator.ssr.ts
function defineFilterSuggestionsGenerator() {
  return {
    search: true,
    listing: true,
    standalone: true,
    build: (engine) => buildFilterSuggestionsGenerator(engine)
  };
}

// src/ssr/commerce/controllers/generator/headless-commerce-facet-generator.ssr.ts
function defineFacetGenerator(options) {
  ensureAtLeastOneSolutionType(options);
  return {
    listing: true,
    search: true,
    ...options,
    build: (engine, solutionType) => buildFacetGenerator2(engine, { props: { solutionType } })
  };
}
function buildFacetGenerator2(engine, options) {
  if (!loadFacetGeneratorReducers(engine)) {
    throw loadReducerError;
  }
  const getEngineState = () => engine[stateKey];
  const solutionType = options.props.solutionType;
  const getFacetResponseSelector = (facetId2) => {
    return solutionType === "listing" /* listing */ ? facetResponseSelector(getEngineState(), facetId2) : facetResponseSelector2(getEngineState(), facetId2);
  };
  const isFacetLoadingResponseSelector4 = solutionType === "listing" /* listing */ ? isFacetLoadingResponseSelector2(getEngineState()) : isFacetLoadingResponseSelector3(getEngineState());
  const createFacetState = (facetResponseSelector3) => {
    const facetId2 = facetResponseSelector3.facetId;
    return getCoreFacetState(
      facetId2,
      facetRequestSelector(getEngineState(), facetId2),
      facetResponseSelector3,
      isFacetLoadingResponseSelector4
    );
  };
  const baseController = solutionType === "listing" /* listing */ ? buildProductListing(engine).facetGenerator() : buildSearch(engine).facetGenerator();
  const { state: _state, ...restOfBaseController } = baseController;
  return {
    ...restOfBaseController,
    getFacetController: (facetId2, facetType) => {
      const controller = baseController.facets.find(
        (f2) => f2.state.facetId === facetId2 && f2.type === facetType
      );
      return controller;
    },
    get state() {
      const facetResponseSelectors = baseController.state.map(getFacetResponseSelector).filter((selector) => selector !== void 0);
      return facetResponseSelectors.map((selector) => {
        const facetResponseSelector3 = selector;
        const facetId2 = facetResponseSelector3.facetId;
        switch (facetResponseSelector3.type) {
          case "hierarchical":
            return getCategoryFacetState(
              createFacetState(facetResponseSelector3),
              categoryFacetSearchStateSelector(getEngineState(), facetId2),
              facetRequestSelector(
                getEngineState(),
                facetId2
              )
            );
          case "dateRange":
            return getDateFacetState(
              createFacetState(facetResponseSelector3)
            );
          case "numericalRange":
            return getNumericFacetState(
              createFacetState(facetResponseSelector3),
              facetResponseSelector3,
              manualNumericFacetSelector(getEngineState(), facetId2)
            );
          case "regular":
            return getRegularFacetState(
              createFacetState(facetResponseSelector3),
              specificFacetSearchStateSelector(getEngineState(), facetId2)
            );
          case "location":
            return getLocationFacetState(
              createFacetState(facetResponseSelector3)
            );
        }
      });
    }
  };
}
function loadFacetGeneratorReducers(engine) {
  engine.addReducers({ manualNumericFacetSet: manualNumericFacetReducer });
  return true;
}

// src/controllers/commerce/instant-products/headless-instant-products.ts
var import_bueno75 = require("@coveo/bueno");

// src/features/commerce/instant-products/instant-products-actions.ts
var import_bueno74 = require("@coveo/bueno");
var import_toolkit93 = require("@reduxjs/toolkit");
var instantProductsIdDefinition = {
  id: requiredNonEmptyString
};
var instantProductsQueryDefinition = {
  ...instantProductsIdDefinition,
  query: requiredEmptyAllowedString
};
var clearExpiredProducts = (0, import_toolkit93.createAction)(
  "commerce/instantProducts/clearExpired",
  (payload) => validatePayload(payload, instantProductsIdDefinition)
);
var promoteChildToParentDefinition4 = {
  child: new import_bueno74.RecordValue({
    options: { required: true },
    values: {
      permanentid: new import_bueno74.StringValue({ required: true })
    }
  }),
  ...instantProductsQueryDefinition
};
var promoteChildToParent4 = (0, import_toolkit93.createAction)(
  "commerce/instantProducts/promoteChildToParent",
  (payload) => validatePayload(payload, promoteChildToParentDefinition4)
);
var registerInstantProducts = (0, import_toolkit93.createAction)(
  "commerce/instantProducts/register",
  (payload) => validatePayload(payload, instantProductsIdDefinition)
);
var updateInstantProductsQuery = (0, import_toolkit93.createAction)(
  "commerce/instantProducts/updateQuery",
  (payload) => validatePayload(payload, instantProductsQueryDefinition)
);

// src/features/commerce/instant-products/instant-products-slice.ts
var import_toolkit94 = require("@reduxjs/toolkit");

// src/features/instant-items/instant-items-state.ts
function hasExpired(cached) {
  if (!cached) {
    return false;
  }
  return cached.expiresAt && Date.now() >= cached.expiresAt;
}

// src/features/instant-items/instant-items-slice.ts
var registerInstantItem = (payload, state) => {
  const { id: id2 } = payload;
  if (state[id2]) {
    return;
  }
  state[id2] = { q: "", cache: {} };
  return state;
};
var updateInstantItemQuery = (payload, state) => {
  const { q, id: id2 } = payload;
  if (!q) {
    return;
  }
  state[id2].q = q;
};
var clearExpiredItems = (payload, state) => {
  const { id: id2 } = payload;
  Object.entries(state[id2].cache).forEach(([q, cached]) => {
    if (hasExpired(cached)) {
      delete state[id2].cache[q];
    }
  });
};
var fetchItemsPending = (payload, state, toSetEmptyIfNotFound) => {
  for (const id2 in state) {
    for (const query2 in state[id2].cache) {
      state[id2].cache[query2].isActive = false;
    }
  }
  if (!getCached(payload, state)) {
    makeEmptyCache(payload, state, toSetEmptyIfNotFound);
    return;
  }
  const cached = getCached(payload, state);
  cached.isLoading = true;
  cached.isActive = true;
  cached.error = null;
};
var fetchItemsFulfilled = (payload, state, toAddToCache) => {
  const { id: id2, q, searchUid, cacheTimeout, totalCountFiltered, duration } = payload;
  state[id2].cache[q] = {
    ...getCached(payload, state),
    ...toAddToCache,
    isActive: true,
    searchUid,
    isLoading: false,
    error: null,
    expiresAt: cacheTimeout ? cacheTimeout + Date.now() : 0,
    totalCountFiltered,
    duration
  };
};
var fetchItemsRejected = (payload, state) => {
  const { id: id2, q, error } = payload;
  state[id2].cache[q].error = error || null;
  state[id2].cache[q].isLoading = false;
  state[id2].cache[q].isActive = false;
};
var getCached = (payload, state) => {
  const { q, id: id2 } = payload;
  return state[id2].cache[q] || null;
};
var makeEmptyCache = (payload, state, setToEmpty) => {
  const { q, id: id2 } = payload;
  state[id2].cache[q] = {
    isLoading: true,
    error: null,
    expiresAt: 0,
    isActive: true,
    searchUid: "",
    totalCountFiltered: 0,
    duration: 0,
    ...setToEmpty
  };
};

// src/features/commerce/instant-products/instant-products-state.ts
function getInstantProductsInitialState() {
  return {};
}

// src/features/commerce/instant-products/instant-products-slice.ts
var instantProductsReducer = (0, import_toolkit94.createReducer)(
  getInstantProductsInitialState(),
  (builder) => {
    builder.addCase(registerInstantProducts, (state, action) => {
      registerInstantItem(action.payload, state);
    }).addCase(updateInstantProductsQuery, (state, action) => {
      updateInstantItemQuery(
        { ...action.payload, q: action.payload.query },
        state
      );
    }).addCase(clearExpiredProducts, (state, action) => {
      clearExpiredItems(action.payload, state);
    }).addCase(fetchInstantProducts.pending, (state, action) => {
      fetchItemsPending(action.meta.arg, state, { products: [] });
    }).addCase(fetchInstantProducts.fulfilled, (state, action) => {
      const {
        response: {
          products,
          responseId,
          pagination: { totalEntries }
        }
      } = action.payload;
      fetchItemsFulfilled(
        {
          duration: 0,
          searchUid: responseId,
          totalCountFiltered: totalEntries,
          ...action.meta.arg
        },
        state,
        {
          products: products.map(
            (product, index) => preprocessProduct3(product, index + 1, responseId)
          )
        }
      );
    }).addCase(fetchInstantProducts.rejected, (state, action) => {
      fetchItemsRejected(action.meta.arg, state);
    }).addCase(promoteChildToParent4, (state, action) => {
      const cache = state[action.payload.id].cache[action.payload.query];
      if (!cache) {
        return;
      }
      const products = cache.products;
      let childToPromote;
      const currentParentIndex = products.findIndex((product) => {
        childToPromote = product.children.find(
          (child) => child.permanentid === action.payload.child.permanentid
        );
        return !!childToPromote;
      });
      if (currentParentIndex === -1 || childToPromote === void 0) {
        return;
      }
      const responseId = products[currentParentIndex].responseId;
      const position = products[currentParentIndex].position;
      const { children, totalNumberOfChildren } = products[currentParentIndex];
      const newParent = {
        ...childToPromote,
        resultType: "product" /* PRODUCT */,
        children,
        totalNumberOfChildren,
        position,
        responseId
      };
      const newProducts = [...products];
      newProducts.splice(currentParentIndex, 1, newParent);
      cache.products = newProducts;
    });
  }
);
function preprocessProduct3(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some(
    (child) => child.permanentid === product.permanentid
  );
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const {
    children,
    totalNumberOfChildren: _totalNumberOfChildren,
    ...restOfProduct
  } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}

// src/controllers/commerce/instant-products/headless-instant-products.ts
var instantProductsOptionDefinitions = {
  searchBoxId: nonEmptyString,
  cacheTimeout: new import_bueno75.NumberValue()
};
var instantProductsOptionsSchema = new import_bueno75.Schema(instantProductsOptionDefinitions);
function buildInstantProducts(engine, props) {
  if (!loadInstantProductsReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const options = {
    searchBoxId: props.options.searchBoxId || randomID("instant-products-"),
    cacheTimeout: props.options.cacheTimeout || 6e4
  };
  validateOptions(
    engine,
    instantProductsOptionsSchema,
    options,
    "buildInstantProducts"
  );
  const searchBoxId = options.searchBoxId;
  dispatch(registerInstantProducts({ id: searchBoxId }));
  const getStateForSearchBox = () => getState().instantProducts[searchBoxId];
  const getCached2 = (q) => getStateForSearchBox().cache[q];
  const getQuery = () => getStateForSearchBox().q;
  const getProducts = () => {
    const cached = getCached2(getQuery());
    if (!cached) {
      return [];
    }
    if (cached.isLoading) {
      return [];
    }
    return cached.products;
  };
  return {
    ...controller,
    updateQuery(query2) {
      if (!query2) {
        return;
      }
      const cached = getCached2(query2);
      if (!cached || !cached.isLoading && (cached.error || hasExpired(cached))) {
        dispatch(
          fetchInstantProducts({
            id: searchBoxId,
            q: query2,
            cacheTimeout: options.cacheTimeout
          })
        );
      }
      dispatch(updateInstantProductsQuery({ id: searchBoxId, query: query2 }));
    },
    clearExpired() {
      dispatch(
        clearExpiredProducts({
          id: searchBoxId
        })
      );
    },
    promoteChildToParent(child) {
      dispatch(
        promoteChildToParent4({
          child,
          id: searchBoxId,
          query: getQuery()
        })
      );
    },
    interactiveProduct(props2) {
      return buildCoreInteractiveProduct(engine, {
        ...props2,
        responseIdSelector: () => getStateForSearchBox().cache[getQuery()].searchUid
      });
    },
    get state() {
      const query2 = getQuery();
      const cached = getCached2(query2);
      return {
        query: query2,
        isLoading: cached?.isLoading || false,
        error: cached?.error || null,
        products: getProducts(),
        totalCount: cached?.totalCountFiltered || 0
      };
    }
  };
}
function loadInstantProductsReducers(engine) {
  engine.addReducers({ instantProducts: instantProductsReducer });
  return true;
}

// src/ssr/commerce/controllers/instant-products/headless-instant-products.ssr.ts
function defineInstantProducts(props = { options: {} }) {
  return {
    listing: true,
    search: true,
    standalone: true,
    build: (engine) => buildInstantProducts(engine, props)
  };
}

// src/ssr/commerce/controllers/pagination/headless-core-commerce-pagination.ssr.ts
function definePagination(props) {
  ensureAtLeastOneSolutionType(props);
  return {
    listing: true,
    search: true,
    ...props,
    build: (engine, solutionType) => solutionType === "listing" /* listing */ ? buildProductListing(engine).pagination(props) : buildSearch(engine).pagination(props)
  };
}

// src/features/query-set/query-set-slice.ts
var import_bueno77 = require("@coveo/bueno");
var import_toolkit98 = require("@reduxjs/toolkit");

// src/features/commerce/query-set/query-set-actions.ts
var import_toolkit96 = require("@reduxjs/toolkit");

// src/features/query-set/query-set-actions.ts
var import_toolkit95 = require("@reduxjs/toolkit");
var querySetDefinition = {
  id: requiredNonEmptyString,
  query: requiredEmptyAllowedString
};
var registerQuerySetQuery = (0, import_toolkit95.createAction)(
  "querySet/register",
  (payload) => validatePayload(payload, querySetDefinition)
);
var updateQuerySetQuery = (0, import_toolkit95.createAction)(
  "querySet/update",
  (payload) => validatePayload(payload, querySetDefinition)
);

// src/features/commerce/query-set/query-set-actions.ts
var registerQuerySetQuery2 = (0, import_toolkit96.createAction)(
  "commerce/querySet/register",
  (payload) => validatePayload(payload, querySetDefinition)
);
var updateQuerySetQuery2 = (0, import_toolkit96.createAction)(
  "commerce/querySet/update",
  (payload) => validatePayload(payload, querySetDefinition)
);

// src/features/query-suggest/query-suggest-actions.ts
var import_bueno76 = require("@coveo/bueno");
var import_toolkit97 = require("@reduxjs/toolkit");
var idDefinition = {
  id: requiredNonEmptyString
};
var registerQuerySuggest2 = (0, import_toolkit97.createAction)(
  "querySuggest/register",
  (payload) => validatePayload(payload, {
    ...idDefinition,
    count: new import_bueno76.NumberValue({ min: 0 })
  })
);
var unregisterQuerySuggest = (0, import_toolkit97.createAction)(
  "querySuggest/unregister",
  (payload) => validatePayload(payload, idDefinition)
);
var selectQuerySuggestion2 = (0, import_toolkit97.createAction)(
  "querySuggest/selectSuggestion",
  (payload) => validatePayload(payload, {
    ...idDefinition,
    expression: requiredEmptyAllowedString
  })
);
var clearQuerySuggest2 = (0, import_toolkit97.createAction)(
  "querySuggest/clear",
  (payload) => validatePayload(payload, idDefinition)
);
var fetchQuerySuggestions2 = (0, import_toolkit97.createAsyncThunk)(
  "querySuggest/fetch",
  async (payload, {
    getState,
    rejectWithValue,
    extra: { apiClient, validatePayload: validatePayload2, navigatorContext }
  }) => {
    validatePayload2(payload, idDefinition);
    const id2 = payload.id;
    const request = await buildQuerySuggestRequest2(
      id2,
      getState(),
      navigatorContext
    );
    const response = await apiClient.querySuggest(request);
    if (isErrorResponse(response)) {
      return rejectWithValue(response.error);
    }
    return {
      id: id2,
      q: request.q,
      ...response.success
    };
  }
);
var buildQuerySuggestRequest2 = async (id2, s, navigatorContext) => {
  return {
    accessToken: s.configuration.accessToken,
    organizationId: s.configuration.organizationId,
    url: s.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      s.configuration.organizationId,
      s.configuration.environment
    ),
    count: s.querySuggest[id2].count,
    q: s.querySet[id2],
    locale: s.configuration.search.locale,
    timezone: s.configuration.search.timezone,
    actionsHistory: s.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : [],
    ...s.context && { context: s.context.contextValues },
    ...s.pipeline && { pipeline: s.pipeline },
    ...s.searchHub && { searchHub: s.searchHub },
    tab: s.configuration.analytics.originLevel2,
    ...s.configuration.analytics.enabled && {
      ...s.configuration.analytics.enabled && s.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams2(
        s.configuration.analytics
      ) : fromAnalyticsStateToAnalyticsParams(
        s.configuration.analytics,
        navigatorContext
      )
    },
    ...s.configuration.search.authenticationProviders.length && {
      authentication: s.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/query-set/query-set-slice.ts
var querySetReducer = (0, import_toolkit98.createReducer)(
  getQuerySetInitialState(),
  (builder) => {
    builder.addCase(
      registerQuerySetQuery,
      (state, action) => registerQuery(state, action.payload)
    ).addCase(
      registerQuerySetQuery2,
      (state, action) => registerQuery(state, action.payload)
    ).addCase(updateQuerySetQuery, (state, action) => {
      const { id: id2, query: query2 } = action.payload;
      updateQuery3(state, id2, query2);
    }).addCase(updateQuerySetQuery2, (state, action) => {
      const { id: id2, query: query2 } = action.payload;
      updateQuery3(state, id2, query2);
    }).addCase(selectQuerySuggestion2, (state, action) => {
      const { id: id2, expression } = action.payload;
      updateQuery3(state, id2, expression);
    }).addCase(selectQuerySuggestion, (state, action) => {
      const { id: id2, expression } = action.payload;
      updateQuery3(state, id2, expression);
    }).addCase(executeSearch3.fulfilled, (state, action) => {
      const { queryExecuted } = action.payload;
      updateAllQuerySetQuery(state, queryExecuted);
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const { queryExecuted } = action.payload;
      updateAllQuerySetQuery(state, queryExecuted);
    }).addCase(restoreSearchParameters, handleRestoreSearchParameters).addCase(restoreSearchParameters2, handleRestoreSearchParameters).addCase(change.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      for (const [id2, query2] of Object.entries(action.payload.querySet)) {
        updateQuery3(state, id2, query2);
      }
    });
  }
);
function handleRestoreSearchParameters(state, action) {
  if (!(0, import_bueno77.isNullOrUndefined)(action.payload.q)) {
    updateAllQuerySetQuery(state, action.payload.q);
  }
}
function updateAllQuerySetQuery(state, query2) {
  Object.keys(state).forEach((id2) => {
    state[id2] = query2;
  });
}
var updateQuery3 = (state, id2, query2) => {
  if (id2 in state) {
    state[id2] = query2;
  }
};
var registerQuery = (state, actionPayload) => {
  const { id: id2, query: query2 } = actionPayload;
  if (id2 in state) {
    return;
  }
  state[id2] = query2;
};

// src/ssr/commerce/controllers/parameter-manager/headless-core-parameter-manager.ssr.ts
function defineParameterManager(options) {
  ensureAtLeastOneSolutionType(options);
  return {
    listing: true,
    search: true,
    ...options,
    buildWithProps: (engine, props, solutionType) => {
      if (solutionType === "listing" /* listing */) {
        if (!loadCommerceProductListingParameterReducers(engine)) {
          throw loadReducerError;
        }
        const controller = buildProductListing(engine).parameterManager({
          ...props,
          excludeDefaultParameters: true
        });
        return createControllerWithKind(controller, "PARAMETER_MANAGER" /* ParameterManager */);
      } else {
        if (!loadCommerceSearchParameterReducers(engine)) {
          throw loadReducerError;
        }
        const controller = buildSearch(engine).parameterManager({
          ...props,
          excludeDefaultParameters: true
        });
        return createControllerWithKind(controller, "PARAMETER_MANAGER" /* ParameterManager */);
      }
    }
  };
}
function loadCommerceCommonParameterReducers(engine) {
  engine.addReducers({
    commerceParameters: parametersReducer,
    commerceFacetSet: commerceFacetSetReducer,
    commerceSort: sortReducer,
    commercePagination: paginationReducer,
    facetOrder: facetOrderReducer,
    manualNumericFacetSet: manualNumericFacetReducer
  });
  return true;
}
function loadCommerceSearchParameterReducers(engine) {
  loadCommerceCommonParameterReducers(engine);
  engine.addReducers({ query: queryReducer, querySet: querySetReducer });
  return true;
}
function loadCommerceProductListingParameterReducers(engine) {
  loadCommerceCommonParameterReducers(engine);
  return true;
}

// src/features/commerce/product-enrichment/product-enrichment.ts
var import_bueno78 = require("@coveo/bueno");
var productEnrichmentDefinition = {
  placementIds: new import_bueno78.ArrayValue({
    required: false,
    min: 1,
    each: requiredNonEmptyString
  }),
  productId: nonEmptyString
};
var productEnrichmentOptionsSchema = new import_bueno78.Schema(productEnrichmentDefinition);

// src/features/commerce/product-enrichment/product-enrichment-actions.ts
var import_toolkit99 = require("@reduxjs/toolkit");
var registerProductEnrichmentOptions = (0, import_toolkit99.createAction)(
  "commerce/productEnrichment/registerOptions"
);
var buildProductEnrichmentBadgesRequest2 = (payload, state, navigatorContext) => {
  const baseRequest2 = buildBaseCommerceAPIRequest(state, navigatorContext);
  return {
    ...baseRequest2,
    context: {
      ...baseRequest2.context,
      ...payload.productId ? { product: { productId: payload.productId } } : {}
    },
    placementIds: payload.placementIds
  };
};
var fetchBadges = (0, import_toolkit99.createAsyncThunk)(
  "commerce/productEnrichment/fetchBadges",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    validatePayload(payload, productEnrichmentDefinition);
    const request = buildProductEnrichmentBadgesRequest2(
      payload,
      getState(),
      navigatorContext
    );
    const fetched = await apiClient.getBadges(request);
    if ("error" in fetched) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);

// src/features/commerce/product-enrichment/product-enrichment-slice.ts
var import_toolkit100 = require("@reduxjs/toolkit");

// src/features/commerce/product-enrichment/product-enrichment-state.ts
function getProductEnrichmentInitialState() {
  return {
    products: [],
    isLoading: false,
    error: null,
    productId: void 0,
    placementIds: []
  };
}

// src/features/commerce/product-enrichment/product-enrichment-slice.ts
var productEnrichmentReducer = (0, import_toolkit100.createReducer)(
  getProductEnrichmentInitialState(),
  (builder) => {
    builder.addCase(registerProductEnrichmentOptions, (state, action) => {
      state.productId = action.payload.productId;
      state.placementIds = action.payload.placementIds ?? [];
    }).addCase(fetchBadges.pending, (state) => {
      state.isLoading = true;
      state.error = null;
    }).addCase(fetchBadges.fulfilled, (state, action) => {
      handleFulfilled3(state);
      state.products = action.payload.response.products;
    }).addCase(fetchBadges.rejected, (state, action) => {
      handleError3(state, action.payload);
    });
  }
);
function handleError3(state, error) {
  state.error = error || null;
  state.isLoading = false;
  state.products = [];
}
function handleFulfilled3(state) {
  state.error = null;
  state.isLoading = false;
}

// src/controllers/commerce/product-enrichment/headless-product-enrichment.ts
var defaultProductEnrichmentOptions = {
  placementIds: [],
  productId: void 0
};
function validateProductEnrichmentProps(engine, props) {
  validateInitialState(
    engine,
    productEnrichmentOptionsSchema,
    props?.options,
    "buildProductEnrichment"
  );
}
function buildProductEnrichment(engine, props) {
  if (!loadProductEnrichmentReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const registrationOptions = {
    ...defaultProductEnrichmentOptions,
    ...props?.options
  };
  validateProductEnrichmentProps(engine, {
    options: props?.options
  });
  dispatch(
    registerProductEnrichmentOptions({
      productId: registrationOptions.productId,
      placementIds: registrationOptions.placementIds
    })
  );
  return {
    ...controller,
    get state() {
      return getState().productEnrichment;
    },
    getBadges() {
      const { placementIds, productId } = getState().productEnrichment;
      if (!placementIds || placementIds.length === 0) {
        throw new Error(
          "placementIds must be provided and non-empty to fetch badges"
        );
      }
      dispatch(
        fetchBadges({
          placementIds,
          productId
        })
      );
    }
  };
}
function loadProductEnrichmentReducer(engine) {
  engine.addReducers({ productEnrichment: productEnrichmentReducer });
  return true;
}

// src/ssr/commerce/controllers/product-enrichment/headless-product-enrichment.ssr.ts
function defineProductEnrichment() {
  return {
    standalone: true,
    buildWithProps: (engine, props) => {
      if (props === void 0) {
        throw new MissingControllerProps("PRODUCT_ENRICHMENT" /* ProductEnrichment */);
      }
      const controller = buildProductEnrichment(engine, props);
      return createControllerWithKind(controller, "PRODUCT_ENRICHMENT" /* ProductEnrichment */);
    }
  };
}

// src/ssr/commerce/controllers/product-list/headless-product-list.ssr.ts
function defineProductList(options) {
  ensureAtLeastOneSolutionType(options);
  return {
    listing: true,
    search: true,
    ...options,
    build: (engine, solutionType) => solutionType === "listing" /* listing */ ? buildProductListing(engine) : buildSearch(engine)
  };
}

// src/controllers/commerce/product-view/headless-product-view.ts
function buildProductView(engine) {
  return {
    view: (product) => {
      engine.dispatch(productView(product));
    }
  };
}

// src/ssr/commerce/controllers/product-view/headless-product-view.ssr.ts
function defineProductView() {
  return {
    listing: true,
    search: true,
    standalone: true,
    build: (engine) => buildSSRProductView(engine)
  };
}
function buildSSRProductView(engine) {
  const controller = buildController(engine);
  const productView2 = buildProductView(engine);
  return {
    ...controller,
    ...productView2
  };
}

// src/controllers/commerce/recent-queries-list/headless-recent-queries-list.ts
var import_bueno80 = require("@coveo/bueno");

// src/features/commerce/recent-queries/recent-queries-actions.ts
var import_toolkit102 = require("@reduxjs/toolkit");

// src/features/recent-queries/recent-queries-actions.ts
var import_bueno79 = require("@coveo/bueno");
var import_toolkit101 = require("@reduxjs/toolkit");
var registerRecentQueriesPayloadDefinition = {
  queries: new import_bueno79.ArrayValue({
    required: true,
    each: new import_bueno79.StringValue({ emptyAllowed: false })
  }),
  maxLength: new import_bueno79.NumberValue({ required: true, min: 1, default: 10 })
};
var registerRecentQueries = (0, import_toolkit101.createAction)(
  "recentQueries/registerRecentQueries",
  (payload) => validatePayload(payload, registerRecentQueriesPayloadDefinition)
);
var clearRecentQueries = (0, import_toolkit101.createAction)(
  "recentQueries/clearRecentQueries"
);

// src/features/commerce/recent-queries/recent-queries-actions.ts
var clearRecentQueries2 = (0, import_toolkit102.createAction)("commerce/recentQueries/clear");
var registerRecentQueries2 = (0, import_toolkit102.createAction)(
  "commerce/recentQueries/register",
  (payload) => validatePayload(payload, registerRecentQueriesPayloadDefinition)
);

// src/features/commerce/recent-queries/recent-queries-slice.ts
var import_toolkit104 = require("@reduxjs/toolkit");

// src/features/recent-queries/recent-queries-slice.ts
var import_toolkit103 = require("@reduxjs/toolkit");

// src/features/recent-queries/recent-queries-state.ts
function getRecentQueriesInitialState() {
  return {
    queries: [],
    maxLength: 10
  };
}

// src/features/recent-queries/recent-queries-slice.ts
var recentQueriesReducer = (0, import_toolkit103.createReducer)(
  getRecentQueriesInitialState(),
  (builder) => {
    builder.addCase(registerRecentQueries, handleRegisterQueries).addCase(clearRecentQueries, handleClearRecentQueries).addCase(executeSearch2.fulfilled, (state, action) => {
      const query2 = action.payload.queryExecuted;
      const results = action.payload.response.results;
      if (!query2.length || !results.length) {
        return;
      }
      handleExecuteSearchFulfilled(query2, state);
    });
  }
);
function handleRegisterQueries(state, action) {
  state.queries = Array.from(
    new Set(action.payload.queries.map((query2) => query2.trim().toLowerCase()))
  ).slice(0, action.payload.maxLength);
  state.maxLength = action.payload.maxLength;
}
function handleClearRecentQueries(state) {
  state.queries = [];
}
function handleExecuteSearchFulfilled(query2, state) {
  const cleanNewQuery = query2.trim().toLowerCase();
  if (cleanNewQuery === "") {
    return;
  }
  const previousQueries = Array.from(
    new Set(
      state.queries.filter(
        (query3) => query3.trim().toLowerCase() !== cleanNewQuery
      )
    )
  ).slice(0, state.maxLength - 1);
  state.queries = [cleanNewQuery, ...previousQueries];
}

// src/features/commerce/recent-queries/recent-queries-slice.ts
var recentQueriesReducer2 = (0, import_toolkit104.createReducer)(
  getRecentQueriesInitialState(),
  (builder) => {
    builder.addCase(registerRecentQueries2, handleRegisterQueries).addCase(clearRecentQueries2, handleClearRecentQueries).addCase(executeSearch3.fulfilled, (state, action) => {
      const query2 = action.payload.queryExecuted;
      const products = action.payload.response.products;
      if (!query2.length || !products.length) {
        return;
      }
      handleExecuteSearchFulfilled(query2, state);
    });
  }
);

// src/controllers/commerce/recent-queries-list/headless-recent-queries-list.ts
var defaultRecentQueriesState = {
  queries: []
};
var defaultRecentQueriesOptions = {
  maxLength: 10,
  clearFilters: true
};
var initialStateSchema4 = new import_bueno80.Schema({
  queries: new import_bueno80.ArrayValue({ required: true })
});
var optionsSchema3 = new import_bueno80.Schema({
  maxLength: new import_bueno80.NumberValue({ required: true, min: 1 }),
  clearFilters: new import_bueno80.BooleanValue()
});
function validateRecentQueriesProps(engine, props) {
  validateOptions(
    engine,
    optionsSchema3,
    props?.options,
    "buildRecentQueriesList"
  );
  validateInitialState(
    engine,
    initialStateSchema4,
    props?.initialState,
    "buildRecentQueriesList"
  );
}
function buildRecentQueriesList(engine, props) {
  if (!loadRecentQueriesListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const registrationOptions = {
    ...defaultRecentQueriesOptions,
    ...props?.options
  };
  const registrationState = {
    ...defaultRecentQueriesState,
    ...props?.initialState
  };
  validateRecentQueriesProps(engine, {
    options: registrationOptions,
    initialState: registrationState
  });
  const options = {
    queries: registrationState.queries,
    maxLength: registrationOptions.maxLength
  };
  dispatch(registerRecentQueries2(options));
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...state.recentQueries,
        analyticsEnabled: state.configuration.analytics.enabled
      };
    },
    clear() {
      dispatch(clearRecentQueries2());
    },
    updateRecentQueries(queries) {
      const errorMessage = new import_bueno80.ArrayValue({
        required: true,
        each: new import_bueno80.StringValue({ required: true }),
        min: 1
      }).validate(queries);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      dispatch(
        registerRecentQueries2({
          queries,
          maxLength: registrationOptions.maxLength
        })
      );
    },
    executeRecentQuery(index) {
      const errorMessage = new import_bueno80.NumberValue({
        required: true,
        min: 0,
        max: this.state.queries.length
      }).validate(index);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      const queryOptions = {
        query: this.state.queries[index],
        clearFilters: registrationOptions.clearFilters
      };
      dispatch(prepareForSearchWithQuery2(queryOptions));
      dispatch(executeSearch3());
    }
  };
}
function loadRecentQueriesListReducer(engine) {
  engine.addReducers({ search: commerceSearchReducer, recentQueries: recentQueriesReducer2 });
  return true;
}

// src/ssr/commerce/controllers/recent-queries-list/headless-recent-queries-list.ssr.ts
function defineRecentQueriesList(props = {}) {
  return {
    search: true,
    listing: true,
    standalone: true,
    build: (engine) => buildRecentQueriesList(engine, props)
  };
}

// src/features/commerce/recommendations/recommendations-slice.ts
var import_toolkit105 = require("@reduxjs/toolkit");

// src/features/commerce/recommendations/recommendations-state.ts
var getRecommendationsInitialState = () => ({});
var getRecommendationsSliceInitialState = () => ({
  headline: "",
  error: null,
  isLoading: false,
  responseId: "",
  products: [],
  productId: void 0
});

// src/features/commerce/recommendations/recommendations-slice.ts
var recommendationsReducer = (0, import_toolkit105.createReducer)(
  getRecommendationsInitialState(),
  (builder) => {
    builder.addCase(registerRecommendationsSlot, (state, action) => {
      const slotId = action.payload.slotId;
      const productId = action.payload.productId;
      if (slotId in state) {
        return;
      }
      if (!productId) {
        state[slotId] = buildRecommendationsSlice();
        return;
      }
      state[slotId] = buildRecommendationsSlice({ productId });
    }).addCase(fetchRecommendations.rejected, (state, action) => {
      handleError4(state, action.meta.arg.slotId, action.payload);
    }).addCase(fetchMoreRecommendations.rejected, (state, action) => {
      handleError4(state, action.meta.arg.slotId, action.payload);
    }).addCase(fetchRecommendations.fulfilled, (state, action) => {
      const slotId = action.meta.arg.slotId;
      const response = action.payload.response;
      handleFulfilled4(state, slotId, response);
      const recommendations = state[slotId];
      if (!recommendations) {
        return;
      }
      const paginationOffset = getPaginationOffset3(action.payload);
      recommendations.products = response.products.map(
        (product, index) => preprocessProduct4(
          product,
          paginationOffset + index + 1,
          response.responseId
        )
      );
    }).addCase(fetchMoreRecommendations.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      const slotId = action.meta.arg.slotId;
      const response = action.payload.response;
      handleFulfilled4(state, slotId, response);
      const recommendations = state[slotId];
      if (!recommendations) {
        return;
      }
      const paginationOffset = getPaginationOffset3(action.payload);
      recommendations.products = recommendations.products.concat(
        response.products.map(
          (product, index) => preprocessProduct4(
            product,
            paginationOffset + index + 1,
            response.responseId
          )
        )
      );
    }).addCase(fetchRecommendations.pending, (state, action) => {
      handlePending3(state, action.meta.arg.slotId);
    }).addCase(fetchMoreRecommendations.pending, (state, action) => {
      handlePending3(state, action.meta.arg.slotId);
    }).addCase(promoteChildToParent3, (state, action) => {
      const recommendations = state[action.payload.slotId];
      if (!recommendations) {
        return;
      }
      const { products } = recommendations;
      let childToPromote;
      const currentParentIndex = products.findIndex((product) => {
        childToPromote = product.children.find(
          (child) => child.permanentid === action.payload.child.permanentid
        );
        return !!childToPromote;
      });
      if (currentParentIndex === -1 || childToPromote === void 0) {
        return;
      }
      const responseId = products[currentParentIndex].responseId;
      const position = products[currentParentIndex].position;
      const { children, totalNumberOfChildren } = products[currentParentIndex];
      const newParent = {
        ...childToPromote,
        resultType: "product" /* PRODUCT */,
        children,
        totalNumberOfChildren,
        position,
        responseId
      };
      products.splice(currentParentIndex, 1, newParent);
    }).addCase(setError, (state, action) => {
      Object.keys(state).forEach((slotId) => {
        handleError4(state, slotId, action.payload);
      });
    });
  }
);
function buildRecommendationsSlice(config) {
  return {
    ...getRecommendationsSliceInitialState(),
    ...config
  };
}
function handleError4(state, slotId, error) {
  const recommendations = state[slotId];
  if (!recommendations) {
    return;
  }
  recommendations.error = error ?? null;
  recommendations.isLoading = false;
}
function handleFulfilled4(state, slotId, response) {
  const recommendations = state[slotId];
  if (!recommendations) {
    return;
  }
  recommendations.error = null;
  recommendations.headline = response.headline;
  recommendations.responseId = response.responseId;
  recommendations.isLoading = false;
}
function handlePending3(state, slotId) {
  const recommendations = state[slotId];
  if (!recommendations) {
    return;
  }
  recommendations.isLoading = true;
}
function getPaginationOffset3(actionPayload) {
  const pagination = actionPayload.response.pagination;
  return pagination.page * pagination.perPage;
}
function preprocessProduct4(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some(
    (child) => child.permanentid === product.permanentid
  );
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const {
    children,
    totalNumberOfChildren: _totalNumberOfChildren,
    ...restOfProduct
  } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}

// src/controllers/commerce/recommendations/headless-recommendations.ts
function buildRecommendations(engine, props) {
  if (!loadBaseRecommendationsReducers(engine)) {
    throw loadReducerError;
  }
  validateInitialState(
    engine,
    recommendationsOptionsSchema,
    props.options,
    "buildRecommendations"
  );
  const controller = buildController(engine);
  const { dispatch } = engine;
  const { slotId, productId } = props.options;
  dispatch(registerRecommendationsSlot({ slotId, productId }));
  const recommendationStateSelector = (state) => state.recommendations[slotId];
  const subControllers = buildBaseSubControllers(
    engine,
    {
      slotId,
      responseIdSelector: (state) => state.recommendations[slotId].responseId,
      fetchProductsActionCreator: () => fetchRecommendations({ slotId }),
      fetchMoreProductsActionCreator: () => fetchMoreRecommendations({ slotId }),
      isLoadingSelector: (state) => isLoadingSelector3(state, slotId),
      errorSelector: (state) => state.recommendations[slotId].error,
      pageSelector: (state) => pageRecommendationSelector(state, slotId),
      perPageSelector: (state) => perPageRecommendationSelector(state, slotId),
      totalEntriesSelector: (state) => totalEntriesRecommendationSelector(state, slotId),
      numberOfProductsSelector: (state) => numberOfRecommendationsSelector(state, slotId)
    }
  );
  return {
    ...controller,
    ...subControllers,
    promoteChildToParent(child) {
      dispatch(promoteChildToParent3({ child, slotId }));
    },
    get state() {
      return recommendationStateSelector(engine[stateKey]);
    },
    refresh: () => dispatch(fetchRecommendations({ slotId, productId }))
  };
}
function loadBaseRecommendationsReducers(engine) {
  engine.addReducers({ recommendations: recommendationsReducer });
  return true;
}

// src/ssr/commerce/controllers/recommendations/headless-recommendations.ssr.ts
function defineRecommendations(props) {
  return {
    recommendation: true,
    [recommendationInternalOptionKey]: {
      ...props.options
    },
    buildWithProps: (engine, options) => {
      const staticOptions = props.options;
      const controller = buildRecommendations(engine, {
        options: { ...staticOptions, ...options }
      });
      return createControllerWithKind(controller, "RECOMMENDATIONS" /* Recommendations */);
    }
  };
}

// src/features/query-suggest/query-suggest-slice.ts
var import_toolkit106 = require("@reduxjs/toolkit");

// src/features/query-suggest/query-suggest-state.ts
var getQuerySuggestSetInitialState = () => ({});

// src/features/query-suggest/query-suggest-slice.ts
var querySuggestReducer = (0, import_toolkit106.createReducer)(
  getQuerySuggestSetInitialState(),
  (builder) => builder.addCase(registerQuerySuggest2, (state, action) => {
    handleRegisterQuerySuggest(state, action.payload);
  }).addCase(registerQuerySuggest, (state, action) => {
    handleRegisterQuerySuggest(state, action.payload);
  }).addCase(unregisterQuerySuggest, (state, action) => {
    delete state[action.payload.id];
  }).addCase(fetchQuerySuggestions2.pending, handleFetchPending).addCase(fetchQuerySuggestions2.fulfilled, (state, action) => {
    const querySuggest = state[action.meta.arg.id];
    if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
      return;
    }
    const { q } = action.payload;
    if (q) {
      querySuggest.partialQueries.push(
        q.replace(/;/, encodeURIComponent(";"))
      );
    }
    querySuggest.responseId = action.payload.responseId;
    querySuggest.completions = action.payload.completions;
    querySuggest.isLoading = false;
    querySuggest.error = null;
  }).addCase(fetchQuerySuggestions2.rejected, handleFetchRejected).addCase(fetchQuerySuggestions.pending, handleFetchPending).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
    const querySuggest = state[action.meta.arg.id];
    if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
      return;
    }
    const { query: query2 } = action.payload;
    if (query2) {
      querySuggest.partialQueries.push(
        query2.replace(/;/, encodeURIComponent(";"))
      );
    }
    querySuggest.responseId = action.payload.responseId;
    querySuggest.completions = action.payload.completions.map(
      (completion) => ({
        expression: completion.expression,
        highlighted: completion.highlighted,
        score: 0,
        executableConfidence: 0
      })
    );
    querySuggest.isLoading = false;
    querySuggest.error = null;
  }).addCase(fetchQuerySuggestions.rejected, handleFetchRejected).addCase(clearQuerySuggest2, (state, action) => {
    handleClearQuerySuggest(state, action.payload);
  }).addCase(clearQuerySuggest, (state, action) => {
    handleClearQuerySuggest(state, action.payload);
  }).addCase(setError, (state, action) => {
    Object.keys(state).forEach((slotId) => {
      const slot = state[slotId];
      if (slot) {
        slot.error = action.payload;
        slot.isLoading = false;
      }
    });
  })
);
function handleRegisterQuerySuggest(state, payload) {
  const id2 = payload.id;
  if (id2 in state) {
    return;
  }
  state[id2] = buildQuerySuggest(payload);
}
function buildQuerySuggest(config) {
  return {
    id: "",
    completions: [],
    responseId: "",
    count: 5,
    currentRequestId: "",
    error: null,
    partialQueries: [],
    isLoading: false,
    ...config
  };
}
function handleFetchPending(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.currentRequestId = action.meta.requestId;
  querySuggest.isLoading = true;
}
function handleFetchRejected(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.error = action.payload || null;
  querySuggest.isLoading = false;
}
function handleClearQuerySuggest(state, payload) {
  const querySuggest = state[payload.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.responseId = "";
  querySuggest.completions = [];
  querySuggest.partialQueries = [];
}

// src/features/query/query-slice.ts
var import_toolkit107 = require("@reduxjs/toolkit");
var queryReducer2 = (0, import_toolkit107.createReducer)(
  getQueryInitialState(),
  (builder) => builder.addCase(updateQuery, (state, action) => ({ ...state, ...action.payload })).addCase(applyDidYouMeanCorrection, (state, action) => {
    state.q = action.payload;
  }).addCase(selectQuerySuggestion2, (state, action) => {
    state.q = action.payload.expression;
  }).addCase(
    change.fulfilled,
    (state, action) => action.payload?.query ?? state
  ).addCase(restoreSearchParameters, (state, action) => {
    state.q = action.payload.q ?? state.q;
    state.enableQuerySyntax = action.payload.enableQuerySyntax ?? state.enableQuerySyntax;
  })
);

// src/utils/highlight.ts
var import_bueno81 = require("@coveo/bueno");
function getHighlightedSuggestion(suggestion, options) {
  suggestion = escapeHtml(suggestion);
  return suggestion.replace(
    /\[(.*?)\]|\{(.*?)\}|\((.*?)\)/g,
    (part, notMatched, matched, corrected) => {
      if (notMatched) {
        return suggestionWithDelimiters(notMatched, options.notMatchDelimiters);
      }
      if (matched) {
        return suggestionWithDelimiters(matched, options.exactMatchDelimiters);
      }
      if (corrected) {
        return suggestionWithDelimiters(
          corrected,
          options.correctionDelimiters
        );
      }
      return part;
    }
  );
}
function suggestionWithDelimiters(suggestion, delimiters) {
  if (delimiters) {
    return delimiters.open + suggestion + delimiters.close;
  }
  return suggestion;
}
function escapeHtml(str) {
  const mapOfCharToEscape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };
  const source = `(?:${Object.keys(mapOfCharToEscape).join("|")})`;
  const testRegexp = RegExp(source);
  const replaceRegexp = RegExp(source, "g");
  return testRegexp.test(str) ? str.replace(replaceRegexp, (substring) => mapOfCharToEscape[substring]) : str;
}

// src/controllers/core/search-box/headless-core-search-box-options.ts
var import_bueno82 = require("@coveo/bueno");
var openCloseDelimitersDefinition = {
  open: new import_bueno82.StringValue(),
  close: new import_bueno82.StringValue()
};
var searchBoxOptionDefinitions = {
  id: requiredNonEmptyString,
  numberOfSuggestions: new import_bueno82.NumberValue({ min: 0 }),
  enableQuerySyntax: new import_bueno82.BooleanValue(),
  highlightOptions: new import_bueno82.RecordValue({
    values: {
      notMatchDelimiters: new import_bueno82.RecordValue({
        values: openCloseDelimitersDefinition
      }),
      exactMatchDelimiters: new import_bueno82.RecordValue({
        values: openCloseDelimitersDefinition
      }),
      correctionDelimiters: new import_bueno82.RecordValue({
        values: openCloseDelimitersDefinition
      })
    }
  }),
  clearFilters: new import_bueno82.BooleanValue()
};
var searchBoxOptionsSchema = new import_bueno82.Schema(
  searchBoxOptionDefinitions
);

// src/controllers/core/search-box/headless-core-search-box.ts
function getSuggestions(state, highlightOptions2) {
  if (!state) {
    return [];
  }
  return state.completions.map((completion) => ({
    highlightedValue: getHighlightedSuggestion(
      completion.highlighted,
      highlightOptions2
    ),
    rawValue: completion.expression
  }));
}

// src/controllers/commerce/search-box/headless-search-box-options.ts
var import_bueno83 = require("@coveo/bueno");
var defaultSearchBoxOptions2 = {
  clearFilters: true,
  enableResults: false
};
var { id, highlightOptions, clearFilters } = searchBoxOptionDefinitions;
var searchBoxOptionDefinitions2 = {
  id,
  highlightOptions,
  clearFilters,
  enableResults: new import_bueno83.BooleanValue()
};
var searchBoxOptionsSchema2 = new import_bueno83.Schema(
  searchBoxOptionDefinitions2
);

// src/controllers/commerce/search-box/headless-search-box.ts
function buildSearchBox(engine, props = {}) {
  if (!loadSearchBoxReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const id2 = props.options?.id || randomID("search_box");
  const options = {
    id: id2,
    highlightOptions: { ...props.options?.highlightOptions },
    ...defaultSearchBoxOptions2,
    ...props.options
  };
  validateOptions(engine, searchBoxOptionsSchema2, options, "buildSearchBox");
  dispatch(
    registerQuerySetQuery2({ id: id2, query: getState().commerceQuery.query ?? "" })
  );
  dispatch(registerQuerySuggest({ id: id2 }));
  const getValue = () => getState().querySet[options.id];
  const performSearch = async () => {
    const queryOptions = {
      query: getValue(),
      clearFilters: options.clearFilters
    };
    dispatch(prepareForSearchWithQuery2(queryOptions));
    dispatch(executeSearch3({ enableResults: options.enableResults }));
  };
  return {
    ...controller,
    updateText(value) {
      dispatch(updateQuerySetQuery2({ id: id2, query: value }));
      this.showSuggestions();
    },
    clear() {
      dispatch(updateQuerySetQuery2({ id: id2, query: "" }));
      dispatch(clearQuerySuggest({ id: id2 }));
    },
    showSuggestions() {
      dispatch(fetchQuerySuggestions({ id: id2 }));
    },
    selectSuggestion(value) {
      dispatch(selectQuerySuggestion({ id: id2, expression: value }));
      performSearch().then(() => {
        dispatch(clearQuerySuggest({ id: id2 }));
      });
    },
    submit() {
      performSearch();
      dispatch(clearQuerySuggest({ id: id2 }));
    },
    get state() {
      const querySuggest = getState().querySuggest[options.id];
      const suggestions = getSuggestions(
        querySuggest,
        options.highlightOptions
      );
      const isLoadingSuggestions = querySuggest ? querySuggest.isLoading : false;
      return {
        searchBoxId: id2,
        value: getValue(),
        suggestions,
        isLoading: getState().commerceSearch.isLoading,
        isLoadingSuggestions
      };
    }
  };
}
function loadSearchBoxReducers(engine) {
  engine.addReducers({
    commerceQuery: queryReducer,
    querySuggest: querySuggestReducer,
    configuration,
    querySet: querySetReducer,
    commerceSearch: commerceSearchReducer
  });
  return true;
}

// src/ssr/commerce/controllers/search-box/headless-search-box.ssr.ts
function defineSearchBox(props = {}) {
  return {
    search: true,
    build: (engine) => buildSearchBox(engine, props)
  };
}

// src/ssr/commerce/controllers/sort/headless-core-commerce-sort.ssr.ts
function defineSort(props) {
  ensureAtLeastOneSolutionType(props);
  return {
    listing: true,
    search: true,
    ...props,
    build: (engine, solutionType) => solutionType === "listing" /* listing */ ? buildProductListing(engine).sort(props) : buildSearch(engine).sort(props)
  };
}

// src/features/commerce/standalone-search-box-set/standalone-search-box-set-actions.ts
var import_bueno84 = require("@coveo/bueno");
var import_toolkit108 = require("@reduxjs/toolkit");

// src/features/commerce/standalone-search-box-set/plan-request-builder.ts
var buildPlanRequest = (state, navigatorContext) => {
  const baseRequest2 = buildBaseCommerceAPIRequest(state, navigatorContext);
  return {
    ...baseRequest2,
    context: {
      ...baseRequest2.context,
      capture: false
    },
    query: state.commerceQuery.query
  };
};

// src/features/commerce/standalone-search-box-set/standalone-search-box-set-actions.ts
var fetchRedirectUrl = (0, import_toolkit108.createAsyncThunk)(
  "commerce/standaloneSearchBox/fetchRedirect",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    validatePayload(payload, { id: new import_bueno84.StringValue({ emptyAllowed: false }) });
    const state = getState();
    const request = buildPlanRequest(state, navigatorContext);
    const response = await apiClient.plan(request);
    if (isErrorResponse2(response)) {
      return rejectWithValue(response.error);
    }
    return response.success.redirect || "";
  }
);
var registerStandaloneSearchBox = (0, import_toolkit108.createAction)(
  "commerce/standaloneSearchBox/register",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    redirectionUrl: requiredNonEmptyString,
    overwrite: new import_bueno84.BooleanValue({ required: false })
  })
);
var updateStandaloneSearchBoxRedirectionUrl = (0, import_toolkit108.createAction)(
  "commerce/standaloneSearchBox/updateRedirectionUrl",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    redirectionUrl: requiredNonEmptyString
  })
);
var resetStandaloneSearchBox = (0, import_toolkit108.createAction)(
  "commerce/standaloneSearchBox/reset",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString
  })
);

// src/features/commerce/standalone-search-box-set/standalone-search-box-set-slice.ts
var import_toolkit109 = require("@reduxjs/toolkit");

// src/features/commerce/standalone-search-box-set/standalone-search-box-set-state.ts
function getCommerceStandaloneSearchBoxSetInitialState() {
  return {};
}

// src/features/commerce/standalone-search-box-set/standalone-search-box-set-slice.ts
var commerceStandaloneSearchBoxSetReducer = (0, import_toolkit109.createReducer)(
  getCommerceStandaloneSearchBoxSetInitialState(),
  (builder) => builder.addCase(registerStandaloneSearchBox, (state, action) => {
    const { id: id2, redirectionUrl, overwrite } = action.payload;
    if (!overwrite && id2 in state) {
      return;
    }
    state[id2] = buildStandaloneSearchBoxEntry(redirectionUrl);
  }).addCase(updateStandaloneSearchBoxRedirectionUrl, (state, action) => {
    const { id: id2, redirectionUrl } = action.payload;
    const searchBox = state[id2];
    if (!searchBox) {
      return;
    }
    searchBox.defaultRedirectionUrl = redirectionUrl;
  }).addCase(resetStandaloneSearchBox, (state, action) => {
    const { id: id2 } = action.payload;
    const searchBox = state[id2];
    if (searchBox) {
      state[id2] = buildStandaloneSearchBoxEntry(
        searchBox.defaultRedirectionUrl
      );
      return;
    }
  }).addCase(fetchRedirectUrl.pending, (state, action) => {
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.isLoading = true;
  }).addCase(fetchRedirectUrl.fulfilled, (state, action) => {
    const redirectionUrl = action.payload;
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.redirectTo = redirectionUrl ? redirectionUrl : searchBox.defaultRedirectionUrl;
    searchBox.isLoading = false;
  }).addCase(fetchRedirectUrl.rejected, (state, action) => {
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.isLoading = false;
  })
);
function buildStandaloneSearchBoxEntry(defaultRedirectionUrl) {
  return {
    defaultRedirectionUrl,
    redirectTo: "",
    isLoading: false
  };
}

// src/controllers/commerce/standalone-search-box/headless-standalone-search-box-options.ts
var import_bueno85 = require("@coveo/bueno");
var standaloneSearchBoxSchema = new import_bueno85.Schema({
  ...searchBoxOptionDefinitions2,
  redirectionUrl: new import_bueno85.StringValue({
    required: true,
    emptyAllowed: false
  }),
  overwrite: new import_bueno85.BooleanValue({
    required: false
  })
});

// src/controllers/commerce/standalone-search-box/headless-standalone-search-box.ts
function buildStandaloneSearchBox(engine, props) {
  if (!loadStandaloneSearchBoxReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const id2 = props.options.id || randomID("standalone_search_box");
  const options = {
    id: id2,
    highlightOptions: { ...props.options.highlightOptions },
    ...defaultSearchBoxOptions2,
    ...{ overwrite: false },
    ...props.options
  };
  validateOptions(
    engine,
    standaloneSearchBoxSchema,
    options,
    "buildStandaloneSearchBox"
  );
  const searchBox = buildSearchBox(engine, { options });
  dispatch(
    registerStandaloneSearchBox({
      id: id2,
      redirectionUrl: options.redirectionUrl,
      overwrite: options.overwrite
    })
  );
  return {
    ...searchBox,
    updateText(value) {
      searchBox.updateText(value);
    },
    selectSuggestion(value) {
      dispatch(selectQuerySuggestion({ id: id2, expression: value }));
      this.submit();
    },
    afterRedirection() {
      dispatch(resetStandaloneSearchBox({ id: id2 }));
    },
    updateRedirectUrl(url) {
      dispatch(
        updateStandaloneSearchBoxRedirectionUrl({ id: id2, redirectionUrl: url })
      );
    },
    submit() {
      dispatch(
        updateQuery2({
          query: this.state.value
        })
      );
      dispatch(fetchRedirectUrl({ id: id2 }));
    },
    get state() {
      const state = getState();
      const standaloneSearchBoxState = state.commerceStandaloneSearchBoxSet[id2];
      return {
        ...searchBox.state,
        redirectTo: standaloneSearchBoxState.redirectTo
      };
    }
  };
}
function loadStandaloneSearchBoxReducers(engine) {
  engine.addReducers({
    commerceQuery: queryReducer,
    commerceStandaloneSearchBoxSet: commerceStandaloneSearchBoxSetReducer,
    configuration,
    querySuggest: querySuggestReducer
  });
  return true;
}

// src/ssr/commerce/controllers/standalone-search-box/headless-standalone-search-box.ssr.ts
function defineStandaloneSearchBox(props) {
  return {
    listing: true,
    standalone: true,
    build: (engine) => buildStandaloneSearchBox(engine, props)
  };
}

// src/ssr/commerce/controllers/summary/headless-core-summary.ssr.ts
function defineSummary(options) {
  ensureAtLeastOneSolutionType(options);
  return {
    listing: true,
    search: true,
    ...options,
    build: (engine, solutionType) => solutionType === "listing" /* listing */ ? buildProductListing(engine).summary() : buildSearch(engine).summary()
  };
}

// src/features/commerce/triggers/triggers-slice.ts
var import_toolkit110 = require("@reduxjs/toolkit");

// src/features/triggers/triggers-slice-functions.ts
function handleFetchItemsPending(state) {
  state.query = "";
  state.queryModification = {
    originalQuery: "",
    newQuery: "",
    queryToIgnore: state.queryModification.queryToIgnore
  };
  return state;
}
function handleFetchItemsFulfilled(state, triggers) {
  const redirectTriggers = [];
  const queryTriggers = [];
  const executeTriggers = [];
  const notifyTriggers = [];
  triggers.forEach((trigger) => {
    switch (trigger.type) {
      case "redirect":
        redirectTriggers.push(trigger.content);
        break;
      case "query":
        queryTriggers.push(trigger.content);
        break;
      case "execute":
        executeTriggers.push({
          functionName: trigger.content.name,
          params: trigger.content.params
        });
        break;
      case "notify":
        notifyTriggers.push(trigger.content);
        break;
    }
  });
  state.redirectTo = redirectTriggers[0] ?? "";
  state.query = state.queryModification.newQuery;
  state.executions = executeTriggers;
  state.notifications = notifyTriggers;
  return state;
}
function handleApplyQueryTriggerModification(state, payload) {
  state.queryModification = { ...payload, queryToIgnore: "" };
  return state;
}
function handleUpdateIgnoreQueryTrigger(state, payload) {
  state.queryModification.queryToIgnore = payload;
  return state;
}

// src/features/triggers/triggers-state.ts
var getTriggerInitialState = () => ({
  redirectTo: "",
  query: "",
  executions: [],
  notifications: [],
  queryModification: { originalQuery: "", newQuery: "", queryToIgnore: "" }
});

// src/features/commerce/triggers/triggers-slice.ts
var commerceTriggersReducer = (0, import_toolkit110.createReducer)(
  getTriggerInitialState(),
  (builder) => builder.addCase(executeSearch3.pending, handleFetchItemsPending).addCase(
    executeSearch3.fulfilled,
    (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)
  ).addCase(fetchProductListing.pending, handleFetchItemsPending).addCase(
    fetchProductListing.fulfilled,
    (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)
  ).addCase(
    applyQueryTriggerModification2,
    (state, action) => handleApplyQueryTriggerModification(state, action.payload)
  ).addCase(
    updateIgnoreQueryTrigger2,
    (state, action) => handleUpdateIgnoreQueryTrigger(state, action.payload.q)
  )
);

// src/controllers/commerce/triggers/headless-notify-trigger.ts
function buildNotifyTrigger(engine) {
  if (!loadNotifyTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine[stateKey];
  let previousNotifications = getState().triggers.notifications;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(
          previousNotifications,
          this.state.notifications
        );
        previousNotifications = this.state.notifications;
        if (hasChanged) {
          listener();
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        notifications: getState().triggers.notifications
      };
    }
  };
}
function loadNotifyTriggerReducers(engine) {
  engine.addReducers({ triggers: commerceTriggersReducer });
  return true;
}

// src/ssr/commerce/controllers/triggers/headless-notify-trigger.ssr.ts
function defineNotifyTrigger() {
  return {
    listing: true,
    search: true,
    build: (engine) => buildNotifyTrigger(engine)
  };
}

// src/controllers/commerce/triggers/headless-query-trigger.ts
function buildQueryTrigger(engine, { enableResults = false } = { enableResults: false }) {
  if (!loadQueryTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const modification = () => getState().triggers.queryModification.newQuery;
  const originalQuery = () => getState().triggers.queryModification.originalQuery;
  return {
    ...controller,
    get state() {
      return {
        newQuery: modification(),
        originalQuery: originalQuery(),
        wasQueryModified: modification() !== ""
      };
    },
    undo() {
      dispatch(updateIgnoreQueryTrigger2({ q: modification() }));
      dispatch(updateQuery2({ query: originalQuery() }));
      dispatch(executeSearch3({ enableResults }));
    }
  };
}
function loadQueryTriggerReducers(engine) {
  engine.addReducers({ triggers: commerceTriggersReducer, query: queryReducer });
  return true;
}

// src/ssr/commerce/controllers/triggers/headless-query-trigger.ssr.ts
function defineQueryTrigger() {
  return {
    search: true,
    build: (engine) => buildQueryTrigger(engine)
  };
}

// src/controllers/commerce/triggers/headless-redirection-trigger.ts
function buildRedirectionTrigger(engine) {
  if (!loadRedirectionReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine[stateKey];
  let previousRedirectTo = getState().triggers.redirectTo;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = previousRedirectTo !== this.state.redirectTo;
        previousRedirectTo = this.state.redirectTo;
        if (hasChanged && this.state.redirectTo) {
          listener();
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        redirectTo: getState().triggers.redirectTo
      };
    }
  };
}
function loadRedirectionReducers(engine) {
  engine.addReducers({ triggers: commerceTriggersReducer });
  return true;
}

// src/ssr/commerce/controllers/triggers/headless-redirection-trigger.ssr.ts
function defineRedirectionTrigger() {
  return {
    search: true,
    build: (engine) => buildRedirectionTrigger(engine)
  };
}

// src/ssr/common/access-token-manager.ts
function createAccessTokenManager(initialToken) {
  const tokenChangeCallbacks = /* @__PURE__ */ new Set();
  let queuedToken = null;
  let currentAccessToken = initialToken;
  return {
    /**
     * Gets the current access token.
     */
    getAccessToken() {
      return currentAccessToken;
    },
    /**
     * Sets the access token, updating both configuration and active engines.
     */
    setAccessToken(accessToken) {
      currentAccessToken = accessToken;
      if (tokenChangeCallbacks.size > 0) {
        tokenChangeCallbacks.forEach((callback) => {
          callback(accessToken);
        });
        queuedToken = null;
      } else {
        queuedToken = accessToken;
      }
    },
    /**
     * Registers a callback function to be invoked when the access token changes.
     * If there's a queued token, the callback will be invoked immediately.
     */
    registerCallback(callback) {
      tokenChangeCallbacks.add(callback);
      if (queuedToken) {
        callback(queuedToken);
        queuedToken = null;
      }
    }
  };
}

// src/api/preprocess-request.ts
var NoopPreprocessRequest = (request) => request;

// src/features/commerce/configuration/configuration-actions.ts
var import_bueno86 = require("@coveo/bueno");
var import_toolkit111 = require("@reduxjs/toolkit");
var updateBasicConfiguration2 = (0, import_toolkit111.createAction)(
  "commerce/configuration/updateBasicConfiguration",
  (payload) => validatePayload(payload, {
    accessToken: nonEmptyString,
    environment: new import_bueno86.StringValue({
      required: false,
      constrainTo: ["prod", "hipaa", "stg", "dev"]
    }),
    organizationId: nonEmptyString
  })
);
var updateProxyBaseUrl = (0, import_toolkit111.createAction)(
  "commerce/configuration/updateProxyBaseUrl",
  (payload) => validatePayload(payload, {
    proxyBaseUrl: new import_bueno86.StringValue({ required: false, url: true })
  })
);
var updateAnalyticsConfiguration2 = (0, import_toolkit111.createAction)(
  "commerce/configuration/updateAnalyticsConfiguration",
  (payload) => {
    return validatePayload(payload, {
      enabled: analyticsConfigurationSchema.enabled,
      proxyBaseUrl: analyticsConfigurationSchema.proxyBaseUrl,
      source: analyticsConfigurationSchema.source,
      trackingId: requiredTrackingId
    });
  }
);
var disableAnalytics2 = (0, import_toolkit111.createAction)(
  "commerce/configuration/analytics/disable"
);
var enableAnalytics2 = (0, import_toolkit111.createAction)(
  "commerce/configuration/analytics/enable"
);

// src/features/commerce/configuration/configuration-slice.ts
var import_bueno87 = require("@coveo/bueno");
var import_toolkit112 = require("@reduxjs/toolkit");

// src/features/commerce/configuration/configuration-state.ts
var getConfigurationInitialState2 = () => ({
  accessToken: "",
  environment: "prod",
  organizationId: "",
  analytics: {
    enabled: true,
    trackingId: "",
    source: {}
  },
  commerce: {}
});

// src/features/commerce/configuration/configuration-slice.ts
var configurationReducer2 = (0, import_toolkit112.createReducer)(
  getConfigurationInitialState2(),
  (builder) => builder.addCase(updateBasicConfiguration2, (state, action) => {
    handleUpdateBasicConfiguration2(state, action.payload);
  }).addCase(updateBasicConfiguration, (state, action) => {
    handleUpdateBasicConfiguration2(state, action.payload);
  }).addCase(updateProxyBaseUrl, (state, action) => {
    handleUpdateCommerceProxyBaseUrl(state, action.payload);
  }).addCase(updateAnalyticsConfiguration2, (state, action) => {
    handleupdateAnalyticsConfiguration(state, action.payload);
  }).addCase(disableAnalytics2, (state) => {
    state.analytics.enabled = false;
  }).addCase(enableAnalytics2, (state) => {
    state.analytics.enabled = true;
  })
);
function handleUpdateBasicConfiguration2(state, payload) {
  if (!(0, import_bueno87.isNullOrUndefined)(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!(0, import_bueno87.isNullOrUndefined)(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateCommerceProxyBaseUrl(state, payload) {
  if (!(0, import_bueno87.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.commerce.apiBaseUrl = payload.proxyBaseUrl;
  }
}
function handleupdateAnalyticsConfiguration(state, payload) {
  if (!(0, import_bueno87.isNullOrUndefined)(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!(0, import_bueno87.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno87.isNullOrUndefined)(payload.source)) {
    state.analytics.source = payload.source;
  }
  if (!(0, import_bueno87.isNullOrUndefined)(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
}

// src/features/debug/version-slice.ts
var import_toolkit113 = require("@reduxjs/toolkit");
var versionReducer = (0, import_toolkit113.createReducer)(VERSION, (builder) => builder);

// src/api/knowledge/answer-generation/answer-generation-api.ts
var import_query2 = require("@reduxjs/toolkit/query");

// src/api/knowledge/answer-slice.ts
var import_query = require("@reduxjs/toolkit/query");
var dynamicBaseQuery = async (args, api, extraOptions) => {
  const state = api.getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const answerConfigurationId = state.generatedAnswer.answerConfigurationId;
  const updatedArgs = {
    ...args,
    headers: {
      ...args?.headers || {},
      Authorization: `Bearer ${accessToken}`
    }
  };
  try {
    const platformEndpoint = getOrganizationEndpoint(
      organizationId,
      environment
    );
    const data = (0, import_query.fetchBaseQuery)({
      baseUrl: `${platformEndpoint}/rest/organizations/${organizationId}/answer/v1/configs/${answerConfigurationId}`
    })(updatedArgs, api, extraOptions);
    return { data };
  } catch (error) {
    return { error };
  }
};
var answerSlice = (0, import_query.createApi)({
  reducerPath: "answer",
  baseQuery: (0, import_query.retry)(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// src/api/knowledge/answer-generation/answer-generation-api.ts
var answerGenerationApi = (0, import_query2.createApi)({
  reducerPath: "answerGenerationApi",
  refetchOnMountOrArgChange: true,
  baseQuery: (0, import_query2.retry)(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// src/api/knowledge/stream-answer-api.ts
var import_query3 = require("@reduxjs/toolkit/query");

// src/features/generated-answer/answer-api-selectors.ts
var import_toolkit114 = require("@reduxjs/toolkit");

// src/features/query/query-selectors.ts
var selectQuery = (state) => state.query;
var selectEnableQuerySyntax = (state) => state.query?.enableQuerySyntax;

// src/features/generated-answer/answer-api-selectors.ts
var selectAnswerTriggerParams = (0, import_toolkit114.createSelector)(
  (state) => selectQuery(state)?.q,
  (state) => state.search.requestId,
  (state) => state.generatedAnswer.cannotAnswer,
  (state) => state.configuration.analytics.analyticsMode,
  (state) => state.search.searchAction?.actionCause,
  (q, requestId, cannotAnswer, analyticsMode, actionCause) => ({
    q,
    requestId,
    cannotAnswer,
    analyticsMode,
    actionCause
  })
);
var selectAnswerApiQueryParams = (0, import_toolkit114.createSelector)(
  (state) => state.generatedAnswer?.answerApiQueryParams,
  (answerApiQueryParams) => answerApiQueryParams
);

// src/features/generated-answer/generated-answer-actions.ts
var import_bueno90 = require("@coveo/bueno");
var import_toolkit118 = require("@reduxjs/toolkit");

// src/api/knowledge/answer-generation/answer-generation-api-state.ts
var initialAnswerGenerationServerState = () => ({
  contentFormat: void 0,
  answer: void 0,
  citations: void 0,
  error: void 0,
  generated: false,
  isStreaming: false,
  isLoading: true
});

// src/utils/fetch-event-source/parse.ts
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10 /* NewLine */) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58 /* Colon */:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case 13 /* CarriageReturn */:
            discardTrailingNewline = true;
            lineEnd = position;
            break;
          case 10 /* NewLine */:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage?.(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field2 = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field2) {
        case "data":
          message.data = message.data ? `${message.data}
${value}` : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          retry3(value, message, onRetry);
          break;
      }
    }
  };
}
function retry3(value, message, onRetry) {
  const retry4 = parseInt(value, 10);
  if (!Number.isNaN(retry4)) {
    onRetry(message.retry = retry4);
  }
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}

// src/utils/fetch-event-source/fetch.ts
var EventStreamContentType = "text/event-stream";
var DefaultRetryInterval = 1e3;
var LastEventId = "last-event-id";
function isBrowser2() {
  return typeof window !== "undefined";
}
function fetchEventSource(input, {
  signal: inputSignal,
  headers: inputHeaders,
  onopen: inputOnOpen,
  onmessage,
  onclose,
  onerror,
  openWhenHidden,
  fetch: inputFetch,
  ...rest
}) {
  return new Promise((resolve, reject) => {
    const headers = { ...inputHeaders };
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController?.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden && isBrowser2()) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer;
    function dispose() {
      if (isBrowser2()) {
        document.removeEventListener("visibilitychange", onVisibilityChange);
      }
      clearTimeout(retryTimer);
      curRequestController?.abort();
    }
    inputSignal?.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const outputFetch = inputFetch ?? fetch;
    const onopen = inputOnOpen ?? defaultOnOpen;
    async function create() {
      curRequestController = AbortController ? new AbortController() : null;
      try {
        const response = await outputFetch(input, {
          ...rest,
          headers,
          signal: curRequestController?.signal
        });
        await onopen(response);
        await getBytes(
          response.body,
          getLines(
            getMessages(
              (id2) => {
                if (id2) {
                  headers[LastEventId] = id2;
                } else {
                  delete headers[LastEventId];
                }
              },
              (retry4) => {
                retryInterval = retry4;
              },
              onmessage
            )
          )
        );
        onclose?.();
        dispose();
        resolve();
      } catch (err) {
        if (!curRequestController?.signal?.aborted) {
          try {
            const interval = onerror?.(err) ?? retryInterval;
            clearTimeout(retryTimer);
            retryTimer = setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType?.startsWith(EventStreamContentType)) {
    throw new Error(
      `Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`
    );
  }
}

// src/api/knowledge/answer-generation/streaming/answer-draft-reducer/answer-draft-reducer.ts
var setAnswerId = (draft, answerId) => {
  if (answerId) {
    draft.answerId = answerId;
  }
};
var initializeStreamingAnswer = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var setAnswer = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var setCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var endStreaming = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var setAnswerError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code ?? 500
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(
    `Generated answer error: ${errorMessage} (code: ${message.code})`
  );
};

// src/api/knowledge/answer-generation/streaming/server-state-event-handler/server-state-event-handler.ts
var serverStateEventHandler = {
  handleOpen: (response, updateCachedData) => {
    const answerId = response.headers.get("x-answer-id");
    if (answerId) {
      updateCachedData((draft) => {
        setAnswerId(draft, answerId);
      });
    }
  },
  handleMessage: {
    "agentInteraction.answerHeader": (_message, updateCachedData) => {
      updateCachedData((draft) => {
        initializeStreamingAnswer(draft, { contentFormat: "text/markdown" });
      });
    },
    "generativeengines.messageType": (message, updateCachedData) => {
      if (message?.payload?.textDelta) {
        updateCachedData((draft) => {
          setAnswer(draft, message.payload);
        });
      }
    },
    "agentInteraction.citations": (message, updateCachedData) => {
      if (message?.payload?.citations !== void 0) {
        updateCachedData((draft) => {
          setCitations(draft, message.payload);
        });
      }
    },
    "generativeengines.endOfStreamType": (message, updateCachedData) => {
      updateCachedData((draft) => {
        endStreaming(draft, message.payload);
      });
    },
    error: (message, updateCachedData) => {
      if (message.finishReason === "ERROR") {
        updateCachedData((draft) => {
          setAnswerError(draft, message);
        });
      }
    }
  }
};

// src/api/knowledge/answer-generation/streaming/answer-streaming-runner.ts
var streamAnswerWithStrategy = (endpointUrl, args, api, strategy) => {
  const { dispatch, updateCachedData, getState } = api;
  const {
    configuration: { accessToken }
  } = getState();
  return fetchEventSource(endpointUrl, {
    method: "POST",
    body: JSON.stringify(args),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "text/event-stream",
      "Content-Type": "application/json",
      "Accept-Encoding": "*"
    },
    fetch,
    onopen: async (response) => {
      serverStateEventHandler.handleOpen(response, updateCachedData);
      strategy.handleOpen(response, dispatch);
    },
    onclose: () => {
      strategy.handleClose?.(dispatch);
    },
    onerror: (error) => {
      strategy.handleError(error);
    },
    onmessage: (event) => {
      const message = parsePayload(event.data);
      if (!message) {
        return;
      }
      serverStateEventHandler.handleMessage.error?.(message, updateCachedData);
      strategy.handleMessage.error?.(message, dispatch);
      const messageType = message.payloadType;
      serverStateEventHandler.handleMessage[messageType]?.(
        message,
        updateCachedData
      );
      strategy.handleMessage[messageType]?.(message, dispatch);
    }
  });
};
function parsePayload(payload) {
  if (!payload?.length) {
    return null;
  }
  try {
    return JSON.parse(payload);
  } catch (err) {
    console.warn("Failed to parse message", {
      payload,
      error: err
    });
    return null;
  }
}

// src/features/follow-up-answers/follow-up-answers-actions.ts
var import_bueno88 = require("@coveo/bueno");
var import_toolkit115 = require("@reduxjs/toolkit");

// src/api/knowledge/answer-generation/endpoints/follow-up/url-builders/endpoint-url-builder.ts
var buildFollowUpEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const {
    organizationId,
    environment,
    knowledge: { agentId }
  } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId?.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for follow up endpoint");
  }
  const basePath2 = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath2}/${trimmedAgentId}/follow-up`;
};

// src/api/knowledge/answer-generation/endpoints/follow-up/follow-up-endpoint.ts
var followUpEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateFollowUpAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        const { strategyKey, ...params } = args;
        const endpointUrl = buildFollowUpEndpointUrl(
          getState()
        );
        await streamAnswerWithStrategy(
          endpointUrl,
          params,
          {
            getState,
            updateCachedData,
            dispatch
          },
          streamingStrategyCreators[strategyKey]?.()
        );
      }
    })
  })
});
var initiateFollowUpEndpoint = (args) => {
  return followUpEndpoint.endpoints.generateFollowUpAnswer.initiate(args);
};

// src/features/follow-up-answers/follow-up-answer-request.ts
var constructGenerateFollowUpAnswerParams = (followUpQuestion, state) => {
  const conversationId = state.followUpAnswers?.conversationId ?? "";
  return {
    conversationId,
    q: followUpQuestion
  };
};

// src/features/follow-up-answers/follow-up-answers-actions.ts
var stringValue = new import_bueno88.StringValue({ required: true });
var setIsEnabled = (0, import_toolkit115.createAction)(
  "followUpAnswers/setIsEnabled",
  (payload) => validatePayload(payload, new import_bueno88.BooleanValue({ required: true }))
);
var setFollowUpAnswersConversationId = (0, import_toolkit115.createAction)(
  "followUpAnswers/setFollowUpAnswersConversationId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var createFollowUpAnswer = (0, import_toolkit115.createAction)(
  "followUpAnswers/createFollowUpAnswer",
  (payload) => validatePayload(payload, {
    question: requiredNonEmptyString
  })
);
var setActiveFollowUpAnswerId = (0, import_toolkit115.createAction)(
  "followUpAnswers/setActiveFollowUpAnswerId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setFollowUpAnswerContentFormat = (0, import_toolkit115.createAction)(
  "followUpAnswers/setFollowUpAnswerContentFormat",
  (payload) => validatePayload(payload, {
    contentFormat: answerContentFormatSchema,
    answerId: requiredNonEmptyString
  })
);
var setFollowUpIsLoading = (0, import_toolkit115.createAction)(
  "followUpAnswers/setFollowUpIsLoading",
  (payload) => validatePayload(payload, {
    isLoading: new import_bueno88.BooleanValue({ required: true }),
    answerId: requiredNonEmptyString
  })
);
var followUpMessageChunkReceived = (0, import_toolkit115.createAction)(
  "followUpAnswers/followUpMessageChunkReceived",
  (payload) => validatePayload(payload, {
    textDelta: stringValue,
    answerId: requiredNonEmptyString
  })
);
var followUpCitationsReceived = (0, import_toolkit115.createAction)(
  "followUpAnswers/followUpCitationsReceived",
  (payload) => validatePayload(payload, {
    citations: new import_bueno88.ArrayValue({
      required: true,
      each: new import_bueno88.RecordValue({
        values: citationSchema
      })
    }),
    answerId: requiredNonEmptyString
  })
);
var followUpCompleted = (0, import_toolkit115.createAction)(
  "followUpAnswers/followUpCompleted",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
    cannotAnswer: new import_bueno88.BooleanValue({ required: false })
  })
);
var followUpFailed = (0, import_toolkit115.createAction)(
  "followUpAnswers/followUpFailed",
  (payload) => validatePayload(payload, {
    message: new import_bueno88.StringValue(),
    code: new import_bueno88.NumberValue({ min: 0 }),
    answerId: requiredNonEmptyString
  })
);
var likeFollowUp = (0, import_toolkit115.createAction)(
  "followUpAnswers/likeFollowUp",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var dislikeFollowUp = (0, import_toolkit115.createAction)(
  "followUpAnswers/dislikeFollowUp",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var submitFollowUpFeedback = (0, import_toolkit115.createAction)(
  "followUpAnswers/submitFollowUpFeedback",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var resetFollowUpAnswers = (0, import_toolkit115.createAction)(
  "followUpAnswers/resetFollowUpAnswers"
);
var generateFollowUpAnswer = (0, import_toolkit115.createAsyncThunk)(
  "generatedAnswerWithFollowUps/generateFollowUpAnswer",
  async (question, { getState, dispatch, extra: { logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state)?.trim();
    const generateFollowUpAnswerParams = constructGenerateFollowUpAnswerParams(
      question,
      state
    );
    if (!agentId) {
      logger.warn(
        "Missing agentId in engine configuration. The generateFollowUpAnswer action requires an agent ID."
      );
      return;
    }
    if (!generateFollowUpAnswerParams.conversationId) {
      logger.warn(
        "Missing conversationId when generating a follow-up answer. The generateFollowUpAnswer action requires an existing conversation."
      );
      return;
    }
    dispatch(createFollowUpAnswer({ question }));
    await dispatch(
      initiateFollowUpEndpoint({
        strategyKey: "follow-up-answer",
        ...generateFollowUpAnswerParams
      })
    );
  }
);

// src/features/follow-up-answers/follow-up-answer-strategy.ts
var createFollowUpAnswerStrategy = () => {
  let answerId = null;
  return {
    handleOpen: (response, dispatch) => {
      answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setActiveFollowUpAnswerId(answerId));
        dispatch(setFollowUpIsLoading({ answerId, isLoading: true }));
        dispatch(
          setFollowUpAnswerContentFormat({
            contentFormat: "text/markdown",
            answerId
          })
        );
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "generativeengines.messageType": (message, dispatch) => {
        if (message?.payload?.textDelta) {
          dispatch(
            followUpMessageChunkReceived({
              textDelta: message.payload.textDelta,
              answerId
            })
          );
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        if (message?.payload?.citations !== void 0) {
          dispatch(
            followUpCitationsReceived({
              citations: message.payload.citations,
              answerId
            })
          );
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        const answerGenerated = message?.payload?.answerGenerated ?? false;
        dispatch(
          followUpCompleted({
            cannotAnswer: !answerGenerated,
            answerId
          })
        );
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(
            followUpFailed({
              answerId,
              message: message.errorMessage,
              code: message.code
            })
          );
        }
      }
    }
  };
};

// src/features/generated-answer/generated-answer-analytics-actions.ts
var logGeneratedAnswerStreamEnd = (answerGenerated) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/streamEnd",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const answerTextIsEmpty = answerGenerated ? !state.generatedAnswer?.answer || !state.generatedAnswer?.answer.length : void 0;
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerStreamEnd({
      generativeQuestionAnsweringId,
      answerGenerated,
      answerTextIsEmpty
    });
  },
  analyticsType: "Rga.AnswerReceived",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      answerGenerated: answerGenerated ?? false
    };
  }
});
var logGeneratedAnswerResponseLinked = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/responseLinked",
  __legacy__getBuilder: () => {
    return null;
  },
  analyticsType: "Rga.ResponseLinked",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      responseId: state.search?.searchResponseId || state.search?.response.searchUid || ""
    };
  }
});

// src/features/generated-answer/head-answer-strategy.ts
var createHeadAnswerStrategy = () => {
  return {
    handleOpen: (response, dispatch) => {
      const answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setAnswerId2(answerId));
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "agentInteraction.answerHeader": (message, dispatch) => {
        if (message?.payload?.conversationId) {
          dispatch(
            setFollowUpAnswersConversationId(message.payload.conversationId)
          );
        }
        if (message.payload.followUpEnabled) {
          dispatch(setIsEnabled(message.payload.followUpEnabled));
        }
        dispatch(setAnswerContentFormat("text/markdown"));
        dispatch(setIsStreaming(true));
        dispatch(setIsLoading(false));
      },
      "generativeengines.messageType": (message, dispatch) => {
        if (message?.payload?.textDelta) {
          dispatch(updateMessage({ textDelta: message.payload.textDelta }));
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        if (message?.payload?.citations !== void 0) {
          dispatch(updateCitations({ citations: message.payload.citations }));
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        const answerGenerated = message?.payload?.answerGenerated ?? false;
        dispatch(setIsAnswerGenerated(answerGenerated));
        dispatch(setCannotAnswer(!answerGenerated));
        dispatch(setIsStreaming(false));
        dispatch(setIsLoading(false));
        dispatch(logGeneratedAnswerStreamEnd(answerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(updateError(message));
        }
      }
    }
  };
};

// src/api/knowledge/answer-generation/streaming/strategies/streaming-strategy-creators.ts
var streamingStrategyCreators = {
  "head-answer": createHeadAnswerStrategy,
  "follow-up-answer": createFollowUpAnswerStrategy
};

// src/api/knowledge/answer-generation/endpoints/answer/url-builders/endpoint-url-builder.ts
var buildAnswerEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const {
    organizationId,
    environment,
    knowledge: { agentId }
  } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId?.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath2}/${trimmedAgentId}/answer`;
};

// src/api/knowledge/answer-generation/endpoints/answer/answer-endpoint.ts
var answerEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        const { strategyKey, ...params } = args;
        const endpointUrl = buildAnswerEndpointUrl(
          getState()
        );
        await streamAnswerWithStrategy(
          endpointUrl,
          params,
          {
            getState,
            updateCachedData,
            dispatch
          },
          streamingStrategyCreators[strategyKey]?.()
        );
      }
    })
  })
});
var initiateAnswerEndpoint = (args) => {
  return answerEndpoint.endpoints.generateAnswer.initiate(args);
};

// src/features/advanced-search-queries/advanced-search-query-selectors.ts
var import_toolkit116 = require("@reduxjs/toolkit");
var selectAdvancedSearchQueries = (0, import_toolkit116.createSelector)(
  (state) => state.advancedSearchQueries,
  (advancedSearchQueries) => {
    if (!advancedSearchQueries) {
      return {};
    }
    const { aq, cq, dq, lq } = advancedSearchQueries;
    return {
      ...aq && { aq },
      ...cq && { cq },
      ...dq && { dq },
      ...lq && { lq }
    };
  }
);

// src/features/context/context-selector.ts
var selectContext = (state) => state.context;

// src/features/pipeline/select-pipeline.ts
var selectPipeline = (state) => state.pipeline;

// src/features/search/search-selectors.ts
var import_toolkit117 = require("@reduxjs/toolkit");

// src/features/result-templates/result-templates-helpers.ts
var import_bueno89 = require("@coveo/bueno");

// src/features/search/search-selectors.ts
var selectSearchActionCause = (0, import_toolkit117.createSelector)(
  (state) => state.search,
  (state) => {
    return state?.searchAction?.actionCause || "";
  }
);

// src/features/search-hub/search-hub-selectors.ts
var selectSearchHub = (state) => state.searchHub;

// src/features/dictionary-field-context/dictionary-field-context-selectors.ts
var selectDictionaryFieldContext = (state) => {
  if (!state.dictionaryFieldContext || !Object.keys(state.dictionaryFieldContext.contextValues).length) {
    return void 0;
  }
  return state.dictionaryFieldContext.contextValues;
};

// src/features/excerpt-length/excerpt-length-selectors.ts
var selectExcerptLength = (state) => state.excerptLength?.length;

// src/features/folding/folding-selectors.ts
var selectFoldingQueryParams = (state) => {
  if (!state.folding) {
    return void 0;
  }
  return {
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: state.folding.filterFieldRange
  };
};

// src/features/sort-criteria/sort-criteria-selectors.ts
var selectSortCriteria = (state) => state.sortCriteria;

// src/features/generated-answer/generated-answer-request.ts
var buildStreamingRequest = async (state) => ({
  accessToken: state.configuration.accessToken,
  organizationId: state.configuration.organizationId,
  url: getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment
  ),
  streamId: state.search.extendedResults?.generativeQuestionAnsweringId
});
var constructAnswerAPIQueryParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const { aq, cq, dq, lq } = buildAdvancedSearchQueryParams(state);
  const context = selectContext(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    { actionCause: selectSearchActionCause(state) }
  );
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  const facetParams = getGeneratedFacetParams(state);
  const tab = selectActiveTab(state.tabSet) || "default";
  const locale = selectLocale(state);
  const timezone2 = selectTimezone(state);
  const referrer = navigatorContext.referrer || "";
  const facetOptions = selectFacetOptions(state);
  const sortCriteria = selectSortCriteria(state);
  const actionsHistory = getActionsHistory(state);
  const excerptLength = selectExcerptLength(state);
  const foldingParams = selectFoldingQueryParams(state);
  const dictionaryFieldContext = selectDictionaryFieldContext(state);
  return {
    q,
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq },
    ...state.query && { enableQuerySyntax: selectEnableQuerySyntax(state) },
    ...context?.contextValues && {
      context: context.contextValues
    },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...facetParams.length && { facets: facetParams },
    ...state.fields && { fieldsToInclude: state.fields.fieldsToInclude },
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    tab,
    locale,
    timezone: timezone2,
    ...state.debug !== void 0 && { debug: state.debug },
    referrer,
    ...actionsHistory,
    ...foldingParams ?? {},
    ...excerptLength && { excerptLength },
    ...dictionaryFieldContext && {
      dictionaryFieldContext
    },
    sortCriteria,
    ...facetOptions && { facetOptions },
    ...analyticsParams,
    ...state.insightCaseContext?.caseContext && {
      caseContext: state.insightCaseContext?.caseContext
    }
  };
};
var constructGenerateHeadAnswerParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const facetParams = getGeneratedFacetParams(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    { actionCause: selectSearchActionCause(state) }
  );
  const locale = selectLocale(state);
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  return {
    q: q || "",
    ...facetParams.length && { facets: facetParams },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...analyticsParams,
    locale
  };
};
var getGeneratedFacetParams = (state) => getFacets2(state)?.map(
  (facetRequest) => mapFacetRequest(facetRequest, initialSearchMappings())
).sort(
  (a, b) => a.facetId > b.facetId ? 1 : b.facetId > a.facetId ? -1 : 0
);
var getActionsHistory = (state) => ({
  actionsHistory: state.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : []
});
var buildAdvancedSearchQueryParams = (state) => {
  const advancedSearchQueryParams = selectAdvancedSearchQueries(state);
  const mergedCq = buildConstantQuery2(state);
  return {
    ...advancedSearchQueryParams,
    ...mergedCq && { cq: mergedCq }
  };
};

// src/features/generated-answer/generated-response-format.ts
var generatedContentFormat = ["text/plain", "text/markdown"];

// src/features/generated-answer/generated-answer-actions.ts
var stringValue2 = new import_bueno90.StringValue({ required: true });
var optionalStringValue = new import_bueno90.StringValue();
var booleanValue = new import_bueno90.BooleanValue({ required: true });
var citationSchema = {
  id: stringValue2,
  title: stringValue2,
  uri: stringValue2,
  permanentid: stringValue2,
  clickUri: optionalStringValue
};
var answerContentFormatSchema = new import_bueno90.StringValue({
  required: true,
  constrainTo: generatedContentFormat
});
var setIsVisible = (0, import_toolkit118.createAction)(
  "generatedAnswer/setIsVisible",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerId2 = (0, import_toolkit118.createAction)(
  "generatedAnswer/setAnswerId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setAnswerGenerationMode = (0, import_toolkit118.createAction)(
  "generatedAnswer/setAnswerGenerationMode",
  (payload) => validatePayload(
    payload,
    new import_bueno90.StringValue({
      constrainTo: ["automatic", "manual"],
      required: false,
      default: "automatic"
    })
  )
);
var setIsEnabled2 = (0, import_toolkit118.createAction)(
  "generatedAnswer/setIsEnabled",
  (payload) => validatePayload(payload, booleanValue)
);
var updateMessage = (0, import_toolkit118.createAction)(
  "generatedAnswer/updateMessage",
  (payload) => validatePayload(payload, {
    textDelta: stringValue2
  })
);
var updateCitations = (0, import_toolkit118.createAction)(
  "generatedAnswer/updateCitations",
  (payload) => validatePayload(payload, {
    citations: new import_bueno90.ArrayValue({
      required: true,
      each: new import_bueno90.RecordValue({
        values: citationSchema
      })
    })
  })
);
var updateError = (0, import_toolkit118.createAction)(
  "generatedAnswer/updateError",
  (payload) => validatePayload(payload, {
    message: optionalStringValue,
    code: new import_bueno90.NumberValue({ min: 0 })
  })
);
var resetAnswer = (0, import_toolkit118.createAction)("generatedAnswer/resetAnswer");
var likeGeneratedAnswer = (0, import_toolkit118.createAction)("generatedAnswer/like");
var dislikeGeneratedAnswer = (0, import_toolkit118.createAction)("generatedAnswer/dislike");
var openGeneratedAnswerFeedbackModal = (0, import_toolkit118.createAction)(
  "generatedAnswer/feedbackModal/open"
);
var expandGeneratedAnswer = (0, import_toolkit118.createAction)("generatedAnswer/expand");
var collapseGeneratedAnswer = (0, import_toolkit118.createAction)("generatedAnswer/collapse");
var setId = (0, import_toolkit118.createAction)(
  "generatedAnswer/setId",
  (payload) => validatePayload(payload, {
    id: new import_bueno90.StringValue({
      required: true
    })
  })
);
var closeGeneratedAnswerFeedbackModal = (0, import_toolkit118.createAction)(
  "generatedAnswer/feedbackModal/close"
);
var sendGeneratedAnswerFeedback = (0, import_toolkit118.createAction)(
  "generatedAnswer/sendFeedback"
);
var setIsLoading = (0, import_toolkit118.createAction)(
  "generatedAnswer/setIsLoading",
  (payload) => validatePayload(payload, booleanValue)
);
var setIsStreaming = (0, import_toolkit118.createAction)(
  "generatedAnswer/setIsStreaming",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerContentFormat = (0, import_toolkit118.createAction)(
  "generatedAnswer/setAnswerContentFormat",
  (payload) => validatePayload(payload, answerContentFormatSchema)
);
var updateResponseFormat = (0, import_toolkit118.createAction)(
  "generatedAnswer/updateResponseFormat",
  (payload) => validatePayload(payload, {
    contentFormat: new import_bueno90.ArrayValue({
      each: answerContentFormatSchema,
      default: ["text/plain"]
    })
  })
);
var updateAnswerConfigurationId = (0, import_toolkit118.createAction)(
  "knowledge/updateAnswerConfigurationId",
  (payload) => validatePayload(payload, stringValue2)
);
var registerFieldsToIncludeInCitations = (0, import_toolkit118.createAction)(
  "generatedAnswer/registerFieldsToIncludeInCitations",
  (payload) => validatePayload(payload, nonEmptyStringArray)
);
var setIsAnswerGenerated = (0, import_toolkit118.createAction)(
  "generatedAnswer/setIsAnswerGenerated",
  (payload) => validatePayload(payload, booleanValue)
);
var setCannotAnswer = (0, import_toolkit118.createAction)(
  "generatedAnswer/setCannotAnswer",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerApiQueryParams = (0, import_toolkit118.createAction)(
  "generatedAnswer/setAnswerApiQueryParams",
  (payload) => validatePayload(payload, new import_bueno90.RecordValue({}))
);
var streamAnswer = (0, import_toolkit118.createAsyncThunk)("generatedAnswer/streamAnswer", async (params, config) => {
  const state = config.getState();
  const { dispatch, extra, getState } = config;
  const { search } = getState();
  const { queryExecuted } = search;
  const { setAbortControllerRef } = params;
  const request = await buildStreamingRequest(state);
  const handleStreamPayload = (payloadType, payload) => {
    switch (payloadType) {
      case "genqa.headerMessageType": {
        const header = JSON.parse(
          payload
        );
        dispatch(setAnswerContentFormat(header.contentFormat));
        break;
      }
      case "genqa.messageType":
        dispatch(
          updateMessage(JSON.parse(payload))
        );
        break;
      case "genqa.citationsType":
        dispatch(
          updateCitations(
            JSON.parse(payload)
          )
        );
        break;
      case "genqa.endOfStreamType": {
        const isAnswerGenerated = JSON.parse(payload).answerGenerated;
        const cannotAnswer = queryExecuted.length !== 0 && !isAnswerGenerated;
        dispatch(setCannotAnswer(cannotAnswer));
        dispatch(setIsStreaming(false));
        dispatch(setIsAnswerGenerated(isAnswerGenerated));
        dispatch(logGeneratedAnswerStreamEnd(isAnswerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
        break;
      }
      default:
        if (state.debug) {
          extra.logger.warn(`Unknown payloadType: "${payloadType}"`);
        }
    }
  };
  dispatch(setIsLoading(true));
  const currentStreamRequestMatchesOriginalStreamRequest = (request2) => {
    return request2.streamId === config.getState().search.extendedResults.generativeQuestionAnsweringId;
  };
  const abortController = extra.streamingClient?.streamGeneratedAnswer(
    request,
    {
      write: (data) => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(setIsLoading(false));
          if (data.payload && data.payloadType) {
            handleStreamPayload(data.payloadType, data.payload);
          }
        }
      },
      abort: (error) => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(updateError(error));
        }
      },
      close: () => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(setIsStreaming(false));
        }
      },
      resetAnswer: () => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(resetAnswer());
        }
      }
    }
  );
  if (abortController) {
    setAbortControllerRef(abortController);
  } else {
    dispatch(setIsLoading(false));
  }
});
var generateAnswer = (0, import_toolkit118.createAsyncThunk)(
  "generatedAnswer/generateAnswer",
  async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
    dispatch(resetAnswer());
    const state = getState();
    if (state.generatedAnswer.answerConfigurationId) {
      const answerApiQueryParams = constructAnswerAPIQueryParams(
        state,
        navigatorContext
      );
      dispatch(setAnswerApiQueryParams(answerApiQueryParams));
      await dispatch(fetchAnswer(answerApiQueryParams));
    } else {
      logger.warn(
        "[WARNING] Missing answerConfigurationId in engine configuration. The generateAnswer action requires an answer configuration ID to use CRGA with the Answer API."
      );
    }
  }
);
var generateHeadAnswer = (0, import_toolkit118.createAsyncThunk)(
  "generatedAnswerWithFollowUps/generateHeadAnswer",
  async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state);
    if (!agentId) {
      logger.warn(
        "Missing agentId in engine configuration. The generateHeadAnswer action requires an agent ID."
      );
      return;
    }
    dispatch(resetAnswer());
    const generateHeadAnswerParams = constructGenerateHeadAnswerParams(
      state,
      navigatorContext
    );
    const headAnswerEndpointArgs = {
      ...generateHeadAnswerParams,
      strategyKey: "head-answer"
    };
    dispatch(setAnswerApiQueryParams(generateHeadAnswerParams));
    await dispatch(initiateAnswerEndpoint(headAnswerEndpointArgs));
  }
);

// src/api/knowledge/stream-answer-api.ts
var handleHeaderMessage = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var handleMessage = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var handleCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var handleEndOfStream = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var handleError5 = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(
    `Generated answer error: ${errorMessage} (code: ${message.code})`
  );
};
var updateCacheWithEvent = (event, draft, dispatch) => {
  const message = JSON.parse(event.data);
  if (message.finishReason === "ERROR" && message.errorMessage) {
    handleError5(draft, message);
  }
  const parsedPayload = message.payload.length ? JSON.parse(message.payload) : {};
  switch (message.payloadType) {
    case "genqa.headerMessageType":
      if (parsedPayload.contentFormat) {
        handleHeaderMessage(draft, parsedPayload);
        dispatch(setAnswerContentFormat(parsedPayload.contentFormat));
      }
      break;
    case "genqa.messageType":
      if (parsedPayload.textDelta) {
        handleMessage(draft, parsedPayload);
        dispatch(updateMessage({ textDelta: parsedPayload.textDelta }));
      }
      break;
    case "genqa.citationsType":
      if (parsedPayload.citations) {
        handleCitations(draft, parsedPayload);
        dispatch(updateCitations({ citations: parsedPayload.citations }));
      }
      break;
    case "genqa.endOfStreamType":
      handleEndOfStream(draft, parsedPayload);
      dispatch(
        logGeneratedAnswerStreamEnd(parsedPayload.answerGenerated ?? false)
      );
      dispatch(logGeneratedAnswerResponseLinked());
      break;
  }
};
var buildAnswerEndpoint = (platformEndpoint, organizationId, answerConfigurationId, insightId) => {
  if (!platformEndpoint || !organizationId || !answerConfigurationId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/rest/organizations/${organizationId}`;
  const prefix = insightId ? `insight/v1/configs/${insightId}/answer` : `answer/v1/configs`;
  return `${platformEndpoint}${basePath2}/${prefix}/${answerConfigurationId}/generate`;
};
var answerApi = answerSlice.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    getAnswer: builder.query({
      queryFn: () => ({
        data: {
          contentFormat: void 0,
          answer: void 0,
          citations: void 0,
          error: void 0,
          generated: false,
          isStreaming: true,
          isLoading: true
        }
      }),
      serializeQueryArgs: ({ endpointName, queryArgs }) => {
        const { analytics: _analytics, ...queryArgsWithoutAnalytics } = queryArgs;
        return `${endpointName}(${JSON.stringify(queryArgsWithoutAnalytics)})`;
      },
      async onCacheEntryAdded(args, { getState, cacheDataLoaded, updateCachedData, dispatch }) {
        await cacheDataLoaded;
        const { configuration: configuration2, generatedAnswer, insightConfiguration } = getState();
        const { organizationId, environment, accessToken } = configuration2;
        const platformEndpoint = getOrganizationEndpoint(
          organizationId,
          environment
        );
        const answerEndpoint2 = buildAnswerEndpoint(
          platformEndpoint,
          organizationId,
          generatedAnswer.answerConfigurationId,
          insightConfiguration?.insightId
        );
        await fetchEventSource(answerEndpoint2, {
          method: "POST",
          body: JSON.stringify(args),
          headers: {
            Authorization: `Bearer ${accessToken}`,
            Accept: "application/json",
            "Content-Type": "application/json",
            "Accept-Encoding": "*"
          },
          fetch,
          onopen: async (res) => {
            const answerId = res.headers.get("x-answer-id");
            if (answerId) {
              updateCachedData((draft) => {
                draft.answerId = answerId;
                dispatch(setAnswerId2(answerId));
              });
            }
          },
          onmessage: (event) => {
            updateCachedData((draft) => {
              updateCacheWithEvent(event, draft, dispatch);
            });
          },
          onerror: (error) => {
            throw error;
          },
          onclose: () => {
            updateCachedData((draft) => {
              dispatch(setCannotAnswer(!draft.generated));
            });
          }
        });
      }
    })
  })
});
var fetchAnswer = (fetchAnswerParams) => {
  return answerApi.endpoints.getAnswer.initiate(fetchAnswerParams);
};

// src/app/analytics-middleware.ts
var import_bueno91 = require("@coveo/bueno");
function isAnalyticsAction(action) {
  const analytics = action.payload?.analyticsAction;
  return isActionWithType(action) && !(0, import_bueno91.isNullOrUndefined)(analytics);
}
function isActionWithType(action) {
  return "type" in action;
}
var analyticsMiddleware = (api) => (next) => (action) => {
  let analytics;
  if (isAnalyticsAction(action)) {
    analytics = action.payload.analyticsAction;
    delete action.payload.analyticsAction;
  }
  const ret = next(action);
  if (isActionWithType(action)) {
    if (action.type === "search/executeSearch/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with search:", action);
    }
    if (action.type === "recommendation/get/fullfilled" && analytics === void 0) {
      console.error(
        "No analytics action associated with recommendation:",
        action
      );
    }
    if (action.type === "productRecommendations/get/fullfilled" && analytics === void 0) {
      console.error(
        "No analytics action associated with product recommendation:",
        action
      );
    }
  }
  if (analytics !== void 0) {
    api.dispatch(analytics);
  }
  return ret;
};

// src/app/instantly-callable-middleware.ts
function isInstantlyCallableThunkAction(action) {
  return action.instantlyCallable;
}
var instantlyCallableThunkActionMiddleware = () => (next) => (action) => next(isInstantlyCallableThunkAction(action) ? action() : action);

// src/app/listener-middleware/generate-answer-listener-middleware.ts
var import_toolkit119 = require("@reduxjs/toolkit");
var generateAnswerListener = (0, import_toolkit119.createListenerMiddleware)();
generateAnswerListener.startListening({
  actionCreator: executeSearch2.pending,
  effect: async (_action, listenerApi) => {
    const state = listenerApi.getState();
    const q = selectQuery(state)?.q;
    const queryIsEmpty = !q || q.trim() === "";
    if (!isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
      return;
    }
    listenerApi.dispatch(resetAnswer());
    listenerApi.dispatch(resetFollowUpAnswers());
    if (queryIsEmpty) {
      return;
    }
    listenerApi.dispatch(generateHeadAnswer());
  }
});

// src/app/logger-middlewares.ts
var logActionErrorMiddleware = (logger) => () => (next) => (action) => {
  const unknownAction = action;
  if (!unknownAction.error) {
    return next(action);
  }
  const error = unknownAction.error;
  if (!unknownAction.payload?.ignored) {
    logger.error(
      { error, action },
      `Action dispatch error ${unknownAction.type}`
    );
  }
  if (unknownAction.error.name === "SchemaValidationError") {
    return;
  }
  return next(action);
};
var logActionMiddleware = (logger) => (api) => (next) => (action) => {
  logger.debug(
    {
      action,
      nextState: api.getState()
    },
    `Action dispatched: ${action.type}`
  );
  return next(action);
};

// src/app/navigator-context-provider.ts
var getNavigatorContext = (relay, customProvider) => {
  const { referrer, userAgent, location, clientId } = relay.getMeta("");
  const customContext = customProvider ? customProvider() : {};
  return { ...customContext, referrer, userAgent, location, clientId };
};

// src/app/reducer-manager.ts
var import_toolkit120 = require("@reduxjs/toolkit");
function createReducerManager(initialReducers, preloadedState) {
  const reducers = { ...initialReducers };
  let crossReducer;
  const rootReducer = (combined) => {
    return (state, action) => {
      const intermediate = combined(state, action);
      const final = crossReducer ? crossReducer(intermediate, action) : intermediate;
      return final;
    };
  };
  return {
    get combinedReducer() {
      const placeholderReducers = fromEntries(
        Object.entries(preloadedState).filter(([key]) => !(key in reducers)).map(([key, value]) => [key, () => value])
      );
      return rootReducer(
        (0, import_toolkit120.combineReducers)({ ...placeholderReducers, ...reducers })
      );
    },
    containsAll(newReducers) {
      const keys = Object.keys(newReducers);
      return keys.every((key) => key in reducers);
    },
    add(newReducers) {
      Object.keys(newReducers).filter((key) => !(key in reducers)).forEach((key) => {
        reducers[key] = newReducers[key];
      });
    },
    addCrossReducer(reducer) {
      crossReducer = reducer;
    }
  };
}

// src/utils/jwt-utils.ts
function parseJWT(token) {
  if (!token || !isJWTToken(token)) {
    return null;
  }
  try {
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const base64decoded = atob(base64);
    const jsonPayload = decodeURIComponent(
      base64decoded.split("").map((character) => {
        return `%${`00${character.charCodeAt(0).toString(16)}`.slice(-2)}`;
      }).join("")
    );
    return JSON.parse(jsonPayload);
  } catch (_) {
    return null;
  }
}
function shouldRenewJWT(token, bufferSeconds = 60) {
  if (!token) {
    return false;
  }
  const parsedToken = parseJWT(token);
  if (!parsedToken || typeof parsedToken.exp !== "number") {
    return false;
  }
  const nowSeconds = Math.floor(Date.now() / 1e3);
  return parsedToken.exp <= nowSeconds + bufferSeconds;
}
function isJWTToken(token) {
  if (!token) {
    return false;
  }
  return /^[A-Za-z0-9_-]{2,}(?:\.[A-Za-z0-9_-]{2,}){2}$/.test(token);
}

// src/app/renew-access-token-middleware.ts
function createRenewAccessTokenMiddleware(logger, renewToken) {
  let accessTokenRenewalsAttempts = 0;
  let pendingTokenRenewal = null;
  const resetRenewalTriesAfterDelay = debounce(() => {
    accessTokenRenewalsAttempts = 0;
  }, 500);
  const handleTokenRenewal = async (store, handleErrors = false) => {
    const isTokenRenewalPending = !pendingTokenRenewal;
    if (isTokenRenewalPending && renewToken) {
      pendingTokenRenewal = (async () => {
        if (handleErrors) {
          attempt(renewToken);
        }
        return await renewToken();
      })().finally(() => {
        pendingTokenRenewal = null;
      });
    }
    const accessToken = await pendingTokenRenewal;
    if (isTokenRenewalPending && accessToken) {
      store.dispatch(updateBasicConfiguration({ accessToken }));
    }
    return accessToken;
  };
  const handleProactiveTokenRenewal = async (store) => {
    const state = store.getState();
    const accessToken = getAccessTokenFromState(state);
    if (!accessToken || !shouldRenewJWT(accessToken)) {
      return;
    }
    logger.debug(
      "Access token is expired or about to expire, attempting renewal."
    );
    try {
      const newAccessToken = await handleTokenRenewal(store);
      if (newAccessToken) {
        logger.debug("Access token was renewed.");
      } else {
        logger.warn(
          "Access token renewal returned an empty token. Please check the #renewAccessToken function."
        );
      }
    } catch (error) {
      logger.warn(
        error,
        "Access token renewal failed. A retry will occur if necessary."
      );
    }
  };
  const handleExpiredToken = async (store, payload, action) => {
    if (accessTokenRenewalsAttempts >= 5) {
      logger.warn(
        "Attempted to renew the token but was not successful. Please check the #renewAccessToken function."
      );
      dispatchError(store, payload.error);
      return payload;
    }
    accessTokenRenewalsAttempts++;
    resetRenewalTriesAfterDelay();
    await handleTokenRenewal(store, true);
    store.dispatch(action);
    return;
  };
  return (store) => (next) => async (action) => {
    const isThunk = typeof action === "function";
    const hasRenewFunction = typeof renewToken === "function";
    if (!isThunk) {
      return next(action);
    }
    if (hasRenewFunction) {
      await handleProactiveTokenRenewal(store);
    }
    const payload = await next(action);
    if (!isExpiredTokenError(payload)) {
      return payload;
    }
    if (!hasRenewFunction) {
      logger.warn(
        "Unable to renew the expired token because a renew function was not provided. Please specify the #renewAccessToken option when initializing the engine."
      );
      dispatchError(store, payload.error);
      return payload;
    }
    return await handleExpiredToken(store, payload, action);
  };
}
function isExpiredTokenError(action) {
  return typeof action === "object" && action !== null && "error" in action && // biome-ignore lint/suspicious/noExplicitAny: any action is possible here.
  action.error?.name === new UnauthorizedTokenError().name;
}
function dispatchError(store, error) {
  store.dispatch(
    setError({
      status: 401,
      statusCode: 401,
      message: error.message,
      type: error.name
    })
  );
}
async function attempt(fn) {
  try {
    return await fn();
  } catch (_) {
    return "";
  }
}
function getAccessTokenFromState(state) {
  return state.configuration.accessToken;
}

// src/app/store.ts
var import_toolkit121 = require("@reduxjs/toolkit");
function configureStore({
  reducer,
  preloadedState,
  middlewares = [],
  thunkExtraArguments,
  name
}) {
  return (0, import_toolkit121.configureStore)({
    reducer,
    preloadedState,
    devTools: {
      stateSanitizer: (state) => state.history ? { ...state, history: "<<OMIT>>" } : state,
      name,
      shouldHotReload: false
      // KIT-961 -> Redux dev tool + hot reloading interacts badly with replaceReducers mechanism.
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ thunk: { extraArgument: thunkExtraArguments } }).prepend(...middlewares).concat(logActionMiddleware(thunkExtraArguments.logger))
  });
}

// src/app/engine.ts
function buildCoreEngine(options, thunkExtraArguments, configurationReducer3) {
  const { reducers, navigatorContextProvider } = options;
  const reducerManager = createReducerManager(
    { ...reducers, configurationReducer: configurationReducer3 },
    options.preloadedState ?? {}
  );
  if (options.crossReducer) {
    reducerManager.addCrossReducer(options.crossReducer);
  }
  const logger = thunkExtraArguments.logger;
  const thunkExtraArgumentsWithRelay = {
    ...thunkExtraArguments,
    get relay() {
      return getRelayInstanceFromState(engine.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    }
  };
  const store = createStore(
    options,
    thunkExtraArgumentsWithRelay,
    reducerManager
  );
  const engine = {
    addReducers(reducers2) {
      if (reducerManager.containsAll(reducers2)) {
        return;
      }
      reducerManager.add(reducers2);
      store.replaceReducer(reducerManager.combinedReducer);
    },
    dispatch: store.dispatch,
    subscribe: store.subscribe,
    enableAnalytics() {
      store.dispatch(enableAnalytics());
    },
    disableAnalytics() {
      store.dispatch(disableAnalytics());
    },
    get state() {
      return store.getState();
    },
    get relay() {
      return getRelayInstanceFromState(this.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    },
    logger,
    store
  };
  return engine;
}
function createStore(options, thunkExtraArguments, reducerManager) {
  const { preloadedState, configuration: configuration2 } = options;
  const name = configuration2.name || "coveo-headless";
  const middlewares = createMiddleware(options, thunkExtraArguments.logger);
  return configureStore({
    preloadedState,
    reducer: reducerManager.combinedReducer,
    middlewares,
    thunkExtraArguments,
    name
  });
}
function createMiddleware(options, logger) {
  const { renewAccessToken } = options.configuration;
  const renewTokenMiddleware = createRenewAccessTokenMiddleware(
    logger,
    renewAccessToken
  );
  return [
    instantlyCallableThunkActionMiddleware,
    renewTokenMiddleware,
    logActionErrorMiddleware(logger),
    analyticsMiddleware
  ].concat(
    answerApi.middleware,
    answerGenerationApi.middleware,
    generateAnswerListener.middleware,
    options.middlewares || []
  );
}

// src/app/logger.ts
var import_pino = require("pino");
function buildLogger(options) {
  return (0, import_pino.pino)({
    name: "@coveo/headless",
    level: options?.level || "warn",
    formatters: {
      log: options?.logFormatter
    }
  });
}

// src/app/thunk-extra-arguments.ts
function buildThunkExtraArguments(configuration2, logger) {
  const analyticsClientMiddleware = getAnalyticsClientMiddleware(configuration2);
  const validatePayload2 = validatePayloadAndThrow;
  const preprocessRequest = getPreprocessRequest(configuration2);
  return {
    analyticsClientMiddleware,
    validatePayload: validatePayload2,
    preprocessRequest,
    logger
  };
}
function getAnalyticsClientMiddleware(configuration2) {
  const { analytics } = configuration2;
  const NoopAnalyticsMiddleware = (_, p) => p;
  return analytics?.analyticsClientMiddleware || NoopAnalyticsMiddleware;
}
function getPreprocessRequest(configuration2) {
  return configuration2.preprocessRequest || NoopPreprocessRequest;
}

// src/app/commerce-engine/commerce-engine.ts
var commerceEngineReducers = {
  productListing: productListingReducer,
  recommendations: recommendationsReducer,
  commerceSearch: commerceSearchReducer,
  commercePagination: paginationReducer,
  commerceSort: sortReducer,
  facetOrder: facetOrderReducer,
  fieldSuggestionsOrder: fieldSuggestionsOrderReducer,
  facetSearchSet: specificFacetSearchSetReducer,
  categoryFacetSearchSet: categoryFacetSearchSetReducer,
  commerceFacetSet: commerceFacetSetReducer,
  manualNumericFacetSet: manualNumericFacetReducer,
  commerceContext: contextReducer,
  commerceQuery: queryReducer,
  cart: cartReducer,
  didYouMean: didYouMeanReducer,
  triggers: commerceTriggersReducer
};
function buildCommerceEngine(options) {
  const logger = buildLogger(options.loggerOptions);
  const { configuration: configuration2 } = options;
  validateConfiguration(configuration2, logger);
  const commerceClient = createCommerceAPIClient(configuration2, logger);
  const thunkArguments = {
    ...buildThunkExtraArguments(configuration2, logger),
    apiClient: commerceClient
  };
  const reducers = {
    ...commerceEngineReducers,
    configuration: configurationReducer2,
    version: versionReducer
  };
  const augmentedOptions = {
    ...options,
    reducers
  };
  const internalEngine = buildCoreEngine(
    augmentedOptions,
    thunkArguments,
    configurationReducer2
  );
  const { state: _, ...engine } = internalEngine;
  const {
    accessToken,
    environment,
    organizationId,
    analytics,
    proxyBaseUrl,
    context,
    cart
  } = configuration2;
  engine.dispatch(
    updateBasicConfiguration2({
      accessToken,
      environment,
      organizationId
    })
  );
  engine.dispatch(updateAnalyticsConfiguration2(analytics));
  if (proxyBaseUrl !== void 0) {
    engine.dispatch(
      updateProxyBaseUrl({
        proxyBaseUrl
      })
    );
  }
  engine.dispatch(setContext(context));
  if (cart?.items !== void 0) {
    engine.dispatch(setItems(cart.items));
  }
  return redactEngine({
    ...engine,
    get relay() {
      return internalEngine.relay;
    },
    get [stateKey]() {
      return internalEngine.state;
    },
    get configuration() {
      return {
        ...internalEngine.state.configuration
      };
    }
  });
}
function validateConfiguration(configuration2, logger) {
  try {
    commerceEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error(error, "Commerce engine configuration error");
    throw error;
  }
}
function createCommerceAPIClient(configuration2, logger) {
  return new CommerceAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest
  });
}

// src/features/commerce/configuration/configuration-actions-loader.ts
function loadConfigurationActions(engine) {
  engine.addReducers({ configuration: configurationReducer });
  return {
    disableAnalytics: disableAnalytics2,
    enableAnalytics: enableAnalytics2,
    updateAnalyticsConfiguration: updateAnalyticsConfiguration2,
    updateBasicConfiguration: updateBasicConfiguration2,
    updateProxyBaseUrl
  };
}

// src/ssr/commerce/factories/build-factory.ts
function isListingFetchCompletedAction(action) {
  return /^commerce\/productListing\/fetch\/(fulfilled|rejected)$/.test(
    action.type
  );
}
function isSearchCompletedAction(action) {
  return /^commerce\/search\/executeSearch\/(fulfilled|rejected)$/.test(
    action.type
  );
}
function isRecommendationCompletedAction(action) {
  return /^commerce\/recommendations\/fetch\/(fulfilled|rejected)$/.test(
    action.type
  );
}
function noSearchActionRequired(_action) {
  return true;
}
function buildSSRCommerceEngine(solutionType, options, recommendationCount) {
  let actionCompletionMiddleware;
  const middlewares = [];
  const memo = /* @__PURE__ */ new Set();
  switch (solutionType) {
    case "listing" /* listing */:
      actionCompletionMiddleware = createWaitForActionMiddleware(
        isListingFetchCompletedAction
      );
      middlewares.push(actionCompletionMiddleware);
      break;
    case "search" /* search */:
      actionCompletionMiddleware = createWaitForActionMiddleware(
        isSearchCompletedAction
      );
      middlewares.push(actionCompletionMiddleware);
      break;
    case "recommendation" /* recommendation */:
      middlewares.push(
        ...Array.from(
          { length: recommendationCount },
          () => createWaitForActionMiddlewareForRecommendation(
            isRecommendationCompletedAction,
            memo
          )
        )
      );
      break;
    case "standalone" /* standalone */:
      actionCompletionMiddleware = createWaitForActionMiddleware(
        noSearchActionRequired
      );
      break;
    default:
      throw new Error("Unsupported solution type", solutionType);
  }
  const commerceEngine = buildCommerceEngine({
    ...options,
    middlewares: [
      ...options.middlewares ?? [],
      ...middlewares.map(({ middleware }) => middleware)
    ]
  });
  return {
    ...commerceEngine,
    get [stateKey]() {
      return commerceEngine[stateKey];
    },
    waitForRequestCompletedAction() {
      return [...middlewares.map(({ promise }) => promise)];
    }
  };
}
function fetchActiveRecommendationControllers(controllerProps, solutionType) {
  return solutionType === "recommendation" /* recommendation */ ? Object.values(controllerProps).filter(
    (controller) => controller && typeof controller === "object" && "enabled" in controller && controller.enabled
  ).length : 0;
}
var buildFactory = (controllerDefinitions, options) => (solutionType) => async (...[buildOptions]) => {
  const logger = buildLogger(options.loggerOptions);
  if (!options.navigatorContextProvider) {
    logger.warn(
      "[WARNING] Missing navigator context in server-side code. Make sure to set it with `setNavigatorContextProvider` before calling fetchStaticState()"
    );
  }
  const controllerProps = buildOptions && "controllers" in buildOptions ? buildOptions.controllers : {};
  const enabledRecommendationControllers = fetchActiveRecommendationControllers(controllerProps, solutionType);
  const engine = buildSSRCommerceEngine(
    solutionType,
    buildOptions && "extend" in buildOptions && buildOptions?.extend ? await buildOptions.extend(options) : options,
    enabledRecommendationControllers
  );
  const updateEngineConfiguration = (accessToken) => {
    const { updateBasicConfiguration: updateBasicConfiguration3 } = loadConfigurationActions(engine);
    engine.dispatch(
      updateBasicConfiguration3({
        accessToken
      })
    );
  };
  if (options.onAccessTokenUpdate) {
    options.onAccessTokenUpdate(updateEngineConfiguration);
  }
  const controllers = buildControllerDefinitions({
    definitionsMap: controllerDefinitions ?? {},
    engine,
    solutionType,
    propsMap: buildOptions && "controllers" in buildOptions ? buildOptions.controllers : {}
  });
  return {
    engine,
    controllers
  };
};

// src/ssr/common/controller-utils.ts
function composeFunction(parentFunction, children) {
  const newFunction = (...params) => parentFunction(...params);
  for (const [key, value] of Object.entries(children)) {
    newFunction[key] = value;
  }
  return newFunction;
}

// src/ssr/commerce/factories/hydrated-state-factory.ts
var hydratedStaticStateFactory = (controllerDefinitions, options) => (solutionType) => composeFunction(
  async (...params) => {
    const solutionTypeBuild = await buildFactory(controllerDefinitions, {
      ...options
    })(solutionType);
    const buildResult = await solutionTypeBuild(
      ...params
    );
    const staticStateBuild = await hydratedStaticStateFactory(
      controllerDefinitions,
      options
    )(solutionType);
    const staticState = await staticStateBuild.fromBuildResult({
      buildResult,
      searchActions: params[0].searchActions
    });
    return staticState;
  },
  {
    fromBuildResult: async (...params) => {
      const [
        {
          buildResult: { engine, controllers },
          searchActions
        }
      ] = params;
      searchActions.forEach((action) => {
        engine.dispatch(action);
      });
      await engine.waitForRequestCompletedAction();
      return { engine, controllers };
    }
  }
);

// src/ssr/commerce/factories/recommendation-hydrated-state-factory.ts
function hydratedRecommendationStaticStateFactory(controllerDefinitions, options) {
  return composeFunction(
    async (...params) => {
      const solutionTypeBuild = await buildFactory(
        controllerDefinitions,
        options
      )("recommendation" /* recommendation */);
      const buildResult = await solutionTypeBuild(
        ...params
      );
      const staticState = await hydratedRecommendationStaticStateFactory(
        controllerDefinitions,
        options
      ).fromBuildResult({
        buildResult,
        searchActions: params[0].searchActions
      });
      return staticState;
    },
    {
      fromBuildResult: async (...params) => {
        const [
          {
            buildResult: { engine, controllers },
            searchActions
          }
        ] = params;
        searchActions.forEach((action) => {
          engine.dispatch(action);
        });
        await engine.waitForRequestCompletedAction();
        return { engine, controllers };
      }
    }
  );
}

// src/ssr/commerce/utils/recommendation-filter.ts
function filterRecommendationControllers(controllers, controllerDefinitions) {
  const slotIdSet = /* @__PURE__ */ new Set();
  const isRecommendationDefinition = (controllerDefinition) => {
    const isControllerRecommendation = "recommendation" in controllerDefinition && controllerDefinition.recommendation === true;
    const hasSlotId = recommendationInternalOptionKey in controllerDefinition && "slotId" in controllerDefinition[recommendationInternalOptionKey];
    return isControllerRecommendation && hasSlotId;
  };
  const ensureSingleRecommendationPerSlot = (slotId) => {
    throw new MultipleRecommendationError(slotId);
  };
  const filtered = Object.entries(controllerDefinitions).filter(
    ([_, value]) => {
      if (!isRecommendationDefinition(value)) {
        return false;
      }
      const { slotId } = value[recommendationInternalOptionKey];
      const key = slotId;
      if (slotIdSet.has(slotId)) {
        ensureSingleRecommendationPerSlot(slotId);
        return false;
      }
      slotIdSet.add(key);
      return true;
    }
  );
  const name = filtered.map(([name2, _]) => name2);
  return {
    /**
     * Go through all the controllers passed in argument and only refresh recommendation controllers.
     *
     * @param controllers - A record of all controllers where the key is the controller name and the value is the controller instance.
     * @param controllerNames - A list of all recommendation controllers to refresh
     */
    refresh(whitelist) {
      if (whitelist === void 0) {
        return;
      }
      const isRecommendationController = (key) => name.includes(key) && whitelist.includes(key);
      for (const [key, controller] of Object.entries(controllers)) {
        if (isRecommendationController(key)) {
          controller.refresh?.();
        }
      }
    }
  };
}

// src/ssr/commerce/factories/recommendation-static-state-factory.ts
function fetchRecommendationStaticStateFactory(controllerDefinitions, options) {
  const getAllowedRecommendationKeys = (props) => {
    if (props && "controllers" in props) {
      const enabledRecommendationControllers = filterObject(
        props.controllers,
        (value) => Boolean(value.enabled)
      );
      return Object.keys(enabledRecommendationControllers);
    }
    return [];
  };
  return composeFunction(
    async (...params) => {
      const [props] = params;
      const allowedRecommendationKeys = getAllowedRecommendationKeys(props);
      const solutionTypeBuild = await buildFactory(
        controllerDefinitions,
        options
      )("recommendation" /* recommendation */);
      const buildResult = await solutionTypeBuild(
        ...params
      );
      const staticState = await fetchRecommendationStaticStateFactory(
        controllerDefinitions,
        options
      ).fromBuildResult({
        buildResult,
        allowedRecommendationKeys
      });
      return staticState;
    },
    {
      fromBuildResult: async (...params) => {
        const [
          {
            buildResult: { engine, controllers },
            allowedRecommendationKeys
          }
        ] = params;
        filterRecommendationControllers(
          controllers,
          controllerDefinitions ?? {}
        ).refresh(allowedRecommendationKeys);
        const searchActions = await Promise.all(
          engine.waitForRequestCompletedAction()
        );
        return createStaticState({
          searchActions,
          controllers
        });
      }
    }
  );
}

// src/ssr/common/augment-preprocess-request.ts
var AUGMENTED_MARKER = Symbol("augmentedWithForwardedFor");
function augmentPreprocessRequestWithForwardedFor(options) {
  const originalPreprocessRequest = options.preprocessRequest;
  if (originalPreprocessRequest?.[AUGMENTED_MARKER]) {
    return originalPreprocessRequest;
  }
  const augmentedFunction = async (request, clientOrigin, metadata) => {
    if (!isBrowser()) {
      const headers = new Headers(request.headers);
      const forwardedFor = options.navigatorContextProvider?.()?.forwardedFor;
      if (forwardedFor) {
        headers.set("x-forwarded-for", forwardedFor);
      } else {
        const logger = buildLogger(options.loggerOptions);
        logger.warn(
          "[WARNING] Unable to set x-forwarded-for header. Make sure to set the 'forwardedFor' property in the navigator context provider."
        );
      }
      request.headers = headers;
    }
    if (originalPreprocessRequest) {
      return originalPreprocessRequest(request, clientOrigin, metadata);
    }
    return request;
  };
  augmentedFunction[AUGMENTED_MARKER] = true;
  return augmentedFunction;
}

// src/ssr/commerce/factories/static-state-factory.ts
var fetchStaticStateFactory = (controllerDefinitions, options) => (solutionType) => composeFunction(
  async (...params) => {
    const solutionTypeBuild = await buildFactory(controllerDefinitions, {
      ...options
    })(solutionType);
    const buildResult = await solutionTypeBuild(...params);
    options.configuration.preprocessRequest = augmentPreprocessRequestWithForwardedFor({
      preprocessRequest: options.configuration.preprocessRequest,
      navigatorContextProvider: options.navigatorContextProvider,
      loggerOptions: options.loggerOptions
    });
    const staticStateBuild = await fetchStaticStateFactory(
      controllerDefinitions,
      options
    )(solutionType);
    const staticState = await staticStateBuild.fromBuildResult({
      buildResult
    });
    return staticState;
  },
  {
    fromBuildResult: async (...params) => {
      const [
        {
          buildResult: { engine, controllers }
        }
      ] = params;
      switch (solutionType) {
        case "listing" /* listing */:
          buildProductListing(engine).executeFirstRequest();
          break;
        case "search" /* search */:
          buildSearch(engine).executeFirstSearch();
          break;
      }
      const searchActions = await Promise.all(
        engine.waitForRequestCompletedAction()
      );
      return createStaticState({
        searchActions,
        controllers
      });
    }
  }
);

// src/ssr/commerce/engine/commerce-engine.ssr.ts
function defineCommerceEngine(options) {
  const { controllers: controllerDefinitions, ...engineOptions } = options;
  const setNavigatorContextProvider = (navigatorContextProvider) => {
    engineOptions.navigatorContextProvider = navigatorContextProvider;
  };
  const tokenManager = createAccessTokenManager(
    engineOptions.configuration.accessToken
  );
  const onAccessTokenUpdate = (updateCallback) => {
    tokenManager.registerCallback(updateCallback);
  };
  const definitionOptions = engineOptions;
  definitionOptions.onAccessTokenUpdate = onAccessTokenUpdate;
  const getAccessToken = () => tokenManager.getAccessToken();
  const setAccessToken = (accessToken) => {
    engineOptions.configuration.accessToken = accessToken;
    tokenManager.setAccessToken(accessToken);
  };
  const build = buildFactory(
    controllerDefinitions,
    definitionOptions
  );
  const fetchStaticState = fetchStaticStateFactory(
    controllerDefinitions,
    definitionOptions
  );
  const hydrateStaticState = hydratedStaticStateFactory(
    controllerDefinitions,
    definitionOptions
  );
  const fetchRecommendationStaticState = fetchRecommendationStaticStateFactory(
    controllerDefinitions,
    definitionOptions
  );
  const hydrateRecommendationStaticState = hydratedRecommendationStaticStateFactory(
    controllerDefinitions,
    definitionOptions
  );
  return {
    listingEngineDefinition: {
      build: build("listing" /* listing */),
      fetchStaticState: fetchStaticState("listing" /* listing */),
      hydrateStaticState: hydrateStaticState("listing" /* listing */),
      setNavigatorContextProvider,
      getAccessToken,
      setAccessToken
    },
    searchEngineDefinition: {
      build: build("search" /* search */),
      fetchStaticState: fetchStaticState("search" /* search */),
      hydrateStaticState: hydrateStaticState("search" /* search */),
      setNavigatorContextProvider,
      getAccessToken,
      setAccessToken
    },
    recommendationEngineDefinition: {
      build: build("recommendation" /* recommendation */),
      fetchStaticState: fetchRecommendationStaticState,
      hydrateStaticState: hydrateRecommendationStaticState,
      setNavigatorContextProvider,
      getAccessToken,
      setAccessToken
    },
    // TODO KIT-3738 :  The standaloneEngineDefinition should not be async since no request is sent to the API
    standaloneEngineDefinition: {
      build: build("standalone" /* standalone */),
      fetchStaticState: fetchStaticState("standalone" /* standalone */),
      hydrateStaticState: hydrateStaticState("standalone" /* standalone */),
      setNavigatorContextProvider,
      getAccessToken,
      setAccessToken
    }
  };
}

// src/features/commerce/context/cart/cart-actions-loader.ts
function loadCartActions(engine) {
  engine.addReducers({ cart: cartReducer });
  return {
    emitPurchaseEvent,
    emitCartActionEvent,
    purchase,
    setItems,
    updateItemQuantity
  };
}

// src/features/commerce/context/context-actions-loader.ts
function loadContextActions(engine) {
  engine.addReducers({ commerceContext: contextReducer });
  return {
    setContext,
    setView,
    setLocation,
    setCustom
  };
}

// src/features/commerce/facets/category-facet/category-facet-actions-loader.ts
function loadCategoryFacetSetActions(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return {
    toggleSelectCategoryFacetValue: toggleSelectCategoryFacetValue2,
    updateCategoryFacetNumberOfValues: updateCategoryFacetNumberOfValues2
  };
}

// src/features/commerce/facets/core-facet/core-facet-actions-loader.ts
function loadCoreFacetActions(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return {
    clearAllCoreFacets,
    deleteAllCoreFacets,
    deselectAllValuesInCoreFacet,
    updateAutoSelectionForAllCoreFacets,
    updateCoreFacetFreezeCurrentValues,
    updateCoreFacetIsFieldExpanded,
    updateCoreFacetNumberOfValues
  };
}

// src/features/commerce/facets/date-facet/date-facet-actions-loader.ts
function loadDateFacetActions(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return {
    toggleSelectDateFacetValue: toggleSelectDateFacetValue2,
    toggleExcludeDateFacetValue: toggleExcludeDateFacetValue2,
    updateDateFacetValues: updateDateFacetValues2
  };
}

// src/features/commerce/facets/numeric-facet/numeric-facet-actions-loader.ts
function loadNumericFacetActions(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return {
    toggleSelectNumericFacetValue: toggleSelectNumericFacetValue2,
    toggleExcludeNumericFacetValue: toggleExcludeNumericFacetValue2,
    updateNumericFacetValues: updateNumericFacetValues2
  };
}

// src/features/commerce/facets/regular-facet/regular-facet-actions-loader.ts
function loadRegularFacetActions(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return {
    toggleExcludeFacetValue: toggleExcludeFacetValue2,
    toggleSelectFacetValue: toggleSelectFacetValue2
  };
}

// src/features/commerce/instant-products/instant-products-actions-loader.ts
function loadInstantProductsActions(engine) {
  engine.addReducers({ instantProducts: instantProductsReducer });
  return {
    clearExpiredProducts,
    promoteChildToParent: promoteChildToParent4,
    registerInstantProducts,
    updateInstantProductsQuery
  };
}

// src/features/commerce/pagination/pagination-actions-loader.ts
function loadPaginationActions(engine) {
  engine.addReducers({ commercePagination: paginationReducer });
  return {
    registerRecommendationsSlotPagination,
    setPageSize,
    selectPage,
    nextPage: nextPage2,
    previousPage: previousPage2
  };
}

// src/features/commerce/product/product-actions-loaders.ts
function loadProductActions() {
  return {
    productClick,
    productView
  };
}

// src/features/commerce/product-enrichment/product-enrichment-actions-loader.ts
function loadProductEnrichmentActions(engine) {
  engine.addReducers({ productEnrichment: productEnrichmentReducer });
  return {
    fetchBadges,
    registerProductEnrichmentOptions
  };
}

// src/features/commerce/product-listing/product-listing-actions-loader.ts
function loadProductListingActions(engine) {
  engine.addReducers({ productListing: productListingReducer });
  return {
    fetchProductListing,
    fetchMoreProducts,
    promoteChildToParent
  };
}

// src/features/commerce/product-listing-parameters/product-listing-parameters-actions-loader.ts
function loadProductListingParametersActions(engine) {
  engine.addReducers({
    facetOrder: facetOrderReducer,
    commerceFacetSet: commerceFacetSetReducer,
    commercePagination: paginationReducer,
    commerceSort: sortReducer
  });
  return {
    restoreProductListingParameters
  };
}

// src/features/commerce/query/query-actions-loader.ts
function loadQueryActions(engine) {
  engine.addReducers({ query: queryReducer });
  return {
    updateQuery: updateQuery2
  };
}

// src/features/commerce/query-set/query-set-actions-loader.ts
function loadQuerySetActions(engine) {
  engine.addReducers({ querySetReducer });
  return {
    registerQuerySetQuery: registerQuerySetQuery2,
    updateQuerySetQuery: updateQuerySetQuery2
  };
}

// src/features/commerce/query-suggest/query-suggest-actions-loader.ts
function loadQuerySuggestActions(engine) {
  engine.addReducers({ querySuggest: querySuggestReducer });
  return {
    clearQuerySuggest,
    fetchQuerySuggestions,
    registerQuerySuggest,
    selectQuerySuggestion
  };
}

// src/features/commerce/recent-queries/recent-queries-actions-loader.ts
function loadRecentQueriesActions(engine) {
  engine.addReducers({ recentQueries: recentQueriesReducer2 });
  return {
    registerRecentQueries,
    clearRecentQueries
  };
}

// src/features/commerce/recommendations/recommendations-actions-loader.ts
function loadRecommendationsActions(engine) {
  engine.addReducers({ recommendations: recommendationsReducer });
  return {
    fetchRecommendations,
    fetchMoreRecommendations,
    promoteChildToParent: promoteChildToParent3,
    registerRecommendationsSlot
  };
}

// src/features/commerce/search/search-actions-loader.ts
function loadSearchActions(engine) {
  engine.addReducers({ commerceSearch: commerceSearchReducer });
  return {
    executeSearch: executeSearch3,
    fetchMoreProducts: fetchMoreProducts2,
    prepareForSearchWithQuery: prepareForSearchWithQuery2,
    promoteChildToParent: promoteChildToParent2
  };
}

// src/features/commerce/search-parameters/search-parameters-actions-loader.ts
function loadSearchParametersActions(engine) {
  engine.addReducers({
    facetOrder: facetOrderReducer,
    commerceFacetSet: commerceFacetSetReducer,
    commercePagination: paginationReducer,
    query: queryReducer,
    querySet: querySetReducer,
    commerceSort: sortReducer
  });
  return {
    restoreSearchParameters: restoreSearchParameters2
  };
}

// src/features/commerce/sort/sort-actions-loader.ts
function loadSortActions(engine) {
  engine.addReducers({ commerceSort: sortReducer });
  return {
    applySort
  };
}

// src/features/standalone-search-box-set/standalone-search-box-set-slice.ts
var import_toolkit123 = require("@reduxjs/toolkit");

// src/features/standalone-search-box-set/standalone-search-box-set-actions.ts
var import_bueno92 = require("@coveo/bueno");
var import_toolkit122 = require("@reduxjs/toolkit");

// src/api/common/trigger.ts
function isRedirectTrigger(trigger) {
  return trigger.type === "redirect";
}

// src/api/search/plan/plan-endpoint.ts
var ExecutionPlan = class {
  constructor(response) {
    this.response = response;
  }
  /**
   * Gets the final value of the basic expression (`q`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get basicExpression() {
    return this.response.parsedInput.basicExpression;
  }
  /**
   * Gets the final value of the large expression (`lq`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get largeExpression() {
    return this.response.parsedInput.largeExpression;
  }
  /**
   * Gets the URL to redirect the browser to, if the search request satisfies the condition of a `redirect` trigger rule in the query pipeline.
   *
   * Returns `null` otherwise.
   */
  get redirectionUrl() {
    const redirects = this.response.preprocessingOutput.triggers.filter(isRedirectTrigger);
    return redirects.length ? redirects[0].content : null;
  }
};

// src/features/standalone-search-box-set/standalone-search-box-set-actions.ts
var registerStandaloneSearchBox2 = (0, import_toolkit122.createAction)(
  "standaloneSearchBox/register",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    redirectionUrl: requiredNonEmptyString,
    overwrite: new import_bueno92.BooleanValue({ required: false })
  })
);
var updateStandaloneSearchBoxRedirectionUrl2 = (0, import_toolkit122.createAction)(
  "standaloneSearchBox/updateRedirectionUrl",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    redirectionUrl: requiredNonEmptyString
  })
);
var resetStandaloneSearchBox2 = (0, import_toolkit122.createAction)(
  "standaloneSearchBox/reset",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString
  })
);
var updateAnalyticsToSearchFromLink = (0, import_toolkit122.createAction)(
  "standaloneSearchBox/updateAnalyticsToSearchFromLink",
  (payload) => validatePayload(payload, { id: requiredNonEmptyString })
);
var updateAnalyticsToOmniboxFromLink = (0, import_toolkit122.createAction)(
  "standaloneSearchBox/updateAnalyticsToOmniboxFromLink"
);
var fetchRedirectUrl2 = (0, import_toolkit122.createAsyncThunk)(
  "standaloneSearchBox/fetchRedirect",
  async (payload, {
    dispatch,
    getState,
    rejectWithValue,
    extra: { apiClient, validatePayload: validatePayload2, navigatorContext }
  }) => {
    validatePayload2(payload, { id: new import_bueno92.StringValue({ emptyAllowed: false }) });
    const request = await buildPlanRequest2(getState(), navigatorContext);
    const response = await apiClient.plan(request);
    if (isErrorResponse(response)) {
      return rejectWithValue(response.error);
    }
    const { redirectionUrl } = new ExecutionPlan(response.success);
    if (redirectionUrl) {
      dispatch(logRedirect(redirectionUrl));
    }
    return redirectionUrl || "";
  }
);
var logRedirect = (url) => makeAnalyticsAction(
  "analytics/standaloneSearchBox/redirect",
  (client) => client.makeTriggerRedirect({ redirectedTo: url })
);
var buildPlanRequest2 = async (state, navigatorContext) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    timezone: state.configuration.search.timezone,
    q: state.query.q,
    ...state.context && { context: state.context.contextValues },
    ...state.pipeline && { pipeline: state.pipeline },
    ...state.searchHub && { searchHub: state.searchHub },
    ...state.configuration.analytics.enabled && state.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams2(
      state.configuration.analytics
    ) : fromAnalyticsStateToAnalyticsParams(
      state.configuration.analytics,
      navigatorContext
    ),
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/standalone-search-box-set/standalone-search-box-set-state.ts
function getStandaloneSearchBoxSetInitialState() {
  return {};
}

// src/features/standalone-search-box-set/standalone-search-box-set-slice.ts
var standaloneSearchBoxSetReducer = (0, import_toolkit123.createReducer)(
  getStandaloneSearchBoxSetInitialState(),
  (builder) => builder.addCase(registerStandaloneSearchBox2, (state, action) => {
    const { id: id2, redirectionUrl, overwrite } = action.payload;
    if (!overwrite && id2 in state) {
      return;
    }
    state[id2] = buildStandaloneSearchBoxEntry2(redirectionUrl);
  }).addCase(resetStandaloneSearchBox2, (state, action) => {
    const { id: id2 } = action.payload;
    const searchBox = state[id2];
    if (searchBox) {
      state[id2] = buildStandaloneSearchBoxEntry2(
        searchBox.defaultRedirectionUrl
      );
      return;
    }
  }).addCase(updateStandaloneSearchBoxRedirectionUrl2, (state, action) => {
    const { id: id2, redirectionUrl } = action.payload;
    if (!(id2 in state)) {
      return;
    }
    state[id2] = buildStandaloneSearchBoxEntry2(redirectionUrl);
  }).addCase(fetchRedirectUrl2.pending, (state, action) => {
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.isLoading = true;
  }).addCase(fetchRedirectUrl2.fulfilled, (state, action) => {
    const url = action.payload;
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.redirectTo = url ? url : searchBox.defaultRedirectionUrl;
    searchBox.isLoading = false;
  }).addCase(fetchRedirectUrl2.rejected, (state, action) => {
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.isLoading = false;
  }).addCase(updateAnalyticsToSearchFromLink, (state, action) => {
    const searchBox = state[action.payload.id];
    if (!searchBox) {
      return;
    }
    searchBox.analytics.cause = "searchFromLink";
  }).addCase(updateAnalyticsToOmniboxFromLink, (state, action) => {
    const searchBox = state[action.payload.id];
    if (!searchBox) {
      return;
    }
    searchBox.analytics.cause = "omniboxFromLink";
    searchBox.analytics.metadata = action.payload.metadata;
  })
);
function buildStandaloneSearchBoxEntry2(defaultRedirectionUrl) {
  return {
    defaultRedirectionUrl,
    redirectTo: "",
    isLoading: false,
    analytics: {
      cause: "",
      metadata: null
    }
  };
}

// src/features/commerce/standalone-search-box-set/standalone-search-box-set-actions-loader.ts
function loadStandaloneSearchBoxSetActions(engine) {
  engine.addReducers({ standaloneSearchBoxSet: standaloneSearchBoxSetReducer });
  return {
    fetchRedirectUrl,
    registerStandaloneSearchBox,
    updateStandaloneSearchBoxRedirectionUrl,
    resetStandaloneSearchBox
  };
}

// src/features/commerce/triggers/triggers-actions-loader.ts
function loadTriggersActions(engine) {
  engine.addReducers({ triggers: commerceTriggersReducer });
  return {
    updateIgnoreQueryTrigger: updateIgnoreQueryTrigger2,
    applyQueryTriggerModification: applyQueryTriggerModification2
  };
}

// src/features/fields/fields-slice.ts
var import_toolkit126 = require("@reduxjs/toolkit");

// src/features/folding/folding-actions.ts
var import_bueno93 = require("@coveo/bueno");
var import_toolkit124 = require("@reduxjs/toolkit");
var foldingOptionsSchemaDefinition = {
  collectionField: new import_bueno93.StringValue({ emptyAllowed: false, required: false }),
  parentField: new import_bueno93.StringValue({ emptyAllowed: false, required: false }),
  childField: new import_bueno93.StringValue({ emptyAllowed: false, required: false }),
  numberOfFoldedResults: new import_bueno93.NumberValue({ min: 0, required: false })
};
var registerFolding = (0, import_toolkit124.createAction)(
  "folding/register",
  (payload) => validatePayload(payload, foldingOptionsSchemaDefinition)
);
var loadCollection = (0, import_toolkit124.createAsyncThunk)(
  "folding/loadCollection",
  async (collectionId, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const sharedWithSearchRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest2(state) : buildSearchAndFoldingLoadCollectionRequest(state, navigatorContext);
    const response = await apiClient.search(
      {
        ...sharedWithSearchRequest,
        q: getQForHighlighting(state),
        enableQuerySyntax: true,
        cq: `@${state.folding.fields.collection}="${collectionId}"`,
        filterField: state.folding.fields.collection,
        childField: state.folding.fields.parent,
        parentField: state.folding.fields.child,
        filterFieldRange: 100
      },
      { origin: "foldingCollection" }
    );
    if (isErrorResponse(response)) {
      return rejectWithValue(response.error);
    }
    return {
      collectionId,
      results: response.success.results,
      searchUid: response.success.searchUid,
      rootResult: state.folding.collections[collectionId].result
    };
  }
);
function getQForHighlighting(state) {
  if (state.query.q === "") {
    return "";
  }
  return state.query.enableQuerySyntax ? `${state.query.q} OR @uri` : `( <@- ${state.query.q} -@> ) OR @uri`;
}

// src/features/folding/folding-state.ts
var getFoldingInitialState = () => ({
  enabled: false,
  fields: {
    collection: "foldingcollection",
    parent: "foldingparent",
    child: "foldingchild"
  },
  filterFieldRange: 2,
  collections: {}
});

// src/features/fields/fields-actions.ts
var import_toolkit125 = require("@reduxjs/toolkit");
var registerFieldsToInclude = (0, import_toolkit125.createAction)(
  "fields/registerFieldsToInclude",
  (payload) => validatePayload(payload, nonEmptyStringArray)
);
var enableFetchAllFields = (0, import_toolkit125.createAction)("fields/fetchall/enable");
var disableFetchAllFields = (0, import_toolkit125.createAction)("fields/fetchall/disable");
var fetchFieldsDescription = (0, import_toolkit125.createAsyncThunk)("fields/fetchDescription", async (_, { extra, getState, rejectWithValue }) => {
  const state = getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const { apiBaseUrl } = state.configuration.search;
  const descriptions = await extra.apiClient.fieldDescriptions({
    accessToken,
    organizationId,
    url: apiBaseUrl ?? getSearchApiBaseUrl(organizationId, environment)
  });
  if (isErrorResponse(descriptions)) {
    return rejectWithValue(descriptions.error);
  }
  return descriptions.success.fields;
});

// src/features/fields/fields-state.ts
var MinimumFieldsToInclude = [
  "author",
  "language",
  "urihash",
  "objecttype",
  "collection",
  "source",
  "permanentid"
];
var DefaultFieldsToInclude = [
  ...MinimumFieldsToInclude,
  "date",
  "filetype",
  "parents"
];
var EcommerceDefaultFieldsToInclude = [
  ...DefaultFieldsToInclude,
  "ec_price",
  "ec_name",
  "ec_description",
  "ec_brand",
  "ec_category",
  "ec_item_group_id",
  "ec_shortdesc",
  "ec_thumbnails",
  "ec_images",
  "ec_promo_price",
  "ec_in_stock",
  "ec_rating"
];
var getFieldsInitialState = () => ({
  fieldsToInclude: MinimumFieldsToInclude,
  fetchAllFields: false,
  fieldsDescription: []
});

// src/features/fields/fields-slice.ts
var fieldsReducer = (0, import_toolkit126.createReducer)(
  getFieldsInitialState(),
  (builder) => builder.addCase(registerFieldsToInclude, (state, action) => {
    state.fieldsToInclude = [
      ...new Set(state.fieldsToInclude.concat(action.payload))
    ];
  }).addCase(enableFetchAllFields, (state) => {
    state.fetchAllFields = true;
  }).addCase(disableFetchAllFields, (state) => {
    state.fetchAllFields = false;
  }).addCase(fetchFieldsDescription.fulfilled, (state, { payload }) => {
    state.fieldsDescription = payload;
  }).addCase(registerFolding, (state, { payload }) => {
    const defaultFields = getFoldingInitialState().fields;
    state.fieldsToInclude.push(
      payload.collectionField ?? defaultFields.collection,
      payload.parentField ?? defaultFields.parent,
      payload.childField ?? defaultFields.child
    );
  })
);

// src/features/templates/templates-manager.ts
var import_bueno94 = require("@coveo/bueno");
var templateSchema = new import_bueno94.Schema({
  content: new import_bueno94.Value({ required: true }),
  conditions: new import_bueno94.Value({ required: true }),
  priority: new import_bueno94.NumberValue({ required: false, default: 0, min: 0 }),
  fields: new import_bueno94.ArrayValue({
    required: false,
    each: requiredNonEmptyString
  })
});
function buildTemplatesManager() {
  const templates = [];
  const validateTemplate = (template) => {
    const validated = templateSchema.validate(template);
    const areConditionsValid = template.conditions.every(
      (condition) => condition instanceof Function
    );
    if (!areConditionsValid) {
      throw new import_bueno94.SchemaValidationError(
        "Each template condition should be a function that takes a Result or Product as an argument and returns a boolean"
      );
    }
    return validated;
  };
  return {
    registerTemplates(...newTemplates) {
      newTemplates.forEach((template) => {
        const templatesWithDefault = {
          ...validateTemplate(template),
          fields: template.fields || []
        };
        templates.push(templatesWithDefault);
      });
      templates.sort((a, b) => b.priority - a.priority);
    },
    selectTemplate(item) {
      const template = templates.find(
        (template2) => template2.conditions.every((condition) => condition(item))
      );
      return template ? template.content : null;
    },
    selectLinkTemplate(item) {
      const template = templates.find(
        (template2) => template2.conditions.every((condition) => condition(item))
      );
      return template ? template.linkContent : null;
    }
  };
}

// src/features/result-templates/result-templates-manager.ts
function buildResultTemplatesManager(engine) {
  if (!loadResultTemplatesManagerReducers(engine)) {
    throw loadReducerError;
  }
  const {
    registerTemplates: coreRegisterTemplates,
    selectTemplate,
    selectLinkTemplate
  } = buildTemplatesManager();
  return {
    registerTemplates: (...newTemplates) => {
      coreRegisterTemplates(...newTemplates);
      const fields = [];
      newTemplates.forEach((template) => {
        template.fields && fields.push(...template.fields);
      });
      engine.dispatch(registerFieldsToInclude(fields));
    },
    selectTemplate,
    selectLinkTemplate
  };
}
function loadResultTemplatesManagerReducers(engine) {
  engine.addReducers({ fields: fieldsReducer });
  return true;
}

// src/features/commerce/parameters/parameters-serializer.ssr.ts
var import_bueno96 = require("@coveo/bueno");

// src/features/search-parameters/search-parameter-utils.ts
var import_bueno95 = require("@coveo/bueno");
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}

// src/features/commerce/parameters/parameters-serializer.ssr.ts
function buildParameterSerializer() {
  return { deserialize: deserialize2, serialize: serialize3 };
}
function deserialize2(urlCommerceSearchParams) {
  const commerceSearchParameters = {};
  const add = (key, value) => extendSearchParams(commerceSearchParameters, key, value);
  if (urlCommerceSearchParams instanceof URLSearchParams) {
    urlCommerceSearchParams.forEach((value, key) => add(key, value));
  } else {
    Object.entries(urlCommerceSearchParams).forEach(
      ([key, value]) => add(key, value)
    );
  }
  return commerceSearchParameters;
}
function serialize3(commerceSearchParameters, initialUrl) {
  initialUrl = new URL(initialUrl);
  const { searchParams } = initialUrl;
  const previousState = wipeSearchParamsFromUrl(searchParams);
  Object.entries(commerceSearchParameters).forEach(
    ([key, value]) => isValidKey2(key) && applyToUrlSearchParam(searchParams, previousState, [key, value])
  );
  return initialUrl.href;
}
function wipeSearchParamsFromUrl(urlSearchParams) {
  const previousSearchParams = {};
  const keysToDelete = [];
  urlSearchParams.forEach((value, key) => {
    if (value !== void 0 && isValidSearchParam(key)) {
      previousSearchParams[key] = [...previousSearchParams[key] || [], value];
      keysToDelete.push(key);
    }
  });
  for (const key of keysToDelete) {
    urlSearchParams.delete(key);
  }
  return previousSearchParams;
}
function applyToUrlSearchParam(urlSearchParams, previousState, pair) {
  if ((0, import_bueno96.isNullOrUndefined)(pair[1])) {
    return;
  }
  if (isSortPair(pair)) {
    applySortToSearchParams(urlSearchParams, pair);
    return;
  }
  if (isFacetPair(pair)) {
    applyFacetValuesToSearchParams(urlSearchParams, previousState, pair);
    return;
  }
  if (isRangeFacetPair(pair)) {
    applyRangeFacetValuesToSearchParams(urlSearchParams, pair);
    return;
  }
  urlSearchParams.set(pair[0], `${pair[1]}`);
}
function applySortToSearchParams(urlSearchParams, [key, value]) {
  const sortCriteria = encodeURIComponent(buildCriterionExpression2(value));
  urlSearchParams.set(key, sortCriteria);
}
function applyFacetValuesToSearchParams(urlSearchParams, previousState, [key, value]) {
  Object.entries(value).forEach(([facetId2, facetValues]) => {
    const id2 = `${key}-${facetId2}`;
    const previousFacetValues = previousState[id2] ?? [];
    if (arrayEqualStrictlyDifferentOrder(previousFacetValues, value[facetId2])) {
      previousFacetValues.forEach((v) => urlSearchParams.append(id2, v));
      return;
    }
    urlSearchParams.delete(id2);
    facetValues.forEach((v) => urlSearchParams.append(id2, v));
  });
}
function applyRangeFacetValuesToSearchParams(urlSearchParams, [key, value]) {
  Object.entries(value).forEach(([facetId2, facetValues]) => {
    const id2 = `${key}-${facetId2}`;
    urlSearchParams.delete(id2);
    facetValues.forEach(
      ({ start, end, endInclusive }) => urlSearchParams.append(
        id2,
        `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`
      )
    );
  });
}
function isValidKey2(key) {
  return isValidBasicKey3(key) || keyHasObjectValue2(key);
}
function isValidBasicKey3(key) {
  const supportedBasicParameters = {
    q: true,
    sortCriteria: true,
    page: true,
    perPage: true
  };
  return key in supportedBasicParameters;
}
function extendSearchParams(commerceSearchParams, key, value) {
  if ((0, import_bueno96.isNullOrUndefined)(value)) {
    return;
  }
  if (key === "sortCriteria") {
    commerceSearchParams[key] = deserializeSortCriteria(
      decodeURIComponent(value)
    );
    return;
  }
  if (isValidBasicKey3(key) && typeof value === "string" && !isEmptyString(value)) {
    const [k, v] = cast3([key, value], false);
    commerceSearchParams[k] = v;
    return;
  }
  const result = commerceFacetsRegex.exec(key);
  if (result) {
    const paramKey = result[1];
    const facetId2 = result[2];
    if (!keyHasObjectValue2(paramKey)) {
      return;
    }
    const add = addFacetValuesToSearchParams(facetId2, paramKey);
    let range;
    switch (paramKey) {
      case "nf":
      case "mnf":
        range = buildNumericRanges(toArray(value), "selected");
        break;
      case "nfExcluded":
      case "mnfExcluded":
        range = buildNumericRanges(toArray(value), "excluded");
        break;
      case "df":
        range = buildDateRanges(toArray(value), "selected");
        break;
      case "dfExcluded":
        range = buildDateRanges(toArray(value), "excluded");
        break;
      default:
        range = toArray(value);
        break;
    }
    add(commerceSearchParams, range);
  }
}
function cast3(pair, decode = true) {
  const [key, value] = pair;
  if (key === "page") {
    return [key, parseInt(value)];
  }
  if (key === "perPage") {
    return [key, parseInt(value)];
  }
  if (keyHasObjectValue2(key)) {
    return [key, castUnknownObject(value)];
  }
  return [key, decode ? decodeURIComponent(value) : value];
}
function isValidSearchParam(key) {
  return commerceFacetsRegex.exec(key) !== null || isValidBasicKey3(key);
}
function isSortPair(pair) {
  const [key, value] = pair;
  const isValidKey3 = key === "sortCriteria";
  const isValidValue = isObject2(value) && "by" in value;
  return isValidKey3 && isValidValue;
}
function isFacetPair(pair) {
  const [key, value] = pair;
  const isValidKey3 = keyHasObjectValue2(key);
  const isValidValue = isFacetObject(value);
  return isValidKey3 && isValidValue;
}
var validRangeFacetKeys = [
  "nf",
  "nfExcluded",
  "mnf",
  "mnfExcluded",
  "df",
  "dfExcluded"
];
function isRangeFacetPair(pair) {
  const [key, value] = pair;
  const isValidKey3 = validRangeFacetKeys.includes(key);
  const isValidValue = isRangeFacetObject2(value);
  return isValidKey3 && isValidValue;
}
function isRangeFacetObject2(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isRangeValue = (v) => isObject2(v) && "start" in v && "end" in v;
  return allEntriesAreValid(obj, isRangeValue);
}
function addFacetValuesToSearchParams(facetId2, paramKey) {
  return (searchParams, valueArray) => {
    if (paramKey in searchParams) {
      const record = searchParams[paramKey] ?? {};
      record[facetId2] = [...record[facetId2] ?? [], ...valueArray];
      searchParams[paramKey] = record;
    } else {
      searchParams[paramKey] = { [facetId2]: valueArray };
    }
  };
}

// src/features/commerce/product-templates/product-templates-helpers.ts
var import_bueno97 = require("@coveo/bueno");
var getProductProperty = (product, property) => {
  const anyProduct = product;
  if (!(0, import_bueno97.isNullOrUndefined)(anyProduct[property])) {
    return anyProduct[property];
  }
  if (!(0, import_bueno97.isNullOrUndefined)(product.additionalFields[property])) {
    return product.additionalFields[property];
  }
  return null;
};
var fieldsMustBeDefined = (fieldNames) => {
  return (product) => {
    return fieldNames.every(
      (fieldName) => !(0, import_bueno97.isNullOrUndefined)(getProductProperty(product, fieldName))
    );
  };
};
var fieldsMustNotBeDefined = (fieldNames) => {
  return (product) => {
    return fieldNames.every(
      (fieldName) => (0, import_bueno97.isNullOrUndefined)(getProductProperty(product, fieldName))
    );
  };
};
var fieldMustMatch = (fieldName, valuesToMatch) => {
  return (product) => {
    const fieldValues = getFieldValuesFromProduct(fieldName, product);
    return valuesToMatch.some(
      (valueToMatch) => fieldValues.some(
        (fieldValue) => `${fieldValue}`.toLowerCase() === valueToMatch.toLowerCase()
      )
    );
  };
};
var fieldMustNotMatch = (fieldName, disallowedValues) => {
  return (product) => {
    const fieldValues = getFieldValuesFromProduct(fieldName, product);
    return disallowedValues.every(
      (disallowedValues2) => fieldValues.every(
        (fieldValue) => `${fieldValue}`.toLowerCase() !== disallowedValues2.toLowerCase()
      )
    );
  };
};
var getFieldValuesFromProduct = (fieldName, product) => {
  const rawValue = getProductProperty(product, fieldName);
  return (0, import_bueno97.isArray)(rawValue) ? rawValue : [rawValue];
};
var ProductTemplatesHelpers = {
  getProductProperty,
  fieldsMustBeDefined,
  fieldsMustNotBeDefined,
  fieldMustMatch,
  fieldMustNotMatch
};

// src/features/sort-criteria/criteria-parser.ts
function parseCriterion(criterion) {
  const { by, order } = criterion;
  switch (by) {
    case "relevancy" /* Relevancy */:
      return buildRelevanceSortCriterion2();
    case "qre" /* QRE */:
      return buildQueryRankingExpressionSortCriterion();
    case "nosort" /* NoSort */:
      return buildNoSortCriterion();
    case "date" /* Date */:
      if (!order) {
        throw new Error(
          'An order (i.e., ascending or descending) should be specified for a sort criterion sorted by "date"'
        );
      }
      return buildDateSortCriterion(order);
    default:
      if (!order) {
        throw new Error(
          `An order (i.e., ascending or descending) should be specified for a sort criterion sorted by a field, such as "${by}"`
        );
      }
      return buildFieldSortCriterion(by, order);
  }
}
function isSortOrder(order) {
  return order === void 0 || order === "ascending" /* Ascending */ || order === "descending" /* Descending */;
}
function parseCriterionExpression(expression) {
  const criteria = expression.split(",");
  const wrongFormatError = new Error(
    `Wrong criterion expression format for "${expression}"`
  );
  if (!criteria.length) {
    throw wrongFormatError;
  }
  return criteria.map((criterion) => {
    const criterionValues = criterion.trim().split(" ");
    const by = criterionValues[0].toLowerCase();
    const order = criterionValues[1]?.toLowerCase();
    if (criterionValues.length > 2) {
      throw wrongFormatError;
    }
    if (by === "") {
      throw wrongFormatError;
    }
    if (!isSortOrder(order)) {
      throw new Error(
        `Wrong criterion sort order "${order}" in expression "${expression}". Order should either be "${"ascending" /* Ascending */}" or "${"descending" /* Descending */}"`
      );
    }
    return parseCriterion({ by, order });
  });
}

// src/utils/query-expression/common/negatable.ts
function getNegationPrefix(config) {
  return config.negate ? "NOT " : "";
}

// src/utils/query-expression/common/operator.ts
function getOperatorSymbol(operator) {
  const dictionary = {
    contains: "=",
    differentThan: "<>",
    fuzzyMatch: "~=",
    greaterThan: ">",
    greaterThanOrEqual: ">=",
    isExactly: "==",
    lowerThan: "<",
    lowerThanOrEqual: "<=",
    phoneticMatch: "%=",
    regexMatch: "/=",
    wildcardMatch: "*="
  };
  return dictionary[operator];
}

// src/utils/query-expression/date-field/date-field.ts
function buildDateField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const operator = getOperatorSymbol(config.operator);
      const prefix = getNegationPrefix(config);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}

// src/utils/query-expression/date-range-field/date-range-field.ts
function buildDateRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}

// src/utils/query-expression/exact-match/exact-match.ts
function buildExactMatch(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { expression } = config;
      return `${prefix}"${expression}"`;
    }
  };
}

// src/utils/query-expression/field-exists/field-exists.ts
function buildFieldExists(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2 } = config;
      return `${prefix}@${field2}`;
    }
  };
}

// src/utils/query-expression/keyword/keyword.ts
function buildKeyword(config) {
  return {
    toQuerySyntax() {
      const { expression, negate } = config;
      return negate ? `NOT (${expression})` : expression;
    }
  };
}

// src/utils/query-expression/near/near.ts
function buildNear(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { startTerm, otherTerms } = config;
      const otherTermsExpression = buildOtherTerms(otherTerms);
      const expression = `${startTerm} ${otherTermsExpression}`;
      return config.negate ? `${prefix}(${expression})` : expression;
    }
  };
}
function buildOtherTerms(terms) {
  return terms.map((term) => {
    const { endTerm, maxKeywordsBetween } = term;
    return `near:${maxKeywordsBetween} ${endTerm}`;
  }).join(" ");
}

// src/utils/query-expression/numeric-field/numeric-field.ts
function buildNumericField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}

// src/utils/query-expression/numeric-range-field/numeric-range-field.ts
function buildNumericRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}

// src/utils/query-expression/query-extension/query-extension.ts
function buildQueryExtension(config) {
  return {
    toQuerySyntax() {
      const { name, parameters } = config;
      const argumentExpression = buildParameters(parameters);
      return `$${name}(${argumentExpression})`;
    }
  };
}
function buildParameters(params) {
  return Object.entries(params).map((entry) => {
    const [name, value] = entry;
    const formatted = typeof value === "string" ? value : value.toQuerySyntax();
    return `${name}: ${formatted}`;
  }).join(", ");
}

// src/utils/query-expression/string-facet-field/string-facet-field.ts
function buildStringFacetField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, operator, value } = config;
      const symbol = getOperatorSymbol(operator);
      const formattedValue = operator === "fuzzyMatch" ? ` $quoteVar(value: ${value})` : `("${value}")`;
      return `${prefix}@${field2}${symbol}${formattedValue}`;
    }
  };
}

// src/utils/query-expression/string-field/string-field.ts
function buildStringField(config) {
  return {
    toQuerySyntax() {
      const { field: field2 } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      const processed = config.values.map((value) => `"${value}"`);
      const values = processed.length === 1 ? processed[0] : `(${processed.join(",")})`;
      return `${prefix}@${field2}${operator}${values}`;
    }
  };
}

// src/utils/query-expression/query-expression.ts
function buildQueryExpression() {
  const parts = [];
  let booleanOperator = "and";
  return {
    addExpression(expression) {
      parts.push(expression);
      return this;
    },
    addKeyword(expression) {
      parts.push(buildKeyword(expression));
      return this;
    },
    addNear(expression) {
      parts.push(buildNear(expression));
      return this;
    },
    addExactMatch(expression) {
      parts.push(buildExactMatch(expression));
      return this;
    },
    addFieldExists(expression) {
      parts.push(buildFieldExists(expression));
      return this;
    },
    addStringField(expression) {
      parts.push(buildStringField(expression));
      return this;
    },
    addStringFacetField(expression) {
      parts.push(buildStringFacetField(expression));
      return this;
    },
    addNumericField(expression) {
      parts.push(buildNumericField(expression));
      return this;
    },
    addNumericRangeField(expression) {
      parts.push(buildNumericRangeField(expression));
      return this;
    },
    addDateField(expression) {
      parts.push(buildDateField(expression));
      return this;
    },
    addDateRangeField(expression) {
      parts.push(buildDateRangeField(expression));
      return this;
    },
    addQueryExtension(expression) {
      parts.push(buildQueryExtension(expression));
      return this;
    },
    joinUsing(operator) {
      booleanOperator = operator;
      return this;
    },
    toQuerySyntax() {
      const symbol = getBooleanOperatorSymbol(booleanOperator);
      const expression = parts.map((part) => part.toQuerySyntax()).join(`) ${symbol} (`);
      return parts.length <= 1 ? expression : `(${expression})`;
    }
  };
}
function getBooleanOperatorSymbol(operator) {
  return operator === "and" ? "AND" : "OR";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Kind,
  ProductTemplatesHelpers,
  ResultType,
  SolutionType,
  SortBy,
  SortOrder,
  VERSION,
  buildCriterionExpression,
  buildDateSortCriterion,
  buildFieldSortCriterion,
  buildNoSortCriterion,
  buildParameterSerializer,
  buildQueryExpression,
  buildQueryRankingExpressionSortCriterion,
  buildRelevanceSortCriterion,
  buildResultTemplatesManager,
  defineBreadcrumbManager,
  defineCart,
  defineCommerceEngine,
  defineContext,
  defineDidYouMean,
  defineFacetGenerator,
  defineFilterSuggestionsGenerator,
  defineInstantProducts,
  defineNotifyTrigger,
  definePagination,
  defineParameterManager,
  defineProductEnrichment,
  defineProductList,
  defineProductView,
  defineQueryTrigger,
  defineRecentQueriesList,
  defineRecommendations,
  defineRedirectionTrigger,
  defineSearchBox,
  defineSort,
  defineStandaloneSearchBox,
  defineSummary,
  deserializeRelativeDate,
  getAnalyticsNextApiBaseUrl,
  getCommerceApiBaseUrl,
  getOrganizationEndpoint,
  getSampleCommerceEngineConfiguration,
  loadCartActions,
  loadCategoryFacetSetActions,
  loadConfigurationActions,
  loadContextActions,
  loadCoreFacetActions,
  loadDateFacetActions,
  loadInstantProductsActions,
  loadNumericFacetActions,
  loadPaginationActions,
  loadProductActions,
  loadProductEnrichmentActions,
  loadProductListingActions,
  loadProductListingParametersActions,
  loadQueryActions,
  loadQuerySetActions,
  loadQuerySuggestActions,
  loadRecentQueriesActions,
  loadRecommendationsActions,
  loadRegularFacetActions,
  loadSearchActions,
  loadSearchParametersActions,
  loadSortActions,
  loadStandaloneSearchBoxSetActions,
  loadTriggersActions,
  parseCriterionExpression,
  validateRelativeDate
});
