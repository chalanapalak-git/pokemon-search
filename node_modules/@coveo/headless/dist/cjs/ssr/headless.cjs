/**
 * @license
 *
 * Copyright 2026 Coveo Solutions Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *       http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/ssr.index.ts
var ssr_index_exports = {};
__export(ssr_index_exports, {
  DefaultFieldsToInclude: () => DefaultFieldsToInclude,
  EcommerceDefaultFieldsToInclude: () => EcommerceDefaultFieldsToInclude,
  MinimumFieldsToInclude: () => MinimumFieldsToInclude,
  ResultTemplatesHelpers: () => ResultTemplatesHelpers,
  SortBy: () => SortBy,
  SortOrder: () => SortOrder,
  VERSION: () => VERSION,
  baseFacetResponseSelector: () => baseFacetResponseSelector,
  buildCriterionExpression: () => buildCriterionExpression,
  buildDateRange: () => buildDateRange,
  buildDateSortCriterion: () => buildDateSortCriterion,
  buildFieldSortCriterion: () => buildFieldSortCriterion,
  buildNoSortCriterion: () => buildNoSortCriterion,
  buildNumericRange: () => buildNumericRange,
  buildQueryExpression: () => buildQueryExpression,
  buildQueryRankingExpressionSortCriterion: () => buildQueryRankingExpressionSortCriterion,
  buildRelevanceSortCriterion: () => buildRelevanceSortCriterion,
  buildResultTemplatesManager: () => buildResultTemplatesManager,
  buildSSRSearchParameterSerializer: () => buildSSRSearchParameterSerializer,
  buildSearchParameterSerializer: () => buildSearchParameterSerializer,
  buildStaticFilterValue: () => buildStaticFilterValue,
  currentPageSelector: () => currentPageSelector,
  currentPagesSelector: () => currentPagesSelector,
  defineAutomaticFacetGenerator: () => defineAutomaticFacetGenerator,
  defineBreadcrumbManager: () => defineBreadcrumbManager,
  defineCategoryFacet: () => defineCategoryFacet,
  defineCategoryFieldSuggestions: () => defineCategoryFieldSuggestions,
  defineContext: () => defineContext,
  defineDateFacet: () => defineDateFacet,
  defineDateFilter: () => defineDateFilter,
  defineDictionaryFieldContext: () => defineDictionaryFieldContext,
  defineDidYouMean: () => defineDidYouMean,
  defineExecuteTrigger: () => defineExecuteTrigger,
  defineFacet: () => defineFacet,
  defineFacetManager: () => defineFacetManager,
  defineFieldSuggestions: () => defineFieldSuggestions,
  defineFoldedResultList: () => defineFoldedResultList,
  defineHistoryManager: () => defineHistoryManager,
  defineInstantResults: () => defineInstantResults,
  defineNotifyTrigger: () => defineNotifyTrigger,
  defineNumericFacet: () => defineNumericFacet,
  defineNumericFilter: () => defineNumericFilter,
  definePager: () => definePager,
  defineQueryError: () => defineQueryError,
  defineQuerySummary: () => defineQuerySummary,
  defineQueryTrigger: () => defineQueryTrigger,
  defineQuickview: () => defineQuickview,
  defineRecentQueriesList: () => defineRecentQueriesList,
  defineRecentResultsList: () => defineRecentResultsList,
  defineRedirectionTrigger: () => defineRedirectionTrigger,
  defineRelevanceInspector: () => defineRelevanceInspector,
  defineResultList: () => defineResultList,
  defineResultsPerPage: () => defineResultsPerPage,
  defineSearchBox: () => defineSearchBox,
  defineSearchEngine: () => defineSearchEngine,
  defineSearchParameterManager: () => defineSearchParameterManager,
  defineSearchStatus: () => defineSearchStatus,
  defineSmartSnippet: () => defineSmartSnippet,
  defineSmartSnippetQuestionsList: () => defineSmartSnippetQuestionsList,
  defineSort: () => defineSort,
  defineStandaloneSearchBox: () => defineStandaloneSearchBox,
  defineStaticFilter: () => defineStaticFilter,
  defineTab: () => defineTab,
  defineTabManager: () => defineTabManager,
  defineUrlManager: () => defineUrlManager,
  deserializeRelativeDate: () => deserializeRelativeDate,
  facetRequestSelector: () => facetRequestSelector,
  facetResponseSelectedValuesSelector: () => facetResponseSelectedValuesSelector,
  facetResponseSelector: () => facetResponseSelector,
  getAnalyticsNextApiBaseUrl: () => getAnalyticsNextApiBaseUrl,
  getOrganizationEndpoint: () => getOrganizationEndpoint,
  getSampleSearchEngineConfiguration: () => getSampleSearchEngineConfiguration,
  loadAdvancedSearchQueryActions: () => loadAdvancedSearchQueryActions,
  loadBreadcrumbActions: () => loadBreadcrumbActions,
  loadCategoryFacetSetActions: () => loadCategoryFacetSetActions,
  loadClickAnalyticsActions: () => loadClickAnalyticsActions,
  loadConfigurationActions: () => loadConfigurationActions,
  loadContextActions: () => loadContextActions,
  loadDateFacetSetActions: () => loadDateFacetSetActions,
  loadDebugActions: () => loadDebugActions,
  loadDictionaryFieldContextActions: () => loadDictionaryFieldContextActions,
  loadDidYouMeanActions: () => loadDidYouMeanActions,
  loadExcerptLengthActions: () => loadExcerptLengthActions,
  loadFacetOptionsActions: () => loadFacetOptionsActions,
  loadFacetSetActions: () => loadFacetSetActions,
  loadFieldActions: () => loadFieldActions,
  loadFoldingActions: () => loadFoldingActions,
  loadGeneratedAnswerActions: () => loadGeneratedAnswerActions,
  loadGenericAnalyticsActions: () => loadGenericAnalyticsActions,
  loadHistoryActions: () => loadHistoryActions,
  loadInstantResultsActions: () => loadInstantResultsActions,
  loadNumericFacetSetActions: () => loadNumericFacetSetActions,
  loadPaginationActions: () => loadPaginationActions,
  loadPipelineActions: () => loadPipelineActions,
  loadQueryActions: () => loadQueryActions,
  loadQuerySetActions: () => loadQuerySetActions,
  loadQuerySuggestActions: () => loadQuerySuggestActions,
  loadQuestionAnsweringActions: () => loadQuestionAnsweringActions,
  loadRecentQueriesActions: () => loadRecentQueriesActions,
  loadRecentResultsActions: () => loadRecentResultsActions,
  loadResultPreviewActions: () => loadResultPreviewActions,
  loadSearchActions: () => loadSearchActions,
  loadSearchAnalyticsActions: () => loadSearchAnalyticsActions,
  loadSearchConfigurationActions: () => loadSearchConfigurationActions,
  loadSearchHubActions: () => loadSearchHubActions,
  loadSortCriteriaActions: () => loadSortCriteriaActions,
  loadStandaloneSearchBoxSetActions: () => loadStandaloneSearchBoxSetActions,
  loadStaticFilterSetActions: () => loadStaticFilterSetActions,
  loadTabSetActions: () => loadTabSetActions,
  maxPageSelector: () => maxPageSelector,
  parseCriterionExpression: () => parseCriterionExpression,
  validateRelativeDate: () => validateRelativeDate
});
module.exports = __toCommonJS(ssr_index_exports);

// src/utils/fetch-event-source/parse.ts
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10 /* NewLine */) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58 /* Colon */:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case 13 /* CarriageReturn */:
            discardTrailingNewline = true;
            lineEnd = position;
            break;
          case 10 /* NewLine */:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage?.(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field2 = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field2) {
        case "data":
          message.data = message.data ? `${message.data}
${value}` : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          retry(value, message, onRetry);
          break;
      }
    }
  };
}
function retry(value, message, onRetry) {
  const retry4 = parseInt(value, 10);
  if (!Number.isNaN(retry4)) {
    onRetry(message.retry = retry4);
  }
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}

// src/utils/fetch-event-source/fetch.ts
var EventStreamContentType = "text/event-stream";
var DefaultRetryInterval = 1e3;
var LastEventId = "last-event-id";
function isBrowser() {
  return typeof window !== "undefined";
}
function fetchEventSource(input, {
  signal: inputSignal,
  headers: inputHeaders,
  onopen: inputOnOpen,
  onmessage,
  onclose,
  onerror,
  openWhenHidden,
  fetch: inputFetch,
  ...rest
}) {
  return new Promise((resolve, reject) => {
    const headers = { ...inputHeaders };
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController?.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden && isBrowser()) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer;
    function dispose() {
      if (isBrowser()) {
        document.removeEventListener("visibilitychange", onVisibilityChange);
      }
      clearTimeout(retryTimer);
      curRequestController?.abort();
    }
    inputSignal?.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const outputFetch = inputFetch ?? fetch;
    const onopen = inputOnOpen ?? defaultOnOpen;
    async function create() {
      curRequestController = AbortController ? new AbortController() : null;
      try {
        const response = await outputFetch(input, {
          ...rest,
          headers,
          signal: curRequestController?.signal
        });
        await onopen(response);
        await getBytes(
          response.body,
          getLines(
            getMessages(
              (id) => {
                if (id) {
                  headers[LastEventId] = id;
                } else {
                  delete headers[LastEventId];
                }
              },
              (retry4) => {
                retryInterval = retry4;
              },
              onmessage
            )
          )
        );
        onclose?.();
        dispose();
        resolve();
      } catch (err) {
        if (!curRequestController?.signal?.aborted) {
          try {
            const interval = onerror?.(err) ?? retryInterval;
            clearTimeout(retryTimer);
            retryTimer = setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType?.startsWith(EventStreamContentType)) {
    throw new Error(
      `Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`
    );
  }
}

// src/utils/url-utils.ts
var URLPath = class {
  constructor(basePath2) {
    __publicField(this, "_basePath");
    __publicField(this, "_params", {});
    this._basePath = basePath2;
  }
  addParam(name, value) {
    this._params = {
      ...this.params,
      [name]: value
    };
  }
  get basePath() {
    return this._basePath;
  }
  get params() {
    return this._params;
  }
  get hasParams() {
    return Object.entries(this._params).length;
  }
  get href() {
    return this.hasParams ? `${this.basePath}?${Object.entries(this.params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&")}` : this.basePath;
  }
};

// src/utils/utils.ts
var randomID = (prepend, length = 5) => prepend + Math.random().toString(36).substring(2, 2 + length);
function isArray(value) {
  return Array.isArray(value);
}
function isEmptyString(str) {
  return str.trim() === "";
}
function removeDuplicates(arr, predicate) {
  return [
    ...arr.reduce((map, item) => {
      const key = predicate(item);
      map.has(key) || map.set(key, item);
      return map;
    }, /* @__PURE__ */ new Map()).values()
  ];
}
function encodedBtoa(stringToEncode) {
  return btoa(encodeURI(stringToEncode));
}
function omit(key, obj) {
  const { [key]: _omitted, ...rest } = obj;
  return rest;
}
function getObjectHash(obj) {
  return encodedBtoa(JSON.stringify(obj));
}
var doNotTrackValues = /* @__PURE__ */ new Set(["1", 1, "yes", true]);
function doNotTrack() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  const nav = navigator;
  const win = window;
  return [
    nav.globalPrivacyControl,
    nav.doNotTrack,
    nav.msDoNotTrack,
    win.doNotTrack
  ].some((value) => doNotTrackValues.has(value));
}
function fromEntries(values) {
  const newObject = {};
  for (const [key, value] of values) {
    newObject[key] = value;
  }
  return newObject;
}
function resetTimeout(callback, timeoutId, ms) {
  clearTimeout(timeoutId);
  return setTimeout(callback, ms);
}
function mapObject(obj, predicate) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key,
      predicate(value, key)
    ])
  );
}
function clone(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (!value) {
    return value;
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (_) {
    return value;
  }
}
function createDeferredPromise() {
  let resolve = null;
  let reject = null;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return { promise, resolve, reject };
}
function createWaitForActionMiddleware(isDesiredAction) {
  const { promise, resolve } = createDeferredPromise();
  const middleware = () => (next) => (action) => {
    next(action);
    if (isDesiredAction(action)) {
      resolve(action);
    }
  };
  return { promise, middleware };
}
function debounce(func, wait, options = {}) {
  let timeoutId;
  return (...args) => {
    const shouldCallImmediately = options.isImmediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = void 0;
      if (!options.isImmediate) {
        func.apply(void 0, args);
      }
    }, wait);
    if (shouldCallImmediately) {
      return func.apply(void 0, args);
    }
  };
}

// src/api/generated-answer/generated-answer-client.ts
var buildStreamingUrl = (url, orgId, streamId) => new URLPath(
  `${url}/rest/organizations/${orgId}/machinelearning/streaming/${streamId}`
).href;
var MAX_RETRIES = 3;
var MAX_TIMEOUT = 5e3;
var EVENT_STREAM_CONTENT_TYPE = "text/event-stream";
var RETRYABLE_STREAM_ERROR_CODE = 1;
var RetryableError = class extends Error {
};
var FatalError = class extends Error {
  constructor(payload) {
    super(payload.message);
    this.payload = payload;
  }
};
var TimeoutStateManager = class {
  constructor() {
    __publicField(this, "timeouts", /* @__PURE__ */ new Set());
  }
  add(timeout) {
    this.timeouts.add(timeout);
  }
  remove(timeout) {
    clearTimeout(timeout);
    this.timeouts.delete(timeout);
  }
  isActive(timeout) {
    return this.timeouts.has(timeout);
  }
};
var GeneratedAnswerAPIClient = class {
  constructor(options) {
    __publicField(this, "logger");
    this.logger = options.logger;
  }
  streamGeneratedAnswer(params, callbacks) {
    const { url, organizationId, streamId, accessToken } = params;
    const { write, abort, close, resetAnswer: resetAnswer2 } = callbacks;
    const timeoutStateManager = new TimeoutStateManager();
    if (!streamId) {
      this.logger.error("No stream ID found");
      return;
    }
    let retryCount = 0;
    let timeout;
    const retryStream = () => {
      if (timeout && !timeoutStateManager.isActive(timeout)) {
        abortController?.abort();
        resetAnswer2();
        stream();
      }
    };
    const refreshTimeout = () => {
      timeoutStateManager.remove(timeout);
      timeout = resetTimeout(retryStream, timeout, MAX_TIMEOUT);
      timeoutStateManager.add(timeout);
    };
    const abortController = new AbortController();
    const stream = () => fetchEventSource(buildStreamingUrl(url, organizationId, streamId), {
      method: "GET",
      fetch,
      headers: {
        Authorization: `Bearer ${accessToken}`,
        accept: "*/*"
      },
      openWhenHidden: true,
      signal: abortController?.signal,
      async onopen(response) {
        if (response.ok && response.headers.get("content-type") === EVENT_STREAM_CONTENT_TYPE) {
          return;
        }
        const isClientSideError = response.status >= 400 && response.status < 500 && response.status !== 429;
        if (isClientSideError) {
          throw new FatalError({
            message: "Error opening stream",
            code: response.status
          });
        } else {
          throw new RetryableError();
        }
      },
      onmessage: (event) => {
        if (abortController?.signal.aborted) {
          return;
        }
        const data = JSON.parse(event.data);
        if (data.finishReason === "ERROR") {
          timeoutStateManager.remove(timeout);
          abortController?.abort();
          abort({
            message: data.errorMessage,
            code: data.statusCode
          });
          return;
        }
        write(data);
        retryCount = 0;
        if (data.finishReason === "COMPLETED") {
          timeoutStateManager.remove(timeout);
          close();
        } else {
          refreshTimeout();
        }
      },
      onerror: (err) => {
        if (abortController?.signal.aborted) {
          return;
        }
        timeoutStateManager.remove(timeout);
        if (err instanceof FatalError) {
          abortController?.abort();
          abort(err);
          throw err;
        }
        if (++retryCount > MAX_RETRIES) {
          this.logger.info("Maximum retry exceeded.");
          const error = {
            message: "Failed to complete stream.",
            code: RETRYABLE_STREAM_ERROR_CODE
          };
          abortController?.abort();
          abort(error);
          throw new FatalError(error);
        }
        this.logger.info(`Retrying...(${retryCount}/${MAX_RETRIES})`);
        resetAnswer2();
      }
    });
    stream();
    return abortController;
  }
};

// src/api/platform-client.ts
var import_exponential_backoff = require("exponential-backoff");

// src/utils/errors.ts
var loadReducerError = new Error("Failed to load reducers.");
var UnauthorizedTokenError = class extends Error {
  constructor() {
    super();
    this.name = "UnauthorizedTokenError";
    this.message = "The token being used to perform the request is unauthorized. It may be expired or invalid.";
  }
};
var DisconnectedError = class extends Error {
  constructor(url, statusCode) {
    super();
    __publicField(this, "statusCode");
    this.name = "Disconnected";
    this.message = `Client could not connect to the following URL: ${url}`;
    this.statusCode = statusCode ?? 0;
  }
};

// src/api/form-url-encoder.ts
function encodeAsFormUrl(obj) {
  const body = [];
  for (const property in obj) {
    const key = encodeURIComponent(property);
    const value = encodeURIComponent(obj[property]);
    body.push(`${key}=${value}`);
  }
  return body.join("&");
}
function canBeFormUrlEncoded(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (!obj) {
    return false;
  }
  return Object.values(obj).every(isPrimitive);
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}

// src/api/platform-client.ts
function isThrottled(status) {
  return status === 429;
}
var PlatformClient = class _PlatformClient {
  static async call(options) {
    const defaultRequestOptions = buildDefaultRequestOptions(options);
    const { logger } = options;
    const requestInfo = await _PlatformClient.preprocessRequest(
      defaultRequestOptions,
      options
    );
    logger.info(requestInfo, "Platform request");
    const { url, ...requestData } = requestInfo;
    const request = async () => {
      const response = await fetch(url, requestData);
      if (isThrottled(response.status)) {
        throw response;
      }
      return response;
    };
    try {
      const response = await (0, import_exponential_backoff.backOff)(request, {
        startingDelay: 100,
        timeMultiple: 2,
        maxDelay: 800,
        numOfAttempts: 4,
        jitter: "full",
        retry: async (e) => {
          const shouldRetry = e && isThrottled(e.status);
          if (shouldRetry) {
            logger.info("Platform retrying request");
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
          return shouldRetry;
        }
      });
      switch (response.status) {
        case 419:
        case 401:
          logger.info("Platform renewing token");
          throw new UnauthorizedTokenError();
        case 404:
          throw new DisconnectedError(url, response.status);
        default:
          logger.info({ response, requestInfo }, "Platform response");
          return response;
      }
    } catch (error) {
      if (error.message === "Failed to fetch") {
        return new DisconnectedError(url);
      }
      return error;
    }
  }
  static async preprocessRequest(defaultRequestOptions, options) {
    const { origin, preprocessRequest, logger, requestMetadata } = options;
    const { signal: _signal, ...withoutSignal } = defaultRequestOptions;
    const untaintedOutput = clone(withoutSignal);
    try {
      const processedRequest = await preprocessRequest(
        defaultRequestOptions,
        origin,
        requestMetadata
      );
      return {
        ...defaultRequestOptions,
        ...processedRequest
      };
    } catch (e) {
      logger.error(
        e,
        "Platform request preprocessing failed. Returning default request options."
      );
    }
    return untaintedOutput;
  }
};
function getOrganizationEndpoint(organizationId, environment = "prod", endpointType = "platform") {
  const environmentSuffix = environment === "prod" ? "" : environment;
  const endpointTypePart = endpointType === "platform" ? "" : `.${endpointType}`;
  return `https://${organizationId}${endpointTypePart}.org${environmentSuffix}.coveo.com`;
}
function getSearchApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(
    organizationId,
    environment
  );
  return `${organizationEndpoint}/rest/search/v2`;
}
function getAnalyticsNextApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(
    organizationId,
    environment,
    "analytics"
  );
  return `${organizationEndpoint}/rest/organizations/${organizationId}/events/v1`;
}
function buildDefaultRequestOptions(options) {
  const { url, method, requestParams, contentType, accessToken, signal } = options;
  const isMethodWithBody = options.method === "POST" || options.method === "PUT";
  const body = encodeBody(requestParams, contentType);
  return {
    url,
    method,
    headers: {
      "Content-Type": contentType,
      Authorization: `Bearer ${accessToken}`,
      ...options.headers
    },
    ...isMethodWithBody && { body },
    signal
  };
}
function encodeBody(body, contentType) {
  if (contentType === "application/x-www-form-urlencoded") {
    return canBeFormUrlEncoded(body) ? encodeAsFormUrl(body) : "";
  }
  return JSON.stringify(body);
}

// src/api/preprocess-request.ts
var NoopPreprocessRequest = (request) => request;

// src/api/search/search-api-client.ts
var import_bueno = require("@coveo/bueno");

// src/features/search/search-state.ts
function emptyQuestionAnswer() {
  return {
    answerSnippet: "",
    documentId: {
      contentIdKey: "",
      contentIdValue: ""
    },
    question: "",
    relatedQuestions: [],
    score: 0
  };
}
function getSearchInitialState() {
  return {
    response: {
      results: [],
      searchUid: "",
      totalCountFiltered: 0,
      facets: [],
      generateAutomaticFacets: { facets: [] },
      queryCorrections: [],
      triggers: [],
      questionAnswer: emptyQuestionAnswer(),
      pipeline: "",
      splitTestRun: "",
      termsToHighlight: {},
      phrasesToHighlight: {},
      extendedResults: {}
    },
    duration: 0,
    queryExecuted: "",
    error: null,
    automaticallyCorrected: false,
    isLoading: false,
    results: [],
    searchResponseId: "",
    requestId: "",
    questionAnswer: emptyQuestionAnswer(),
    extendedResults: {},
    searchAction: void 0
  };
}

// src/api/api-client-utils.ts
function pickNonBaseParams(req) {
  const {
    url: _url,
    accessToken: _accessToken,
    organizationId: _organizationId,
    authentication: _authentication,
    ...nonBase
  } = req;
  return nonBase;
}
var unwrapError = (payload) => {
  const { response } = payload;
  if (response.body) {
    return unwrapSearchApiError(payload);
  }
  return unwrapClientError(response);
};
var unwrapSearchApiError = (payload) => {
  if (isSearchAPIException(payload)) {
    return unwrapErrorByException(payload);
  }
  if (isSearchAPIErrorWithStatusCode(payload)) {
    return payload.body;
  }
  return { message: "unknown", statusCode: 0, type: "unknown" };
};
var unwrapClientError = (response) => {
  const body = JSON.parse(
    JSON.stringify(response, Object.getOwnPropertyNames(response))
  );
  return {
    ...body,
    message: `Client side error: ${body.message || ""}`,
    statusCode: 400,
    type: "ClientError"
  };
};
function isSearchAPIErrorWithStatusCode(r) {
  return r.body.statusCode !== void 0;
}
function isSearchAPIException(r) {
  return r.body.exception !== void 0;
}
var unwrapErrorByException = (res) => ({
  message: res.body.exception.code,
  statusCode: res.response.status,
  type: res.body.exception.code
});

// src/api/search/api-calls-queue.ts
var APICallsQueue = class {
  constructor() {
    __publicField(this, "currentAbortController", null);
  }
  /**
   * Enqueue an API call so that it can get cancelled if another call is enqueued before it finishes.
   */
  async enqueue(call, options) {
    const lastAbortController = this.currentAbortController;
    this.currentAbortController = new AbortController();
    const abortController = this.currentAbortController;
    if (lastAbortController) {
      if (options.warnOnAbort) {
        options.logger.warn("Cancelling current pending search query");
      }
      lastAbortController.abort();
    }
    try {
      return await call(abortController?.signal ?? null);
    } finally {
      if (this.currentAbortController === abortController) {
        this.currentAbortController = null;
      }
    }
  }
};

// src/api/search/encoding-finder.ts
function findEncoding(response) {
  const contentType = response.headers.get("content-type") || "";
  const charset = contentType.split(";").find((part) => part.indexOf("charset=") !== -1) || "";
  return charset.split("=")[1] || "UTF-8";
}

// src/api/search/search-api-params.ts
var baseSearchRequest = (req, method, contentType, path) => {
  const url = new URLPath(`${req.url}${path}`);
  url.addParam("organizationId", req.organizationId);
  if (req.authentication) {
    url.addParam("authentication", req.authentication);
  }
  return {
    accessToken: req.accessToken,
    method,
    contentType,
    url: url.href,
    origin: "searchApiFetch"
  };
};

// src/api/search/html/html-api-client.ts
var buildContentURL = (req, path) => {
  const url = new URLPath(`${req.url}${path}`);
  url.addParam("access_token", req.accessToken);
  url.addParam("organizationId", req.organizationId);
  url.addParam("uniqueId", req.uniqueId);
  if (req.authentication) {
    url.addParam("authentication", req.authentication);
  }
  if (req.q !== void 0) {
    url.addParam("q", req.q);
  }
  if (req.enableNavigation !== void 0) {
    url.addParam("enableNavigation", `${req.enableNavigation}`);
  }
  if (req.requestedOutputSize !== void 0) {
    url.addParam("requestedOutputSize", `${req.requestedOutputSize}`);
  }
  return url.href;
};
var getHtml = async (req, options) => {
  const response = await PlatformClient.call({
    ...baseSearchRequest(
      req,
      "POST",
      "application/x-www-form-urlencoded",
      "/html"
    ),
    requestParams: pickNonBaseParams(req),
    requestMetadata: { method: "html" },
    ...options
  });
  if (response instanceof Error) {
    throw response;
  }
  const encoding = findEncoding(response);
  const buffer = await response.arrayBuffer();
  const decoder = new TextDecoder(encoding);
  const body = decoder.decode(buffer);
  if (isSuccessHtmlResponse(body)) {
    return { success: body };
  }
  return { error: unwrapError({ response, body }) };
};
function isSuccessHtmlResponse(body) {
  return typeof body === "string";
}

// src/api/search/search-api-error-response.ts
function buildDisconnectedError(error) {
  return {
    statusCode: error.statusCode,
    type: error.name,
    message: error.message
  };
}
function buildIgnoredAbortedError(error) {
  return {
    statusCode: error.code,
    type: error.name,
    message: error.message,
    ignored: true
  };
}
function buildAPIResponseFromErrorOrThrow(error, disableAbortWarning) {
  if (disableAbortWarning && error.name === "AbortError") {
    return {
      error: buildIgnoredAbortedError(error)
    };
  }
  if (error instanceof DisconnectedError) {
    return { error: buildDisconnectedError(error) };
  }
  throw error;
}

// src/api/search/search-api-client.ts
var SearchAPIClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "apiCallsQueues", {
      unknown: new APICallsQueue(),
      mainSearch: new APICallsQueue(),
      facetValues: new APICallsQueue(),
      foldingCollection: new APICallsQueue(),
      instantResults: new APICallsQueue()
    });
  }
  async plan(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", "/plan"),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "plan" },
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    if (isSuccessPlanResponse(body)) {
      return { success: body };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
  async querySuggest(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", "/querySuggest"),
      requestMetadata: { method: "querySuggest" },
      requestParams: pickNonBaseParams(req),
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    const payload = { response, body };
    if (isSuccessQuerySuggestionsResponse(body)) {
      const processedResponse = await this.options.postprocessQuerySuggestResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError(payload)
    };
  }
  async search(req, options) {
    const origin = options?.origin ?? "unknown";
    const response = await this.apiCallsQueues[origin].enqueue(
      (signal) => PlatformClient.call({
        ...baseSearchRequest(req, "POST", "application/json", ""),
        requestParams: pickNonBaseParams(req),
        requestMetadata: { method: "search", origin: options?.origin },
        ...this.options,
        signal: signal ?? void 0
      }),
      { logger: this.options.logger, warnOnAbort: !options?.disableAbortWarning }
    );
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(
        response,
        options?.disableAbortWarning
      );
    }
    const body = await response.json();
    const payload = { response, body };
    if (isSuccessSearchResponse(body)) {
      payload.body = shimResponse(body);
      const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError(payload)
    };
  }
  async facetSearch(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", "/facet"),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "facetSearch" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    const payload = { response, body };
    const processedResponse = await this.options.postprocessFacetSearchResponseMiddleware(payload);
    return processedResponse.body;
  }
  async recommendations(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", ""),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "recommendations" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    if (isSuccessSearchResponse(body)) {
      const payload = { response, body };
      payload.body = shimResponse(body);
      const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
  async html(req) {
    return getHtml(req, { ...this.options });
  }
  async fieldDescriptions(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "GET", "application/json", "/fields"),
      requestParams: {},
      requestMetadata: { method: "fieldDescriptions" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    if (isSuccessFieldsDescriptionResponse(body)) {
      return { success: body };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
};
var isSuccessResponse = (r) => {
  return r.success !== void 0;
};
var isErrorResponse = (r) => {
  return r.error !== void 0;
};
function isSuccessSearchResponse(body) {
  return body.results !== void 0;
}
function shimResponse(response) {
  const empty = emptyQuestionAnswer();
  if ((0, import_bueno.isNullOrUndefined)(response.questionAnswer)) {
    response.questionAnswer = empty;
    return response;
  }
  response.questionAnswer = { ...empty, ...response.questionAnswer };
  return response;
}
function isSuccessQuerySuggestionsResponse(body) {
  return body.completions !== void 0;
}
function isSuccessPlanResponse(body) {
  return body.preprocessingOutput !== void 0;
}
function isSuccessFieldsDescriptionResponse(body) {
  return body.fields !== void 0;
}

// src/api/search/search-api-client-middleware.ts
var NoopPostprocessSearchResponseMiddleware = (response) => response;
var NoopPostprocessFacetSearchResponseMiddleware = (response) => response;
var NoopPostprocessQuerySuggestResponseMiddleware = (response) => response;

// src/utils/validate-payload.ts
var import_bueno2 = require("@coveo/bueno");
var requiredNonEmptyString = new import_bueno2.StringValue({
  required: true,
  emptyAllowed: false
});
var nonEmptyString = new import_bueno2.StringValue({
  required: false,
  emptyAllowed: false
});
var requiredEmptyAllowedString = new import_bueno2.StringValue({
  required: true,
  emptyAllowed: true
});
var nonRequiredEmptyAllowedString = new import_bueno2.StringValue({
  required: false,
  emptyAllowed: true
});
var nonEmptyStringArray = new import_bueno2.ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
var optionalNonEmptyVersionString = new import_bueno2.StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^\d+\.\d+\.\d+$/
});
var optionalTrackingId = new import_bueno2.StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var requiredTrackingId = new import_bueno2.StringValue({
  required: true,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var serializeSchemaValidationError = ({
  message,
  name,
  stack
}) => ({ message, name, stack });
var validatePayloadAndThrow = (payload, definition4) => {
  const isSchemaValue = "required" in definition4;
  if (isSchemaValue) {
    return {
      payload: new import_bueno2.Schema({
        value: definition4
      }).validate({ value: payload }).value
    };
  }
  const asRecordValue = new import_bueno2.RecordValue({
    options: { required: true },
    values: definition4
  });
  const isInvalid = asRecordValue.validate(payload);
  if (isInvalid) {
    throw new import_bueno2.SchemaValidationError(isInvalid);
  }
  return { payload };
};
var validatePayload = (payload, definition4) => {
  try {
    return validatePayloadAndThrow(payload, definition4);
  } catch (error) {
    return {
      payload,
      error: serializeSchemaValidationError(error)
    };
  }
};
var validateInitialState = (engine, schema, obj, functionName) => {
  const message = `Check the initialState of ${functionName}`;
  return validateObject(
    engine,
    schema,
    obj,
    message,
    "Controller initialization error"
  );
};
var validateOptions = (engine, schema, obj, functionName) => {
  const message = `Check the options of ${functionName}`;
  return validateObject(
    engine,
    schema,
    obj,
    message,
    "Controller initialization error"
  );
};
var validateObject = (engine, schema, obj, validationMessage, errorMessage) => {
  try {
    return schema.validate(obj, validationMessage);
  } catch (error) {
    engine.logger.error(error, errorMessage);
    throw error;
  }
};

// src/features/analytics/analytics-utils.ts
var import_bueno5 = require("@coveo/bueno");
var import_toolkit4 = require("@reduxjs/toolkit");

// src/api/analytics/analytics-relay-client.ts
var import_relay = require("@coveo/relay");
var import_toolkit2 = require("@reduxjs/toolkit");

// src/utils/runtime.ts
function isBrowser2() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}

// src/api/analytics/analytics-selectors.ts
var import_toolkit = require("@reduxjs/toolkit");

// src/utils/version.ts
var VERSION = "3.45.0";
var COVEO_FRAMEWORK = ["@coveo/atomic", "@coveo/quantic"];

// src/api/analytics/analytics-selectors.ts
var getAnalyticsSource = (0, import_toolkit.createSelector)(
  (state) => state.source,
  (source) => Object.entries(source).map(
    ([frameworkName, frameworkVersion]) => `${frameworkName}@${frameworkVersion}`
  ).concat(`@coveo/headless@${VERSION}`)
);

// src/api/analytics/analytics-relay-client.ts
var getRelayInstanceFromState = (0, import_toolkit2.createSelector)(
  (state) => state.configuration.organizationId,
  (state) => state.configuration.environment,
  (state) => state.configuration.accessToken,
  (state) => state.configuration.analytics,
  (state) => getAnalyticsSource(state.configuration.analytics),
  (_state, navigatorContextProvider) => navigatorContextProvider,
  (organizationId, platformEnvironment, token, { trackingId, apiBaseUrl, enabled }, source, navigatorContextProvider) => {
    const environment = getEnvironment(navigatorContextProvider);
    return (0, import_relay.createRelay)({
      mode: enabled ? "emit" : "disabled",
      url: apiBaseUrl ?? getAnalyticsNextApiBaseUrl(organizationId, platformEnvironment),
      token,
      trackingId: trackingId ?? null,
      source,
      environment
    });
  }
);
var noopRelayEnvironment = {
  generateUUID: () => "",
  getLocation: () => null,
  getReferrer: () => null,
  getUserAgent: () => null,
  send: () => {
  },
  storage: {
    getItem: () => null,
    setItem: () => {
    },
    removeItem: () => {
    }
  }
};
var getEnvironment = (customProvider) => {
  if (!customProvider) {
    return void 0;
  }
  const customContext = customProvider();
  const baseEnvironment = isBrowser2() ? (0, import_relay.buildBrowserEnvironment)() : noopRelayEnvironment;
  return {
    ...baseEnvironment,
    generateUUID: () => customContext.clientId,
    getLocation: () => customContext.location,
    getReferrer: () => customContext.referrer,
    getUserAgent: () => customContext.userAgent
  };
};

// ../../node_modules/.pnpm/coveo.analytics@2.30.52_encoding@0.1.13_react-native@0.83.1_@babel+core@7.28.6_@types+react@19.2.7_react@19.2.3_/node_modules/coveo.analytics/dist/browser.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var EventType;
(function(EventType2) {
  EventType2["search"] = "search";
  EventType2["click"] = "click";
  EventType2["custom"] = "custom";
  EventType2["view"] = "view";
  EventType2["collect"] = "collect";
})(EventType || (EventType = {}));
function hasWindow() {
  return typeof window !== "undefined";
}
function hasNavigator() {
  return typeof navigator !== "undefined";
}
function hasDocument() {
  return typeof document !== "undefined";
}
function hasLocalStorage() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage() {
  return hasNavigator() && navigator.cookieEnabled;
}
var eventTypesForDefaultValues = [EventType.click, EventType.custom, EventType.search, EventType.view];
var addDefaultValues = (eventType, payload) => {
  return eventTypesForDefaultValues.indexOf(eventType) !== -1 ? Object.assign({ language: hasDocument() ? document.documentElement.lang : "unknown", userAgent: hasNavigator() ? navigator.userAgent : "unknown" }, payload) : payload;
};
var Cookie = class _Cookie {
  static set(name, value, expire) {
    var domain, expirationDate, domainParts, host;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    host = window.location.hostname;
    if (host.indexOf(".") === -1) {
      writeCookie(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    var cookiePrefix = name + "=";
    var cookieArray = document.cookie.split(";");
    for (var i = 0; i < cookieArray.length; i++) {
      var cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}
function getAvailableStorage() {
  if (hasLocalStorage()) {
    return localStorage;
  }
  if (hasCookieStorage()) {
    return new CookieStorage();
  }
  if (hasSessionStorage()) {
    return sessionStorage;
  }
  return new NullStorage();
}
var CookieStorage = class _CookieStorage2 {
  getItem(key) {
    return Cookie.get(`${_CookieStorage2.prefix}${key}`);
  }
  removeItem(key) {
    Cookie.erase(`${_CookieStorage2.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie.set(`${_CookieStorage2.prefix}${key}`, data, expire);
  }
};
CookieStorage.prefix = "coveo_";
var CookieAndLocalStorage = class {
  constructor() {
    this.cookieStorage = new CookieStorage();
  }
  getItem(key) {
    return localStorage.getItem(key) || this.cookieStorage.getItem(key);
  }
  removeItem(key) {
    this.cookieStorage.removeItem(key);
    localStorage.removeItem(key);
  }
  setItem(key, data) {
    localStorage.setItem(key, data);
    this.cookieStorage.setItem(key, data, 31556926e3);
  }
};
var NullStorage = class {
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, data) {
  }
};
var STORE_KEY = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE = 1e3 * 60;
var MAX_VALUE_SIZE = 75;
var HistoryStore = class {
  constructor(store) {
    this.store = store || getAvailableStorage();
  }
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    let currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory != null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  addElementAsync(elem) {
    return __awaiter(this, void 0, void 0, function* () {
      elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
      elem = this.cropQueryElement(this.stripEmptyQuery(elem));
      let currentHistory = yield this.getHistoryWithInternalTimeAsync();
      if (currentHistory != null) {
        if (this.isValidEntry(elem)) {
          this.setHistory([elem].concat(currentHistory));
        }
      } else {
        this.setHistory([elem]);
      }
    });
  }
  getHistory() {
    const history2 = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history2));
  }
  getHistoryAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      const history2 = yield this.getHistoryWithInternalTimeAsync();
      return this.stripEmptyQueries(this.stripInternalTime(history2));
    });
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  getHistoryWithInternalTimeAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const elements = yield this.store.getItem(STORE_KEY);
        if (elements) {
          return JSON.parse(elements);
        } else {
          return [];
        }
      } catch (e) {
        return [];
      }
    });
  }
  setHistory(history2) {
    try {
      this.store.setItem(STORE_KEY, JSON.stringify(history2.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    let currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE);
    }
    return part;
  }
  isValidEntry(elem) {
    let lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value == elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE;
    }
    return true;
  }
  stripInternalTime(history2) {
    if (Array.isArray(history2)) {
      return history2.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history2) {
    return history2.map((part) => this.stripEmptyQuery(part));
  }
};
var enhanceViewEvent = (eventType, payload) => __awaiter(void 0, void 0, void 0, function* () {
  if (eventType === EventType.view) {
    yield addPageViewToHistory(payload.contentIdValue);
    return Object.assign({ location: window.location.toString(), referrer: document.referrer, title: document.title }, payload);
  }
  return payload;
});
var addPageViewToHistory = (pageViewValue) => __awaiter(void 0, void 0, void 0, function* () {
  const store = new HistoryStore();
  const historyElement = {
    name: "PageView",
    value: pageViewValue,
    time: (/* @__PURE__ */ new Date()).toISOString()
  };
  yield store.addElementAsync(historyElement);
});
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var v5 = v35("v5", 80, sha1);
var uuidv5 = v5;
var libVersion = "2.30.52";
var getFormattedLocation = (location) => `${location.protocol}//${location.hostname}${location.pathname.indexOf("/") === 0 ? location.pathname : `/${location.pathname}`}${location.search}`;
var BasePluginEventTypes = {
  pageview: "pageview",
  event: "event"
};
var Plugin = class {
  constructor({ client, uuidGenerator = v4 }) {
    this.client = client;
    this.uuidGenerator = uuidGenerator;
  }
};
var BasePlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
    this.actionData = {};
    this.pageViewId = uuidGenerator();
    this.nextPageViewId = this.pageViewId;
    this.currentLocation = getFormattedLocation(window.location);
    this.lastReferrer = hasDocument() ? document.referrer : "";
    this.addHooks();
  }
  getApi(name) {
    switch (name) {
      case "setAction":
        return this.setAction;
      default:
        return null;
    }
  }
  setAction(action, options) {
    this.action = action;
    this.actionData = options;
  }
  clearData() {
    this.clearPluginData();
    this.action = void 0;
    this.actionData = {};
  }
  getLocationInformation(eventType, payload) {
    return Object.assign({ hitType: eventType }, this.getNextValues(eventType, payload));
  }
  updateLocationInformation(eventType, payload) {
    this.updateLocationForNextPageView(eventType, payload);
  }
  getDefaultContextInformation(eventType) {
    const documentContext = {
      title: hasDocument() ? document.title : "",
      encoding: hasDocument() ? document.characterSet : "UTF-8"
    };
    const screenContext = {
      screenResolution: `${screen.width}x${screen.height}`,
      screenColor: `${screen.colorDepth}-bit`
    };
    const navigatorContext = {
      language: navigator.language,
      userAgent: navigator.userAgent
    };
    const eventContext = {
      time: Date.now(),
      eventId: this.uuidGenerator()
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, eventContext), screenContext), navigatorContext), documentContext);
  }
  updateLocationForNextPageView(eventType, payload) {
    const { pageViewId, referrer, location } = this.getNextValues(eventType, payload);
    this.lastReferrer = referrer;
    this.pageViewId = pageViewId;
    this.currentLocation = location;
    if (eventType === BasePluginEventTypes.pageview) {
      this.nextPageViewId = this.uuidGenerator();
      this.hasSentFirstPageView = true;
    }
  }
  getNextValues(eventType, payload) {
    return {
      pageViewId: eventType === BasePluginEventTypes.pageview ? this.nextPageViewId : this.pageViewId,
      referrer: eventType === BasePluginEventTypes.pageview && this.hasSentFirstPageView ? this.currentLocation : this.lastReferrer,
      location: eventType === BasePluginEventTypes.pageview ? this.getCurrentLocationFromPayload(payload) : this.currentLocation
    };
  }
  getCurrentLocationFromPayload(payload) {
    if (!!payload.page) {
      const removeStartingSlash = (page) => page.replace(/^\/?(.*)$/, "/$1");
      const extractHostnamePart = (location) => location.split("/").slice(0, 3).join("/");
      return `${extractHostnamePart(this.currentLocation)}${removeStartingSlash(payload.page)}`;
    } else {
      return getFormattedLocation(window.location);
    }
  }
};
var CoveoLinkParam = class _CoveoLinkParam {
  constructor(clientId, timestamp) {
    if (!validate(clientId))
      throw Error("Not a valid uuid");
    this.clientId = clientId;
    this.creationDate = Math.floor(timestamp / 1e3);
  }
  toString() {
    return this.clientId.replace(/-/g, "") + "." + this.creationDate.toString();
  }
  get expired() {
    const age = Math.floor(Date.now() / 1e3) - this.creationDate;
    return age < 0 || age > _CoveoLinkParam.expirationTime;
  }
  validate(referrerString, referrerList) {
    return !this.expired && this.matchReferrer(referrerString, referrerList);
  }
  matchReferrer(referrerString, referrerList) {
    try {
      const url = new URL(referrerString);
      return referrerList.some((value) => {
        const hostRegExp = new RegExp(value.replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*") + "$");
        return hostRegExp.test(url.host);
      });
    } catch (error) {
      return false;
    }
  }
  static fromString(input) {
    const parts = input.split(".");
    if (parts.length !== 2) {
      return null;
    }
    const [clientIdPart, creationDate] = parts;
    if (clientIdPart.length !== 32 || isNaN(parseInt(creationDate))) {
      return null;
    }
    const clientId = clientIdPart.substring(0, 8) + "-" + clientIdPart.substring(8, 12) + "-" + clientIdPart.substring(12, 16) + "-" + clientIdPart.substring(16, 20) + "-" + clientIdPart.substring(20, 32);
    if (validate(clientId)) {
      return new _CoveoLinkParam(clientId, Number.parseInt(creationDate) * 1e3);
    } else {
      return null;
    }
  }
};
CoveoLinkParam.cvo_cid = "cvo_cid";
CoveoLinkParam.expirationTime = 120;
var LinkPlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
  }
  getApi(name) {
    switch (name) {
      case "decorate":
        return this.decorate;
      case "acceptFrom":
        return this.acceptFrom;
      default:
        return null;
    }
  }
  decorate(urlString) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.client.getCurrentVisitorId) {
        throw new Error("Could not retrieve current clientId");
      }
      try {
        const url = new URL(urlString);
        const clientId = yield this.client.getCurrentVisitorId();
        url.searchParams.set(CoveoLinkParam.cvo_cid, new CoveoLinkParam(clientId, Date.now()).toString());
        return url.toString();
      } catch (error) {
        throw new Error("Invalid URL provided");
      }
    });
  }
  acceptFrom(acceptedReferrers) {
    this.client.setAcceptedLinkReferrers(acceptedReferrers);
  }
};
LinkPlugin.Id = "link";
var keysOf = Object.keys;
function isObject(o) {
  return o !== null && typeof o === "object" && !Array.isArray(o);
}
var UTF8_HIGH_BIT = 128;
var UTF8_HEADER_2 = 192;
var UTF8_HEADER_3 = 224;
var UTF8_HEADER_4 = 240;
function utf8ByteCountFromFirstByte(firstByte) {
  if ((firstByte & 248) === UTF8_HEADER_4) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_4) === UTF8_HEADER_3) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_3) === UTF8_HEADER_2) {
    return 2;
  }
  return 1;
}
function truncateUrl(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT) != UTF8_HIGH_BIT) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_2) != UTF8_HIGH_BIT) {
      if (limit - end >= utf8ByteCountFromFirstByte(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
var ticketKeysMapping = {
  id: "svc_ticket_id",
  subject: "svc_ticket_subject",
  description: "svc_ticket_description",
  category: "svc_ticket_category",
  productId: "svc_ticket_product_id",
  custom: "svc_ticket_custom"
};
var ticketKeysMappingValues = keysOf(ticketKeysMapping).map((key) => ticketKeysMapping[key]);
var ticketSubKeysMatchGroup = [...ticketKeysMappingValues].join("|");
var ticketKeyRegex = new RegExp(`^(${ticketSubKeysMatchGroup}$)`);
var serviceActionsKeysMapping = {
  svcAction: "svc_action",
  svcActionData: "svc_action_data"
};
var convertTicketToMeasurementProtocol = (ticket) => {
  return keysOf(ticket).filter((key) => ticket[key] !== void 0).reduce((mappedTicket, key) => {
    const newKey = ticketKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedTicket), { [newKey]: ticket[key] });
  }, {});
};
var isTicketKey = (key) => ticketKeyRegex.test(key);
var isServiceKey = [isTicketKey];
var productKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  price: "pr",
  quantity: "qt",
  coupon: "cc",
  position: "ps",
  group: "group"
};
var impressionKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  position: "ps",
  price: "pr",
  group: "group"
};
var productActionsKeysMapping = {
  action: "pa",
  list: "pal",
  listSource: "pls"
};
var transactionActionsKeysMapping = {
  id: "ti",
  revenue: "tr",
  tax: "tt",
  shipping: "ts",
  coupon: "tcc",
  affiliation: "ta",
  step: "cos",
  option: "col"
};
var coveoCommerceExtensionKeys = [
  "loyaltyCardId",
  "loyaltyTier",
  "thirdPartyPersona",
  "companyName",
  "favoriteStore",
  "storeName",
  "userIndustry",
  "userRole",
  "userDepartment",
  "businessUnit"
];
var quoteActionsKeysMapping = {
  id: "quoteId",
  affiliation: "quoteAffiliation"
};
var reviewActionsKeysMapping = {
  id: "reviewId",
  rating: "reviewRating",
  comment: "reviewComment"
};
var commerceActionKeysMappingPerAction = {
  add: productActionsKeysMapping,
  bookmark_add: productActionsKeysMapping,
  bookmark_remove: productActionsKeysMapping,
  click: productActionsKeysMapping,
  checkout: productActionsKeysMapping,
  checkout_option: productActionsKeysMapping,
  detail: productActionsKeysMapping,
  impression: productActionsKeysMapping,
  remove: productActionsKeysMapping,
  refund: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  purchase: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  quickview: productActionsKeysMapping,
  quote: Object.assign(Object.assign({}, productActionsKeysMapping), quoteActionsKeysMapping),
  review: Object.assign(Object.assign({}, productActionsKeysMapping), reviewActionsKeysMapping)
};
var productKeysMappingValues = keysOf(productKeysMapping).map((key) => productKeysMapping[key]);
var impressionKeysMappingValues = keysOf(impressionKeysMapping).map((key) => impressionKeysMapping[key]);
var productActionsKeysMappingValues = keysOf(productActionsKeysMapping).map((key) => productActionsKeysMapping[key]);
var transactionActionsKeysMappingValues = keysOf(transactionActionsKeysMapping).map((key) => transactionActionsKeysMapping[key]);
var reviewKeysMappingValues = keysOf(reviewActionsKeysMapping).map((key) => reviewActionsKeysMapping[key]);
var quoteKeysMappingValues = keysOf(quoteActionsKeysMapping).map((key) => quoteActionsKeysMapping[key]);
var productSubKeysMatchGroup = [...productKeysMappingValues, "custom"].join("|");
var impressionSubKeysMatchGroup = [...impressionKeysMappingValues, "custom"].join("|");
var productPrefixMatchGroup = "(pr[0-9]+)";
var impressionPrefixMatchGroup = "(il[0-9]+pi[0-9]+)";
var productKeyRegex = new RegExp(`^${productPrefixMatchGroup}(${productSubKeysMatchGroup})$`);
var impressionKeyRegex = new RegExp(`^(${impressionPrefixMatchGroup}(${impressionSubKeysMatchGroup}))|(il[0-9]+nm)$`);
var productActionsKeyRegex = new RegExp(`^(${productActionsKeysMappingValues.join("|")})$`);
var transactionActionsKeyRegex = new RegExp(`^(${transactionActionsKeysMappingValues.join("|")})$`);
var customProductKeyRegex = new RegExp(`^${productPrefixMatchGroup}custom$`);
var customImpressionKeyRegex = new RegExp(`^${impressionPrefixMatchGroup}custom$`);
var coveoCommerceExtensionKeysRegex = new RegExp(`^(${[...coveoCommerceExtensionKeys, ...reviewKeysMappingValues, ...quoteKeysMappingValues].join("|")})$`);
var isProductKey = (key) => productKeyRegex.test(key);
var isImpressionKey = (key) => impressionKeyRegex.test(key);
var isProductActionsKey = (key) => productActionsKeyRegex.test(key);
var isTransactionActionsKeyRegex = (key) => transactionActionsKeyRegex.test(key);
var isCoveoCommerceExtensionKey = (key) => coveoCommerceExtensionKeysRegex.test(key);
var isCommerceKey = [
  isImpressionKey,
  isProductKey,
  isProductActionsKey,
  isTransactionActionsKeyRegex,
  isCoveoCommerceExtensionKey
];
var isCustomCommerceKey = [customProductKeyRegex, customImpressionKeyRegex];
var globalParamKeysMapping = {
  anonymizeIp: "aip"
};
var eventKeysMapping = {
  eventCategory: "ec",
  eventAction: "ea",
  eventLabel: "el",
  eventValue: "ev",
  page: "dp",
  visitorId: "cid",
  clientId: "cid",
  userId: "uid",
  currencyCode: "cu"
};
var contextInformationMapping = {
  hitType: "t",
  pageViewId: "pid",
  encoding: "de",
  location: "dl",
  referrer: "dr",
  screenColor: "sd",
  screenResolution: "sr",
  title: "dt",
  userAgent: "ua",
  language: "ul",
  eventId: "z",
  time: "tm"
};
var coveoExtensionsKeys = [
  "contentId",
  "contentIdKey",
  "contentType",
  "searchHub",
  "tab",
  "searchUid",
  "permanentId",
  "contentLocale",
  "trackingId"
];
var baseMeasurementProtocolKeysMapping = Object.assign(Object.assign(Object.assign(Object.assign({}, globalParamKeysMapping), eventKeysMapping), contextInformationMapping), coveoExtensionsKeys.reduce((all, key) => Object.assign(Object.assign({}, all), { [key]: key }), {}));
var measurementProtocolKeysMapping = Object.assign(Object.assign({}, baseMeasurementProtocolKeysMapping), serviceActionsKeysMapping);
var convertKeysToMeasurementProtocol = (params) => {
  const keysMappingForAction = !!params.action && commerceActionKeysMappingPerAction[params.action] || {};
  return keysOf(params).reduce((mappedKeys, key) => {
    const newKey = keysMappingForAction[key] || measurementProtocolKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedKeys), { [newKey]: params[key] });
  }, {});
};
var measurementProtocolKeysMappingValues = keysOf(measurementProtocolKeysMapping).map((key) => measurementProtocolKeysMapping[key]);
var isKnownMeasurementProtocolKey = (key) => measurementProtocolKeysMappingValues.indexOf(key) !== -1;
var isCustomKey = (key) => key === "custom";
var isMeasurementProtocolKey = (key) => {
  return [...isCommerceKey, ...isServiceKey, isKnownMeasurementProtocolKey, isCustomKey].some((test) => test(key));
};
var convertCustomMeasurementProtocolKeys = (data) => {
  return keysOf(data).reduce((all, current) => {
    const match = getFirstCustomMeasurementProtocolKeyMatch(current);
    if (match) {
      return Object.assign(Object.assign({}, all), convertCustomObject(match, data[current]));
    } else {
      return Object.assign(Object.assign({}, all), { [current]: data[current] });
    }
  }, {});
};
var getFirstCustomMeasurementProtocolKeyMatch = (key) => {
  let matchedKey = void 0;
  [...isCustomCommerceKey].every((regex) => {
    var _a;
    matchedKey = (_a = regex.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
    return !Boolean(matchedKey);
  });
  return matchedKey;
};
var convertCustomObject = (prefix, customData) => {
  return keysOf(customData).reduce((allCustom, currentCustomKey) => Object.assign(Object.assign({}, allCustom), { [`${prefix}${currentCustomKey}`]: customData[currentCustomKey] }), {});
};
var AnalyticsBeaconClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, originalPayload) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isAvailable()) {
        throw new Error(`navigator.sendBeacon is not supported in this browser. Consider adding a polyfill like "sendbeacon-polyfill".`);
      }
      const { baseUrl, preprocessRequest } = this.opts;
      const paramsFragments = yield this.getQueryParamsForEventType(eventType);
      const { url, payload } = yield this.preProcessRequestAsPotentialJSONString(`${baseUrl}/analytics/${eventType}?${paramsFragments}`, originalPayload, preprocessRequest);
      const parsedRequestData = this.encodeForEventType(eventType, payload);
      const body = new Blob([parsedRequestData], {
        type: "application/x-www-form-urlencoded"
      });
      navigator.sendBeacon(url, body);
      return;
    });
  }
  isAvailable() {
    return "sendBeacon" in navigator;
  }
  deleteHttpCookieVisitorId() {
    return Promise.resolve();
  }
  preProcessRequestAsPotentialJSONString(originalURL, originalPayload, preprocessRequest) {
    return __awaiter(this, void 0, void 0, function* () {
      let returnedUrl = originalURL;
      let returnedPayload = originalPayload;
      if (preprocessRequest) {
        const processedRequest = yield preprocessRequest({ url: originalURL, body: JSON.stringify(originalPayload) }, "analyticsBeacon");
        const { url: processedURL, body: processedBody } = processedRequest;
        returnedUrl = processedURL || originalURL;
        try {
          returnedPayload = JSON.parse(processedBody);
        } catch (e) {
          console.error("Unable to process the request body as a JSON string", e);
        }
      }
      return {
        payload: returnedPayload,
        url: returnedUrl
      };
    });
  }
  encodeForEventType(eventType, payload) {
    return this.isEventTypeLegacy(eventType) ? this.encodeEventToJson(eventType, payload) : this.encodeEventToJson(eventType, payload, this.opts.token);
  }
  getQueryParamsForEventType(eventType) {
    return __awaiter(this, void 0, void 0, function* () {
      const { token, visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return [
        token && this.isEventTypeLegacy(eventType) ? `access_token=${token}` : "",
        visitorId ? `visitorId=${visitorId}` : "",
        "discardVisitInfo=true"
      ].filter((p) => !!p).join("&");
    });
  }
  isEventTypeLegacy(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  encodeEventToJson(eventType, payload, access_token) {
    let encoded = `${eventType}Event=${encodeURIComponent(JSON.stringify(payload))}`;
    if (access_token) {
      encoded = `access_token=${encodeURIComponent(access_token)}&${encoded}`;
    }
    return encoded;
  }
};
var NoopAnalyticsClient = class {
  sendEvent(_, __) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
};
var fetch$1 = globalThis.fetch;
var AnalyticsFetchClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl, visitorIdProvider, preprocessRequest } = this.opts;
      const visitorIdParam = this.shouldAppendVisitorId(eventType) ? yield this.getVisitorIdParam() : "";
      const defaultOptions = {
        url: `${baseUrl}/analytics/${eventType}${visitorIdParam}`,
        credentials: "include",
        mode: "cors",
        headers: this.getHeaders(),
        method: "POST",
        body: JSON.stringify(payload)
      };
      const _a = Object.assign(Object.assign({}, defaultOptions), preprocessRequest ? yield preprocessRequest(defaultOptions, "analyticsFetch") : {}), { url } = _a, fetchData = __rest(_a, ["url"]);
      let response;
      try {
        response = yield fetch$1(url, fetchData);
      } catch (error) {
        console.error("An error has occured when sending the event.", error);
        return;
      }
      if (response.ok) {
        const visit = yield response.json();
        if (visit.visitorId) {
          visitorIdProvider.setCurrentVisitorId(visit.visitorId);
        }
        return visit;
      } else {
        try {
          response.json();
        } catch (_b) {
        }
        console.error(`An error has occured when sending the "${eventType}" event.`, response, payload);
        throw new Error(`An error has occurred when sending the "${eventType}" event. Check the console logs for more details.`);
      }
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl } = this.opts;
      const url = `${baseUrl}/analytics/visit`;
      yield fetch$1(url, { headers: this.getHeaders(), method: "DELETE" });
    });
  }
  shouldAppendVisitorId(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  getVisitorIdParam() {
    return __awaiter(this, void 0, void 0, function* () {
      const { visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return visitorId ? `?visitor=${visitorId}` : "";
    });
  }
  getHeaders() {
    const { token } = this.opts;
    return Object.assign(Object.assign({}, token ? { Authorization: `Bearer ${token}` } : {}), { "Content-Type": `application/json` });
  }
};
var BrowserRuntime = class {
  constructor(clientOptions, getUnprocessedRequests) {
    if (hasLocalStorage() && hasCookieStorage()) {
      this.storage = new CookieAndLocalStorage();
    } else if (hasLocalStorage()) {
      this.storage = localStorage;
    } else {
      console.warn("BrowserRuntime detected no valid storage available.", this);
      this.storage = new NullStorage();
    }
    this.client = new AnalyticsFetchClient(clientOptions);
    this.beaconClient = new AnalyticsBeaconClient(clientOptions);
    window.addEventListener("beforeunload", () => {
      const requests = getUnprocessedRequests();
      for (let { eventType, payload } of requests) {
        this.beaconClient.sendEvent(eventType, payload);
      }
    });
  }
  getClientDependingOnEventType(eventType) {
    return eventType === "click" && this.beaconClient.isAvailable() ? this.beaconClient : this.client;
  }
};
var NodeJSRuntime = class {
  constructor(clientOptions, storage) {
    this.storage = storage || new NullStorage();
    this.client = new AnalyticsFetchClient(clientOptions);
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var NoopRuntime = class {
  constructor() {
    this.storage = new NullStorage();
    this.client = new NoopAnalyticsClient();
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var API_KEY_PREFIX = "xx";
var isApiKey = (token) => (token === null || token === void 0 ? void 0 : token.startsWith(API_KEY_PREFIX)) || false;
var ReactNativeRuntimeWarning = `
        We've detected you're using React Native but have not provided the corresponding runtime, 
        for an optimal experience please use the "coveo.analytics/react-native" subpackage.
        Follow the Readme on how to set it up: https://github.com/coveo/coveo.analytics.js#using-react-native
    `;
function isReactNative() {
  return typeof navigator != "undefined" && navigator.product == "ReactNative";
}
var doNotTrackValues2 = ["1", 1, "yes", true];
function doNotTrack2() {
  const checks = [];
  if (hasWindow()) {
    checks.push(window.doNotTrack);
  }
  if (hasNavigator()) {
    checks.push(navigator.doNotTrack, navigator.msDoNotTrack, navigator.globalPrivacyControl);
  }
  return checks.some((value) => doNotTrackValues2.indexOf(value) !== -1);
}
var Version = "v15";
var Endpoints = {
  default: "https://analytics.cloud.coveo.com/rest/ua",
  production: "https://analytics.cloud.coveo.com/rest/ua",
  hipaa: "https://analyticshipaa.cloud.coveo.com/rest/ua"
};
function buildBaseUrl(endpoint = Endpoints.default, apiVersion = Version, isCustomEndpoint = false) {
  endpoint = endpoint.replace(/\/$/, "");
  if (isCustomEndpoint) {
    return `${endpoint}/${apiVersion}`;
  }
  const hasUARestEndpoint = endpoint.endsWith("/rest") || endpoint.endsWith("/rest/ua");
  return `${endpoint}${hasUARestEndpoint ? "" : "/rest"}/${apiVersion}`;
}
var COVEO_NAMESPACE = "38824e1f-37f5-42d3-8372-a4b8fa9df946";
var CoveoAnalyticsClient = class {
  get defaultOptions() {
    return {
      endpoint: Endpoints.default,
      isCustomEndpoint: false,
      token: "",
      version: Version,
      beforeSendHooks: [],
      afterSendHooks: []
    };
  }
  get version() {
    return libVersion;
  }
  constructor(opts) {
    this.acceptedLinkReferrers = [];
    if (!opts) {
      throw new Error("You have to pass options to this constructor");
    }
    this.options = Object.assign(Object.assign({}, this.defaultOptions), opts);
    this.visitorId = "";
    this.bufferedRequests = [];
    this.beforeSendHooks = [enhanceViewEvent, addDefaultValues].concat(this.options.beforeSendHooks);
    this.afterSendHooks = this.options.afterSendHooks;
    this.eventTypeMapping = {};
    const clientsOptions = {
      baseUrl: this.baseUrl,
      token: this.options.token,
      visitorIdProvider: this,
      preprocessRequest: this.options.preprocessRequest
    };
    if (doNotTrack2()) {
      this.runtime = new NoopRuntime();
    } else {
      this.runtime = this.options.runtimeEnvironment || this.initRuntime(clientsOptions);
    }
    this.addEventTypeMapping(EventType.view, { newEventType: EventType.view, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.click, { newEventType: EventType.click, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.custom, { newEventType: EventType.custom, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.search, { newEventType: EventType.search, addClientIdParameter: true });
  }
  initRuntime(clientsOptions) {
    if (hasWindow() && hasDocument()) {
      return new BrowserRuntime(clientsOptions, () => {
        const copy = [...this.bufferedRequests];
        this.bufferedRequests = [];
        return copy;
      });
    } else if (isReactNative()) {
      console.warn(ReactNativeRuntimeWarning);
    }
    return new NodeJSRuntime(clientsOptions);
  }
  get storage() {
    return this.runtime.storage;
  }
  determineVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return hasWindow() && this.extractClientIdFromLink(window.location.href) || (yield this.storage.getItem("visitorId")) || v4();
      } catch (err) {
        console.log("Could not get visitor ID from the current runtime environment storage. Using a random ID instead.", err);
        return v4();
      }
    });
  }
  getCurrentVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.visitorId) {
        const id = yield this.determineVisitorId();
        yield this.setCurrentVisitorId(id);
      }
      return this.visitorId;
    });
  }
  setCurrentVisitorId(visitorId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.visitorId = visitorId;
      yield this.storage.setItem("visitorId", visitorId);
    });
  }
  setClientId(value, namespace) {
    return __awaiter(this, void 0, void 0, function* () {
      if (validate(value)) {
        this.setCurrentVisitorId(value.toLowerCase());
      } else {
        if (!namespace) {
          throw Error("Cannot generate uuid client id without a specific namespace string.");
        }
        this.setCurrentVisitorId(uuidv5(value, uuidv5(namespace, COVEO_NAMESPACE)));
      }
    });
  }
  getParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.resolveParameters(eventType, ...payload);
    });
  }
  getPayload(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      return yield this.resolvePayloadForParameters(eventType, parametersToSend);
    });
  }
  get currentVisitorId() {
    const visitorId = this.visitorId || this.storage.getItem("visitorId");
    if (typeof visitorId !== "string") {
      this.setCurrentVisitorId(v4());
    }
    return this.visitorId;
  }
  set currentVisitorId(visitorId) {
    this.visitorId = visitorId;
    this.storage.setItem("visitorId", visitorId);
  }
  extractClientIdFromLink(urlString) {
    if (doNotTrack2()) {
      return null;
    }
    try {
      const linkParam = new URL(urlString).searchParams.get(CoveoLinkParam.cvo_cid);
      if (linkParam == null) {
        return null;
      }
      const linker = CoveoLinkParam.fromString(linkParam);
      if (!linker || !hasDocument() || !linker.validate(document.referrer, this.acceptedLinkReferrers)) {
        return null;
      }
      return linker.clientId;
    } catch (error) {
    }
    return null;
  }
  resolveParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { variableLengthArgumentsNames = [], addVisitorIdParameter = false, usesMeasurementProtocol = false, addClientIdParameter = false } = this.eventTypeMapping[eventType] || {};
      const processVariableArgumentNamesStep = (currentPayload) => variableLengthArgumentsNames.length > 0 ? this.parseVariableArgumentsPayload(variableLengthArgumentsNames, currentPayload) : currentPayload[0];
      const addVisitorIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, currentPayload), { visitorId: addVisitorIdParameter ? yield this.getCurrentVisitorId() : "" });
      });
      const addClientIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        if (addClientIdParameter) {
          return Object.assign(Object.assign({}, currentPayload), { clientId: yield this.getCurrentVisitorId() });
        }
        return currentPayload;
      });
      const setAnonymousUserStep = (currentPayload) => usesMeasurementProtocol ? this.ensureAnonymousUserWhenUsingApiKey(currentPayload) : currentPayload;
      const processBeforeSendHooksStep = (currentPayload) => this.beforeSendHooks.reduce((promisePayload, current) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield promisePayload;
        return yield current(eventType, payload2);
      }), currentPayload);
      const parametersToSend = yield [
        processVariableArgumentNamesStep,
        addVisitorIdStep,
        addClientIdStep,
        setAnonymousUserStep,
        processBeforeSendHooksStep
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield payloadPromise;
        return yield step(payload2);
      }), Promise.resolve(payload));
      return parametersToSend;
    });
  }
  resolvePayloadForParameters(eventType, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const { usesMeasurementProtocol = false } = this.eventTypeMapping[eventType] || {};
      const addTrackingIdStep = (currentPayload) => this.setTrackingIdIfTrackingIdNotPresent(currentPayload);
      const cleanPayloadStep = (currentPayload) => this.removeEmptyPayloadValues(currentPayload, eventType);
      const validateParams = (currentPayload) => this.validateParams(currentPayload, eventType);
      const processMeasurementProtocolConversionStep = (currentPayload) => usesMeasurementProtocol ? convertKeysToMeasurementProtocol(currentPayload) : currentPayload;
      const removeUnknownParameters = (currentPayload) => usesMeasurementProtocol ? this.removeUnknownParameters(currentPayload) : currentPayload;
      const processCustomParameters = (currentPayload) => usesMeasurementProtocol ? this.processCustomParameters(currentPayload) : this.mapCustomParametersToCustomData(currentPayload);
      const payloadToSend = yield [
        addTrackingIdStep,
        cleanPayloadStep,
        validateParams,
        processMeasurementProtocolConversionStep,
        removeUnknownParameters,
        processCustomParameters
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload = yield payloadPromise;
        return yield step(payload);
      }), Promise.resolve(parameters));
      return payloadToSend;
    });
  }
  makeEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { newEventType: eventTypeToSend = eventType } = this.eventTypeMapping[eventType] || {};
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      const payloadToSend = yield this.resolvePayloadForParameters(eventType, parametersToSend);
      return {
        eventType: eventTypeToSend,
        payload: payloadToSend,
        log: (remainingPayload) => __awaiter(this, void 0, void 0, function* () {
          this.bufferedRequests.push({
            eventType: eventTypeToSend,
            payload: Object.assign(Object.assign({}, payloadToSend), remainingPayload)
          });
          yield Promise.all(this.afterSendHooks.map((hook) => hook(eventType, Object.assign(Object.assign({}, parametersToSend), remainingPayload))));
          yield this.deferExecution();
          return yield this.sendFromBuffer();
        })
      };
    });
  }
  sendEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeEvent(eventType, ...payload)).log({});
    });
  }
  deferExecution() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  sendFromBuffer() {
    return __awaiter(this, void 0, void 0, function* () {
      const popped = this.bufferedRequests.shift();
      if (popped) {
        const { eventType, payload } = popped;
        return this.runtime.getClientDependingOnEventType(eventType).sendEvent(eventType, payload);
      }
    });
  }
  clear() {
    this.storage.removeItem("visitorId");
    const store = new HistoryStore();
    store.clear();
  }
  deleteHttpOnlyVisitorId() {
    this.runtime.client.deleteHttpCookieVisitorId();
  }
  makeSearchEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.search, request);
    });
  }
  sendSearchEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeSearchEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeClickEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.click, request);
    });
  }
  sendClickEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeClickEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeCustomEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.custom, request);
    });
  }
  sendCustomEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { lastSearchQueryUid } = _a, preparedRequest = __rest(_a, ["lastSearchQueryUid"]);
      return (yield this.makeCustomEvent(preparedRequest)).log({ lastSearchQueryUid });
    });
  }
  makeViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.view, request);
    });
  }
  sendViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeViewEvent(request)).log({});
    });
  }
  getVisit() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/visit`);
      const visit = yield response.json();
      this.visitorId = visit.visitorId;
      return visit;
    });
  }
  getHealth() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/monitoring/health`);
      return yield response.json();
    });
  }
  registerBeforeSendEventHook(hook) {
    this.beforeSendHooks.push(hook);
  }
  registerAfterSendEventHook(hook) {
    this.afterSendHooks.push(hook);
  }
  addEventTypeMapping(eventType, eventConfig) {
    this.eventTypeMapping[eventType] = eventConfig;
  }
  setAcceptedLinkReferrers(hosts) {
    if (Array.isArray(hosts) && hosts.every((host) => typeof host == "string"))
      this.acceptedLinkReferrers = hosts;
    else
      throw Error("Parameter should be an array of domain strings");
  }
  parseVariableArgumentsPayload(fieldsOrder, payload) {
    const parsedArguments = {};
    for (let i = 0, length = payload.length; i < length; i++) {
      const currentArgument = payload[i];
      if (typeof currentArgument === "string") {
        parsedArguments[fieldsOrder[i]] = currentArgument;
      } else if (typeof currentArgument === "object") {
        return Object.assign(Object.assign({}, parsedArguments), currentArgument);
      }
    }
    return parsedArguments;
  }
  isKeyAllowedEmpty(evtType, key) {
    const keysThatCanBeEmpty = {
      [EventType.search]: ["queryText"]
    };
    const match = keysThatCanBeEmpty[evtType] || [];
    return match.indexOf(key) !== -1;
  }
  removeEmptyPayloadValues(payload, eventType) {
    const isNotEmptyValue = (value) => typeof value !== "undefined" && value !== null && value !== "";
    return Object.keys(payload).filter((key) => this.isKeyAllowedEmpty(eventType, key) || isNotEmptyValue(payload[key])).reduce((newPayload, key) => Object.assign(Object.assign({}, newPayload), { [key]: payload[key] }), {});
  }
  removeUnknownParameters(payload) {
    const newPayload = Object.keys(payload).filter((key) => {
      if (isMeasurementProtocolKey(key)) {
        return true;
      } else {
        console.log(key, "is not processed by coveoua");
      }
    }).reduce((newPayload2, key) => Object.assign(Object.assign({}, newPayload2), { [key]: payload[key] }), {});
    return newPayload;
  }
  processCustomParameters(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    let lowercasedCustom = {};
    if (custom && isObject(custom)) {
      lowercasedCustom = this.lowercaseKeys(custom);
    }
    const newPayload = convertCustomMeasurementProtocolKeys(rest);
    return Object.assign(Object.assign({}, lowercasedCustom), newPayload);
  }
  mapCustomParametersToCustomData(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    if (custom && isObject(custom)) {
      const lowercasedCustom = this.lowercaseKeys(custom);
      return Object.assign(Object.assign({}, rest), { customData: Object.assign(Object.assign({}, lowercasedCustom), payload.customData) });
    } else {
      return payload;
    }
  }
  lowercaseKeys(custom) {
    const keys = Object.keys(custom);
    let result = {};
    keys.forEach((key) => {
      result[key.toLowerCase()] = custom[key];
    });
    return result;
  }
  validateParams(payload, eventType) {
    const { anonymizeIp } = payload, rest = __rest(payload, ["anonymizeIp"]);
    if (anonymizeIp !== void 0) {
      if (["0", "false", "undefined", "null", "{}", "[]", ""].indexOf(`${anonymizeIp}`.toLowerCase()) == -1) {
        rest.anonymizeIp = 1;
      }
    }
    if (eventType == EventType.view || eventType == EventType.click || eventType == EventType.search || eventType == EventType.custom) {
      rest.originLevel3 = this.limit(rest.originLevel3, 1024);
    }
    if (eventType == EventType.view) {
      rest.location = this.limit(rest.location, 1024);
    }
    if (eventType == "pageview" || eventType == "event") {
      rest.referrer = this.limit(rest.referrer, 2048);
      rest.location = this.limit(rest.location, 2048);
      rest.page = this.limit(rest.page, 2048);
    }
    return rest;
  }
  ensureAnonymousUserWhenUsingApiKey(payload) {
    const { userId } = payload, rest = __rest(payload, ["userId"]);
    if (isApiKey(this.options.token) && !userId) {
      rest["userId"] = "anonymous";
      return rest;
    } else {
      return payload;
    }
  }
  setTrackingIdIfTrackingIdNotPresent(payload) {
    const { trackingId } = payload, rest = __rest(payload, ["trackingId"]);
    if (trackingId) {
      return payload;
    }
    if (rest.hasOwnProperty("custom") && isObject(rest.custom)) {
      if (rest.custom.hasOwnProperty("context_website") || rest.custom.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.custom.context_website || rest.custom.siteName;
      }
    }
    if (rest.hasOwnProperty("customData") && isObject(rest.customData)) {
      if (rest.customData.hasOwnProperty("context_website") || rest.customData.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.customData.context_website || rest.customData.siteName;
      }
    }
    return rest;
  }
  limit(input, length) {
    return typeof input === "string" ? truncateUrl(input, length) : input;
  }
  get baseUrl() {
    return buildBaseUrl(this.options.endpoint, this.options.version, this.options.isCustomEndpoint);
  }
};
var InsightEvents;
(function(InsightEvents2) {
  InsightEvents2["contextChanged"] = "contextChanged";
  InsightEvents2["expandToFullUI"] = "expandToFullUI";
  InsightEvents2["openUserActions"] = "openUserActions";
  InsightEvents2["showPrecedingSessions"] = "showPrecedingSessions";
  InsightEvents2["showFollowingSessions"] = "showFollowingSessions";
  InsightEvents2["clickViewedDocument"] = "clickViewedDocument";
  InsightEvents2["clickPageView"] = "clickPageView";
  InsightEvents2["createArticle"] = "createArticle";
})(InsightEvents || (InsightEvents = {}));
var SearchPageEvents;
(function(SearchPageEvents3) {
  SearchPageEvents3["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents3["interfaceChange"] = "interfaceChange";
  SearchPageEvents3["didyoumeanAutomatic"] = "didyoumeanAutomatic";
  SearchPageEvents3["didyoumeanClick"] = "didyoumeanClick";
  SearchPageEvents3["resultsSort"] = "resultsSort";
  SearchPageEvents3["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents3["searchboxClear"] = "searchboxClear";
  SearchPageEvents3["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents3["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents3["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents3["documentQuickview"] = "documentQuickview";
  SearchPageEvents3["documentOpen"] = "documentOpen";
  SearchPageEvents3["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents3["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents3["searchFromLink"] = "searchFromLink";
  SearchPageEvents3["triggerNotify"] = "notify";
  SearchPageEvents3["triggerExecute"] = "execute";
  SearchPageEvents3["triggerQuery"] = "query";
  SearchPageEvents3["undoTriggerQuery"] = "undoQuery";
  SearchPageEvents3["triggerRedirect"] = "redirect";
  SearchPageEvents3["pagerResize"] = "pagerResize";
  SearchPageEvents3["pagerNumber"] = "pagerNumber";
  SearchPageEvents3["pagerNext"] = "pagerNext";
  SearchPageEvents3["pagerPrevious"] = "pagerPrevious";
  SearchPageEvents3["pagerScrolling"] = "pagerScrolling";
  SearchPageEvents3["staticFilterClearAll"] = "staticFilterClearAll";
  SearchPageEvents3["staticFilterSelect"] = "staticFilterSelect";
  SearchPageEvents3["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents3["facetClearAll"] = "facetClearAll";
  SearchPageEvents3["facetSearch"] = "facetSearch";
  SearchPageEvents3["facetSelect"] = "facetSelect";
  SearchPageEvents3["facetSelectAll"] = "facetSelectAll";
  SearchPageEvents3["facetDeselect"] = "facetDeselect";
  SearchPageEvents3["facetExclude"] = "facetExclude";
  SearchPageEvents3["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents3["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents3["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents3["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents3["queryError"] = "query";
  SearchPageEvents3["queryErrorBack"] = "errorBack";
  SearchPageEvents3["queryErrorClear"] = "errorClearQuery";
  SearchPageEvents3["queryErrorRetry"] = "errorRetry";
  SearchPageEvents3["recommendation"] = "recommendation";
  SearchPageEvents3["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents3["recommendationOpen"] = "recommendationOpen";
  SearchPageEvents3["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents3["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents3["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents3["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents3["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents3["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents3["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents3["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents3["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents3["showMoreSmartSnippetSuggestion"] = "showMoreSmartSnippetSuggestion";
  SearchPageEvents3["showLessSmartSnippetSuggestion"] = "showLessSmartSnippetSuggestion";
  SearchPageEvents3["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents3["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents3["openSmartSnippetInlineLink"] = "openSmartSnippetInlineLink";
  SearchPageEvents3["openSmartSnippetSuggestionInlineLink"] = "openSmartSnippetSuggestionInlineLink";
  SearchPageEvents3["recentQueryClick"] = "recentQueriesClick";
  SearchPageEvents3["clearRecentQueries"] = "clearRecentQueries";
  SearchPageEvents3["recentResultClick"] = "recentResultClick";
  SearchPageEvents3["clearRecentResults"] = "clearRecentResults";
  SearchPageEvents3["noResultsBack"] = "noResultsBack";
  SearchPageEvents3["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents3["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents3["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents3["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents3["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents3["caseAttach"] = "caseAttach";
  SearchPageEvents3["caseDetach"] = "caseDetach";
  SearchPageEvents3["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents3["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents3["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents3["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents3["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents3["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents3["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents3["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents3["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents3["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents3["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents3["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents3["rephraseGeneratedAnswer"] = "rephraseGeneratedAnswer";
  SearchPageEvents3["generatedAnswerFeedbackSubmitV2"] = "generatedAnswerFeedbackSubmitV2";
  SearchPageEvents3["generatedAnswerCitationClick"] = "generatedAnswerCitationClick";
  SearchPageEvents3["generatedAnswerCitationDocumentAttach"] = "generatedAnswerCitationDocumentAttach";
})(SearchPageEvents || (SearchPageEvents = {}));
var CustomEventsTypes = {
  [SearchPageEvents.triggerNotify]: "queryPipelineTriggers",
  [SearchPageEvents.triggerExecute]: "queryPipelineTriggers",
  [SearchPageEvents.triggerQuery]: "queryPipelineTriggers",
  [SearchPageEvents.triggerRedirect]: "queryPipelineTriggers",
  [SearchPageEvents.queryErrorBack]: "errors",
  [SearchPageEvents.queryErrorClear]: "errors",
  [SearchPageEvents.queryErrorRetry]: "errors",
  [SearchPageEvents.pagerNext]: "getMoreResults",
  [SearchPageEvents.pagerPrevious]: "getMoreResults",
  [SearchPageEvents.pagerNumber]: "getMoreResults",
  [SearchPageEvents.pagerResize]: "getMoreResults",
  [SearchPageEvents.pagerScrolling]: "getMoreResults",
  [SearchPageEvents.facetSearch]: "facet",
  [SearchPageEvents.facetShowLess]: "facet",
  [SearchPageEvents.facetShowMore]: "facet",
  [SearchPageEvents.recommendation]: "recommendation",
  [SearchPageEvents.likeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.dislikeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippet]: "smartSnippet",
  [SearchPageEvents.collapseSmartSnippet]: "smartSnippet",
  [SearchPageEvents.openSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.closeSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.sendSmartSnippetReason]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.collapseSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showMoreSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showLessSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.clearRecentQueries]: "recentQueries",
  [SearchPageEvents.recentResultClick]: "recentlyClickedDocuments",
  [SearchPageEvents.clearRecentResults]: "recentlyClickedDocuments",
  [SearchPageEvents.showLessFoldedResults]: "folding",
  [SearchPageEvents.caseDetach]: "case",
  [SearchPageEvents.likeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.dislikeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.openGeneratedAnswerSource]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerStreamEnd]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerSourceHover]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCopyToClipboard]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerHideAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerShowAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerExpand]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCollapse]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmit]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmitV2]: "generatedAnswer",
  [InsightEvents.expandToFullUI]: "interface",
  [InsightEvents.openUserActions]: "User Actions",
  [InsightEvents.showPrecedingSessions]: "User Actions",
  [InsightEvents.showFollowingSessions]: "User Actions",
  [InsightEvents.clickViewedDocument]: "User Actions",
  [InsightEvents.clickPageView]: "User Actions",
  [InsightEvents.createArticle]: "createArticle"
};
var NoopAnalytics = class {
  constructor() {
    this.runtime = new NoopRuntime();
    this.currentVisitorId = "";
  }
  getPayload() {
    return Promise.resolve();
  }
  getParameters() {
    return Promise.resolve();
  }
  makeEvent(eventType) {
    return Promise.resolve({ eventType, payload: null, log: () => Promise.resolve() });
  }
  sendEvent() {
    return Promise.resolve();
  }
  makeSearchEvent() {
    return this.makeEvent(EventType.search);
  }
  sendSearchEvent() {
    return Promise.resolve();
  }
  makeClickEvent() {
    return this.makeEvent(EventType.click);
  }
  sendClickEvent() {
    return Promise.resolve();
  }
  makeCustomEvent() {
    return this.makeEvent(EventType.custom);
  }
  sendCustomEvent() {
    return Promise.resolve();
  }
  makeViewEvent() {
    return this.makeEvent(EventType.view);
  }
  sendViewEvent() {
    return Promise.resolve();
  }
  getVisit() {
    return Promise.resolve({ id: "", visitorId: "" });
  }
  getHealth() {
    return Promise.resolve({ status: "" });
  }
  registerBeforeSendEventHook() {
  }
  registerAfterSendEventHook() {
  }
  addEventTypeMapping() {
  }
  get version() {
    return libVersion;
  }
};
function filterConsecutiveRepeatedValues(rawData) {
  let prev = "";
  return rawData.filter((value) => {
    const isDifferent = value !== prev;
    prev = value;
    return isDifferent;
  });
}
function removeSemicolons(rawData) {
  return rawData.map((value) => {
    return value.replace(/;/g, "");
  });
}
function getDataString(data) {
  const ANALYTICS_LENGTH_LIMIT = 256;
  const formattedData = data.join(";");
  if (formattedData.length <= ANALYTICS_LENGTH_LIMIT) {
    return formattedData;
  }
  return getDataString(data.slice(1));
}
var formatArrayForCoveoCustomData = (rawData) => {
  const dataWithoutSemicolons = removeSemicolons(rawData);
  const dataWithoutRepeatedValues = filterConsecutiveRepeatedValues(dataWithoutSemicolons);
  return getDataString(dataWithoutRepeatedValues);
};
function formatOmniboxMetadata(meta) {
  const partialQueries = typeof meta.partialQueries === "string" ? meta.partialQueries : formatArrayForCoveoCustomData(meta.partialQueries);
  const suggestions = typeof meta.suggestions === "string" ? meta.suggestions : formatArrayForCoveoCustomData(meta.suggestions);
  return Object.assign(Object.assign({}, meta), {
    partialQueries,
    suggestions
  });
}
var CoveoSearchPageClient = class {
  constructor(opts, provider) {
    this.opts = opts;
    this.provider = provider;
    const shouldDisableAnalytics = opts.enableAnalytics === false || doNotTrack2();
    this.coveoAnalyticsClient = shouldDisableAnalytics ? new NoopAnalytics() : new CoveoAnalyticsClient(opts);
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.opts);
  }
  makeInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.interfaceLoad);
  }
  logInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.recommendationInterfaceLoad);
  }
  logRecommendationInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendation() {
    return this.makeCustomEvent(SearchPageEvents.recommendation);
  }
  logRecommendation() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendation()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.recommendationOpen, info, identifier);
  }
  logRecommendationOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterClearAll, meta);
  }
  logStaticFilterClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterSelect, meta);
  }
  logStaticFilterSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterDeselect, meta);
  }
  logStaticFilterDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFetchMoreResults() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling, { type: "getMoreResults" });
  }
  logFetchMoreResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFetchMoreResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeInterfaceChange(metadata) {
    return this.makeSearchEvent(SearchPageEvents.interfaceChange, metadata);
  }
  logInterfaceChange(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceChange(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanAutomatic() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanAutomatic);
  }
  logDidYouMeanAutomatic() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanAutomatic()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanClick() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanClick);
  }
  logDidYouMeanClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeResultsSort(metadata) {
    return this.makeSearchEvent(SearchPageEvents.resultsSort, metadata);
  }
  logResultsSort(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeResultsSort(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxSubmit() {
    return this.makeSearchEvent(SearchPageEvents.searchboxSubmit);
  }
  logSearchboxSubmit() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxSubmit()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxClear() {
    return this.makeSearchEvent(SearchPageEvents.searchboxClear);
  }
  logSearchboxClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxAsYouType() {
    return this.makeSearchEvent(SearchPageEvents.searchboxAsYouType);
  }
  logSearchboxAsYouType() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxAsYouType()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbFacet(metadata) {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbFacet, metadata);
  }
  logBreadcrumbFacet(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbFacet(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbResetAll() {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbResetAll);
  }
  logBreadcrumbResetAll() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbResetAll()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentQuickview(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentQuickview, info, identifier);
  }
  logDocumentQuickview(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentQuickview(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentOpen, info, identifier);
  }
  logDocumentOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxAnalytics(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxAnalytics, formatOmniboxMetadata(meta));
  }
  logOmniboxAnalytics(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxAnalytics(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxFromLink(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxFromLink, formatOmniboxMetadata(meta));
  }
  logOmniboxFromLink(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxFromLink(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchFromLink() {
    return this.makeSearchEvent(SearchPageEvents.searchFromLink);
  }
  logSearchFromLink() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchFromLink()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerNotify(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerNotify, meta);
  }
  logTriggerNotify(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerNotify(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerExecute(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerExecute, meta);
  }
  logTriggerExecute(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerExecute(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerQuery() {
    return this.makeCustomEvent(SearchPageEvents.triggerQuery, { query: this.provider.getSearchEventRequestPayload().queryText }, "queryPipelineTriggers");
  }
  logTriggerQuery() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerQuery()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeUndoTriggerQuery(meta) {
    return this.makeSearchEvent(SearchPageEvents.undoTriggerQuery, meta);
  }
  logUndoTriggerQuery(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeUndoTriggerQuery(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerRedirect(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerRedirect, Object.assign(Object.assign({}, meta), { query: this.provider.getSearchEventRequestPayload().queryText }));
  }
  logTriggerRedirect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerRedirect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerResize(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerResize, meta);
  }
  logPagerResize(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerResize(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNumber(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNumber, meta);
  }
  logPagerNumber(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNumber(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNext(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNext, meta);
  }
  logPagerNext(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNext(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerPrevious(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerPrevious, meta);
  }
  logPagerPrevious(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerPrevious(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerScrolling() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling);
  }
  logPagerScrolling() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerScrolling()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetClearAll, meta);
  }
  logFacetClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSearch(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSearch, meta);
  }
  logFacetSearch(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSearch(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelect, meta);
  }
  logFacetSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetDeselect, meta);
  }
  logFacetDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetExclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetExclude, meta);
  }
  logFacetExclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetExclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUnexclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUnexclude, meta);
  }
  logFacetUnexclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUnexclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelectAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelectAll, meta);
  }
  logFacetSelectAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelectAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUpdateSort(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUpdateSort, meta);
  }
  logFacetUpdateSort(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUpdateSort(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowMore(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowMore, meta);
  }
  logFacetShowMore(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowMore(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowLess(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowLess, meta);
  }
  logFacetShowLess(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowLess(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryError(meta) {
    return this.makeCustomEvent(SearchPageEvents.queryError, meta);
  }
  logQueryError(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryError(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorBack);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorBack);
        })
      };
    });
  }
  logQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorRetry);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorRetry);
        })
      };
    });
  }
  logQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorRetry()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorClear);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorClear);
        })
      };
    });
  }
  logQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeLikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.likeSmartSnippet);
  }
  logLikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.dislikeSmartSnippet);
  }
  logDislikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeExpandSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippet);
  }
  logExpandSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippet);
  }
  logCollapseSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.openSmartSnippetFeedbackModal);
  }
  logOpenSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCloseSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.closeSmartSnippetFeedbackModal);
  }
  logCloseSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCloseSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSmartSnippetFeedbackReason(reason, details) {
    return this.makeCustomEvent(SearchPageEvents.sendSmartSnippetReason, { reason, details });
  }
  logSmartSnippetFeedbackReason(reason, details) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSmartSnippetFeedbackReason(reason, details)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeExpandSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logExpandSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logCollapseSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showMoreSmartSnippetSuggestion, snippet);
  }
  logShowMoreSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showLessSmartSnippetSuggestion, snippet);
  }
  logShowLessSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSource(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSource, info, identifier);
  }
  logOpenSmartSnippetSource(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSource(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSuggestionSource(info, snippet) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionSource, info, { contentIDKey: snippet.documentId.contentIdKey, contentIDValue: snippet.documentId.contentIdValue }, snippet);
  }
  makeCopyToClipboard(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.copyToClipboard, info, identifier);
  }
  logCopyToClipboard(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCopyToClipboard(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  logOpenSmartSnippetSuggestionSource(info, snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionSource(info, snippet)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetInlineLink, info, { contentIDKey: identifierAndLink.contentIDKey, contentIDValue: identifierAndLink.contentIDValue }, identifierAndLink);
  }
  logOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetInlineLink(info, identifierAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionInlineLink, info, {
      contentIDKey: snippetAndLink.documentId.contentIdKey,
      contentIDValue: snippetAndLink.documentId.contentIdValue
    }, snippetAndLink);
  }
  logOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRecentQueryClick() {
    return this.makeSearchEvent(SearchPageEvents.recentQueryClick);
  }
  logRecentQueryClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentQueryClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentQueries() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentQueries);
  }
  logClearRecentQueries() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentQueries()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecentResultClick(info, identifier) {
    return this.makeCustomEvent(SearchPageEvents.recentResultClick, { info, identifier });
  }
  logRecentResultClick(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentResultClick(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentResults() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentResults);
  }
  logClearRecentResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeNoResultsBack() {
    return this.makeSearchEvent(SearchPageEvents.noResultsBack);
  }
  logNoResultsBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeNoResultsBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreFoldedResults(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.showMoreFoldedResults, info, identifier);
  }
  logShowMoreFoldedResults(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreFoldedResults(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessFoldedResults() {
    return this.makeCustomEvent(SearchPageEvents.showLessFoldedResults);
  }
  logShowLessFoldedResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessFoldedResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeEventDescription(preparedEvent, actionCause) {
    var _a;
    return { actionCause, customData: (_a = preparedEvent.payload) === null || _a === void 0 ? void 0 : _a.customData };
  }
  makeCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      this.coveoAnalyticsClient.getParameters;
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const request = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), { eventType, eventValue: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      return (yield this.makeCustomEvent(event, metadata, eventType)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const payload = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), {
        eventType,
        eventValue
      });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(payload);
      return {
        description: this.makeEventDescription(preparedEvent, eventValue),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCustomEventWithType(eventValue, eventType, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  logSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchEvent(event, metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.getBaseSearchEventRequest(event, metadata);
      const preparedEvent = yield this.coveoAnalyticsClient.makeSearchEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  makeClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { queryPipeline: this.provider.getPipeline(), actionCause: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeClickEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClickEvent(event, info, identifier, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  getBaseSearchEventRequest(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      return Object.assign(Object.assign(Object.assign({}, yield this.getBaseEventRequest(Object.assign(Object.assign({}, metadata), (_b = (_a = this.provider).getGeneratedAnswerMetadata) === null || _b === void 0 ? void 0 : _b.call(_a)))), this.provider.getSearchEventRequestPayload()), { queryPipeline: this.provider.getPipeline(), actionCause: event });
    });
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      return Object.assign(Object.assign(Object.assign({}, this.getOrigins()), this.getSplitTestRun()), { customData, language: this.provider.getLanguage(), facetState: this.provider.getFacetState ? this.provider.getFacetState() : [], anonymous: this.provider.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getOrigins() {
    var _a, _b;
    return {
      originContext: (_b = (_a = this.provider).getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: this.provider.getOriginLevel1(),
      originLevel2: this.provider.getOriginLevel2(),
      originLevel3: this.provider.getOriginLevel3()
    };
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getSplitTestRun() {
    const splitTestRunName = this.provider.getSplitTestRunName ? this.provider.getSplitTestRunName() : "";
    const splitTestRunVersion = this.provider.getSplitTestRunVersion ? this.provider.getSplitTestRunVersion() : "";
    return Object.assign(Object.assign({}, splitTestRunName && { splitTestRunName }), splitTestRunVersion && { splitTestRunVersion });
  }
  makeLikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.likeGeneratedAnswer, metadata);
  }
  logLikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.dislikeGeneratedAnswer, metadata);
  }
  logDislikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenGeneratedAnswerSource(metadata) {
    return this.makeCustomEvent(SearchPageEvents.openGeneratedAnswerSource, metadata);
  }
  logOpenGeneratedAnswerSource(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenGeneratedAnswerSource(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCitationClick(info, citation) {
    return this.makeClickEvent(SearchPageEvents.generatedAnswerCitationClick, Object.assign(Object.assign({}, info), { documentPosition: 1 }), { contentIDKey: citation.documentId.contentIdKey, contentIDValue: citation.documentId.contentIdValue }, citation);
  }
  logGeneratedAnswerCitationClick(info, citation) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCitationClick(info, citation)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerSourceHover(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerSourceHover, metadata);
  }
  logGeneratedAnswerSourceHover(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerSourceHover(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCopyToClipboard(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCopyToClipboard, metadata);
  }
  logGeneratedAnswerCopyToClipboard(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCopyToClipboard(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerHideAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerHideAnswers, metadata);
  }
  logGeneratedAnswerHideAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerHideAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerShowAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerShowAnswers, metadata);
  }
  logGeneratedAnswerShowAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerShowAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerExpand(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerExpand, metadata);
  }
  logGeneratedAnswerExpand(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerExpand(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerCollapse(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCollapse, metadata);
  }
  logGeneratedAnswerCollapse(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCollapse(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerFeedbackSubmit(meta) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmit, meta);
  }
  logGeneratedAnswerFeedbackSubmit(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmit(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerFeedbackSubmitV2(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmitV2, metadata);
  }
  logGeneratedAnswerFeedbackSubmitV2(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmitV2(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRephraseGeneratedAnswer(meta) {
    return this.makeSearchEvent(SearchPageEvents.rephraseGeneratedAnswer, meta);
  }
  logRephraseGeneratedAnswer(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRephraseGeneratedAnswer(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRetryGeneratedAnswer() {
    return this.makeSearchEvent(SearchPageEvents.retryGeneratedAnswer);
  }
  logRetryGeneratedAnswer() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRetryGeneratedAnswer()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerStreamEnd(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerStreamEnd, metadata);
  }
  logGeneratedAnswerStreamEnd(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerStreamEnd(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
};
var SVCPluginEventTypes = Object.assign({}, BasePluginEventTypes);
var allSVCEventTypes = Object.keys(SVCPluginEventTypes).map((key) => SVCPluginEventTypes[key]);
var SVCPlugin = class extends BasePlugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
    this.ticket = {};
  }
  getApi(name) {
    const superCall = super.getApi(name);
    if (superCall !== null)
      return superCall;
    switch (name) {
      case "setTicket":
        return this.setTicket;
      default:
        return null;
    }
  }
  addHooks() {
    this.addHooksForEvent();
    this.addHooksForPageView();
    this.addHooksForSVCEvents();
  }
  setTicket(ticket) {
    this.ticket = ticket;
  }
  clearPluginData() {
    this.ticket = {};
  }
  addHooksForSVCEvents() {
    this.client.registerBeforeSendEventHook((eventType, ...[payload]) => {
      return allSVCEventTypes.indexOf(eventType) !== -1 ? this.addSVCDataToPayload(eventType, payload) : payload;
    });
    this.client.registerAfterSendEventHook((eventType, ...[payload]) => {
      if (allSVCEventTypes.indexOf(eventType) !== -1) {
        this.updateLocationInformation(eventType, payload);
      }
      return payload;
    });
  }
  addHooksForPageView() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.pageview, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["page"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addHooksForEvent() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.event, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["eventCategory", "eventAction", "eventLabel", "eventValue"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addSVCDataToPayload(eventType, payload) {
    var _a;
    const svcPayload = Object.assign(Object.assign(Object.assign(Object.assign({}, this.getLocationInformation(eventType, payload)), this.getDefaultContextInformation(eventType)), this.action ? { svcAction: this.action } : {}), Object.keys((_a = this.actionData) !== null && _a !== void 0 ? _a : {}).length > 0 ? { svcActionData: this.actionData } : {});
    const ticketPayload = this.getTicketPayload();
    this.clearData();
    return Object.assign(Object.assign(Object.assign({}, ticketPayload), svcPayload), payload);
  }
  getTicketPayload() {
    return convertTicketToMeasurementProtocol(this.ticket);
  }
};
SVCPlugin.Id = "svc";
var CaseAssistEvents;
(function(CaseAssistEvents2) {
  CaseAssistEvents2["click"] = "click";
  CaseAssistEvents2["flowStart"] = "flowStart";
})(CaseAssistEvents || (CaseAssistEvents = {}));
var CaseAssistActions;
(function(CaseAssistActions2) {
  CaseAssistActions2["enterInterface"] = "ticket_create_start";
  CaseAssistActions2["fieldUpdate"] = "ticket_field_update";
  CaseAssistActions2["fieldSuggestionClick"] = "ticket_classification_click";
  CaseAssistActions2["documentSuggestionClick"] = "documentSuggestionClick";
  CaseAssistActions2["documentSuggestionQuickview"] = "documentSuggestionQuickview";
  CaseAssistActions2["suggestionRate"] = "suggestion_rate";
  CaseAssistActions2["nextCaseStep"] = "ticket_next_stage";
  CaseAssistActions2["caseCancelled"] = "ticket_cancel";
  CaseAssistActions2["caseSolved"] = "ticket_cancel";
  CaseAssistActions2["caseCreated"] = "ticket_create";
})(CaseAssistActions || (CaseAssistActions = {}));
var CaseCancelledReasons;
(function(CaseCancelledReasons2) {
  CaseCancelledReasons2["quit"] = "Quit";
  CaseCancelledReasons2["solved"] = "Solved";
})(CaseCancelledReasons || (CaseCancelledReasons = {}));
var CaseAssistClient = class {
  constructor(options, provider) {
    var _a;
    this.options = options;
    this.provider = provider;
    const analyticsEnabled = ((_a = options.enableAnalytics) !== null && _a !== void 0 ? _a : true) && !doNotTrack2();
    this.coveoAnalyticsClient = analyticsEnabled ? new CoveoAnalyticsClient(options) : new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.options);
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  logEnterInterface(meta) {
    this.svc.setAction(CaseAssistActions.enterInterface);
    this.svc.setTicket(meta.ticket);
    return this.sendFlowStartEvent();
  }
  logUpdateCaseField(meta) {
    this.svc.setAction(CaseAssistActions.fieldUpdate, {
      fieldName: meta.fieldName
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectFieldSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.fieldSuggestionClick, meta.suggestion);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionClick, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logQuickviewDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionQuickview, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logRateDocumentSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.suggestionRate, Object.assign({ rate: meta.rating }, meta.suggestion));
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logMoveToNextCaseStep(meta) {
    this.svc.setAction(CaseAssistActions.nextCaseStep, {
      stage: meta === null || meta === void 0 ? void 0 : meta.stage
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCancelled(meta) {
    this.svc.setAction(CaseAssistActions.caseCancelled, {
      reason: CaseCancelledReasons.quit
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseSolved(meta) {
    this.svc.setAction(CaseAssistActions.caseSolved, {
      reason: CaseCancelledReasons.solved
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCreated(meta) {
    this.svc.setAction(CaseAssistActions.caseCreated);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  sendFlowStartEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.flowStart, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  sendClickEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.click, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const customData = Object.assign({}, metadata);
      return Object.assign(Object.assign({}, this.getOrigins()), { customData, language: (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getLanguage(), anonymous: (_b = this.provider) === null || _b === void 0 ? void 0 : _b.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getOrigins() {
    var _a, _b, _c, _d, _e;
    return {
      originContext: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: (_c = this.provider) === null || _c === void 0 ? void 0 : _c.getOriginLevel1(),
      originLevel2: (_d = this.provider) === null || _d === void 0 ? void 0 : _d.getOriginLevel2(),
      originLevel3: (_e = this.provider) === null || _e === void 0 ? void 0 : _e.getOriginLevel3()
    };
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const payload = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { searchQueryUid: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getSearchUID()) !== null && _b !== void 0 ? _b : "", actionCause: event });
      return this.coveoAnalyticsClient.sendClickEvent(payload);
    });
  }
};

// src/features/search-hub/search-hub-state.ts
var getSearchHubInitialState = () => "default";

// src/api/analytics/base-analytics.ts
var getLanguage = (state) => {
  const langKey = state.configuration.search.locale.split("-")[0];
  if (!langKey || langKey.length !== 2) {
    return "en";
  }
  return langKey;
};
var BaseAnalyticsProvider = class {
  constructor(getState) {
    this.getState = getState;
    __publicField(this, "state");
    this.state = getState();
  }
  getLanguage() {
    return getLanguage(this.state);
  }
  getBaseMetadata() {
    const { context, configuration: configuration2 } = this.state;
    const contextValues = context?.contextValues || {};
    const formattedObject = {};
    for (const [key, value] of Object.entries(contextValues)) {
      const formattedKey = `context_${key}`;
      formattedObject[formattedKey] = value;
    }
    if (configuration2.analytics.analyticsMode === "legacy") {
      formattedObject.coveoHeadlessVersion = VERSION;
    }
    return formattedObject;
  }
  getOriginContext() {
    return this.state.configuration.analytics.originContext;
  }
  getOriginLevel1() {
    return this.state.searchHub || getSearchHubInitialState();
  }
  getOriginLevel2() {
    return this.state.configuration.analytics.originLevel2;
  }
  getOriginLevel3() {
    return this.state.configuration.analytics.originLevel3;
  }
  getIsAnonymous() {
    return this.state.configuration.analytics.anonymous;
  }
};

// src/api/analytics/coveo-analytics-utils.ts
var getVisitorID = (options) => new CoveoAnalyticsClient(options).getCurrentVisitorId();
var wrapPreprocessRequest = (logger, preprocessRequest) => {
  return typeof preprocessRequest === "function" ? (...args) => {
    const untaintedOutput = clone(args[0]);
    try {
      return preprocessRequest.apply(preprocessRequest, args);
    } catch (e) {
      logger.error(
        e,
        "Error in analytics preprocessRequest. Returning original request."
      );
      return untaintedOutput;
    }
  } : void 0;
};
var wrapAnalyticsClientSendEventHook = (logger, hook) => {
  return (...args) => {
    const untaintedOutput = clone(args[1]);
    try {
      return hook.apply(hook, args);
    } catch (e) {
      logger.error(
        e,
        "Error in analytics hook. Returning original request."
      );
      return untaintedOutput;
    }
  };
};

// src/api/analytics/case-assist-analytics.ts
var CaseAssistAnalyticsProvider = class extends BaseAnalyticsProvider {
  getSearchUID() {
    return this.state.documentSuggestion?.status.lastResponseId ?? "";
  }
};
var configureCaseAssistAnalytics = ({
  logger,
  getState,
  analyticsClientMiddleware = (_, p) => p,
  preprocessRequest,
  provider = new CaseAssistAnalyticsProvider(getState)
}) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment,
    "analytics"
  );
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CaseAssistClient(
    {
      enableAnalytics: enableAnalytics2,
      token,
      endpoint,
      runtimeEnvironment,
      preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
      beforeSendHooks: [
        wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
        (type, payload) => {
          logger.info(
            {
              ...payload,
              type,
              endpoint,
              token
            },
            "Analytics request"
          );
          return payload;
        }
      ]
    },
    provider
  );
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};

// src/features/facets/automatic-facet-set/automatic-facet-set-constants.ts
var DESIRED_COUNT_MINIMUM = 1;
var DESIRED_COUNT_MAXIMUM = 20;
var DESIRED_COUNT_DEFAULT = 5;
var NUMBER_OF_VALUE_MINIMUM = 1;
var NUMBER_OF_VALUE_DEFAULT = 8;

// src/features/facets/automatic-facet-set/automatic-facet-set-state.ts
function getAutomaticFacetSetInitialState() {
  return {
    desiredCount: DESIRED_COUNT_DEFAULT,
    numberOfValues: NUMBER_OF_VALUE_DEFAULT,
    set: {}
  };
}

// src/features/facets/facet-set/facet-set-selectors.ts
function isFacetResponse(state, response) {
  return !!response && response.facetId in state.facetSet;
}
var baseFacetResponseSelector = (state, id) => state.search?.response.facets.find((response) => response.facetId === id);
var facetRequestSelector = (state, id) => state.facetSet[id]?.request;
var facetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  return isFacetResponse(state, response) ? response : void 0;
};
var facetResponseSelectedValuesSelector = (state, facetId2) => facetResponseSelector(state, facetId2)?.values.filter(
  (value) => value.state === "selected"
) || [];
var facetResponseActiveValuesSelector = (state, facetId2) => facetResponseSelector(state, facetId2)?.values.filter(
  (value) => value.state !== "idle"
) || [];
var isFacetLoadingResponseSelector = (state) => state.search.isLoading;

// src/features/facets/category-facet-set/category-facet-utils.ts
function partitionIntoParentsAndValues(nestedValues) {
  if (!nestedValues) {
    return { parents: [], values: [] };
  }
  let parents = [];
  let values = nestedValues;
  while (values.length && values[0].children.length) {
    parents = [...parents, ...values];
    values = values[0].children;
  }
  const selectedLeafValue = values.find((v) => v.state === "selected");
  if (selectedLeafValue) {
    parents = [...parents, selectedLeafValue];
    values = [];
  }
  return { parents, values };
}
function findActiveValueAncestry(valuesAsTree) {
  const { activeValue, ancestryMap } = getActiveValueAndAncestryFromValueTree(valuesAsTree);
  return activeValue ? getActiveValueAncestry(activeValue, ancestryMap) : [];
}
function getActiveValueAndAncestryFromValueTree(valuesAsTrees) {
  const valueToVisit = [...valuesAsTrees];
  const ancestryMap = /* @__PURE__ */ new Map();
  while (valueToVisit.length > 0) {
    const currentValue = valueToVisit.shift();
    if (currentValue.state === "selected") {
      return { activeValue: currentValue, ancestryMap };
    }
    if (ancestryMap) {
      for (const childValue of currentValue.children) {
        ancestryMap.set(childValue, currentValue);
      }
    }
    valueToVisit.unshift(...currentValue.children);
  }
  return {};
}
function getActiveValueAncestry(activeValue, valueToParentMap) {
  const activeValueAncestry = [];
  if (!activeValue) {
    return [];
  }
  let lastParent = activeValue;
  do {
    activeValueAncestry.unshift(lastParent);
    lastParent = valueToParentMap.get(lastParent);
  } while (lastParent);
  return activeValueAncestry;
}

// src/features/facets/category-facet-set/category-facet-set-selectors.ts
function isCategoryFacetResponse(state, response) {
  return !!response && response.facetId in state.categoryFacetSet;
}
var categoryFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isCategoryFacetResponse(state, response)) {
    return response;
  }
  return void 0;
};
var categoryFacetRequestSelector = (state, id) => {
  return state.categoryFacetSet[id]?.request;
};
var categoryFacetResponseSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = categoryFacetResponseSelector(state, facetId2);
  return findActiveValueAncestry(facetResponse?.values ?? []);
};
var categoryFacetRequestSelectedValuesSelector = (state, facetId2) => {
  const facetRequest = categoryFacetRequestSelector(state, facetId2);
  return findActiveValueAncestry(facetRequest?.currentValues ?? []);
};

// src/features/facets/category-facet-set/category-facet-set-state.ts
function getCategoryFacetSetInitialState() {
  return {};
}

// src/features/facets/range-facets/date-facet-set/date-facet-set-state.ts
function getDateFacetSetSliceInitialState(request) {
  return { request };
}
function getDateFacetSetInitialState() {
  return {};
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-set-state.ts
function getNumericFacetSetSliceInitialState(request) {
  return { request };
}
function getNumericFacetSetInitialState() {
  return {};
}

// src/features/facets/facet-set/facet-set-state.ts
function getFacetSetSliceInitialState(request) {
  return { request, hasBreadcrumbs: true };
}
function getFacetSetInitialState() {
  return {};
}

// src/features/facets/facet-set/facet-set-analytics-actions-utils.ts
var buildFacetBaseMetadata = (facetId2, state) => {
  const facet = getFacetRequest(state, facetId2);
  const facetField = facet ? facet.field : "";
  const facetTitle = getFacetTitle(facetField, facetId2);
  return { facetId: facetId2, facetField, facetTitle };
};
function buildFacetSelectionChangeMetadata(payload, state) {
  const { facetId: facetId2, facetValue } = payload;
  const base = buildFacetBaseMetadata(facetId2, state);
  const facetType = getFacetType(state, facetId2);
  return {
    ...base,
    facetValue: facetType === "hierarchical" ? getCategoryFacetSelectedValue(state, facetId2) : facetValue
  };
}
function getStateNeededForFacetMetadata(s) {
  return {
    facetSet: s.facetSet ?? getFacetSetInitialState(),
    categoryFacetSet: s.categoryFacetSet ?? getCategoryFacetSetInitialState(),
    dateFacetSet: s.dateFacetSet ?? getDateFacetSetInitialState(),
    numericFacetSet: s.numericFacetSet ?? getNumericFacetSetInitialState(),
    automaticFacetSet: s.automaticFacetSet ?? getAutomaticFacetSetInitialState()
  };
}
var buildFacetStateMetadata = (state) => {
  const facetState = [];
  getFacetRequests(state).forEach((facetRequest, facetIndex) => {
    const facetType = getFacetType(state, facetRequest.facetId);
    const facetRequestAnalytics = mapFacetRequestToAnalytics(
      facetRequest,
      facetIndex + 1
    );
    if (isCategoryFacetRequest(facetRequest)) {
      const hasSelectedValue = !!categoryFacetRequestSelectedValuesSelector(
        state,
        facetRequest.facetId
      ).length;
      if (!hasSelectedValue) {
        return;
      }
      facetState.push({
        ...facetRequestAnalytics,
        ...mapCategoryFacetValueToAnalytics(state, facetRequest.facetId),
        facetType,
        state: "selected"
      });
      return;
    }
    facetRequest.currentValues.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(
        facetValue,
        facetValueIndex + 1,
        facetType
      );
      const facetDisplayValueAnalytics = isSpecificFacetRequest(facetRequest) ? mapFacetDisplayValueToAnalytics(facetValue) : mapRangeDisplayFacetValueToAnalytics(
        facetValue
      );
      facetState.push({
        ...facetRequestAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  getAutomaticFacets(state).forEach((facet, facetIndex) => {
    const facetAnalytics = mapAutomaticFacetToAnalytics(facet, facetIndex + 1);
    facet.values.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(
        facetValue,
        facetValueIndex + 1,
        "specific"
      );
      const facetDisplayValueAnalytics = mapFacetDisplayValueToAnalytics(facetValue);
      facetState.push({
        ...facetAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  return facetState;
};
var isSpecificFacetRequest = (request) => request.type === "specific";
var isCategoryFacetRequest = (request) => request.type === "hierarchical";
var getFacetRequests = (state) => {
  return [
    ...Object.values(state.facetSet),
    ...Object.values(state.categoryFacetSet),
    ...Object.values(state.dateFacetSet),
    ...Object.values(state.numericFacetSet)
  ].map((facet) => facet.request);
};
var getAutomaticFacets = (state) => {
  return [...Object.values(state.automaticFacetSet.set)].map(
    (facet) => facet.response
  );
};
var mapFacetValueToAnalytics = (facetValue, valuePosition, facetType) => {
  return {
    state: facetValue.state,
    valuePosition,
    facetType
  };
};
var mapRangeDisplayFacetValueToAnalytics = (facetValue) => {
  return {
    displayValue: `${facetValue.start}..${facetValue.end}`,
    value: `${facetValue.start}..${facetValue.end}`,
    start: facetValue.start,
    end: facetValue.end,
    endInclusive: facetValue.endInclusive
  };
};
var mapFacetDisplayValueToAnalytics = (facetValue) => {
  return {
    displayValue: facetValue.value,
    value: facetValue.value
  };
};
var getCategoryFacetSelectedValue = (state, facetId2) => {
  const selectedCategoryFacetValues = categoryFacetRequestSelectedValuesSelector(state, facetId2);
  return selectedCategoryFacetValues.map((selectedCategoryFacetValue) => selectedCategoryFacetValue.value).join(";");
};
var mapCategoryFacetValueToAnalytics = (state, facetId2) => {
  const valuePosition = 1;
  const value = getCategoryFacetSelectedValue(state, facetId2);
  return {
    value,
    valuePosition,
    displayValue: value
  };
};
var mapAutomaticFacetToAnalytics = (facet, facetPosition) => {
  return {
    title: getFacetTitle(facet.field, facet.field),
    field: facet.field,
    id: facet.field,
    facetPosition
  };
};
var mapFacetRequestToAnalytics = (request, facetPosition) => {
  return {
    title: getFacetTitle(request.field, request.facetId),
    field: request.field,
    id: request.facetId,
    facetPosition
  };
};
var getFacetTitle = (field2, facetId2) => {
  return `${field2}_${facetId2}`;
};
var getFacetRequest = (state, facetId2) => {
  return state.facetSet[facetId2]?.request || state.categoryFacetSet[facetId2]?.request || state.dateFacetSet[facetId2]?.request || state.numericFacetSet[facetId2]?.request || state.automaticFacetSet.set[facetId2]?.response;
};
var getFacetType = (state, facetId2) => {
  const facet = getFacetRequest(state, facetId2);
  return facet ? facet.type : "specific";
};

// src/features/generated-answer/generated-answer-selectors.ts
var import_bueno3 = require("@coveo/bueno");
var import_toolkit3 = require("@reduxjs/toolkit");

// src/features/configuration/configuration-selectors.ts
var selectLocale = (state) => state.configuration.search.locale;
var selectTimezone = (state) => state.configuration.search.timezone;
var selectAgentId = (state) => state.configuration?.knowledge?.agentId;

// src/features/generated-answer/generated-answer-selectors.ts
var generativeQuestionAnsweringIdSelector = (state) => {
  if (isGeneratedAnswerFeatureEnabledWithAnswerAPI(state) || isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
    return state.generatedAnswer?.answerId;
  }
  if (isSearchSection(state)) {
    return state.search?.response?.extendedResults?.generativeQuestionAnsweringId;
  }
  return void 0;
};
var isGeneratedAnswerFeatureEnabledWithAnswerAPI = (state) => "answer" in state && "generatedAnswer" in state && !(0, import_bueno3.isNullOrUndefined)(state.generatedAnswer?.answerConfigurationId);
var isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI = (state) => {
  const agentId = selectAgentId(state);
  return "answerGenerationApi" in state && "generatedAnswer" in state && typeof agentId === "string" && agentId.trim().length > 0;
};
var isSearchSection = (state) => "search" in state && state.search !== void 0 && typeof state.search === "object";
var selectFieldsToIncludeInCitation = (state) => state.generatedAnswer?.fieldsToIncludeInCitations;
var citationSourceSelector = (0, import_toolkit3.createSelector)(
  (state) => state.generatedAnswer?.citations,
  (_state, citationId) => citationId,
  (citations, citationId) => citations?.find(
    (citation) => citation.id === citationId
  )
);

// src/features/query/query-state.ts
var getQueryInitialState = () => ({
  q: "",
  enableQuerySyntax: false
});

// src/features/sort-criteria/criteria.ts
var import_bueno4 = require("@coveo/bueno");
var SortOrder = /* @__PURE__ */ ((SortOrder2) => {
  SortOrder2["Ascending"] = "ascending";
  SortOrder2["Descending"] = "descending";
  return SortOrder2;
})(SortOrder || {});
var SortBy = /* @__PURE__ */ ((SortBy3) => {
  SortBy3["Relevancy"] = "relevancy";
  SortBy3["QRE"] = "qre";
  SortBy3["Date"] = "date";
  SortBy3["Field"] = "field";
  SortBy3["NoSort"] = "nosort";
  return SortBy3;
})(SortBy || {});
var buildCriterionExpression = (criterion) => {
  if ((0, import_bueno4.isArray)(criterion)) {
    return criterion.map((c) => buildCriterionExpression(c)).join(",");
  }
  switch (criterion.by) {
    case "relevancy" /* Relevancy */:
    case "qre" /* QRE */:
    case "nosort" /* NoSort */:
      return criterion.by;
    case "date" /* Date */:
      return `date ${criterion.order}`;
    case "field" /* Field */:
      return `@${criterion.field} ${criterion.order}`;
    default:
      return "";
  }
};
var buildRelevanceSortCriterion = () => ({
  by: "relevancy" /* Relevancy */
});
var buildDateSortCriterion = (order) => ({
  by: "date" /* Date */,
  order
});
var buildFieldSortCriterion = (field2, order) => ({
  by: "field" /* Field */,
  order,
  field: field2
});
var buildQueryRankingExpressionSortCriterion = () => ({
  by: "qre" /* QRE */
});
var buildNoSortCriterion = () => ({ by: "nosort" /* NoSort */ });
var criterionDefinition = new import_bueno4.RecordValue({
  values: {
    by: new import_bueno4.EnumValue({ enum: SortBy, required: true }),
    order: new import_bueno4.EnumValue({ enum: SortOrder }),
    field: new import_bueno4.StringValue()
  }
});

// src/features/sort-criteria/sort-criteria-state.ts
function getSortCriteriaInitialState() {
  return buildCriterionExpression(buildRelevanceSortCriterion());
}

// src/api/analytics/coveo.analytics/cookie.ts
var Cookie2 = class _Cookie {
  static set(name, value, expire) {
    let domain, expirationDate, domainParts;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    const host = window.location.hostname;
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
    if (ipv4Regex.test(host) || ipv6Regex.test(host)) {
      writeCookie2(name, value, expirationDate);
    } else if (host.indexOf(".") === -1) {
      writeCookie2(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie2(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    const cookiePrefix = name + "=";
    const cookieArray = document.cookie.split(";");
    for (let i = 0; i < cookieArray.length; i++) {
      let cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie2(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}

// src/api/analytics/coveo.analytics/detector.ts
function hasNavigator2() {
  return typeof navigator !== "undefined";
}
function hasLocalStorage2() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage2() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage2() {
  return Boolean(hasNavigator2() && navigator.cookieEnabled);
}

// src/api/analytics/coveo.analytics/storage.ts
var preferredStorage = null;
function getAvailableStorage2() {
  if (preferredStorage) {
    return preferredStorage;
  }
  if (hasLocalStorage2()) {
    return localStorage;
  }
  if (hasCookieStorage2()) {
    return new CookieStorage2();
  }
  if (hasSessionStorage2()) {
    return sessionStorage;
  }
  return new NullStorage2();
}
var _CookieStorage = class _CookieStorage {
  getItem(key) {
    return Cookie2.get(`${_CookieStorage.prefix}${key}`);
  }
  removeItem(key) {
    Cookie2.erase(`${_CookieStorage.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie2.set(`${_CookieStorage.prefix}${key}`, data, expire);
  }
};
__publicField(_CookieStorage, "prefix", "coveo_");
var CookieStorage2 = _CookieStorage;
var NullStorage2 = class {
  getItem(_key) {
    return null;
  }
  removeItem(_key) {
  }
  setItem(_key, _data) {
  }
};

// src/api/analytics/coveo.analytics/history-store.ts
var STORE_KEY2 = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS2 = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE2 = 1e3 * 60;
var MAX_VALUE_SIZE2 = 75;
var _HistoryStore = class _HistoryStore {
  constructor(store) {
    __publicField(this, "store");
    this.store = store || getAvailableStorage2();
  }
  static getInstance(store) {
    if (!_HistoryStore.instance) {
      _HistoryStore.instance = new _HistoryStore(store);
    }
    return _HistoryStore.instance;
  }
  /**
   * @deprecated Synchronous method is deprecated, use addElementAsync instead. This method will NOT work with react-native.
   */
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  async addElementAsync(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = await this.getHistoryWithInternalTimeAsync();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  /**
   * @deprecated Synchronous method is deprecated, use getHistoryAsync instead. This method will NOT work with react-native.
   */
  getHistory() {
    const history2 = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history2));
  }
  async getHistoryAsync() {
    const history2 = await this.getHistoryWithInternalTimeAsync();
    return this.stripEmptyQueries(this.stripInternalTime(history2));
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY2);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  async getHistoryWithInternalTimeAsync() {
    try {
      const elements = await this.store.getItem(STORE_KEY2);
      if (elements) {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  setHistory(history2) {
    try {
      this.store.setItem(
        STORE_KEY2,
        JSON.stringify(history2.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS2))
      );
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY2);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    const currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort(
        (first, second) => {
          return (second.internalTime || 0) - (first.internalTime || 0);
        }
      );
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE2);
    }
    return part;
  }
  isValidEntry(elem) {
    const lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value === elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE2;
    }
    return true;
  }
  stripInternalTime(history2) {
    if (Array.isArray(history2)) {
      return history2.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history2) {
    return history2.map((part) => this.stripEmptyQuery(part));
  }
};
__publicField(_HistoryStore, "instance", null);
var HistoryStore2 = _HistoryStore;
var history_store_default = HistoryStore2;

// src/api/analytics/search-analytics.ts
var _SearchAnalyticsProvider = class _SearchAnalyticsProvider extends BaseAnalyticsProvider {
  constructor() {
    super(...arguments);
    __publicField(this, "getFacetRequest", (id) => {
      return this.state.facetSet?.[id]?.request || this.state.categoryFacetSet?.[id]?.request || this.state.dateFacetSet?.[id]?.request || this.state.numericFacetSet?.[id]?.request || this.state.automaticFacetSet?.set[id]?.response;
    });
  }
  getFacetState() {
    return buildFacetStateMetadata(
      getStateNeededForFacetMetadata(this.getState())
    );
  }
  getPipeline() {
    return this.state.pipeline || this.state.search?.response.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
  }
  getSearchEventRequestPayload() {
    return {
      queryText: this.queryText,
      responseTime: this.responseTime,
      results: this.resultURIs,
      numberOfResults: this.numberOfResults
    };
  }
  getSearchUID() {
    const newState = this.getState();
    return newState.search?.searchResponseId || newState.search?.response.searchUid || getSearchInitialState().response.searchUid;
  }
  getSplitTestRunName() {
    return this.state.search?.response.splitTestRun;
  }
  getSplitTestRunVersion() {
    const hasSplitTestRun = !!this.getSplitTestRunName();
    const effectivePipelineWithSplitTestRun = this.state.search?.response.pipeline || this.state.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
    return hasSplitTestRun ? effectivePipelineWithSplitTestRun : void 0;
  }
  getBaseMetadata() {
    const state = this.getState();
    const baseObject = super.getBaseMetadata();
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (generativeQuestionAnsweringId) {
      baseObject.generativeQuestionAnsweringId = generativeQuestionAnsweringId;
    }
    return baseObject;
  }
  getFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetValue,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetClearAllMetadata(facetId2) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetUpdateSortMetadata(facetId2, criteria) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      criteria,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getRangeBreadcrumbFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetRangeEnd: facetValue.end,
      facetRangeEndInclusive: facetValue.endInclusive,
      facetRangeStart: facetValue.start,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getResultSortMetadata() {
    return {
      ...this.getBaseMetadata(),
      resultsSortBy: this.state.sortCriteria ?? getSortCriteriaInitialState()
    };
  }
  getStaticFilterToggleMetadata(staticFilterId, staticFilterValue) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId,
      staticFilterValue
    };
  }
  getStaticFilterClearAllMetadata(staticFilterId) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId
    };
  }
  getUndoTriggerQueryMetadata(undoneQuery) {
    return {
      ...this.getBaseMetadata(),
      undoneQuery
    };
  }
  getCategoryBreadcrumbFacetMetadata(categoryFacetId, categoryFacetPath) {
    const facetRequest = this.getFacetRequest(categoryFacetId);
    const categoryFacetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      categoryFacetId,
      categoryFacetField,
      categoryFacetPath,
      categoryFacetTitle: `${categoryFacetField}_${categoryFacetId}`
    };
  }
  getOmniboxAnalyticsMetadata(id, suggestion) {
    const querySuggest = this.state.querySuggest?.[id];
    const suggestions = querySuggest.completions.map(
      (completion) => completion.expression
    );
    const lastIndex = querySuggest.partialQueries.length - 1;
    const partialQuery = querySuggest.partialQueries[lastIndex] || "";
    const querySuggestResponseId = querySuggest.responseId;
    return {
      ...this.getBaseMetadata(),
      suggestionRanking: suggestions.indexOf(suggestion),
      partialQuery,
      partialQueries: querySuggest.partialQueries.length > 0 ? querySuggest.partialQueries : "",
      suggestions: suggestions.length > 0 ? suggestions : "",
      querySuggestResponseId
    };
  }
  getInterfaceChangeMetadata() {
    return {
      ...this.getBaseMetadata(),
      interfaceChangeTo: this.state.configuration.analytics.originLevel2
    };
  }
  getOmniboxFromLinkMetadata(metadata) {
    return {
      ...this.getBaseMetadata(),
      ...metadata
    };
  }
  getGeneratedAnswerMetadata() {
    const state = this.getState();
    const formattedObject = {};
    if (state.generatedAnswer?.isVisible !== void 0) {
      formattedObject.showGeneratedAnswer = state.generatedAnswer.isVisible;
    }
    return formattedObject;
  }
  get resultURIs() {
    return this.results?.map((r) => ({
      documentUri: r.uri,
      documentUriHash: r.raw.urihash
    }));
  }
  get results() {
    return this.state.search?.response.results;
  }
  get queryText() {
    return this.state.query?.q || getQueryInitialState().q;
  }
  get responseTime() {
    return this.state.search?.duration || getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.state.search?.response.totalCountFiltered || getSearchInitialState().response.totalCountFiltered;
  }
};
__publicField(_SearchAnalyticsProvider, "fallbackPipelineName", "default");
var SearchAnalyticsProvider = _SearchAnalyticsProvider;
var configureLegacyAnalytics = ({
  logger,
  getState,
  analyticsClientMiddleware = (_, p) => p,
  preprocessRequest,
  provider
}) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment,
    "analytics"
  );
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CoveoSearchPageClient(
    {
      token,
      endpoint,
      runtimeEnvironment,
      preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
      beforeSendHooks: [
        wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
        (type, payload) => {
          logger.info(
            {
              ...payload,
              type,
              endpoint,
              token
            },
            "Analytics request"
          );
          return payload;
        }
      ]
    },
    provider
  );
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};
var getPageID = () => {
  const actions = history_store_default.getInstance().getHistory();
  const lastPageView = actions.reverse().find((action) => {
    return action.name === "PageView" && action.value;
  });
  if (!lastPageView) {
    return "";
  }
  return lastPageView.value;
};

// src/features/folding/folding-utils.ts
function getAllIncludedResultsFrom(relevantResult) {
  const foldedResults = getChildResultsRecursively(relevantResult);
  const parentResults = [relevantResult, ...foldedResults].filter((result) => result.parentResult).map((result) => result.parentResult);
  const resultsInCollection = removeDuplicates(
    [relevantResult, ...foldedResults, ...parentResults],
    (result) => result.uniqueId
  );
  return resultsInCollection;
}
function getChildResultsRecursively(result) {
  if (!result.childResults) {
    return [];
  }
  return result.childResults.flatMap((childResult) => [
    childResult,
    ...getChildResultsRecursively(childResult)
  ]);
}

// src/features/pipeline/pipeline-state.ts
var getPipelineInitialState = () => "";

// src/features/analytics/analytics-utils.ts
function makeBasicNewSearchAnalyticsAction(actionCause, getState) {
  return {
    ...new SearchAnalyticsProvider(getState).getBaseMetadata(),
    actionCause,
    type: actionCause
  };
}
function makeInstantlyCallable(action) {
  return Object.assign(action, { instantlyCallable: true });
}
function makePreparableAnalyticsAction(prefix, buildEvent) {
  const createAnalyticsAction = (body) => makeInstantlyCallable(
    (0, import_toolkit4.createAsyncThunk)(prefix, body)
  );
  const rootAction = createAnalyticsAction(async (_, { getState, extra }) => {
    const { analyticsClientMiddleware, preprocessRequest, logger } = extra;
    return await (await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    })).log({ state: getState(), extra });
  });
  const prepare = async ({
    getState,
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  }) => {
    const { description, log } = await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    });
    return {
      description,
      action: createAnalyticsAction(
        async (_, { getState: getNewState, extra: newExtra }) => {
          return await log({ state: getNewState(), extra: newExtra });
        }
      )
    };
  };
  Object.assign(rootAction, {
    prepare
  });
  return rootAction;
}
var makeAnalyticsActionFactory = (configurator, legacyGetBuilderConverter, providerClass) => {
  function makeAnalyticsAction2(...params) {
    const options = params.length === 1 ? {
      ...params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(
        params[0].__legacy__getBuilder
      ),
      analyticsConfigurator: configurator,
      providerClass
    } : {
      prefix: params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[1]),
      __legacy__provider: params[2],
      analyticsConfigurator: configurator,
      providerClass
    };
    return internalMakeAnalyticsAction(options);
  }
  return makeAnalyticsAction2;
};
var shouldSendLegacyEvent = (state) => state.configuration.analytics.analyticsMode === "legacy";
var shouldSendNextEvent = (state) => state.configuration.analytics.analyticsMode === "next";
var internalMakeAnalyticsAction = ({
  prefix,
  __legacy__getBuilder,
  __legacy__provider,
  analyticsPayloadBuilder,
  analyticsType,
  analyticsConfigurator,
  providerClass
}) => {
  __legacy__provider ?? (__legacy__provider = (getState) => new providerClass(getState));
  return makePreparableAnalyticsAction(
    prefix,
    async ({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    }) => {
      const loggers = [];
      const analyticsAction = {
        log: async ({ state: state2 }) => {
          for (const log of loggers) {
            await log(state2);
          }
        }
      };
      const state = getState();
      const client = analyticsConfigurator({
        getState,
        logger,
        analyticsClientMiddleware,
        preprocessRequest,
        provider: __legacy__provider(getState)
      });
      const builder = await __legacy__getBuilder(client, getState());
      analyticsAction.description = builder?.description;
      loggers.push(async (state2) => {
        if (shouldSendLegacyEvent(state2)) {
          await logLegacyEvent(
            builder,
            __legacy__provider,
            state2,
            logger,
            client.coveoAnalyticsClient
          );
        }
      });
      const { emit } = getRelayInstanceFromState(state);
      loggers.push(async (state2) => {
        if (shouldSendNextEvent(state2) && analyticsType && analyticsPayloadBuilder) {
          const payload = analyticsPayloadBuilder(state2);
          await logNextEvent(emit, analyticsType, payload);
        }
      });
      return analyticsAction;
    }
  );
};
async function logLegacyEvent(builder, __legacy__provider, state, logger, client) {
  __legacy__provider(() => state);
  const response = await builder?.log({
    searchUID: __legacy__provider(() => state).getSearchUID()
  });
  logger.info({ client, response }, "Analytics response");
}
var fromLogToLegacyBuilderFactory = (actionCause) => {
  const fromLogToLegacyBuilder = (log) => {
    return (client, state) => Promise.resolve({
      description: { actionCause },
      log: async (_metadata) => {
        log(client, state);
      }
    });
  };
  return fromLogToLegacyBuilder;
};
var makeAnalyticsAction = makeAnalyticsActionFactory(
  (options) => configureLegacyAnalytics({
    ...options,
    provider: options.provider || new SearchAnalyticsProvider(options.getState)
  }),
  (original) => original,
  SearchAnalyticsProvider
);
var makeCaseAssistAnalyticsAction = makeAnalyticsActionFactory(
  configureCaseAssistAnalytics,
  fromLogToLegacyBuilderFactory("caseAssist"),
  CaseAssistAnalyticsProvider
);
var partialDocumentInformation = (result, state) => {
  const paginationBasedIndex = (index) => index + (state.pagination?.firstResult ?? 0);
  let resultIndex = -1;
  const parentResults = state.search?.results;
  resultIndex = findPositionWithUniqueId(result, parentResults);
  if (resultIndex < 0) {
    resultIndex = findPositionInChildResults(result, parentResults);
  }
  if (resultIndex < 0) {
    resultIndex = 0;
  }
  return buildPartialDocumentInformation(
    result,
    paginationBasedIndex(resultIndex),
    state
  );
};
function buildPartialDocumentInformation(result, resultIndex, state) {
  const collection = result.raw.collection;
  const collectionName = typeof collection === "string" ? collection : "default";
  return {
    collectionName,
    documentAuthor: getDocumentAuthor(result),
    documentPosition: resultIndex + 1,
    documentTitle: result.title,
    documentUri: result.uri,
    documentUriHash: result.raw.urihash,
    documentUrl: result.clickUri,
    rankingModifier: result.rankingModifier || "",
    sourceName: getSourceName(result),
    queryPipeline: state.pipeline || getPipelineInitialState()
  };
}
var documentIdentifier = (result) => {
  if (!result.raw.permanentid) {
    console.warn(
      "Missing field permanentid on result. This might cause many issues with your Coveo deployment. See https://docs.coveo.com/en/1913 and https://docs.coveo.com/en/1640 for more information.",
      result
    );
  }
  return {
    contentIDKey: "permanentid",
    contentIDValue: result.raw.permanentid || ""
  };
};
var rawPartialDefinition = {
  urihash: new import_bueno5.StringValue(),
  sourcetype: new import_bueno5.StringValue(),
  permanentid: new import_bueno5.StringValue()
};
var resultPartialDefinition = {
  uniqueId: requiredNonEmptyString,
  raw: new import_bueno5.RecordValue({ values: rawPartialDefinition }),
  title: requiredNonEmptyString,
  uri: requiredNonEmptyString,
  clickUri: requiredNonEmptyString,
  rankingModifier: new import_bueno5.StringValue({ required: false, emptyAllowed: true })
};
function partialRawPayload(raw) {
  return Object.assign(
    {},
    ...Object.keys(rawPartialDefinition).map((key) => ({ [key]: raw[key] }))
  );
}
function partialResultPayload(result) {
  return Object.assign(
    {},
    ...Object.keys(resultPartialDefinition).map((key) => ({
      [key]: result[key]
    })),
    { raw: partialRawPayload(result.raw) }
  );
}
function getDocumentAuthor(result) {
  const author = result.raw.author;
  if ((0, import_bueno5.isNullOrUndefined)(author)) {
    return "unknown";
  }
  return Array.isArray(author) ? author.join(";") : `${author}`;
}
function getSourceName(result) {
  const source = result.raw.source;
  if ((0, import_bueno5.isNullOrUndefined)(source)) {
    return "unknown";
  }
  return source;
}
var validateResultPayload = (result) => new import_bueno5.Schema(resultPartialDefinition).validate(partialResultPayload(result));
function findPositionInChildResults(targetResult, parentResults) {
  for (const [i, parent] of parentResults.entries()) {
    const children = getAllIncludedResultsFrom(parent);
    const childIndex = findPositionWithUniqueId(targetResult, children);
    if (childIndex !== -1) {
      return i;
    }
  }
  return -1;
}
function findPositionWithUniqueId(targetResult, results = []) {
  return results.findIndex(({ uniqueId }) => uniqueId === targetResult.uniqueId);
}
async function logNextEvent(emitEvent, type, payload) {
  await emitEvent(type, payload);
  return;
}

// src/features/analytics/analytics-actions.ts
var validateEvent = (p) => validatePayload(p, {
  evt: requiredNonEmptyString,
  type: nonEmptyString
});
var logSearchEvent = (p) => makeAnalyticsAction("analytics/generic/search", (client) => {
  validateEvent(p);
  const { evt, meta } = p;
  return client.makeSearchEvent(evt, meta);
});
var logClickEvent = (p) => makeAnalyticsAction("analytics/generic/click", (client, state) => {
  validateResultPayload(p.result);
  validateEvent(p);
  return client.makeClickEvent(
    p.evt,
    partialDocumentInformation(p.result, state),
    documentIdentifier(p.result),
    p.meta
  );
});
var logCustomEvent = (p) => makeAnalyticsAction("analytics/generic/custom", (client) => {
  validateEvent(p);
  return client.makeCustomEventWithType(p.evt, p.type, p.meta);
});
var logInterfaceLoad = () => makeAnalyticsAction(
  "analytics/interface/load",
  (client) => client.makeInterfaceLoad()
);
var logInterfaceChange = () => makeAnalyticsAction(
  "analytics/interface/change",
  (client, state) => client.makeInterfaceChange({
    interfaceChangeTo: state.configuration.analytics.originLevel2
  })
);
var logSearchFromLink = () => makeAnalyticsAction(
  "analytics/interface/searchFromLink",
  (client) => client.makeSearchFromLink()
);
var logOmniboxFromLink = (metadata) => makeAnalyticsAction(
  "analytics/interface/omniboxFromLink",
  (client) => client.makeOmniboxFromLink(metadata)
);
var interfaceLoad = () => ({
  actionCause: "interfaceLoad" /* interfaceLoad */
});
var interfaceChange = () => ({
  actionCause: "interfaceChange" /* interfaceChange */
});
var searchFromLink = () => ({
  actionCause: "searchFromLink" /* searchFromLink */
});
var omniboxFromLink = () => ({
  actionCause: "omniboxFromLink" /* omniboxFromLink */
});

// src/features/configuration/configuration-actions.ts
var import_bueno6 = require("@coveo/bueno");
var import_toolkit5 = require("@reduxjs/toolkit");
var originSchemaOnConfigUpdate = () => nonEmptyString;
var originSchemaOnUpdate = () => requiredNonEmptyString;
var updateBasicConfiguration = (0, import_toolkit5.createAction)(
  "configuration/updateBasicConfiguration",
  (payload) => validatePayload(payload, {
    accessToken: nonEmptyString,
    environment: new import_bueno6.StringValue({
      required: false,
      constrainTo: ["prod", "hipaa", "stg", "dev"]
    }),
    organizationId: nonEmptyString
  })
);
var updateSearchConfiguration = (0, import_toolkit5.createAction)(
  "configuration/updateSearchConfiguration",
  (payload) => {
    return validatePayload(payload, {
      proxyBaseUrl: new import_bueno6.StringValue({ required: false, url: true }),
      pipeline: new import_bueno6.StringValue({ required: false, emptyAllowed: true }),
      searchHub: nonEmptyString,
      timezone: nonEmptyString,
      locale: nonEmptyString,
      authenticationProviders: new import_bueno6.ArrayValue({
        required: false,
        each: requiredNonEmptyString
      })
    });
  }
);
var analyticsConfigurationSchema = {
  enabled: new import_bueno6.BooleanValue({ default: true }),
  originContext: originSchemaOnConfigUpdate(),
  originLevel2: originSchemaOnConfigUpdate(),
  originLevel3: originSchemaOnConfigUpdate(),
  proxyBaseUrl: new import_bueno6.StringValue({ required: false, url: true }),
  runtimeEnvironment: new import_bueno6.Value(),
  anonymous: new import_bueno6.BooleanValue({ default: false }),
  deviceId: nonEmptyString,
  userDisplayName: nonEmptyString,
  documentLocation: nonEmptyString,
  trackingId: optionalTrackingId,
  analyticsMode: new import_bueno6.StringValue({
    constrainTo: ["legacy", "next"],
    required: false,
    default: "next"
  }),
  source: new import_bueno6.RecordValue({
    options: { required: false },
    values: COVEO_FRAMEWORK.reduce(
      (acc, framework) => {
        acc[framework] = optionalNonEmptyVersionString;
        return acc;
      },
      {}
    )
  })
};
var updateAnalyticsConfiguration = (0, import_toolkit5.createAction)(
  "configuration/updateAnalyticsConfiguration",
  (payload) => {
    return validatePayload(payload, analyticsConfigurationSchema);
  }
);
var disableAnalytics = (0, import_toolkit5.createAction)("configuration/analytics/disable");
var enableAnalytics = (0, import_toolkit5.createAction)("configuration/analytics/enable");
var setOriginLevel2 = (0, import_toolkit5.createAction)(
  "configuration/analytics/originlevel2",
  (payload) => validatePayload(payload, { originLevel2: originSchemaOnUpdate() })
);
var setOriginLevel3 = (0, import_toolkit5.createAction)(
  "configuration/analytics/originlevel3",
  (payload) => validatePayload(payload, { originLevel3: originSchemaOnUpdate() })
);
var setAgentId = (0, import_toolkit5.createAction)(
  "knowledge/setAgentId",
  (payload) => validatePayload(payload, new import_bueno6.StringValue({ required: true }))
);

// src/features/debug/debug-slice.ts
var import_toolkit8 = require("@reduxjs/toolkit");

// src/features/search-parameters/search-parameter-actions.ts
var import_toolkit6 = require("@reduxjs/toolkit");

// src/features/search-parameters/search-parameter-schema.ts
var import_bueno7 = require("@coveo/bueno");
var searchParametersDefinition = {
  q: new import_bueno7.StringValue(),
  enableQuerySyntax: new import_bueno7.BooleanValue(),
  aq: new import_bueno7.StringValue(),
  cq: new import_bueno7.StringValue(),
  firstResult: new import_bueno7.NumberValue({ min: 0 }),
  numberOfResults: new import_bueno7.NumberValue({ min: 0 }),
  sortCriteria: new import_bueno7.StringValue(),
  f: new import_bueno7.RecordValue(),
  fExcluded: new import_bueno7.RecordValue(),
  cf: new import_bueno7.RecordValue(),
  nf: new import_bueno7.RecordValue(),
  mnf: new import_bueno7.RecordValue(),
  df: new import_bueno7.RecordValue(),
  debug: new import_bueno7.BooleanValue(),
  sf: new import_bueno7.RecordValue(),
  tab: new import_bueno7.StringValue(),
  af: new import_bueno7.RecordValue()
};

// src/features/search-parameters/search-parameter-actions.ts
var restoreSearchParameters = (0, import_toolkit6.createAction)(
  "searchParameters/restore",
  (payload) => validatePayload(payload, searchParametersDefinition)
);
var restoreTab = (0, import_toolkit6.createAction)(
  "searchParameters/restoreTab",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);

// src/features/debug/debug-actions.ts
var import_toolkit7 = require("@reduxjs/toolkit");
var enableDebug = (0, import_toolkit7.createAction)("debug/enable");
var disableDebug = (0, import_toolkit7.createAction)("debug/disable");

// src/features/debug/debug-state.ts
var getDebugInitialState = () => false;

// src/features/debug/debug-slice.ts
var debugReducer = (0, import_toolkit8.createReducer)(getDebugInitialState(), (builder) => {
  builder.addCase(enableDebug, () => true).addCase(disableDebug, () => false).addCase(restoreSearchParameters, (state, action) => {
    return action.payload.debug ?? state;
  });
});

// src/features/pipeline/pipeline-slice.ts
var import_toolkit11 = require("@reduxjs/toolkit");

// src/features/history/history-actions.ts
var import_toolkit9 = require("@reduxjs/toolkit");
var undo = (0, import_toolkit9.createAction)("history/undo");
var redo = (0, import_toolkit9.createAction)("history/redo");
var snapshot = (0, import_toolkit9.createAction)("history/snapshot");
var back = (0, import_toolkit9.createAsyncThunk)("history/back", async (_, { dispatch }) => {
  dispatch(undo());
  await dispatch(change());
});
var forward = (0, import_toolkit9.createAsyncThunk)(
  "history/forward",
  async (_, { dispatch }) => {
    dispatch(redo());
    await dispatch(change());
  }
);
var change = (0, import_toolkit9.createAsyncThunk)(
  "history/change",
  async (_, { getState }) => {
    const s = getState();
    return s.history.present;
  }
);

// src/features/pipeline/pipeline-actions.ts
var import_bueno8 = require("@coveo/bueno");
var import_toolkit10 = require("@reduxjs/toolkit");
var setPipeline = (0, import_toolkit10.createAction)(
  "pipeline/set",
  (payload) => validatePayload(
    payload,
    new import_bueno8.StringValue({ required: true, emptyAllowed: true })
  )
);

// src/features/pipeline/pipeline-slice.ts
var pipelineReducer = (0, import_toolkit11.createReducer)(
  getPipelineInitialState(),
  (builder) => {
    builder.addCase(setPipeline, (_, action) => action.payload).addCase(
      change.fulfilled,
      (state, action) => action.payload?.pipeline ?? state
    ).addCase(
      updateSearchConfiguration,
      (state, action) => action.payload.pipeline || state
    );
  }
);

// src/features/search/search-actions.ts
var import_bueno21 = require("@coveo/bueno");
var import_toolkit21 = require("@reduxjs/toolkit");

// src/features/breadcrumb/breadcrumb-actions.ts
var import_toolkit12 = require("@reduxjs/toolkit");
var deselectAllBreadcrumbs = (0, import_toolkit12.createAction)("breadcrumb/deselectAll");
var deselectAllNonBreadcrumbs = (0, import_toolkit12.createAction)(
  "breadcrumb/deselectAllNonBreadcrumbs"
);

// src/features/facets/generic/facet-actions.ts
var import_bueno9 = require("@coveo/bueno");
var import_toolkit13 = require("@reduxjs/toolkit");
var updateFacetAutoSelection = (0, import_toolkit13.createAction)(
  "facet/updateFacetAutoSelection",
  (payload) => validatePayload(payload, {
    allow: new import_bueno9.BooleanValue({ required: true })
  })
);

// src/api/analytics/instant-result-analytics.ts
var InstantResultsAnalyticsProvider = class extends SearchAnalyticsProvider {
  constructor(getState) {
    super(getState);
    this.getState = getState;
  }
  get activeInstantResultQuery() {
    const state = this.getState().instantResults;
    for (const id in state) {
      for (const query2 in state[id].cache) {
        if (state[id].cache[query2].isActive) {
          return state[id].q;
        }
      }
    }
    return null;
  }
  get activeInstantResultCache() {
    const state = this.getState().instantResults;
    for (const id in state) {
      for (const query2 in state[id].cache) {
        if (state[id].cache[query2].isActive) {
          return state[id].cache[query2];
        }
      }
    }
    return null;
  }
  get results() {
    return this.activeInstantResultCache?.results;
  }
  get queryText() {
    return this.activeInstantResultQuery ?? getQueryInitialState().q;
  }
  get responseTime() {
    return this.activeInstantResultCache?.duration ?? getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.activeInstantResultCache?.totalCountFiltered ?? getSearchInitialState().response.totalCountFiltered;
  }
  getSearchUID() {
    const searchUid = this.activeInstantResultCache?.searchUid;
    return searchUid || super.getSearchUID();
  }
};

// src/features/instant-results/instant-result-analytics-actions.ts
var logInstantResultsSearch = () => makeAnalyticsAction(
  "analytics/instantResult/searchboxAsYouType",
  (client) => client.makeSearchboxAsYouType(),
  (getState) => new InstantResultsAnalyticsProvider(getState)
);
var searchboxAsYouType = () => ({
  actionCause: "searchboxAsYouType" /* searchboxAsYouType */
});

// src/features/instant-results/instant-results-actions.ts
var import_toolkit14 = require("@reduxjs/toolkit");
var instantResultsRegisterDefinition = {
  id: requiredNonEmptyString
};
var instantResultsQueryDefinition = {
  ...instantResultsRegisterDefinition,
  q: requiredEmptyAllowedString
};
var registerInstantResults = (0, import_toolkit14.createAction)(
  "instantResults/register",
  (payload) => validatePayload(payload, instantResultsRegisterDefinition)
);
var updateInstantResultsQuery = (0, import_toolkit14.createAction)(
  "instantResults/updateQuery",
  (payload) => validatePayload(payload, instantResultsQueryDefinition)
);
var clearExpiredResults = (0, import_toolkit14.createAction)(
  "instantResults/clearExpired",
  (payload) => validatePayload(payload, instantResultsRegisterDefinition)
);

// src/features/pagination/pagination-actions.ts
var import_bueno10 = require("@coveo/bueno");
var import_toolkit15 = require("@reduxjs/toolkit");
var numberValue = new import_bueno10.NumberValue({ required: true, min: 0 });
var registerNumberOfResults = (0, import_toolkit15.createAction)(
  "pagination/registerNumberOfResults",
  (payload) => validatePayload(payload, numberValue)
);
var updateNumberOfResults = (0, import_toolkit15.createAction)(
  "pagination/updateNumberOfResults",
  (payload) => validatePayload(payload, numberValue)
);
var registerPage = (0, import_toolkit15.createAction)(
  "pagination/registerPage",
  (payload) => validatePayload(payload, numberValue)
);
var updatePage = (0, import_toolkit15.createAction)(
  "pagination/updatePage",
  (payload) => validatePayload(payload, numberValue)
);
var nextPage = (0, import_toolkit15.createAction)("pagination/nextPage");
var previousPage = (0, import_toolkit15.createAction)("pagination/previousPage");

// src/features/query/query-actions.ts
var import_bueno11 = require("@coveo/bueno");
var import_toolkit16 = require("@reduxjs/toolkit");
var updateQuery = (0, import_toolkit16.createAction)(
  "query/updateQuery",
  (payload) => validatePayload(payload, {
    q: new import_bueno11.StringValue(),
    enableQuerySyntax: new import_bueno11.BooleanValue()
  })
);

// src/features/search-and-folding/search-and-folding-request.ts
var import_bueno12 = require("@coveo/bueno");

// src/features/configuration/analytics-params.ts
var fromAnalyticsStateToAnalyticsParams = (s, navigatorContext, eventDescription) => {
  return {
    analytics: {
      clientId: navigatorContext.clientId,
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: navigatorContext.referrer,
      documentLocation: navigatorContext.location,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause
      },
      ...eventDescription && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.deviceId && { deviceId: s.deviceId },
      ...s.trackingId && { trackingId: s.trackingId },
      ...{
        capture: navigatorContext.capture ?? navigatorContext.clientId !== ""
      },
      ...{ source: getAnalyticsSource(s) }
    }
  };
};

// src/features/search-and-folding/search-and-folding-request.ts
var buildSearchAndFoldingLoadCollectionRequest = (state, navigatorContext, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: navigatorContext.referrer,
    timezone: state.configuration.search.timezone,
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && fromAnalyticsStateToAnalyticsParams(
      state.configuration.analytics,
      navigatorContext,
      eventDescription
    ),
    ...state.excerptLength && !(0, import_bueno12.isNullOrUndefined)(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/search/legacy/search-actions.ts
var import_bueno19 = require("@coveo/bueno");
var import_toolkit19 = require("@reduxjs/toolkit");

// src/features/search-and-folding/legacy/search-and-folding-request.ts
var import_bueno13 = require("@coveo/bueno");

// src/features/configuration/legacy-analytics-params.ts
var fromAnalyticsStateToAnalyticsParams2 = async (s, eventDescription) => {
  const isNextAnalytics = s.analyticsMode === "next";
  return {
    analytics: {
      clientId: await getVisitorID(s),
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: s.originLevel3,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause,
        customData: eventDescription.customData
      },
      ...eventDescription && !isNextAnalytics && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.documentLocation && { documentLocation: s.documentLocation },
      ...s.deviceId && { deviceId: s.deviceId },
      ...getPageID() && { pageId: getPageID() },
      ...isNextAnalytics && s.trackingId && { trackingId: s.trackingId },
      ...{ capture: isNextAnalytics },
      ...isNextAnalytics && { source: getAnalyticsSource(s) }
    }
  };
};

// src/features/search-and-folding/legacy/search-and-folding-request.ts
var buildSearchAndFoldingLoadCollectionRequest2 = async (state, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: state.configuration.analytics.originLevel3,
    timezone: state.configuration.search.timezone,
    ...state.configuration.analytics.enabled && {
      actionsHistory: history_store_default.getInstance().getHistory()
    },
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && await fromAnalyticsStateToAnalyticsParams2(
      state.configuration.analytics,
      eventDescription
    ),
    ...state.excerptLength && !(0, import_bueno13.isNullOrUndefined)(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/advanced-search-queries/advanced-search-queries-state.ts
var getAdvancedSearchQueriesInitialState = () => ({
  cq: "",
  cqWasSet: false,
  aq: "",
  aqWasSet: false,
  lq: "",
  lqWasSet: false,
  dq: "",
  dqWasSet: false,
  defaultFilters: {
    cq: "",
    aq: "",
    lq: "",
    dq: ""
  }
});

// src/features/search/search-analytics-actions.ts
var logFetchMoreResults = () => makeAnalyticsAction(
  "search/logFetchMoreResults",
  (client) => client.makeFetchMoreResults()
);
var logQueryError = (error) => makeAnalyticsAction(
  "search/queryError",
  (client, state) => client.makeQueryError({
    query: state.query?.q || getQueryInitialState().q,
    aq: state.advancedSearchQueries?.aq || getAdvancedSearchQueriesInitialState().aq,
    cq: state.advancedSearchQueries?.cq || getAdvancedSearchQueriesInitialState().cq,
    dq: state.advancedSearchQueries?.dq || getAdvancedSearchQueriesInitialState().dq,
    errorType: error.type,
    errorMessage: error.message
  })
);

// src/api/search/date/relative-date.ts
var import_bueno14 = require("@coveo/bueno");
var import_dayjs2 = __toESM(require("dayjs"), 1);
var import_quarterOfYear = __toESM(require("dayjs/plugin/quarterOfYear.js"), 1);

// src/api/search/date/date-format.ts
var import_dayjs = __toESM(require("dayjs"), 1);
var import_customParseFormat = __toESM(require("dayjs/plugin/customParseFormat.js"), 1);
import_dayjs.default.extend(import_customParseFormat.default);
var API_DATE_FORMAT = "YYYY/MM/DD@HH:mm:ss";
var API_DATE_MINIMUM = "1401-01-01";
function parseDate(date, format) {
  const parsedDate = (0, import_dayjs.default)(date, format);
  if (!parsedDate.isValid() && !format) {
    return (0, import_dayjs.default)(date, API_DATE_FORMAT);
  }
  return parsedDate;
}
function formatDateForSearchApi(date) {
  return date.format(API_DATE_FORMAT);
}
function isSearchApiDate(date) {
  return formatDateForSearchApi(parseDate(date)) === date;
}
function validateAbsoluteDate(date, dateFormat) {
  const dayJSDate = parseDate(date, dateFormat);
  if (!dayJSDate.isValid()) {
    const provideFormat = ". Please provide a date format string in the configuration options. See https://day.js.org/docs/en/parse/string-format for more information.";
    const withFormat = ` with the format "${dateFormat}"`;
    throw new Error(
      `Could not parse the provided date "${date}"${dateFormat ? withFormat : provideFormat}`
    );
  }
  assertDateAboveAPIMinimum(dayJSDate);
}
function assertDateAboveAPIMinimum(date) {
  if (date.isBefore(API_DATE_MINIMUM)) {
    throw new Error(
      `Date is before year 1401, which is unsupported by the API: ${date}`
    );
  }
}

// src/api/search/date/relative-date.ts
import_dayjs2.default.extend(import_quarterOfYear.default);
var validRelativeDatePeriods = ["past", "now", "next"];
var validRelativeDateUnits = [
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year"
];
var buildRelativeDateDefinition = (period) => {
  const isNow = period === "now";
  return {
    amount: new import_bueno14.NumberValue({ required: !isNow, min: 1 }),
    unit: new import_bueno14.StringValue({
      required: !isNow,
      constrainTo: validRelativeDateUnits
    }),
    period: new import_bueno14.StringValue({
      required: true,
      constrainTo: validRelativeDatePeriods
    })
  };
};
function validateRelativeDate(date) {
  if (typeof date === "string" && !isRelativeDateFormat(date)) {
    throw new Error(
      `The value "${date}" is not respecting the relative date format "period-amount-unit"`
    );
  }
  const relativeDate = typeof date === "string" ? parseRelativeDate(date) : date;
  new import_bueno14.Schema(buildRelativeDateDefinition(relativeDate.period)).validate(
    relativeDate
  );
  const dayJsDate = relativeToAbsoluteDate(relativeDate);
  const stringifiedDate = JSON.stringify(relativeDate);
  if (!dayJsDate.isValid()) {
    throw new Error(`Date is invalid: ${stringifiedDate}`);
  }
  assertDateAboveAPIMinimum(dayJsDate);
}
function serializeRelativeDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
    case "next":
      return `${period}-${amount}-${unit}`;
    case "now":
      return period;
  }
}
function relativeToAbsoluteDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
      return (0, import_dayjs2.default)().subtract(amount, unit);
    case "next":
      return (0, import_dayjs2.default)().add(amount, unit);
    case "now":
      return (0, import_dayjs2.default)();
  }
}
function formatRelativeDateForSearchApi(relativeDate) {
  return formatDateForSearchApi(
    relativeToAbsoluteDate(parseRelativeDate(relativeDate))
  );
}
function splitDate(date) {
  return date.toLocaleLowerCase().split("-");
}
function isRelativeDateFormat(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return true;
  }
  if (!validRelativeDatePeriods.includes(period)) {
    return false;
  }
  if (!validRelativeDateUnits.includes(unit)) {
    return false;
  }
  const intAmount = parseInt(amount);
  if (Number.isNaN(intAmount) || intAmount <= 0) {
    return false;
  }
  return true;
}
function isRelativeDate(date) {
  return !!date && typeof date === "object" && "period" in date;
}
function parseRelativeDate(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return {
      period: "now"
    };
  }
  return {
    period,
    amount: amount ? parseInt(amount) : void 0,
    unit: unit ? unit : void 0
  };
}
function deserializeRelativeDate(date) {
  validateRelativeDate(date);
  return parseRelativeDate(date);
}

// src/features/facets/range-facets/date-facet-set/interfaces/request.ts
function isDateFacetRequest(request) {
  return request.type === "dateRange";
}

// src/features/search/search-mappings.ts
function formatStartFacetValue(value) {
  return `start${value}`;
}
function formatEndFacetValue(value) {
  return `end${value}`;
}
var initialSearchMappings = () => ({
  dateFacetValueMap: {}
});
function mapDateRangeRequest(value, facetId2, mappings) {
  let start = value.start;
  let end = value.end;
  if (isRelativeDateFormat(start)) {
    start = formatRelativeDateForSearchApi(start);
    mappings.dateFacetValueMap[facetId2][formatStartFacetValue(start)] = value.start;
  }
  if (isRelativeDateFormat(end)) {
    end = formatRelativeDateForSearchApi(end);
    mappings.dateFacetValueMap[facetId2][formatEndFacetValue(end)] = value.end;
  }
  return { ...value, start, end };
}
function mapFacetRequest(facetRequest, mappings) {
  if (isDateFacetRequest(facetRequest)) {
    const { facetId: facetId2, currentValues } = facetRequest;
    mappings.dateFacetValueMap[facetId2] = {};
    return {
      ...facetRequest,
      currentValues: currentValues.map(
        (value) => mapDateRangeRequest(value, facetId2, mappings)
      )
    };
  }
  return facetRequest;
}
function mapSearchRequest(searchRequest) {
  const mappings = initialSearchMappings();
  const request = {
    ...searchRequest,
    facets: searchRequest.facets?.map(
      (facetRequest) => mapFacetRequest(facetRequest, mappings)
    )
  };
  return { request, mappings };
}
function mapDateRangeResponse(value, facetId2, mappings) {
  return {
    ...value,
    start: mappings.dateFacetValueMap[facetId2][formatStartFacetValue(value.start)] || value.start,
    end: mappings.dateFacetValueMap[facetId2][formatEndFacetValue(value.end)] || value.end
  };
}
function isDateFacetResponse(facetResponse, mappings) {
  return facetResponse.facetId in mappings.dateFacetValueMap;
}
function mapFacetResponse(facetResponse, mappings) {
  if (isDateFacetResponse(facetResponse, mappings)) {
    return {
      ...facetResponse,
      values: facetResponse.values.map(
        (value) => mapDateRangeResponse(value, facetResponse.facetId, mappings)
      )
    };
  }
  return facetResponse;
}
function mapSearchResponse(response, mappings) {
  if ("success" in response) {
    const success = {
      ...response.success,
      facets: response.success.facets?.map(
        (facetResponse) => mapFacetResponse(facetResponse, mappings)
      )
    };
    return { success };
  }
  return response;
}

// src/features/search/legacy/search-actions-thunk-processor.ts
var import_bueno18 = require("@coveo/bueno");

// src/features/did-you-mean/did-you-mean-actions.ts
var import_bueno15 = require("@coveo/bueno");
var import_toolkit17 = require("@reduxjs/toolkit");
var enableDidYouMean = (0, import_toolkit17.createAction)("didYouMean/enable");
var disableDidYouMean = (0, import_toolkit17.createAction)("didYouMean/disable");
var disableAutomaticQueryCorrection = (0, import_toolkit17.createAction)(
  "didYouMean/automaticCorrections/disable"
);
var enableAutomaticQueryCorrection = (0, import_toolkit17.createAction)(
  "didYouMean/automaticCorrections/enable"
);
var applyDidYouMeanCorrection = (0, import_toolkit17.createAction)(
  "didYouMean/correction",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setCorrectionMode = (0, import_toolkit17.createAction)(
  "didYouMean/automaticCorrections/mode",
  (payload) => validatePayload(
    payload,
    new import_bueno15.StringValue({
      constrainTo: ["next", "legacy"],
      emptyAllowed: false,
      required: true
    })
  )
);

// src/features/did-you-mean/did-you-mean-analytics-actions.ts
var logDidYouMeanClick = () => makeAnalyticsAction(
  "analytics/didyoumean/click",
  (client) => client.makeDidYouMeanClick()
);
var logDidYouMeanAutomatic = () => makeAnalyticsAction(
  "analytics/didyoumean/automatic",
  (client) => client.makeDidYouMeanAutomatic()
);
var didYouMeanClick = () => ({
  actionCause: "didYouMeanClick" /* didYouMeanClick */
});
var didYouMeanAutomatic = () => ({
  actionCause: "didYouMeanAutomatic" /* didYouMeanAutomatic */
});

// src/features/context/context-state.ts
function getContextInitialState() {
  return {
    contextValues: {}
  };
}

// src/features/dictionary-field-context/dictionary-field-context-state.ts
function getDictionaryFieldContextInitialState() {
  return {
    contextValues: {}
  };
}

// src/features/facet-options/facet-options-state.ts
function getFacetOptionsSliceInitialState() {
  return { enabled: true, tabs: {} };
}
function getFacetOptionsInitialState() {
  return {
    freezeFacetOrder: false,
    facets: {}
  };
}

// src/features/facets/facet-order/facet-order-state.ts
function getFacetOrderInitialState() {
  return [];
}

// src/features/pagination/pagination-state.ts
function getPaginationInitialState() {
  return {
    firstResult: 0,
    defaultNumberOfResults: 10,
    numberOfResults: 10,
    totalCountFiltered: 0
  };
}

// src/features/query-set/query-set-state.ts
function getQuerySetInitialState() {
  return {};
}

// src/features/static-filter-set/static-filter-set-state.ts
function getStaticFilterSetInitialState() {
  return {};
}

// src/features/tab-set/tab-set-state.ts
function getTabSetInitialState() {
  return {};
}

// src/features/history/history-state.ts
function getHistoryInitialState() {
  return extractHistory({});
}
function extractHistory(state) {
  return {
    context: state.context || getContextInitialState(),
    dictionaryFieldContext: state.dictionaryFieldContext || getDictionaryFieldContextInitialState(),
    facetSet: state.facetSet || getFacetSetInitialState(),
    numericFacetSet: state.numericFacetSet || getNumericFacetSetInitialState(),
    dateFacetSet: state.dateFacetSet || getDateFacetSetInitialState(),
    categoryFacetSet: state.categoryFacetSet || getCategoryFacetSetInitialState(),
    automaticFacetSet: state.automaticFacetSet ?? getAutomaticFacetSetInitialState(),
    pagination: state.pagination || getPaginationInitialState(),
    query: state.query || getQueryInitialState(),
    tabSet: state.tabSet || getTabSetInitialState(),
    advancedSearchQueries: state.advancedSearchQueries || getAdvancedSearchQueriesInitialState(),
    staticFilterSet: state.staticFilterSet || getStaticFilterSetInitialState(),
    querySet: state.querySet || getQuerySetInitialState(),
    sortCriteria: state.sortCriteria || getSortCriteriaInitialState(),
    pipeline: state.pipeline || getPipelineInitialState(),
    searchHub: state.searchHub || getSearchHubInitialState(),
    facetOptions: state.facetOptions || getFacetOptionsInitialState(),
    facetOrder: state.facetOrder ?? getFacetOrderInitialState(),
    debug: state.debug ?? getDebugInitialState()
  };
}

// src/features/triggers/trigger-analytics-actions.ts
var import_bueno16 = require("@coveo/bueno");
var logUndoTriggerQueryPayloadDefinition = new import_bueno16.RecordValue({
  values: {
    undoneQuery: requiredEmptyAllowedString
  },
  options: { required: true }
});
var logTriggerQuery = () => makeAnalyticsAction("analytics/trigger/query", (client, state) => {
  if (state.triggers?.queryModification.newQuery) {
    return client.makeTriggerQuery();
  }
  return null;
});
var logUndoTriggerQuery = (payload) => makeAnalyticsAction("analytics/trigger/query/undo", (client) => {
  validatePayload(payload, logUndoTriggerQueryPayloadDefinition);
  return client.makeUndoTriggerQuery(payload);
});
var logNotifyTrigger = () => makeAnalyticsAction("analytics/trigger/notify", (client, state) => {
  if (!state.triggers?.notifications.length) {
    return null;
  }
  return client.makeTriggerNotify({
    notifications: state.triggers.notifications
  });
});
var logTriggerRedirect = () => makeAnalyticsAction("analytics/trigger/redirect", (client, state) => {
  if (state.triggers?.redirectTo) {
    return client.makeTriggerRedirect({
      redirectedTo: state.triggers.redirectTo
    });
  }
  return null;
});
var logTriggerExecute = () => makeAnalyticsAction("analytics/trigger/execute", (client, state) => {
  if (!state.triggers?.executions.length) {
    return null;
  }
  return client.makeTriggerExecute({
    executions: state.triggers.executions
  });
});

// src/features/triggers/triggers-actions.ts
var import_bueno17 = require("@coveo/bueno");
var import_toolkit18 = require("@reduxjs/toolkit");
var updateIgnoreQueryTrigger = (0, import_toolkit18.createAction)(
  "trigger/query/ignore",
  (q) => validatePayload(q, new import_bueno17.StringValue({ emptyAllowed: true, required: true }))
);
var applyQueryTriggerModification = (0, import_toolkit18.createAction)(
  "trigger/query/modification",
  (payload) => validatePayload(
    payload,
    new import_bueno17.RecordValue({
      values: { originalQuery: nonEmptyString, modification: nonEmptyString }
    })
  )
);

// src/features/facets/generic/interfaces/generic-facet-request.ts
function getFacetRequests2(state) {
  return Object.values(state).map(
    (slice) => slice.request
  );
}

// src/utils/facet-utils.ts
function sortFacets(facets, sortOrder) {
  const payloadMap = {};
  facets.forEach((f2) => {
    payloadMap[f2.facetId] = f2;
  });
  const sortedFacets = [];
  sortOrder.forEach((facetId2) => {
    if (facetId2 in payloadMap) {
      sortedFacets.push(payloadMap[facetId2]);
      delete payloadMap[facetId2];
    }
  });
  const remainingFacets = Object.values(payloadMap);
  return [...sortedFacets, ...remainingFacets];
}
function getRangeFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    if (request.generateAutomaticRanges && !hasActiveValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
var sortCriteriaMap = {
  alphanumericDescending: { type: "alphanumeric", order: "descending" },
  alphanumericNaturalDescending: {
    type: "alphanumericNatural",
    order: "descending"
  }
};
function getSpecificFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getAllFacets(state) {
  return [
    ...getSpecificFacetRequests(state.facetSet ?? {}),
    ...getRangeFacetRequests(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getAllEnabledFacets(state) {
  return getAllFacets(state).filter(
    ({ facetId: facetId2 }) => state.facetOptions?.facets[facetId2]?.enabled ?? true
  );
}
function getFacets(state) {
  return sortFacets(getAllEnabledFacets(state), state.facetOrder ?? []);
}

// src/features/pagination/pagination-constants.ts
var minimumPage = 1;
var maximumNumberOfResultsFromIndex = 5e3;

// src/features/search/legacy/search-request.ts
var buildSearchRequest = async (state, eventDescription) => {
  const cq = buildConstantQuery(state);
  const facets = getFacets(state);
  const automaticFacets = getAutomaticFacets2(state);
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest2(state, eventDescription);
  const getNumberOfResultsWithinIndexLimit2 = () => {
    if (!state.pagination) {
      return void 0;
    }
    const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
    if (isOverIndexLimit) {
      return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
    }
    return state.pagination.numberOfResults;
  };
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit2(),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getAutomaticFacets2(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function buildConstantQuery(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find(
    (tab) => tab.isActive
  );
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = getStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}
function getStaticFilterExpressions(state) {
  const filters = Object.values(state.staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter(
      (value) => value.state === "selected" && !!value.expression.trim()
    );
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
}

// src/features/search/legacy/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    const startedAt = Date.now();
    const response = mapSearchResponse(
      await this.extra.apiClient.search(request, options),
      mappings
    );
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !(0, import_bueno18.isNullOrUndefined)(queryCorrection) && !(0, import_bueno18.isNullOrUndefined)(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(
      originalFetchedResponse
    );
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    this.analyticsAction?.()(
      this.dispatch,
      () => this.getStateAfterResponse(
        originalFetchedResponse.queryExecuted,
        originalFetchedResponse.duration,
        state,
        successResponse
      ),
      this.extra
    );
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    if (this.analyticsAction) {
      await this.dispatch(this.analyticsAction);
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery,
      analyticsAction: logTriggerQuery()
    };
  }
  getStateAfterResponse(query2, duration, previousState, response) {
    return {
      ...previousState,
      query: {
        q: query2,
        enableQuerySyntax: previousState.query?.enableQuerySyntax ?? getQueryInitialState().enableQuerySyntax
      },
      search: {
        ...getSearchInitialState(),
        duration,
        response,
        results: response.results
      }
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery(),
      analyticsAction: this.analyticsAction
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest(this.getState()),
      { origin: "mainSearch" }
    );
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(
      applyQueryTriggerModification({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest(this.getState()),
      { origin: "mainSearch" }
    );
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get analyticsAction() {
    return this.config.analyticsAction;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// src/features/search/legacy/search-actions.ts
var executeSearch = (0, import_toolkit19.createAsyncThunk)("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  return await legacyExecuteSearch(state, config, searchAction);
});
var fetchPage = (0, import_toolkit19.createAsyncThunk)("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchPage(state, config, searchAction);
});
var fetchMoreResults = (0, import_toolkit19.createAsyncThunk)("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  return await legacyFetchMoreResults(config, state);
});
var fetchFacetValues = (0, import_toolkit19.createAsyncThunk)(
  "search/fetchFacetValues",
  async (searchAction, config) => {
    const state = config.getState();
    return await legacyFetchFacetValues(config, searchAction, state);
  }
);
var fetchInstantResults = (0, import_toolkit19.createAsyncThunk)(
  "search/fetchInstantResults",
  async (payload, config) => {
    return legacyFetchInstantResults(payload, config);
  }
);
var buildFetchMoreRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest = async (state, q, numberOfResults) => {
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest2(state);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory = (state) => {
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
async function legacyFetchInstantResults(payload, config) {
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new import_bueno19.NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new import_bueno19.NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const state = config.getState();
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: logInstantResultsSearch() }, (modification) => {
    config.dispatch(
      updateInstantResultsQuery({ q: modification, id: payload.id })
    );
  });
  const request = await buildInstantResultSearchRequest(
    state,
    q,
    maxResultsPerQuery
  );
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      analyticsAction: processed.analyticsAction,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
}
async function legacyFetchPage(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: searchAction
  });
  const request = await buildSearchRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchMoreResults(config, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await logFetchMoreResults().prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: logFetchMoreResults()
  });
  const request = await buildFetchMoreRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchFacetValues(config, searchAction, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const request = await buildFetchFacetValuesRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
}
async function legacyExecuteSearch(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const request = await buildSearchRequest(state, eventDescription);
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}

// src/features/search/search-actions-thunk-processor.ts
var import_bueno20 = require("@coveo/bueno");

// src/features/static-filter-set/static-filter-set-selectors.ts
var import_toolkit20 = require("@reduxjs/toolkit");
var selectStaticFilterExpressions = (0, import_toolkit20.createSelector)(
  (state) => state.staticFilterSet,
  (staticFilterSet) => {
    const filters = Object.values(staticFilterSet || {});
    return filters.map((filter) => {
      const selected = filter.values.filter(
        (value) => value.state === "selected" && !!value.expression.trim()
      );
      const expression = selected.map((value) => value.expression).join(" OR ");
      return selected.length > 1 ? `(${expression})` : expression;
    });
  }
);

// src/features/search/search-request.ts
var buildSearchRequest2 = async (state, navigatorContext, eventDescription) => {
  const cq = buildConstantQuery2(state);
  const facets = getFacets2(state);
  const automaticFacets = getAutomaticFacets3(state);
  const sharedWithFoldingRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest2(
    state,
    eventDescription
  ) : buildSearchAndFoldingLoadCollectionRequest(
    state,
    navigatorContext,
    eventDescription
  );
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getNumberOfResultsWithinIndexLimit(state) {
  if (!state.pagination) {
    return void 0;
  }
  const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
  if (isOverIndexLimit) {
    return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
  }
  return state.pagination.numberOfResults;
}
function getFacets2(state) {
  return sortFacets(getAllEnabledFacets2(state), state.facetOrder ?? []);
}
function getAutomaticFacets3(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest2).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest2(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function getAllEnabledFacets2(state) {
  return getAllFacets2(state).filter(
    ({ facetId: facetId2 }) => state.facetOptions?.facets[facetId2]?.enabled ?? true
  );
}
function getAllFacets2(state) {
  return [
    ...getSpecificFacetRequests2(state.facetSet ?? {}),
    ...getRangeFacetRequests2(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests2(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getSpecificFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getRangeFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    const hasPreviousStateValues = currentValues.some(
      (value) => value.previousState
    );
    if (request.generateAutomaticRanges && !hasActiveValues && !hasPreviousStateValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
function buildConstantQuery2(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find(
    (tab) => tab.isActive
  );
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = selectStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}

// src/features/search/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor2 = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    const startedAt = Date.now();
    const response = mapSearchResponse(
      await this.extra.apiClient.search(request, options),
      mappings
    );
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !(0, import_bueno20.isNullOrUndefined)(queryCorrection) && !(0, import_bueno20.isNullOrUndefined)(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(
      originalFetchedResponse
    );
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery()
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const state = this.getState();
    const { actionCause } = didYouMeanAutomatic();
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest2(state, this.extra.navigatorContext, {
        actionCause
      }),
      { origin: "mainSearch" }
    );
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(
      applyQueryTriggerModification({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest2(this.getState(), this.extra.navigatorContext),
      { origin: "mainSearch" }
    );
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// src/features/search/search-actions.ts
var prepareForSearchWithQuery = (0, import_toolkit21.createAsyncThunk)("search/prepareForSearchWithQuery", (payload, thunk) => {
  const { dispatch } = thunk;
  validatePayload(payload, {
    q: new import_bueno21.StringValue(),
    enableQuerySyntax: new import_bueno21.BooleanValue(),
    clearFilters: new import_bueno21.BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deselectAllBreadcrumbs());
    dispatch(deselectAllNonBreadcrumbs());
  }
  dispatch(updateFacetAutoSelection({ allow: true }));
  dispatch(
    updateQuery({ q: payload.q, enableQuerySyntax: payload.enableQuerySyntax })
  );
  dispatch(updatePage(1));
});
var updateSearchAction = (0, import_toolkit21.createAction)(
  "search/updateSearchAction"
);
var executeSearch2 = (0, import_toolkit21.createAsyncThunk)(
  "search/executeSearch",
  async (searchAction, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyExecuteSearch(state, config, searchAction.legacy);
    }
    addEntryInActionsHistory2(state);
    const analyticsAction = searchAction.next ? buildSearchReduxAction(searchAction.next) : void 0;
    const request = await buildSearchRequest2(
      state,
      config.extra.navigatorContext,
      analyticsAction
    );
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: analyticsAction ?? {} });
    const fetched = await processor.fetchFromAPI(request, {
      origin: "mainSearch"
    });
    return await processor.process(fetched);
  }
);
var fetchPage2 = (0, import_toolkit21.createAsyncThunk)("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  addEntryInActionsHistory2(state);
  if (state.configuration.analytics.analyticsMode === "legacy" || !searchAction.next) {
    return legacyFetchPage(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction: searchAction.next
  });
  const request = await buildSearchRequest2(
    state,
    config.extra.navigatorContext,
    searchAction.next
  );
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchMoreResults2 = (0, import_toolkit21.createAsyncThunk)("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchMoreResults(config, state);
  }
  const analyticsAction = makeBasicNewSearchAnalyticsAction(
    "browseResults" /* browseResults */,
    config.getState
  );
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction
  });
  const request = await buildFetchMoreRequest2(
    state,
    config.extra.navigatorContext,
    analyticsAction
  );
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchFacetValues2 = (0, import_toolkit21.createAsyncThunk)(
  "search/fetchFacetValues",
  async (searchAction, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyExecuteSearch(state, config, searchAction.legacy);
    }
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: {} });
    const request = await buildFetchFacetValuesRequest2(
      state,
      config.extra.navigatorContext
    );
    const fetched = await processor.fetchFromAPI(request, {
      origin: "facetValues"
    });
    return await processor.process(fetched);
  }
);
var fetchInstantResults2 = (0, import_toolkit21.createAsyncThunk)(
  "search/fetchInstantResults",
  async (payload, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyFetchInstantResults(payload, config);
    }
    validatePayload(payload, {
      id: requiredNonEmptyString,
      q: requiredNonEmptyString,
      maxResultsPerQuery: new import_bueno21.NumberValue({
        required: true,
        min: 1
      }),
      cacheTimeout: new import_bueno21.NumberValue()
    });
    const { q, maxResultsPerQuery } = payload;
    const analyticsAction = buildSearchReduxAction(searchboxAsYouType());
    const request = await buildInstantResultSearchRequest2(
      state,
      config.extra.navigatorContext,
      q,
      maxResultsPerQuery,
      analyticsAction
    );
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction }, (modification) => {
      config.dispatch(
        updateInstantResultsQuery({ q: modification, id: payload.id })
      );
    });
    const fetched = await processor.fetchFromAPI(request, {
      origin: "instantResults",
      disableAbortWarning: true
    });
    const processed = await processor.process(fetched);
    if ("response" in processed) {
      return {
        results: processed.response.results,
        searchUid: processed.response.searchUid,
        totalCountFiltered: processed.response.totalCountFiltered,
        duration: processed.duration
      };
    }
    return processed;
  }
);
var buildFetchMoreRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(
    state,
    navigatorContext,
    eventDescription
  );
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest2 = async (state, navigatorContext, q, numberOfResults, eventDescription) => {
  const sharedWithFoldingRequest = buildSearchAndFoldingLoadCollectionRequest(
    state,
    navigatorContext,
    eventDescription
  );
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(
    state,
    navigatorContext,
    eventDescription
  );
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory2 = (state) => {
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
var buildSearchReduxAction = (action) => ({
  actionCause: action.actionCause,
  type: action.actionCause
});

// src/features/search/search-selectors.ts
var import_toolkit22 = require("@reduxjs/toolkit");

// src/features/result-templates/result-templates-helpers.ts
var import_bueno22 = require("@coveo/bueno");
var getResultProperty = (result, property) => {
  const anyResult = result;
  if (!(0, import_bueno22.isNullOrUndefined)(anyResult[property])) {
    return anyResult[property];
  }
  if (!(0, import_bueno22.isNullOrUndefined)(result.raw[property])) {
    return result.raw[property];
  }
  return null;
};
var fieldsMustBeDefined = (fieldNames) => {
  return (result) => {
    return fieldNames.every(
      (fieldName) => !(0, import_bueno22.isNullOrUndefined)(getResultProperty(result, fieldName))
    );
  };
};
var fieldsMustNotBeDefined = (fieldNames) => {
  return (result) => {
    return fieldNames.every(
      (fieldName) => (0, import_bueno22.isNullOrUndefined)(getResultProperty(result, fieldName))
    );
  };
};
var fieldMustMatch = (fieldName, valuesToMatch) => {
  return (result) => {
    const fieldValues = getFieldValuesFromResult(fieldName, result);
    return valuesToMatch.some(
      (valueToMatch) => fieldValues.some(
        (fieldValue) => `${fieldValue}`.toLowerCase() === valueToMatch.toLowerCase()
      )
    );
  };
};
var fieldMustNotMatch = (fieldName, blacklistedValues) => {
  return (result) => {
    const fieldValues = getFieldValuesFromResult(fieldName, result);
    return blacklistedValues.every(
      (blacklistedValue) => fieldValues.every(
        (fieldValue) => `${fieldValue}`.toLowerCase() !== blacklistedValue.toLowerCase()
      )
    );
  };
};
var getFieldValuesFromResult = (fieldName, result) => {
  const rawValue = getResultProperty(result, fieldName);
  return isArray(rawValue) ? rawValue : [rawValue];
};
var ResultTemplatesHelpers = {
  getResultProperty,
  fieldsMustBeDefined,
  fieldsMustNotBeDefined,
  fieldMustMatch,
  fieldMustNotMatch
};

// src/features/search/search-selectors.ts
function firstSearchExecutedSelector(state) {
  return state.search.response.searchUid !== "";
}
function resultFromFieldSelector(state, contentIdKey, contentIdValue) {
  return state.search.results.find(
    (result) => getResultProperty(result, contentIdKey) === contentIdValue
  );
}
var selectSearchActionCause = (0, import_toolkit22.createSelector)(
  (state) => state.search,
  (state) => {
    return state?.searchAction?.actionCause || "";
  }
);

// src/features/search/search-slice.ts
var import_toolkit24 = require("@reduxjs/toolkit");

// src/features/error/error-actions.ts
var import_toolkit23 = require("@reduxjs/toolkit");
var setError = (0, import_toolkit23.createAction)("app/setError");

// src/features/search/search-slice.ts
function handleRejectedSearch(state, action) {
  const error = action.payload ?? null;
  if (error) {
    state.response = getSearchInitialState().response;
    state.results = [];
    state.questionAnswer = emptyQuestionAnswer();
  }
  state.error = error;
  state.isLoading = false;
}
function handleFulfilledSearch(state, action) {
  state.error = null;
  state.response = action.payload.response;
  state.queryExecuted = action.payload.queryExecuted;
  state.duration = action.payload.duration;
  state.isLoading = false;
}
function handleFulfilledNewSearch(state, action) {
  handleFulfilledSearch(state, action);
  state.results = action.payload.response.results.map((result) => ({
    ...result,
    searchUid: action.payload.response.searchUid
  }));
  state.searchResponseId = action.payload.response.searchUid;
  state.questionAnswer = action.payload.response.questionAnswer;
  state.extendedResults = action.payload.response.extendedResults;
}
function handlePendingSearch(state, action) {
  state.isLoading = true;
  state.searchAction = action.meta.arg.next;
  state.requestId = action.meta.requestId;
}
function handlePendingFetchMoreResults(state, action) {
  state.isLoading = true;
  state.searchAction = { actionCause: "browseResults" /* browseResults */ };
  state.requestId = action.meta.requestId;
}
var searchReducer = (0, import_toolkit24.createReducer)(
  getSearchInitialState(),
  (builder) => {
    builder.addCase(
      executeSearch2.rejected,
      (state, action) => handleRejectedSearch(state, action)
    );
    builder.addCase(
      fetchMoreResults2.rejected,
      (state, action) => handleRejectedSearch(state, action)
    );
    builder.addCase(
      fetchPage2.rejected,
      (state, action) => handleRejectedSearch(state, action)
    );
    builder.addCase(executeSearch2.fulfilled, (state, action) => {
      handleFulfilledNewSearch(state, action);
    });
    builder.addCase(fetchMoreResults2.fulfilled, (state, action) => {
      handleFulfilledSearch(state, action);
      state.results = [
        ...state.results,
        ...action.payload.response.results.map((result) => ({
          ...result,
          searchUid: action.payload.response.searchUid
        }))
      ];
    });
    builder.addCase(fetchPage2.fulfilled, (state, action) => {
      handleFulfilledSearch(state, action);
      state.results = [
        ...action.payload.response.results.map((result) => ({
          ...result,
          searchUid: action.payload.response.searchUid
        }))
      ];
    });
    builder.addCase(fetchFacetValues2.fulfilled, (state, action) => {
      state.response.facets = action.payload.response.facets;
      state.response.searchUid = action.payload.response.searchUid;
    });
    builder.addCase(executeSearch2.pending, handlePendingSearch);
    builder.addCase(fetchMoreResults2.pending, handlePendingFetchMoreResults);
    builder.addCase(fetchPage2.pending, handlePendingSearch);
    builder.addCase(updateSearchAction, (state, action) => {
      state.searchAction = action.payload;
    });
    builder.addCase(setError, (state, action) => {
      state.error = action.payload;
      state.isLoading = false;
    });
  }
);

// src/features/search-hub/search-hub-slice.ts
var import_toolkit26 = require("@reduxjs/toolkit");

// src/features/search-hub/search-hub-actions.ts
var import_bueno23 = require("@coveo/bueno");
var import_toolkit25 = require("@reduxjs/toolkit");
var setSearchHub = (0, import_toolkit25.createAction)(
  "searchHub/set",
  (payload) => validatePayload(
    payload,
    new import_bueno23.StringValue({ required: true, emptyAllowed: true })
  )
);

// src/features/search-hub/search-hub-slice.ts
var searchHubReducer = (0, import_toolkit26.createReducer)(
  getSearchHubInitialState(),
  (builder) => {
    builder.addCase(setSearchHub, (_, action) => action.payload).addCase(
      change.fulfilled,
      (state, action) => action.payload?.searchHub ?? state
    ).addCase(
      updateSearchConfiguration,
      (state, action) => action.payload.searchHub || state
    );
  }
);

// src/api/knowledge/answer-generation/answer-generation-api.ts
var import_query2 = require("@reduxjs/toolkit/query");

// src/api/knowledge/answer-slice.ts
var import_query = require("@reduxjs/toolkit/query");
var dynamicBaseQuery = async (args, api, extraOptions) => {
  const state = api.getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const answerConfigurationId = state.generatedAnswer.answerConfigurationId;
  const updatedArgs = {
    ...args,
    headers: {
      ...args?.headers || {},
      Authorization: `Bearer ${accessToken}`
    }
  };
  try {
    const platformEndpoint = getOrganizationEndpoint(
      organizationId,
      environment
    );
    const data = (0, import_query.fetchBaseQuery)({
      baseUrl: `${platformEndpoint}/rest/organizations/${organizationId}/answer/v1/configs/${answerConfigurationId}`
    })(updatedArgs, api, extraOptions);
    return { data };
  } catch (error) {
    return { error };
  }
};
var answerSlice = (0, import_query.createApi)({
  reducerPath: "answer",
  baseQuery: (0, import_query.retry)(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// src/api/knowledge/answer-generation/answer-generation-api.ts
var answerGenerationApi = (0, import_query2.createApi)({
  reducerPath: "answerGenerationApi",
  refetchOnMountOrArgChange: true,
  baseQuery: (0, import_query2.retry)(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// src/api/knowledge/stream-answer-api.ts
var import_query3 = require("@reduxjs/toolkit/query");

// src/features/generated-answer/answer-api-selectors.ts
var import_toolkit27 = require("@reduxjs/toolkit");

// src/features/query/query-selectors.ts
var selectQuery = (state) => state.query;
var selectEnableQuerySyntax = (state) => state.query?.enableQuerySyntax;

// src/features/generated-answer/answer-api-selectors.ts
var selectAnswerTriggerParams = (0, import_toolkit27.createSelector)(
  (state) => selectQuery(state)?.q,
  (state) => state.search.requestId,
  (state) => state.generatedAnswer.cannotAnswer,
  (state) => state.configuration.analytics.analyticsMode,
  (state) => state.search.searchAction?.actionCause,
  (q, requestId, cannotAnswer, analyticsMode, actionCause) => ({
    q,
    requestId,
    cannotAnswer,
    analyticsMode,
    actionCause
  })
);
var selectAnswerApiQueryParams = (0, import_toolkit27.createSelector)(
  (state) => state.generatedAnswer?.answerApiQueryParams,
  (answerApiQueryParams) => answerApiQueryParams
);

// src/features/generated-answer/generated-answer-actions.ts
var import_bueno25 = require("@coveo/bueno");
var import_toolkit31 = require("@reduxjs/toolkit");

// src/api/knowledge/answer-generation/answer-generation-api-state.ts
var initialAnswerGenerationServerState = () => ({
  contentFormat: void 0,
  answer: void 0,
  citations: void 0,
  error: void 0,
  generated: false,
  isStreaming: false,
  isLoading: true
});

// src/api/knowledge/answer-generation/streaming/answer-draft-reducer/answer-draft-reducer.ts
var setAnswerId = (draft, answerId) => {
  if (answerId) {
    draft.answerId = answerId;
  }
};
var initializeStreamingAnswer = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var setAnswer = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var setCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var endStreaming = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var setAnswerError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code ?? 500
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(
    `Generated answer error: ${errorMessage} (code: ${message.code})`
  );
};

// src/api/knowledge/answer-generation/streaming/server-state-event-handler/server-state-event-handler.ts
var serverStateEventHandler = {
  handleOpen: (response, updateCachedData) => {
    const answerId = response.headers.get("x-answer-id");
    if (answerId) {
      updateCachedData((draft) => {
        setAnswerId(draft, answerId);
      });
    }
  },
  handleMessage: {
    "agentInteraction.answerHeader": (_message, updateCachedData) => {
      updateCachedData((draft) => {
        initializeStreamingAnswer(draft, { contentFormat: "text/markdown" });
      });
    },
    "generativeengines.messageType": (message, updateCachedData) => {
      if (message?.payload?.textDelta) {
        updateCachedData((draft) => {
          setAnswer(draft, message.payload);
        });
      }
    },
    "agentInteraction.citations": (message, updateCachedData) => {
      if (message?.payload?.citations !== void 0) {
        updateCachedData((draft) => {
          setCitations(draft, message.payload);
        });
      }
    },
    "generativeengines.endOfStreamType": (message, updateCachedData) => {
      updateCachedData((draft) => {
        endStreaming(draft, message.payload);
      });
    },
    error: (message, updateCachedData) => {
      if (message.finishReason === "ERROR") {
        updateCachedData((draft) => {
          setAnswerError(draft, message);
        });
      }
    }
  }
};

// src/api/knowledge/answer-generation/streaming/answer-streaming-runner.ts
var streamAnswerWithStrategy = (endpointUrl, args, api, strategy) => {
  const { dispatch, updateCachedData, getState } = api;
  const {
    configuration: { accessToken }
  } = getState();
  return fetchEventSource(endpointUrl, {
    method: "POST",
    body: JSON.stringify(args),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "text/event-stream",
      "Content-Type": "application/json",
      "Accept-Encoding": "*"
    },
    fetch,
    onopen: async (response) => {
      serverStateEventHandler.handleOpen(response, updateCachedData);
      strategy.handleOpen(response, dispatch);
    },
    onclose: () => {
      strategy.handleClose?.(dispatch);
    },
    onerror: (error) => {
      strategy.handleError(error);
    },
    onmessage: (event) => {
      const message = parsePayload(event.data);
      if (!message) {
        return;
      }
      serverStateEventHandler.handleMessage.error?.(message, updateCachedData);
      strategy.handleMessage.error?.(message, dispatch);
      const messageType = message.payloadType;
      serverStateEventHandler.handleMessage[messageType]?.(
        message,
        updateCachedData
      );
      strategy.handleMessage[messageType]?.(message, dispatch);
    }
  });
};
function parsePayload(payload) {
  if (!payload?.length) {
    return null;
  }
  try {
    return JSON.parse(payload);
  } catch (err) {
    console.warn("Failed to parse message", {
      payload,
      error: err
    });
    return null;
  }
}

// src/features/follow-up-answers/follow-up-answers-actions.ts
var import_bueno24 = require("@coveo/bueno");
var import_toolkit28 = require("@reduxjs/toolkit");

// src/api/knowledge/answer-generation/endpoints/follow-up/url-builders/endpoint-url-builder.ts
var buildFollowUpEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const {
    organizationId,
    environment,
    knowledge: { agentId }
  } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId?.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for follow up endpoint");
  }
  const basePath2 = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath2}/${trimmedAgentId}/follow-up`;
};

// src/api/knowledge/answer-generation/endpoints/follow-up/follow-up-endpoint.ts
var followUpEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateFollowUpAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        const { strategyKey, ...params } = args;
        const endpointUrl = buildFollowUpEndpointUrl(
          getState()
        );
        await streamAnswerWithStrategy(
          endpointUrl,
          params,
          {
            getState,
            updateCachedData,
            dispatch
          },
          streamingStrategyCreators[strategyKey]?.()
        );
      }
    })
  })
});
var initiateFollowUpEndpoint = (args) => {
  return followUpEndpoint.endpoints.generateFollowUpAnswer.initiate(args);
};

// src/features/follow-up-answers/follow-up-answer-request.ts
var constructGenerateFollowUpAnswerParams = (followUpQuestion, state) => {
  const conversationId = state.followUpAnswers?.conversationId ?? "";
  return {
    conversationId,
    q: followUpQuestion
  };
};

// src/features/follow-up-answers/follow-up-answers-actions.ts
var stringValue = new import_bueno24.StringValue({ required: true });
var setIsEnabled = (0, import_toolkit28.createAction)(
  "followUpAnswers/setIsEnabled",
  (payload) => validatePayload(payload, new import_bueno24.BooleanValue({ required: true }))
);
var setFollowUpAnswersConversationId = (0, import_toolkit28.createAction)(
  "followUpAnswers/setFollowUpAnswersConversationId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var createFollowUpAnswer = (0, import_toolkit28.createAction)(
  "followUpAnswers/createFollowUpAnswer",
  (payload) => validatePayload(payload, {
    question: requiredNonEmptyString
  })
);
var setActiveFollowUpAnswerId = (0, import_toolkit28.createAction)(
  "followUpAnswers/setActiveFollowUpAnswerId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setFollowUpAnswerContentFormat = (0, import_toolkit28.createAction)(
  "followUpAnswers/setFollowUpAnswerContentFormat",
  (payload) => validatePayload(payload, {
    contentFormat: answerContentFormatSchema,
    answerId: requiredNonEmptyString
  })
);
var setFollowUpIsLoading = (0, import_toolkit28.createAction)(
  "followUpAnswers/setFollowUpIsLoading",
  (payload) => validatePayload(payload, {
    isLoading: new import_bueno24.BooleanValue({ required: true }),
    answerId: requiredNonEmptyString
  })
);
var followUpMessageChunkReceived = (0, import_toolkit28.createAction)(
  "followUpAnswers/followUpMessageChunkReceived",
  (payload) => validatePayload(payload, {
    textDelta: stringValue,
    answerId: requiredNonEmptyString
  })
);
var followUpCitationsReceived = (0, import_toolkit28.createAction)(
  "followUpAnswers/followUpCitationsReceived",
  (payload) => validatePayload(payload, {
    citations: new import_bueno24.ArrayValue({
      required: true,
      each: new import_bueno24.RecordValue({
        values: citationSchema
      })
    }),
    answerId: requiredNonEmptyString
  })
);
var followUpCompleted = (0, import_toolkit28.createAction)(
  "followUpAnswers/followUpCompleted",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
    cannotAnswer: new import_bueno24.BooleanValue({ required: false })
  })
);
var followUpFailed = (0, import_toolkit28.createAction)(
  "followUpAnswers/followUpFailed",
  (payload) => validatePayload(payload, {
    message: new import_bueno24.StringValue(),
    code: new import_bueno24.NumberValue({ min: 0 }),
    answerId: requiredNonEmptyString
  })
);
var likeFollowUp = (0, import_toolkit28.createAction)(
  "followUpAnswers/likeFollowUp",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var dislikeFollowUp = (0, import_toolkit28.createAction)(
  "followUpAnswers/dislikeFollowUp",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var submitFollowUpFeedback = (0, import_toolkit28.createAction)(
  "followUpAnswers/submitFollowUpFeedback",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var resetFollowUpAnswers = (0, import_toolkit28.createAction)(
  "followUpAnswers/resetFollowUpAnswers"
);
var generateFollowUpAnswer = (0, import_toolkit28.createAsyncThunk)(
  "generatedAnswerWithFollowUps/generateFollowUpAnswer",
  async (question, { getState, dispatch, extra: { logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state)?.trim();
    const generateFollowUpAnswerParams = constructGenerateFollowUpAnswerParams(
      question,
      state
    );
    if (!agentId) {
      logger.warn(
        "Missing agentId in engine configuration. The generateFollowUpAnswer action requires an agent ID."
      );
      return;
    }
    if (!generateFollowUpAnswerParams.conversationId) {
      logger.warn(
        "Missing conversationId when generating a follow-up answer. The generateFollowUpAnswer action requires an existing conversation."
      );
      return;
    }
    dispatch(createFollowUpAnswer({ question }));
    await dispatch(
      initiateFollowUpEndpoint({
        strategyKey: "follow-up-answer",
        ...generateFollowUpAnswerParams
      })
    );
  }
);

// src/features/follow-up-answers/follow-up-answer-strategy.ts
var createFollowUpAnswerStrategy = () => {
  let answerId = null;
  return {
    handleOpen: (response, dispatch) => {
      answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setActiveFollowUpAnswerId(answerId));
        dispatch(setFollowUpIsLoading({ answerId, isLoading: true }));
        dispatch(
          setFollowUpAnswerContentFormat({
            contentFormat: "text/markdown",
            answerId
          })
        );
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "generativeengines.messageType": (message, dispatch) => {
        if (message?.payload?.textDelta) {
          dispatch(
            followUpMessageChunkReceived({
              textDelta: message.payload.textDelta,
              answerId
            })
          );
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        if (message?.payload?.citations !== void 0) {
          dispatch(
            followUpCitationsReceived({
              citations: message.payload.citations,
              answerId
            })
          );
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        const answerGenerated = message?.payload?.answerGenerated ?? false;
        dispatch(
          followUpCompleted({
            cannotAnswer: !answerGenerated,
            answerId
          })
        );
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(
            followUpFailed({
              answerId,
              message: message.errorMessage,
              code: message.code
            })
          );
        }
      }
    }
  };
};

// src/features/generated-answer/generated-answer-analytics-actions.ts
var logGeneratedAnswerStreamEnd = (answerGenerated) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/streamEnd",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const answerTextIsEmpty = answerGenerated ? !state.generatedAnswer?.answer || !state.generatedAnswer?.answer.length : void 0;
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerStreamEnd({
      generativeQuestionAnsweringId,
      answerGenerated,
      answerTextIsEmpty
    });
  },
  analyticsType: "Rga.AnswerReceived",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      answerGenerated: answerGenerated ?? false
    };
  }
});
var logGeneratedAnswerResponseLinked = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/responseLinked",
  __legacy__getBuilder: () => {
    return null;
  },
  analyticsType: "Rga.ResponseLinked",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      responseId: state.search?.searchResponseId || state.search?.response.searchUid || ""
    };
  }
});

// src/features/generated-answer/head-answer-strategy.ts
var createHeadAnswerStrategy = () => {
  return {
    handleOpen: (response, dispatch) => {
      const answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setAnswerId2(answerId));
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "agentInteraction.answerHeader": (message, dispatch) => {
        if (message?.payload?.conversationId) {
          dispatch(
            setFollowUpAnswersConversationId(message.payload.conversationId)
          );
        }
        if (message.payload.followUpEnabled) {
          dispatch(setIsEnabled(message.payload.followUpEnabled));
        }
        dispatch(setAnswerContentFormat("text/markdown"));
        dispatch(setIsStreaming(true));
        dispatch(setIsLoading(false));
      },
      "generativeengines.messageType": (message, dispatch) => {
        if (message?.payload?.textDelta) {
          dispatch(updateMessage({ textDelta: message.payload.textDelta }));
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        if (message?.payload?.citations !== void 0) {
          dispatch(updateCitations({ citations: message.payload.citations }));
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        const answerGenerated = message?.payload?.answerGenerated ?? false;
        dispatch(setIsAnswerGenerated(answerGenerated));
        dispatch(setCannotAnswer(!answerGenerated));
        dispatch(setIsStreaming(false));
        dispatch(setIsLoading(false));
        dispatch(logGeneratedAnswerStreamEnd(answerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(updateError(message));
        }
      }
    }
  };
};

// src/api/knowledge/answer-generation/streaming/strategies/streaming-strategy-creators.ts
var streamingStrategyCreators = {
  "head-answer": createHeadAnswerStrategy,
  "follow-up-answer": createFollowUpAnswerStrategy
};

// src/api/knowledge/answer-generation/endpoints/answer/url-builders/endpoint-url-builder.ts
var buildAnswerEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const {
    organizationId,
    environment,
    knowledge: { agentId }
  } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId?.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath2}/${trimmedAgentId}/answer`;
};

// src/api/knowledge/answer-generation/endpoints/answer/answer-endpoint.ts
var answerEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        const { strategyKey, ...params } = args;
        const endpointUrl = buildAnswerEndpointUrl(
          getState()
        );
        await streamAnswerWithStrategy(
          endpointUrl,
          params,
          {
            getState,
            updateCachedData,
            dispatch
          },
          streamingStrategyCreators[strategyKey]?.()
        );
      }
    })
  })
});
var initiateAnswerEndpoint = (args) => {
  return answerEndpoint.endpoints.generateAnswer.initiate(args);
};

// src/features/advanced-search-queries/advanced-search-query-selectors.ts
var import_toolkit29 = require("@reduxjs/toolkit");
var selectAdvancedSearchQueries = (0, import_toolkit29.createSelector)(
  (state) => state.advancedSearchQueries,
  (advancedSearchQueries) => {
    if (!advancedSearchQueries) {
      return {};
    }
    const { aq, cq, dq, lq } = advancedSearchQueries;
    return {
      ...aq && { aq },
      ...cq && { cq },
      ...dq && { dq },
      ...lq && { lq }
    };
  }
);

// src/features/context/context-selector.ts
var selectContext = (state) => state.context;

// src/features/pipeline/select-pipeline.ts
var selectPipeline = (state) => state.pipeline;

// src/features/search-hub/search-hub-selectors.ts
var selectSearchHub = (state) => state.searchHub;

// src/features/tab-set/tab-set-selectors.ts
var import_toolkit30 = require("@reduxjs/toolkit");
var selectActiveTab = (0, import_toolkit30.createSelector)(
  (state) => state,
  (tabSetState) => {
    if (!tabSetState) {
      return "";
    }
    for (const tabId in tabSetState) {
      if (tabSetState[tabId].isActive) {
        return tabSetState[tabId].id;
      }
    }
    return "";
  }
);
var selectActiveTabExpression = (0, import_toolkit30.createSelector)(
  (state) => state,
  (tabSetState) => {
    const activeTabId = selectActiveTab(tabSetState);
    return activeTabId && tabSetState ? tabSetState[activeTabId].expression : "";
  }
);

// src/features/dictionary-field-context/dictionary-field-context-selectors.ts
var selectDictionaryFieldContext = (state) => {
  if (!state.dictionaryFieldContext || !Object.keys(state.dictionaryFieldContext.contextValues).length) {
    return void 0;
  }
  return state.dictionaryFieldContext.contextValues;
};

// src/features/excerpt-length/excerpt-length-selectors.ts
var selectExcerptLength = (state) => state.excerptLength?.length;

// src/features/facet-options/facet-options-selectors.ts
var isFacetEnabledSelector = (state, id) => {
  return state.facetOptions.facets[id]?.enabled ?? true;
};
var selectFacetOptions = (state) => {
  const { freezeFacetOrder } = state.facetOptions ?? {};
  return freezeFacetOrder !== void 0 ? { freezeFacetOrder } : void 0;
};

// src/features/folding/folding-selectors.ts
var selectFoldingQueryParams = (state) => {
  if (!state.folding) {
    return void 0;
  }
  return {
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: state.folding.filterFieldRange
  };
};

// src/features/sort-criteria/sort-criteria-selectors.ts
var selectSortCriteria = (state) => state.sortCriteria;

// src/features/generated-answer/generated-answer-request.ts
var buildStreamingRequest = async (state) => ({
  accessToken: state.configuration.accessToken,
  organizationId: state.configuration.organizationId,
  url: getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment
  ),
  streamId: state.search.extendedResults?.generativeQuestionAnsweringId
});
var constructAnswerAPIQueryParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const { aq, cq, dq, lq } = buildAdvancedSearchQueryParams(state);
  const context = selectContext(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    { actionCause: selectSearchActionCause(state) }
  );
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  const facetParams = getGeneratedFacetParams(state);
  const tab = selectActiveTab(state.tabSet) || "default";
  const locale = selectLocale(state);
  const timezone2 = selectTimezone(state);
  const referrer = navigatorContext.referrer || "";
  const facetOptions = selectFacetOptions(state);
  const sortCriteria = selectSortCriteria(state);
  const actionsHistory = getActionsHistory(state);
  const excerptLength = selectExcerptLength(state);
  const foldingParams = selectFoldingQueryParams(state);
  const dictionaryFieldContext = selectDictionaryFieldContext(state);
  return {
    q,
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq },
    ...state.query && { enableQuerySyntax: selectEnableQuerySyntax(state) },
    ...context?.contextValues && {
      context: context.contextValues
    },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...facetParams.length && { facets: facetParams },
    ...state.fields && { fieldsToInclude: state.fields.fieldsToInclude },
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    tab,
    locale,
    timezone: timezone2,
    ...state.debug !== void 0 && { debug: state.debug },
    referrer,
    ...actionsHistory,
    ...foldingParams ?? {},
    ...excerptLength && { excerptLength },
    ...dictionaryFieldContext && {
      dictionaryFieldContext
    },
    sortCriteria,
    ...facetOptions && { facetOptions },
    ...analyticsParams,
    ...state.insightCaseContext?.caseContext && {
      caseContext: state.insightCaseContext?.caseContext
    }
  };
};
var constructGenerateHeadAnswerParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const facetParams = getGeneratedFacetParams(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    { actionCause: selectSearchActionCause(state) }
  );
  const locale = selectLocale(state);
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  return {
    q: q || "",
    ...facetParams.length && { facets: facetParams },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...analyticsParams,
    locale
  };
};
var getGeneratedFacetParams = (state) => getFacets(state)?.map(
  (facetRequest) => mapFacetRequest(facetRequest, initialSearchMappings())
).sort(
  (a, b) => a.facetId > b.facetId ? 1 : b.facetId > a.facetId ? -1 : 0
);
var getActionsHistory = (state) => ({
  actionsHistory: state.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : []
});
var buildAdvancedSearchQueryParams = (state) => {
  const advancedSearchQueryParams = selectAdvancedSearchQueries(state);
  const mergedCq = buildConstantQuery2(state);
  return {
    ...advancedSearchQueryParams,
    ...mergedCq && { cq: mergedCq }
  };
};

// src/features/generated-answer/generated-response-format.ts
var generatedContentFormat = ["text/plain", "text/markdown"];

// src/features/generated-answer/generated-answer-actions.ts
var stringValue2 = new import_bueno25.StringValue({ required: true });
var optionalStringValue = new import_bueno25.StringValue();
var booleanValue = new import_bueno25.BooleanValue({ required: true });
var citationSchema = {
  id: stringValue2,
  title: stringValue2,
  uri: stringValue2,
  permanentid: stringValue2,
  clickUri: optionalStringValue
};
var answerContentFormatSchema = new import_bueno25.StringValue({
  required: true,
  constrainTo: generatedContentFormat
});
var setIsVisible = (0, import_toolkit31.createAction)(
  "generatedAnswer/setIsVisible",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerId2 = (0, import_toolkit31.createAction)(
  "generatedAnswer/setAnswerId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setAnswerGenerationMode = (0, import_toolkit31.createAction)(
  "generatedAnswer/setAnswerGenerationMode",
  (payload) => validatePayload(
    payload,
    new import_bueno25.StringValue({
      constrainTo: ["automatic", "manual"],
      required: false,
      default: "automatic"
    })
  )
);
var setIsEnabled2 = (0, import_toolkit31.createAction)(
  "generatedAnswer/setIsEnabled",
  (payload) => validatePayload(payload, booleanValue)
);
var updateMessage = (0, import_toolkit31.createAction)(
  "generatedAnswer/updateMessage",
  (payload) => validatePayload(payload, {
    textDelta: stringValue2
  })
);
var updateCitations = (0, import_toolkit31.createAction)(
  "generatedAnswer/updateCitations",
  (payload) => validatePayload(payload, {
    citations: new import_bueno25.ArrayValue({
      required: true,
      each: new import_bueno25.RecordValue({
        values: citationSchema
      })
    })
  })
);
var updateError = (0, import_toolkit31.createAction)(
  "generatedAnswer/updateError",
  (payload) => validatePayload(payload, {
    message: optionalStringValue,
    code: new import_bueno25.NumberValue({ min: 0 })
  })
);
var resetAnswer = (0, import_toolkit31.createAction)("generatedAnswer/resetAnswer");
var likeGeneratedAnswer = (0, import_toolkit31.createAction)("generatedAnswer/like");
var dislikeGeneratedAnswer = (0, import_toolkit31.createAction)("generatedAnswer/dislike");
var openGeneratedAnswerFeedbackModal = (0, import_toolkit31.createAction)(
  "generatedAnswer/feedbackModal/open"
);
var expandGeneratedAnswer = (0, import_toolkit31.createAction)("generatedAnswer/expand");
var collapseGeneratedAnswer = (0, import_toolkit31.createAction)("generatedAnswer/collapse");
var setId = (0, import_toolkit31.createAction)(
  "generatedAnswer/setId",
  (payload) => validatePayload(payload, {
    id: new import_bueno25.StringValue({
      required: true
    })
  })
);
var closeGeneratedAnswerFeedbackModal = (0, import_toolkit31.createAction)(
  "generatedAnswer/feedbackModal/close"
);
var sendGeneratedAnswerFeedback = (0, import_toolkit31.createAction)(
  "generatedAnswer/sendFeedback"
);
var setIsLoading = (0, import_toolkit31.createAction)(
  "generatedAnswer/setIsLoading",
  (payload) => validatePayload(payload, booleanValue)
);
var setIsStreaming = (0, import_toolkit31.createAction)(
  "generatedAnswer/setIsStreaming",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerContentFormat = (0, import_toolkit31.createAction)(
  "generatedAnswer/setAnswerContentFormat",
  (payload) => validatePayload(payload, answerContentFormatSchema)
);
var updateResponseFormat = (0, import_toolkit31.createAction)(
  "generatedAnswer/updateResponseFormat",
  (payload) => validatePayload(payload, {
    contentFormat: new import_bueno25.ArrayValue({
      each: answerContentFormatSchema,
      default: ["text/plain"]
    })
  })
);
var updateAnswerConfigurationId = (0, import_toolkit31.createAction)(
  "knowledge/updateAnswerConfigurationId",
  (payload) => validatePayload(payload, stringValue2)
);
var registerFieldsToIncludeInCitations = (0, import_toolkit31.createAction)(
  "generatedAnswer/registerFieldsToIncludeInCitations",
  (payload) => validatePayload(payload, nonEmptyStringArray)
);
var setIsAnswerGenerated = (0, import_toolkit31.createAction)(
  "generatedAnswer/setIsAnswerGenerated",
  (payload) => validatePayload(payload, booleanValue)
);
var setCannotAnswer = (0, import_toolkit31.createAction)(
  "generatedAnswer/setCannotAnswer",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerApiQueryParams = (0, import_toolkit31.createAction)(
  "generatedAnswer/setAnswerApiQueryParams",
  (payload) => validatePayload(payload, new import_bueno25.RecordValue({}))
);
var streamAnswer = (0, import_toolkit31.createAsyncThunk)("generatedAnswer/streamAnswer", async (params, config) => {
  const state = config.getState();
  const { dispatch, extra, getState } = config;
  const { search } = getState();
  const { queryExecuted } = search;
  const { setAbortControllerRef } = params;
  const request = await buildStreamingRequest(state);
  const handleStreamPayload = (payloadType, payload) => {
    switch (payloadType) {
      case "genqa.headerMessageType": {
        const header = JSON.parse(
          payload
        );
        dispatch(setAnswerContentFormat(header.contentFormat));
        break;
      }
      case "genqa.messageType":
        dispatch(
          updateMessage(JSON.parse(payload))
        );
        break;
      case "genqa.citationsType":
        dispatch(
          updateCitations(
            JSON.parse(payload)
          )
        );
        break;
      case "genqa.endOfStreamType": {
        const isAnswerGenerated = JSON.parse(payload).answerGenerated;
        const cannotAnswer = queryExecuted.length !== 0 && !isAnswerGenerated;
        dispatch(setCannotAnswer(cannotAnswer));
        dispatch(setIsStreaming(false));
        dispatch(setIsAnswerGenerated(isAnswerGenerated));
        dispatch(logGeneratedAnswerStreamEnd(isAnswerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
        break;
      }
      default:
        if (state.debug) {
          extra.logger.warn(`Unknown payloadType: "${payloadType}"`);
        }
    }
  };
  dispatch(setIsLoading(true));
  const currentStreamRequestMatchesOriginalStreamRequest = (request2) => {
    return request2.streamId === config.getState().search.extendedResults.generativeQuestionAnsweringId;
  };
  const abortController = extra.streamingClient?.streamGeneratedAnswer(
    request,
    {
      write: (data) => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(setIsLoading(false));
          if (data.payload && data.payloadType) {
            handleStreamPayload(data.payloadType, data.payload);
          }
        }
      },
      abort: (error) => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(updateError(error));
        }
      },
      close: () => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(setIsStreaming(false));
        }
      },
      resetAnswer: () => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(resetAnswer());
        }
      }
    }
  );
  if (abortController) {
    setAbortControllerRef(abortController);
  } else {
    dispatch(setIsLoading(false));
  }
});
var generateAnswer = (0, import_toolkit31.createAsyncThunk)(
  "generatedAnswer/generateAnswer",
  async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
    dispatch(resetAnswer());
    const state = getState();
    if (state.generatedAnswer.answerConfigurationId) {
      const answerApiQueryParams = constructAnswerAPIQueryParams(
        state,
        navigatorContext
      );
      dispatch(setAnswerApiQueryParams(answerApiQueryParams));
      await dispatch(fetchAnswer(answerApiQueryParams));
    } else {
      logger.warn(
        "[WARNING] Missing answerConfigurationId in engine configuration. The generateAnswer action requires an answer configuration ID to use CRGA with the Answer API."
      );
    }
  }
);
var generateHeadAnswer = (0, import_toolkit31.createAsyncThunk)(
  "generatedAnswerWithFollowUps/generateHeadAnswer",
  async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state);
    if (!agentId) {
      logger.warn(
        "Missing agentId in engine configuration. The generateHeadAnswer action requires an agent ID."
      );
      return;
    }
    dispatch(resetAnswer());
    const generateHeadAnswerParams = constructGenerateHeadAnswerParams(
      state,
      navigatorContext
    );
    const headAnswerEndpointArgs = {
      ...generateHeadAnswerParams,
      strategyKey: "head-answer"
    };
    dispatch(setAnswerApiQueryParams(generateHeadAnswerParams));
    await dispatch(initiateAnswerEndpoint(headAnswerEndpointArgs));
  }
);

// src/api/knowledge/stream-answer-api.ts
var handleHeaderMessage = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var handleMessage = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var handleCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var handleEndOfStream = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var handleError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(
    `Generated answer error: ${errorMessage} (code: ${message.code})`
  );
};
var updateCacheWithEvent = (event, draft, dispatch) => {
  const message = JSON.parse(event.data);
  if (message.finishReason === "ERROR" && message.errorMessage) {
    handleError(draft, message);
  }
  const parsedPayload = message.payload.length ? JSON.parse(message.payload) : {};
  switch (message.payloadType) {
    case "genqa.headerMessageType":
      if (parsedPayload.contentFormat) {
        handleHeaderMessage(draft, parsedPayload);
        dispatch(setAnswerContentFormat(parsedPayload.contentFormat));
      }
      break;
    case "genqa.messageType":
      if (parsedPayload.textDelta) {
        handleMessage(draft, parsedPayload);
        dispatch(updateMessage({ textDelta: parsedPayload.textDelta }));
      }
      break;
    case "genqa.citationsType":
      if (parsedPayload.citations) {
        handleCitations(draft, parsedPayload);
        dispatch(updateCitations({ citations: parsedPayload.citations }));
      }
      break;
    case "genqa.endOfStreamType":
      handleEndOfStream(draft, parsedPayload);
      dispatch(
        logGeneratedAnswerStreamEnd(parsedPayload.answerGenerated ?? false)
      );
      dispatch(logGeneratedAnswerResponseLinked());
      break;
  }
};
var buildAnswerEndpoint = (platformEndpoint, organizationId, answerConfigurationId, insightId) => {
  if (!platformEndpoint || !organizationId || !answerConfigurationId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/rest/organizations/${organizationId}`;
  const prefix = insightId ? `insight/v1/configs/${insightId}/answer` : `answer/v1/configs`;
  return `${platformEndpoint}${basePath2}/${prefix}/${answerConfigurationId}/generate`;
};
var answerApi = answerSlice.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    getAnswer: builder.query({
      queryFn: () => ({
        data: {
          contentFormat: void 0,
          answer: void 0,
          citations: void 0,
          error: void 0,
          generated: false,
          isStreaming: true,
          isLoading: true
        }
      }),
      serializeQueryArgs: ({ endpointName, queryArgs }) => {
        const { analytics: _analytics, ...queryArgsWithoutAnalytics } = queryArgs;
        return `${endpointName}(${JSON.stringify(queryArgsWithoutAnalytics)})`;
      },
      async onCacheEntryAdded(args, { getState, cacheDataLoaded, updateCachedData, dispatch }) {
        await cacheDataLoaded;
        const { configuration: configuration2, generatedAnswer, insightConfiguration } = getState();
        const { organizationId, environment, accessToken } = configuration2;
        const platformEndpoint = getOrganizationEndpoint(
          organizationId,
          environment
        );
        const answerEndpoint2 = buildAnswerEndpoint(
          platformEndpoint,
          organizationId,
          generatedAnswer.answerConfigurationId,
          insightConfiguration?.insightId
        );
        await fetchEventSource(answerEndpoint2, {
          method: "POST",
          body: JSON.stringify(args),
          headers: {
            Authorization: `Bearer ${accessToken}`,
            Accept: "application/json",
            "Content-Type": "application/json",
            "Accept-Encoding": "*"
          },
          fetch,
          onopen: async (res) => {
            const answerId = res.headers.get("x-answer-id");
            if (answerId) {
              updateCachedData((draft) => {
                draft.answerId = answerId;
                dispatch(setAnswerId2(answerId));
              });
            }
          },
          onmessage: (event) => {
            updateCachedData((draft) => {
              updateCacheWithEvent(event, draft, dispatch);
            });
          },
          onerror: (error) => {
            throw error;
          },
          onclose: () => {
            updateCachedData((draft) => {
              dispatch(setCannotAnswer(!draft.generated));
            });
          }
        });
      }
    })
  })
});
var fetchAnswer = (fetchAnswerParams) => {
  return answerApi.endpoints.getAnswer.initiate(fetchAnswerParams);
};

// src/features/debug/version-slice.ts
var import_toolkit32 = require("@reduxjs/toolkit");
var versionReducer = (0, import_toolkit32.createReducer)(VERSION, (builder) => builder);

// src/app/analytics-middleware.ts
var import_bueno26 = require("@coveo/bueno");
function isAnalyticsAction(action) {
  const analytics = action.payload?.analyticsAction;
  return isActionWithType(action) && !(0, import_bueno26.isNullOrUndefined)(analytics);
}
function isActionWithType(action) {
  return "type" in action;
}
var analyticsMiddleware = (api) => (next) => (action) => {
  let analytics;
  if (isAnalyticsAction(action)) {
    analytics = action.payload.analyticsAction;
    delete action.payload.analyticsAction;
  }
  const ret = next(action);
  if (isActionWithType(action)) {
    if (action.type === "search/executeSearch/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with search:", action);
    }
    if (action.type === "recommendation/get/fullfilled" && analytics === void 0) {
      console.error(
        "No analytics action associated with recommendation:",
        action
      );
    }
    if (action.type === "productRecommendations/get/fullfilled" && analytics === void 0) {
      console.error(
        "No analytics action associated with product recommendation:",
        action
      );
    }
  }
  if (analytics !== void 0) {
    api.dispatch(analytics);
  }
  return ret;
};

// src/features/configuration/configuration-slice.ts
var import_bueno28 = require("@coveo/bueno");
var import_toolkit34 = require("@reduxjs/toolkit");

// src/features/tab-set/tab-set-actions.ts
var import_bueno27 = require("@coveo/bueno");
var import_toolkit33 = require("@reduxjs/toolkit");
var registerTab = (0, import_toolkit33.createAction)(
  "tab/register",
  (payload) => {
    const schema = new import_bueno27.RecordValue({
      values: {
        id: requiredNonEmptyString,
        expression: requiredEmptyAllowedString
      }
    });
    return validatePayload(payload, schema);
  }
);
var updateActiveTab = (0, import_toolkit33.createAction)(
  "tab/updateActiveTab",
  (id) => {
    return validatePayload(id, requiredNonEmptyString);
  }
);

// src/features/configuration/configuration-state.ts
var import_dayjs3 = __toESM(require("dayjs"), 1);
var import_timezone = __toESM(require("dayjs/plugin/timezone.js"), 1);
var import_utc = __toESM(require("dayjs/plugin/utc.js"), 1);
import_dayjs3.default.extend(import_utc.default);
import_dayjs3.default.extend(import_timezone.default);
var getConfigurationInitialState = () => ({
  organizationId: "",
  accessToken: "",
  search: {
    locale: "en-US",
    timezone: import_dayjs3.default.tz.guess(),
    authenticationProviders: []
  },
  analytics: {
    enabled: true,
    originContext: "Search",
    originLevel2: "default",
    originLevel3: "default",
    anonymous: false,
    deviceId: "",
    userDisplayName: "",
    documentLocation: "",
    analyticsMode: "next",
    source: {}
  },
  knowledge: {
    answerConfigurationId: "",
    agentId: void 0
  },
  environment: "prod"
});

// src/features/configuration/magic-cookie.ts
var pendragonCookieValueMatcher = /(^|; )Coveo-Pendragon=([^;]*)/;
function getMagicCookie() {
  if (typeof window === "undefined") {
    return false;
  } else {
    return pendragonCookieValueMatcher.exec(document.cookie)?.pop() || null;
  }
}

// src/features/configuration/configuration-slice.ts
var configurationReducer = (0, import_toolkit34.createReducer)(
  getConfigurationInitialState(),
  (builder) => builder.addCase(updateBasicConfiguration, (state, action) => {
    handleUpdateBasicConfiguration(state, action.payload);
  }).addCase(updateSearchConfiguration, (state, action) => {
    handleUpdateSearchConfiguration(state, action.payload);
  }).addCase(updateAnalyticsConfiguration, (state, action) => {
    handleUpdateAnalyticsConfiguration(state, action.payload);
  }).addCase(disableAnalytics, (state) => {
    state.analytics.enabled = false;
  }).addCase(enableAnalytics, (state) => {
    state.analytics.enabled = true;
  }).addCase(setOriginLevel2, (state, action) => {
    state.analytics.originLevel2 = action.payload.originLevel2;
  }).addCase(setOriginLevel3, (state, action) => {
    state.analytics.originLevel3 = action.payload.originLevel3;
  }).addCase(updateActiveTab, (state, action) => {
    state.analytics.originLevel2 = action.payload;
  }).addCase(restoreTab, (state, action) => {
    state.analytics.originLevel2 = action.payload;
  }).addCase(restoreSearchParameters, (state, action) => {
    if (!(0, import_bueno28.isNullOrUndefined)(action.payload.tab)) {
      state.analytics.originLevel2 = action.payload.tab;
    }
  }).addCase(setAgentId, (state, { payload }) => {
    state.knowledge.agentId = payload;
  })
);
function handleUpdateBasicConfiguration(state, payload) {
  if (!(0, import_bueno28.isNullOrUndefined)(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!(0, import_bueno28.isNullOrUndefined)(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateSearchConfiguration(state, payload) {
  if (!(0, import_bueno28.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.search.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.locale)) {
    state.search.locale = payload.locale;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.timezone)) {
    state.search.timezone = payload.timezone;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.authenticationProviders)) {
    state.search.authenticationProviders = payload.authenticationProviders;
  }
}
function handleUpdateAnalyticsConfiguration(state, payload) {
  if (!(0, import_bueno28.isNullOrUndefined)(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.originContext)) {
    state.analytics.originContext = payload.originContext;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.originLevel2)) {
    state.analytics.originLevel2 = payload.originLevel2;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.originLevel3)) {
    state.analytics.originLevel3 = payload.originLevel3;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.analyticsMode)) {
    state.analytics.analyticsMode = payload.analyticsMode;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.source)) {
    state.analytics.source = payload.source;
  }
  try {
    const magicCookie = getMagicCookie();
    if (magicCookie) {
      state.analytics.analyticsMode = "next";
      state.analytics.trackingId = magicCookie;
    }
  } catch (_) {
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.runtimeEnvironment)) {
    state.analytics.runtimeEnvironment = payload.runtimeEnvironment;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.anonymous)) {
    state.analytics.anonymous = payload.anonymous;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.deviceId)) {
    state.analytics.deviceId = payload.deviceId;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.userDisplayName)) {
    state.analytics.userDisplayName = payload.userDisplayName;
  }
  if (!(0, import_bueno28.isNullOrUndefined)(payload.documentLocation)) {
    state.analytics.documentLocation = payload.documentLocation;
  }
}

// src/app/common-reducers.ts
var configuration = configurationReducer;

// src/app/instantly-callable-middleware.ts
function isInstantlyCallableThunkAction(action) {
  return action.instantlyCallable;
}
var instantlyCallableThunkActionMiddleware = () => (next) => (action) => next(isInstantlyCallableThunkAction(action) ? action() : action);

// src/app/listener-middleware/generate-answer-listener-middleware.ts
var import_toolkit35 = require("@reduxjs/toolkit");
var generateAnswerListener = (0, import_toolkit35.createListenerMiddleware)();
generateAnswerListener.startListening({
  actionCreator: executeSearch2.pending,
  effect: async (_action, listenerApi) => {
    const state = listenerApi.getState();
    const q = selectQuery(state)?.q;
    const queryIsEmpty = !q || q.trim() === "";
    if (!isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
      return;
    }
    listenerApi.dispatch(resetAnswer());
    listenerApi.dispatch(resetFollowUpAnswers());
    if (queryIsEmpty) {
      return;
    }
    listenerApi.dispatch(generateHeadAnswer());
  }
});

// src/app/logger-middlewares.ts
var logActionErrorMiddleware = (logger) => () => (next) => (action) => {
  const unknownAction = action;
  if (!unknownAction.error) {
    return next(action);
  }
  const error = unknownAction.error;
  if (!unknownAction.payload?.ignored) {
    logger.error(
      { error, action },
      `Action dispatch error ${unknownAction.type}`
    );
  }
  if (unknownAction.error.name === "SchemaValidationError") {
    return;
  }
  return next(action);
};
var logActionMiddleware = (logger) => (api) => (next) => (action) => {
  logger.debug(
    {
      action,
      nextState: api.getState()
    },
    `Action dispatched: ${action.type}`
  );
  return next(action);
};

// src/app/navigator-context-provider.ts
var getNavigatorContext = (relay, customProvider) => {
  const { referrer, userAgent, location, clientId } = relay.getMeta("");
  const customContext = customProvider ? customProvider() : {};
  return { ...customContext, referrer, userAgent, location, clientId };
};

// src/app/reducer-manager.ts
var import_toolkit36 = require("@reduxjs/toolkit");
function createReducerManager(initialReducers, preloadedState) {
  const reducers = { ...initialReducers };
  let crossReducer;
  const rootReducer = (combined) => {
    return (state, action) => {
      const intermediate = combined(state, action);
      const final = crossReducer ? crossReducer(intermediate, action) : intermediate;
      return final;
    };
  };
  return {
    get combinedReducer() {
      const placeholderReducers = fromEntries(
        Object.entries(preloadedState).filter(([key]) => !(key in reducers)).map(([key, value]) => [key, () => value])
      );
      return rootReducer(
        (0, import_toolkit36.combineReducers)({ ...placeholderReducers, ...reducers })
      );
    },
    containsAll(newReducers) {
      const keys = Object.keys(newReducers);
      return keys.every((key) => key in reducers);
    },
    add(newReducers) {
      Object.keys(newReducers).filter((key) => !(key in reducers)).forEach((key) => {
        reducers[key] = newReducers[key];
      });
    },
    addCrossReducer(reducer) {
      crossReducer = reducer;
    }
  };
}

// src/utils/jwt-utils.ts
function parseJWT(token) {
  if (!token || !isJWTToken(token)) {
    return null;
  }
  try {
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const base64decoded = atob(base64);
    const jsonPayload = decodeURIComponent(
      base64decoded.split("").map((character) => {
        return `%${`00${character.charCodeAt(0).toString(16)}`.slice(-2)}`;
      }).join("")
    );
    return JSON.parse(jsonPayload);
  } catch (_) {
    return null;
  }
}
function shouldRenewJWT(token, bufferSeconds = 60) {
  if (!token) {
    return false;
  }
  const parsedToken = parseJWT(token);
  if (!parsedToken || typeof parsedToken.exp !== "number") {
    return false;
  }
  const nowSeconds = Math.floor(Date.now() / 1e3);
  return parsedToken.exp <= nowSeconds + bufferSeconds;
}
function isJWTToken(token) {
  if (!token) {
    return false;
  }
  return /^[A-Za-z0-9_-]{2,}(?:\.[A-Za-z0-9_-]{2,}){2}$/.test(token);
}

// src/app/renew-access-token-middleware.ts
function createRenewAccessTokenMiddleware(logger, renewToken) {
  let accessTokenRenewalsAttempts = 0;
  let pendingTokenRenewal = null;
  const resetRenewalTriesAfterDelay = debounce(() => {
    accessTokenRenewalsAttempts = 0;
  }, 500);
  const handleTokenRenewal = async (store, handleErrors = false) => {
    const isTokenRenewalPending = !pendingTokenRenewal;
    if (isTokenRenewalPending && renewToken) {
      pendingTokenRenewal = (async () => {
        if (handleErrors) {
          attempt(renewToken);
        }
        return await renewToken();
      })().finally(() => {
        pendingTokenRenewal = null;
      });
    }
    const accessToken = await pendingTokenRenewal;
    if (isTokenRenewalPending && accessToken) {
      store.dispatch(updateBasicConfiguration({ accessToken }));
    }
    return accessToken;
  };
  const handleProactiveTokenRenewal = async (store) => {
    const state = store.getState();
    const accessToken = getAccessTokenFromState(state);
    if (!accessToken || !shouldRenewJWT(accessToken)) {
      return;
    }
    logger.debug(
      "Access token is expired or about to expire, attempting renewal."
    );
    try {
      const newAccessToken = await handleTokenRenewal(store);
      if (newAccessToken) {
        logger.debug("Access token was renewed.");
      } else {
        logger.warn(
          "Access token renewal returned an empty token. Please check the #renewAccessToken function."
        );
      }
    } catch (error) {
      logger.warn(
        error,
        "Access token renewal failed. A retry will occur if necessary."
      );
    }
  };
  const handleExpiredToken = async (store, payload, action) => {
    if (accessTokenRenewalsAttempts >= 5) {
      logger.warn(
        "Attempted to renew the token but was not successful. Please check the #renewAccessToken function."
      );
      dispatchError(store, payload.error);
      return payload;
    }
    accessTokenRenewalsAttempts++;
    resetRenewalTriesAfterDelay();
    await handleTokenRenewal(store, true);
    store.dispatch(action);
    return;
  };
  return (store) => (next) => async (action) => {
    const isThunk = typeof action === "function";
    const hasRenewFunction = typeof renewToken === "function";
    if (!isThunk) {
      return next(action);
    }
    if (hasRenewFunction) {
      await handleProactiveTokenRenewal(store);
    }
    const payload = await next(action);
    if (!isExpiredTokenError(payload)) {
      return payload;
    }
    if (!hasRenewFunction) {
      logger.warn(
        "Unable to renew the expired token because a renew function was not provided. Please specify the #renewAccessToken option when initializing the engine."
      );
      dispatchError(store, payload.error);
      return payload;
    }
    return await handleExpiredToken(store, payload, action);
  };
}
function isExpiredTokenError(action) {
  return typeof action === "object" && action !== null && "error" in action && // biome-ignore lint/suspicious/noExplicitAny: any action is possible here.
  action.error?.name === new UnauthorizedTokenError().name;
}
function dispatchError(store, error) {
  store.dispatch(
    setError({
      status: 401,
      statusCode: 401,
      message: error.message,
      type: error.name
    })
  );
}
async function attempt(fn) {
  try {
    return await fn();
  } catch (_) {
    return "";
  }
}
function getAccessTokenFromState(state) {
  return state.configuration.accessToken;
}

// src/app/store.ts
var import_toolkit37 = require("@reduxjs/toolkit");
function configureStore({
  reducer,
  preloadedState,
  middlewares = [],
  thunkExtraArguments,
  name
}) {
  return (0, import_toolkit37.configureStore)({
    reducer,
    preloadedState,
    devTools: {
      stateSanitizer: (state) => state.history ? { ...state, history: "<<OMIT>>" } : state,
      name,
      shouldHotReload: false
      // KIT-961 -> Redux dev tool + hot reloading interacts badly with replaceReducers mechanism.
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ thunk: { extraArgument: thunkExtraArguments } }).prepend(...middlewares).concat(logActionMiddleware(thunkExtraArguments.logger))
  });
}

// src/app/engine.ts
function getUpdateAnalyticsConfigurationPayload(configuration2, logger) {
  const { analytics } = configuration2;
  const { analyticsClientMiddleware: _, ...payload } = analytics ?? {};
  const payloadWithURL = {
    ...payload,
    ...analytics?.proxyBaseUrl && {
      apiBaseUrl: analytics.proxyBaseUrl,
      nexApiBaseUrl: analytics.proxyBaseUrl
    }
  };
  if (payloadWithURL.analyticsMode !== "next" && doNotTrack()) {
    logger.info("Analytics disabled since doNotTrack is active.");
    return {
      ...payloadWithURL,
      enabled: false
    };
  }
  return payloadWithURL;
}
function buildEngine(options, thunkExtraArguments) {
  const reducers = {
    ...options.reducers,
    configuration,
    version: versionReducer
  };
  const engine = buildCoreEngine(
    { ...options, reducers },
    thunkExtraArguments,
    configuration
  );
  const { accessToken, environment, organizationId } = options.configuration;
  engine.dispatch(
    updateBasicConfiguration({
      accessToken,
      environment,
      organizationId
    })
  );
  const analyticsPayload = getUpdateAnalyticsConfigurationPayload(
    options.configuration,
    engine.logger
  );
  if (analyticsPayload) {
    engine.dispatch(updateAnalyticsConfiguration(analyticsPayload));
  }
  return engine;
}
function buildCoreEngine(options, thunkExtraArguments, configurationReducer2) {
  const { reducers, navigatorContextProvider } = options;
  const reducerManager = createReducerManager(
    { ...reducers, configurationReducer: configurationReducer2 },
    options.preloadedState ?? {}
  );
  if (options.crossReducer) {
    reducerManager.addCrossReducer(options.crossReducer);
  }
  const logger = thunkExtraArguments.logger;
  const thunkExtraArgumentsWithRelay = {
    ...thunkExtraArguments,
    get relay() {
      return getRelayInstanceFromState(engine.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    }
  };
  const store = createStore(
    options,
    thunkExtraArgumentsWithRelay,
    reducerManager
  );
  const engine = {
    addReducers(reducers2) {
      if (reducerManager.containsAll(reducers2)) {
        return;
      }
      reducerManager.add(reducers2);
      store.replaceReducer(reducerManager.combinedReducer);
    },
    dispatch: store.dispatch,
    subscribe: store.subscribe,
    enableAnalytics() {
      store.dispatch(enableAnalytics());
    },
    disableAnalytics() {
      store.dispatch(disableAnalytics());
    },
    get state() {
      return store.getState();
    },
    get relay() {
      return getRelayInstanceFromState(this.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    },
    logger,
    store
  };
  return engine;
}
function createStore(options, thunkExtraArguments, reducerManager) {
  const { preloadedState, configuration: configuration2 } = options;
  const name = configuration2.name || "coveo-headless";
  const middlewares = createMiddleware(options, thunkExtraArguments.logger);
  return configureStore({
    preloadedState,
    reducer: reducerManager.combinedReducer,
    middlewares,
    thunkExtraArguments,
    name
  });
}
function createMiddleware(options, logger) {
  const { renewAccessToken } = options.configuration;
  const renewTokenMiddleware = createRenewAccessTokenMiddleware(
    logger,
    renewAccessToken
  );
  return [
    instantlyCallableThunkActionMiddleware,
    renewTokenMiddleware,
    logActionErrorMiddleware(logger),
    analyticsMiddleware
  ].concat(
    answerApi.middleware,
    answerGenerationApi.middleware,
    generateAnswerListener.middleware,
    options.middlewares || []
  );
}
var nextAnalyticsUsageWithServiceFeatureWarning = '[Warning] A component from the Coveo Headless library has been instantiated with the Analytics Mode: "Next".\nHowever, this mode is not available for Coveo for Service features, and this configuration may not work as expected.\nPlease switch back to the "legacy" analytics mode to ensure proper functionality.\nFor more information, refer to the documentation: https://docs.coveo.com/en/o3r90189/build-a-search-ui/event-protocol';
function warnIfUsingNextAnalyticsModeForServiceFeature(analyticsMode) {
  if (analyticsMode === "next") {
    console.warn(nextAnalyticsUsageWithServiceFeatureWarning);
  }
}

// src/app/logger.ts
var import_pino = require("pino");
function buildLogger(options) {
  return (0, import_pino.pino)({
    name: "@coveo/headless",
    level: options?.level || "warn",
    formatters: {
      log: options?.logFormatter
    }
  });
}

// src/app/thunk-extra-arguments.ts
function buildThunkExtraArguments(configuration2, logger) {
  const analyticsClientMiddleware = getAnalyticsClientMiddleware(configuration2);
  const validatePayload2 = validatePayloadAndThrow;
  const preprocessRequest = getPreprocessRequest(configuration2);
  return {
    analyticsClientMiddleware,
    validatePayload: validatePayload2,
    preprocessRequest,
    logger
  };
}
function getAnalyticsClientMiddleware(configuration2) {
  const { analytics } = configuration2;
  const NoopAnalyticsMiddleware = (_, p) => p;
  return analytics?.analyticsClientMiddleware || NoopAnalyticsMiddleware;
}
function getPreprocessRequest(configuration2) {
  return configuration2.preprocessRequest || NoopPreprocessRequest;
}

// src/app/search-engine/jwt-reducer.ts
var import_bueno29 = require("@coveo/bueno");
var import_toolkit38 = require("@reduxjs/toolkit");
var possiblyWarnOnMismatch = (token, tokenProp, stateProp, defaultProp, payload, logger) => {
  const tokenValue = token[tokenProp];
  if ((0, import_bueno29.isNullOrUndefined)(tokenValue)) {
    return;
  }
  if ((0, import_bueno29.isNullOrUndefined)(payload)) {
    return;
  }
  if (payload === tokenValue) {
    return;
  }
  if (payload === defaultProp) {
    return;
  }
  logger.warn(
    `Mismatch on access token (JWT Token) ${tokenProp} and engine configuration.`
  );
  logger.warn(
    `To remove this warning, make sure that access token value [${tokenValue}] matches engine configuration value [${stateProp}]`
  );
};
var shouldReconcileValues = (tokenValue, stateValue) => {
  if ((0, import_bueno29.isNullOrUndefined)(tokenValue)) {
    return false;
  }
  if (stateValue === tokenValue) {
    return false;
  }
  return true;
};
var decodeJSONWebToken = (token) => {
  const parsed = parseJWT(token);
  return parsed ? parsed : false;
};
var updateSearchHub = (jwt, state) => {
  if (shouldReconcileValues(jwt.searchHub, state.searchHub)) {
    state.searchHub = jwt.searchHub;
  }
  return state;
};
var handleMismatchOnSearchHub = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(
    jwt,
    "searchHub",
    state.searchHub,
    getSearchHubInitialState(),
    payload,
    logger
  );
  return updateSearchHub(jwt, state);
};
var updatePipeline = (jwt, state) => {
  if (shouldReconcileValues(jwt.pipeline, state.pipeline)) {
    state.pipeline = jwt.pipeline;
  }
  return state;
};
var handleMismatchOnPipeline = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(
    jwt,
    "pipeline",
    state.pipeline,
    getPipelineInitialState(),
    payload,
    logger
  );
  return updatePipeline(jwt, state);
};
var updateUserDisplayName = (jwt, state) => {
  if (shouldReconcileValues(
    jwt.userDisplayName,
    state.configuration.analytics.userDisplayName
  )) {
    state.configuration.analytics.userDisplayName = jwt.userDisplayName;
  }
  return state;
};
var handleMismatchOnUserDisplayName = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(
    jwt,
    "userDisplayName",
    state.configuration.analytics.userDisplayName,
    getConfigurationInitialState().analytics.userDisplayName,
    payload,
    logger
  );
  return updateUserDisplayName(jwt, state);
};
var jwtReducer = (logger) => {
  return (0, import_toolkit38.createReducer)({}, (builder) => {
    builder.addCase(setSearchHub, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnSearchHub(jwt, state, action.payload, logger);
    }).addCase(setPipeline, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnPipeline(jwt, state, action.payload, logger);
    }).addCase(updateBasicConfiguration, (state, action) => {
      if (state.configuration.accessToken !== action.payload.accessToken) {
        return state;
      }
      const { accessToken } = action.payload;
      if (!accessToken) {
        return state;
      }
      const jwt = decodeJSONWebToken(accessToken);
      if (!jwt) {
        return state;
      }
      return [updatePipeline, updateSearchHub, updateUserDisplayName].reduce(
        (resultingState, updateProp) => updateProp(jwt, resultingState),
        state
      );
    }).addCase(updateSearchConfiguration, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      const searchHubReconciled = handleMismatchOnSearchHub(
        jwt,
        state,
        action.payload.searchHub,
        logger
      );
      const pipelineReconciled = handleMismatchOnPipeline(
        jwt,
        searchHubReconciled,
        action.payload?.pipeline,
        logger
      );
      return pipelineReconciled;
    }).addCase(updateAnalyticsConfiguration, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnUserDisplayName(
        jwt,
        state,
        action.payload.userDisplayName,
        logger
      );
    });
  });
};

// src/app/search-engine/search-engine-configuration.ts
var import_bueno31 = require("@coveo/bueno");

// src/app/engine-configuration.ts
var import_bueno30 = require("@coveo/bueno");
var engineConfigurationDefinitions = {
  organizationId: requiredNonEmptyString,
  accessToken: requiredNonEmptyString,
  name: new import_bueno30.StringValue({
    required: false,
    emptyAllowed: false
  }),
  analytics: new import_bueno30.RecordValue({
    options: {
      required: false
    },
    values: {
      enabled: new import_bueno30.BooleanValue({
        required: false
      }),
      originContext: new import_bueno30.StringValue({
        required: false
      }),
      originLevel2: new import_bueno30.StringValue({
        required: false
      }),
      originLevel3: new import_bueno30.StringValue({
        required: false
      }),
      analyticsMode: new import_bueno30.StringValue({
        constrainTo: ["legacy", "next"],
        required: false,
        default: "next"
      }),
      proxyBaseUrl: new import_bueno30.StringValue({
        required: false,
        url: true
      }),
      trackingId: new import_bueno30.StringValue({
        required: false,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  environment: new import_bueno30.StringValue({
    required: false,
    default: "prod",
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  })
};
function getSampleEngineConfiguration() {
  return {
    organizationId: "searchuisamples",
    // deepcode ignore HardcodedNonCryptoSecret: Public key freely available for our documentation
    accessToken: "xx564559b1-0045-48e1-953c-3addd1ee4457"
  };
}

// src/app/search-engine/search-engine-configuration.ts
var searchEngineConfigurationSchema = new import_bueno31.Schema({
  ...engineConfigurationDefinitions,
  search: new import_bueno31.RecordValue({
    options: {
      required: false
    },
    values: {
      pipeline: new import_bueno31.StringValue({ required: false, emptyAllowed: true }),
      searchHub: nonEmptyString,
      locale: nonEmptyString,
      timezone: nonEmptyString,
      authenticationProviders: new import_bueno31.ArrayValue({
        required: false,
        each: requiredNonEmptyString
      }),
      proxyBaseUrl: new import_bueno31.StringValue({ required: false, url: true })
    }
  })
});
function getSampleSearchEngineConfiguration() {
  return {
    ...getSampleEngineConfiguration(),
    search: {
      searchHub: "default"
    }
  };
}

// src/app/search-engine/search-engine.ts
var searchEngineReducers = { debug: debugReducer, pipeline: pipelineReducer, searchHub: searchHubReducer, search: searchReducer };
function getUpdateSearchConfigurationPayload(configuration2) {
  const { search, organizationId, environment } = configuration2;
  const apiBaseUrl = search?.proxyBaseUrl ? search.proxyBaseUrl : getSearchApiBaseUrl(organizationId, environment);
  const payloadWithURL = {
    ...search,
    apiBaseUrl
  };
  return payloadWithURL;
}
function buildSearchEngine(options) {
  const logger = buildLogger(options.loggerOptions);
  const { configuration: configuration2 } = options;
  validateConfiguration(configuration2, logger);
  const searchAPIClient = createSearchAPIClient(configuration2, logger);
  const generatedAnswerClient = createGeneratedAnswerAPIClient(logger);
  const thunkArguments = {
    ...buildThunkExtraArguments(configuration2, logger),
    apiClient: searchAPIClient,
    streamingClient: generatedAnswerClient
  };
  const augmentedOptions = {
    ...options,
    reducers: searchEngineReducers,
    crossReducer: jwtReducer(logger)
  };
  const engine = buildEngine(augmentedOptions, thunkArguments);
  const search = getUpdateSearchConfigurationPayload(configuration2);
  if (search) {
    engine.dispatch(updateSearchConfiguration(search));
  }
  return {
    ...engine,
    get state() {
      return engine.state;
    },
    executeFirstSearch(analyticsEvent = logInterfaceLoad()) {
      if (firstSearchExecutedSelector(engine.state)) {
        return;
      }
      const action = executeSearch2({
        legacy: analyticsEvent,
        next: interfaceLoad()
      });
      engine.dispatch(action);
    },
    executeFirstSearchAfterStandaloneSearchBoxRedirect(analytics) {
      const { cause, metadata } = analytics;
      if (firstSearchExecutedSelector(engine.state)) {
        return;
      }
      const isOmniboxFromLink = metadata && cause === "omniboxFromLink";
      const action = executeSearch2({
        legacy: isOmniboxFromLink ? logOmniboxFromLink(metadata) : logSearchFromLink(),
        next: isOmniboxFromLink ? omniboxFromLink() : searchFromLink()
      });
      engine.dispatch(action);
    }
  };
}
function validateConfiguration(configuration2, logger) {
  try {
    searchEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error(error, "Search engine configuration error");
    throw error;
  }
}
function createSearchAPIClient(configuration2, logger) {
  const { search } = configuration2;
  return new SearchAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest,
    postprocessSearchResponseMiddleware: search?.preprocessSearchResponseMiddleware || NoopPostprocessSearchResponseMiddleware,
    postprocessFacetSearchResponseMiddleware: search?.preprocessFacetSearchResponseMiddleware || NoopPostprocessFacetSearchResponseMiddleware,
    postprocessQuerySuggestResponseMiddleware: search?.preprocessQuerySuggestResponseMiddleware || NoopPostprocessQuerySuggestResponseMiddleware
  });
}
function createGeneratedAnswerAPIClient(logger) {
  return new GeneratedAnswerAPIClient({
    logger
  });
}

// src/features/facets/automatic-facet-set/automatic-facet-set-actions.ts
var import_bueno33 = require("@coveo/bueno");
var import_toolkit39 = require("@reduxjs/toolkit");

// src/features/facets/facet-set/facet-set-validate-payload.ts
var import_bueno32 = require("@coveo/bueno");
var facetValueDefinition = {
  value: requiredNonEmptyString,
  numberOfResults: new import_bueno32.NumberValue({ min: 0 }),
  state: requiredNonEmptyString
};

// src/features/facets/generic/facet-actions-validation.ts
var facetIdDefinition = requiredNonEmptyString;

// src/features/facets/automatic-facet-set/automatic-facet-set-actions.ts
var numberOfValuesDefinition = new import_bueno33.NumberValue({
  min: NUMBER_OF_VALUE_MINIMUM,
  default: NUMBER_OF_VALUE_DEFAULT,
  required: false
});
var desiredCountDefinition = new import_bueno33.NumberValue({
  min: DESIRED_COUNT_MINIMUM,
  max: DESIRED_COUNT_MAXIMUM,
  default: DESIRED_COUNT_DEFAULT,
  required: false
});
var optionsSchema = {
  desiredCount: desiredCountDefinition,
  numberOfValues: numberOfValuesDefinition
};
var setOptions = (0, import_toolkit39.createAction)(
  "automaticFacet/setOptions",
  (payload) => validatePayload(payload, optionsSchema)
);
var deselectAllAutomaticFacetValues = (0, import_toolkit39.createAction)(
  "automaticFacet/deselectAll",
  (payload) => validatePayload(payload, facetIdDefinition)
);
var fieldDefinition = requiredNonEmptyString;
var toggleSelectAutomaticFacetValue = (0, import_toolkit39.createAction)(
  "automaticFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    field: fieldDefinition,
    selection: new import_bueno33.RecordValue({ values: facetValueDefinition })
  })
);

// src/features/facets/category-facet-set/category-facet-set-actions.ts
var import_bueno35 = require("@coveo/bueno");
var import_toolkit40 = require("@reduxjs/toolkit");

// src/features/facets/category-facet-set/category-facet-validate-payload.ts
var import_bueno34 = require("@coveo/bueno");
var categoryFacetValueDefinition = {
  state: new import_bueno34.Value({ required: true }),
  numberOfResults: new import_bueno34.NumberValue({ required: true, min: 0 }),
  value: new import_bueno34.StringValue({ required: true, emptyAllowed: true }),
  path: new import_bueno34.ArrayValue({ required: true, each: requiredNonEmptyString }),
  moreValuesAvailable: new import_bueno34.BooleanValue({ required: false })
};
function validateCategoryFacetValue(payload) {
  payload.children.forEach((child) => {
    validateCategoryFacetValue(child);
  });
  validatePayloadAndThrow(
    {
      state: payload.state,
      numberOfResults: payload.numberOfResults,
      value: payload.value,
      path: payload.path,
      moreValuesAvailable: payload.moreValuesAvailable
    },
    categoryFacetValueDefinition
  );
}

// src/features/facets/category-facet-set/category-facet-set-actions.ts
var categoryFacetPayloadDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new import_bueno35.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno35.ArrayValue({ each: new import_bueno35.StringValue() }),
      excluded: new import_bueno35.ArrayValue({ each: new import_bueno35.StringValue() })
    }
  }),
  activeTab: new import_bueno35.StringValue({ required: false }),
  delimitingCharacter: new import_bueno35.StringValue({ required: false, emptyAllowed: true }),
  filterFacetCount: new import_bueno35.BooleanValue({ required: false }),
  injectionDepth: new import_bueno35.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno35.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno35.Value({ required: false }),
  basePath: new import_bueno35.ArrayValue({ required: false, each: requiredNonEmptyString }),
  filterByBasePath: new import_bueno35.BooleanValue({ required: false })
};
var registerCategoryFacet = (0, import_toolkit40.createAction)(
  "categoryFacet/register",
  (payload) => validatePayload(payload, categoryFacetPayloadDefinition)
);
var toggleSelectCategoryFacetValue = (0, import_toolkit40.createAction)(
  "categoryFacet/toggleSelectValue",
  (payload) => {
    try {
      validatePayloadAndThrow(payload.facetId, requiredNonEmptyString);
      validateCategoryFacetValue(payload.selection);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var deselectAllCategoryFacetValues = (0, import_toolkit40.createAction)(
  "categoryFacet/deselectAll",
  (payload) => validatePayload(payload, categoryFacetPayloadDefinition.facetId)
);
var updateCategoryFacetNumberOfValues = (0, import_toolkit40.createAction)(
  "categoryFacet/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: categoryFacetPayloadDefinition.facetId,
    numberOfValues: categoryFacetPayloadDefinition.numberOfValues
  })
);
var updateCategoryFacetSortCriterion = (0, import_toolkit40.createAction)(
  "categoryFacet/updateSortCriterion",
  (payload) => validatePayload(payload, {
    facetId: categoryFacetPayloadDefinition.facetId,
    criterion: new import_bueno35.Value()
  })
);
var updateCategoryFacetBasePath = (0, import_toolkit40.createAction)(
  "categoryFacet/updateBasePath",
  (payload) => validatePayload(payload, {
    facetId: categoryFacetPayloadDefinition.facetId,
    basePath: new import_bueno35.ArrayValue({ each: requiredNonEmptyString })
  })
);

// src/features/facets/category-facet-set/category-facet-set-analytics-actions.ts
var import_bueno36 = require("@coveo/bueno");
var categoryFacetBreadcrumbPayloadDefinition = {
  categoryFacetId: facetIdDefinition,
  categoryFacetPath: new import_bueno36.ArrayValue({
    required: true,
    each: requiredNonEmptyString
  })
};
var getCategoryFacetMetadata = (state, {
  categoryFacetId,
  categoryFacetPath
}) => {
  const facet = state.categoryFacetSet[categoryFacetId];
  const categoryFacetField = facet?.request.field;
  const categoryFacetTitle = `${categoryFacetField}_${categoryFacetId}`;
  return {
    categoryFacetId,
    categoryFacetPath,
    categoryFacetField,
    categoryFacetTitle
  };
};
var logCategoryFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/categoryFacet/breadcrumb", (client, state) => {
  validatePayload(payload, categoryFacetBreadcrumbPayloadDefinition);
  return client.makeBreadcrumbFacet(getCategoryFacetMetadata(state, payload));
});
var categoryBreadcrumbFacet = () => ({
  actionCause: "breadcrumbFacet" /* breadcrumbFacet */
});

// src/features/facets/category-facet-set/category-facet-set-slice.ts
var import_toolkit43 = require("@reduxjs/toolkit");

// src/features/facet-options/facet-options-actions.ts
var import_bueno37 = require("@coveo/bueno");
var import_toolkit41 = require("@reduxjs/toolkit");
var updateFacetOptions = (0, import_toolkit41.createAction)(
  "facetOptions/update",
  (payload = { freezeFacetOrder: true }) => validatePayload(payload, {
    freezeFacetOrder: new import_bueno37.BooleanValue({ required: false })
  })
);
var enableFacet = (0, import_toolkit41.createAction)(
  "facetOptions/facet/enable",
  (payload) => validatePayload(payload, facetIdDefinition)
);
var disableFacet = (0, import_toolkit41.createAction)(
  "facetOptions/facet/disable",
  (payload) => validatePayload(payload, facetIdDefinition)
);

// src/features/facets/facet-search-set/category/category-facet-search-actions.ts
var import_bueno39 = require("@coveo/bueno");
var import_toolkit42 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/generic/generic-facet-search-validate-payload.ts
var import_bueno38 = require("@coveo/bueno");
var facetSearchOptionsDefinition = {
  facetId: facetIdDefinition,
  captions: new import_bueno38.RecordValue({ options: { required: false } }),
  numberOfValues: new import_bueno38.NumberValue({ required: false, min: 1 }),
  query: new import_bueno38.StringValue({ required: false, emptyAllowed: true })
};

// src/features/facets/facet-search-set/category/category-facet-search-actions.ts
var categoryFacetSearchResultDefinition = {
  path: new import_bueno39.ArrayValue({
    required: true,
    each: requiredNonEmptyString
  }),
  displayValue: requiredEmptyAllowedString,
  rawValue: requiredEmptyAllowedString,
  count: new import_bueno39.NumberValue({ required: true, min: 0 })
};
var selectCategoryFacetSearchResult = (0, import_toolkit42.createAction)(
  "categoryFacet/selectSearchResult",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    value: new import_bueno39.RecordValue({ values: categoryFacetSearchResultDefinition })
  })
);
var registerCategoryFacetSearch = (0, import_toolkit42.createAction)(
  "categoryFacetSearch/register",
  (payload) => validatePayload(payload, facetSearchOptionsDefinition)
);

// src/features/facets/generic/facet-reducer-helpers.ts
function handleFacetSortCriterionUpdate(state, payload) {
  const { facetId: facetId2, criterion } = payload;
  const facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.sortCriteria = criterion;
}
function handleFacetDeselectAll(facetRequest) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetRequest.currentValues.map((value) => ({
    ...value,
    ...{ previousState: value.state !== "idle" ? value.state : void 0 },
    state: "idle"
  }));
  facetRequest.preventAutoSelect = true;
}
function handleFacetUpdateNumberOfValues(facetRequest, numberOfValues2) {
  if (!facetRequest) {
    return;
  }
  facetRequest.numberOfValues = numberOfValues2;
}

// src/features/facets/category-facet-set/category-facet-reducer-helpers.ts
function handleCategoryFacetDeselectAll(state, facetId2) {
  const slice = state[facetId2];
  if (!slice) {
    return;
  }
  slice.request.numberOfValues = slice.initialNumberOfValues;
  slice.request.currentValues = [];
  slice.request.preventAutoSelect = true;
}
function selectPath(request, path, initialNumberOfValues) {
  request.currentValues = buildCurrentValuesFromPath(
    path,
    initialNumberOfValues
  );
  request.numberOfValues = path.length ? 1 : initialNumberOfValues;
  request.preventAutoSelect = true;
}
function buildCurrentValuesFromPath(path, retrieveCount) {
  if (!path.length) {
    return [];
  }
  const root = buildCategoryFacetValueRequest(path[0], retrieveCount);
  let curr = root;
  for (const segment of path.splice(1)) {
    const next = buildCategoryFacetValueRequest(segment, retrieveCount);
    curr.children.push(next);
    curr = next;
  }
  curr.state = "selected";
  curr.retrieveChildren = true;
  return [root];
}
function buildCategoryFacetValueRequest(value, retrieveCount) {
  return {
    value,
    retrieveCount,
    children: [],
    state: "idle",
    retrieveChildren: false
  };
}

// src/features/facets/category-facet-set/category-facet-set-slice.ts
var categoryFacetSetReducer = (0, import_toolkit43.createReducer)(
  getCategoryFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerCategoryFacet, (state, action) => {
      const options = action.payload;
      const { facetId: facetId2 } = options;
      if (facetId2 in state) {
        return;
      }
      const request = buildCategoryFacetRequest(options);
      const initialNumberOfValues = request.numberOfValues;
      state[facetId2] = { request, initialNumberOfValues };
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.categoryFacetSet ?? state
    ).addCase(restoreSearchParameters, (state, action) => {
      const cf = action.payload.cf || {};
      Object.keys(state).forEach((id) => {
        const request = state[id].request;
        const path = cf[id] || [];
        if (path.length || request.currentValues.length) {
          selectPath(request, path, state[id].initialNumberOfValues);
        }
      });
    }).addCase(updateCategoryFacetSortCriterion, (state, action) => {
      const { facetId: facetId2, criterion } = action.payload;
      const request = state[facetId2]?.request;
      if (!request) {
        return;
      }
      request.sortCriteria = criterion;
    }).addCase(updateCategoryFacetBasePath, (state, action) => {
      const { facetId: facetId2, basePath: basePath2 } = action.payload;
      const request = state[facetId2]?.request;
      if (!request) {
        return;
      }
      request.basePath = [...basePath2];
    }).addCase(toggleSelectCategoryFacetValue, (state, action) => {
      const { facetId: facetId2, selection, retrieveCount } = action.payload;
      const request = state[facetId2]?.request;
      if (!request) {
        return;
      }
      const { path } = selection;
      const pathToSelection = path.slice(0, path.length - 1);
      const children = ensurePathAndReturnChildren(
        request,
        pathToSelection,
        retrieveCount
      );
      if (children.length) {
        const lastSelectedParent = children[0];
        lastSelectedParent.retrieveChildren = true;
        lastSelectedParent.state = "selected";
        lastSelectedParent.previousState = "idle";
        lastSelectedParent.children = [];
        return;
      }
      const newParent = buildCategoryFacetValueRequest2(
        selection.value,
        retrieveCount
      );
      newParent.state = "selected";
      newParent.previousState = "idle";
      children.push(newParent);
      request.numberOfValues = 1;
    }).addCase(deselectAllCategoryFacetValues, (state, action) => {
      const facetId2 = action.payload;
      handleCategoryFacetDeselectAll(state, facetId2);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.keys(state).forEach(
        (facetId2) => handleCategoryFacetDeselectAll(state, facetId2)
      );
    }).addCase(
      updateFacetAutoSelection,
      (state, action) => Object.keys(state).forEach((facetId2) => {
        state[facetId2].request.preventAutoSelect = !action.payload.allow;
      })
    ).addCase(updateCategoryFacetNumberOfValues, (state, action) => {
      const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
      const request = state[facetId2]?.request;
      if (!request) {
        return;
      }
      if (!request.currentValues.length) {
        return handleFacetUpdateNumberOfValues(
          request,
          numberOfValues2
        );
      }
      handleCategoryFacetNestedNumberOfValuesUpdate(state, action.payload);
    }).addCase(selectCategoryFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facet = state[facetId2];
      if (!facet) {
        return;
      }
      const path = [...value.path, value.rawValue];
      selectPath(facet.request, path, facet.initialNumberOfValues);
    }).addCase(fetchFacetValues2.fulfilled, (state, action) => {
      handleCategoryFacetResponseUpdate(
        state,
        action.payload.response.facets
      );
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      handleCategoryFacetResponseUpdate(
        state,
        action.payload.response.facets
      );
    }).addCase(disableFacet, (state, action) => {
      handleCategoryFacetDeselectAll(state, action.payload);
    });
  }
);
var defaultCategoryFacetOptions = {
  delimitingCharacter: ";",
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 5,
  sortCriteria: "occurrences",
  basePath: [],
  filterByBasePath: true,
  resultsMustMatch: "atLeastOneValue"
};
function ensurePathAndReturnChildren(request, path, retrieveCount) {
  let children = request.currentValues;
  for (const segment of path) {
    let parent = children[0];
    const missingParent = !parent;
    if (missingParent || segment !== parent.value) {
      parent = buildCategoryFacetValueRequest2(segment, retrieveCount);
      children.length = 0;
      children.push(parent);
    }
    parent.retrieveChildren = false;
    parent.previousState = void 0;
    parent.state = "idle";
    children = parent.children;
  }
  return children;
}
function buildCategoryFacetRequest(config) {
  return {
    ...defaultCategoryFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "hierarchical",
    ...config
  };
}
function buildCategoryFacetValueRequest2(value, retrieveCount) {
  return {
    value,
    state: "idle",
    children: [],
    retrieveChildren: true,
    retrieveCount
  };
}
function handleCategoryFacetResponseUpdate(state, facets) {
  facets.forEach((response) => {
    if (!isCategoryFacetResponse2(state, response)) {
      return;
    }
    const id = response.facetId;
    const request = state[id]?.request;
    if (!request) {
      return;
    }
    const requestWasInvalid = isRequestInvalid(request, response);
    request.currentValues = requestWasInvalid ? [] : request.currentValues;
    request.preventAutoSelect = false;
  });
}
function handleCategoryFacetNestedNumberOfValuesUpdate(state, payload) {
  const { facetId: facetId2, numberOfValues: numberOfValues2 } = payload;
  let selectedValue = state[facetId2]?.request.currentValues[0];
  if (!selectedValue) {
    return;
  }
  while (selectedValue.children.length && selectedValue?.state !== "selected") {
    selectedValue = selectedValue.children[0];
  }
  selectedValue.retrieveCount = numberOfValues2;
}
function isCategoryFacetResponse2(state, response) {
  const id = response.facetId;
  return id in state;
}
function isRequestInvalid(request, response) {
  const requestParents = findActiveValueAncestry(request.currentValues);
  const responseParents = findActiveValueAncestry(response.values);
  return requestParents.length !== responseParents.length;
}

// src/features/facets/facet-set/facet-set-actions.ts
var import_bueno41 = require("@coveo/bueno");
var import_toolkit44 = require("@reduxjs/toolkit");

// src/controllers/core/facets/_common/facet-option-definitions.ts
var import_bueno40 = require("@coveo/bueno");
var facetId = new import_bueno40.StringValue({
  regex: /^[a-zA-Z0-9-_]+$/
});
var field = new import_bueno40.StringValue({ required: true });
var basePath = new import_bueno40.ArrayValue({
  each: new import_bueno40.StringValue()
});
var delimitingCharacter = new import_bueno40.StringValue();
var filterByBasePath = new import_bueno40.BooleanValue();
var filterFacetCount = new import_bueno40.BooleanValue();
var injectionDepth = new import_bueno40.NumberValue({ min: 0 });
var numberOfValues = new import_bueno40.NumberValue({ min: 1 });
var generateAutomaticRanges = new import_bueno40.BooleanValue({
  required: true
});
var captions = new import_bueno40.RecordValue();
var query = new import_bueno40.StringValue();
var facetSearchOptionDefinitions = {
  captions,
  numberOfValues,
  query
};
var facetSearch = new import_bueno40.RecordValue({
  values: facetSearchOptionDefinitions
});
var allowedValues = new import_bueno40.RecordValue({
  options: { required: false },
  values: {
    type: new import_bueno40.StringValue({
      constrainTo: ["simple"],
      emptyAllowed: false,
      required: true
    }),
    values: new import_bueno40.ArrayValue({
      required: true,
      max: 25,
      each: new import_bueno40.StringValue({ emptyAllowed: false, required: true })
    })
  }
});
var hasBreadcrumbs = new import_bueno40.BooleanValue();
var customSort = new import_bueno40.ArrayValue({
  min: 1,
  max: 25,
  required: false,
  each: new import_bueno40.StringValue({ emptyAllowed: false, required: true })
});

// src/features/facets/facet-set/facet-set-actions.ts
var facetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: new import_bueno41.StringValue({ required: true, emptyAllowed: true }),
  tabs: new import_bueno41.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno41.ArrayValue({ each: new import_bueno41.StringValue() }),
      excluded: new import_bueno41.ArrayValue({ each: new import_bueno41.StringValue() })
    }
  }),
  activeTab: new import_bueno41.StringValue({ required: false }),
  filterFacetCount: new import_bueno41.BooleanValue({ required: false }),
  injectionDepth: new import_bueno41.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno41.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno41.Value({ required: false }),
  resultsMustMatch: new import_bueno41.Value({ required: false }),
  allowedValues,
  customSort
};
var registerFacet = (0, import_toolkit44.createAction)(
  "facet/register",
  (payload) => validatePayload(payload, facetRegistrationOptionsDefinition)
);
var toggleSelectFacetValue = (0, import_toolkit44.createAction)(
  "facet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno41.RecordValue({ values: facetValueDefinition })
  })
);
var toggleExcludeFacetValue = (0, import_toolkit44.createAction)(
  "facet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno41.RecordValue({ values: facetValueDefinition })
  })
);
var deselectAllFacetValues = (0, import_toolkit44.createAction)(
  "facet/deselectAll",
  (payload) => validatePayload(payload, facetIdDefinition)
);
var updateFacetSortCriterion = (0, import_toolkit44.createAction)(
  "facet/updateSortCriterion",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new import_bueno41.Value({ required: true })
  })
);
var updateFacetNumberOfValues = (0, import_toolkit44.createAction)(
  "facet/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    numberOfValues: new import_bueno41.NumberValue({ required: true, min: 1 })
  })
);
var updateFacetIsFieldExpanded = (0, import_toolkit44.createAction)(
  "facet/updateIsFieldExpanded",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    isFieldExpanded: new import_bueno41.BooleanValue({ required: true })
  })
);
var updateFreezeCurrentValues = (0, import_toolkit44.createAction)(
  "facet/updateFreezeCurrentValues",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    freezeCurrentValues: new import_bueno41.BooleanValue({ required: true })
  })
);

// src/features/facets/facet-set/facet-set-analytics-actions.ts
var import_bueno42 = require("@coveo/bueno");
var logFacetShowMore = (facetId2) => makeAnalyticsAction("analytics/facet/showMore", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const metadata = buildFacetBaseMetadata(
    facetId2,
    getStateNeededForFacetMetadata(state)
  );
  return client.makeFacetShowMore(metadata);
});
var logFacetShowLess = (facetId2) => makeAnalyticsAction("analytics/facet/showLess", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const metadata = buildFacetBaseMetadata(
    facetId2,
    getStateNeededForFacetMetadata(state)
  );
  return client.makeFacetShowLess(metadata);
});
var logFacetUpdateSort = (payload) => makeAnalyticsAction("analytics/facet/sortChange", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new import_bueno42.Value({
      required: true
    })
  });
  const { facetId: facetId2, criterion } = payload;
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const base = buildFacetBaseMetadata(facetId2, stateForAnalytics);
  const metadata = { ...base, criteria: criterion };
  return client.makeFacetUpdateSort(metadata);
});
var logFacetClearAll = (facetId2) => makeAnalyticsAction("analytics/facet/reset", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetBaseMetadata(facetId2, stateForAnalytics);
  return client.makeFacetClearAll(metadata);
});
var logFacetSelect = (payload) => makeAnalyticsAction("analytics/facet/select", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(
    payload,
    stateForAnalytics
  );
  return client.makeFacetSelect(metadata);
});
var logFacetExclude = (payload) => makeAnalyticsAction("analytics/facet/exclude", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(
    payload,
    stateForAnalytics
  );
  return client.makeFacetExclude(metadata);
});
var logFacetDeselect = (payload) => makeAnalyticsAction("analytics/facet/deselect", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(
    payload,
    stateForAnalytics
  );
  return client.makeFacetDeselect(metadata);
});
var logFacetUnexclude = (payload) => makeAnalyticsAction("analytics/facet/unexclude", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(
    payload,
    stateForAnalytics
  );
  return client.makeFacetUnexclude(metadata);
});
var logFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/facet/breadcrumb", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const metadata = buildFacetSelectionChangeMetadata(
    payload,
    getStateNeededForFacetMetadata(state)
  );
  return client.makeBreadcrumbFacet(metadata);
});
var facetClearAll = () => {
  return {
    actionCause: "facetClearAll" /* facetClearAll */
  };
};
var facetSelect = () => ({
  actionCause: "facetSelect" /* facetSelect */
});
var facetExclude = () => ({
  actionCause: "facetExclude" /* facetExclude */
});
var facetDeselect = () => ({
  actionCause: "facetDeselect" /* facetDeselect */
});
var facetUnexclude = () => ({
  actionCause: "facetUnexclude" /* facetUnexclude */
});
var breadcrumbFacet = () => ({
  actionCause: "breadcrumbFacet" /* breadcrumbFacet */
});

// src/features/facets/facet-set/facet-set-slice.ts
var import_toolkit46 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/specific/specific-facet-search-actions.ts
var import_bueno43 = require("@coveo/bueno");
var import_toolkit45 = require("@reduxjs/toolkit");
var selectFacetSearchResultPayloadDefinition = {
  facetId: facetIdDefinition,
  value: new import_bueno43.RecordValue({
    values: {
      displayValue: requiredEmptyAllowedString,
      rawValue: requiredEmptyAllowedString,
      count: new import_bueno43.NumberValue({ required: true, min: 0 })
    }
  })
};
var registerFacetSearch = (0, import_toolkit45.createAction)(
  "facetSearch/register",
  (payload) => validatePayload(payload, facetSearchOptionsDefinition)
);
var updateFacetSearch = (0, import_toolkit45.createAction)(
  "facetSearch/update",
  (payload) => validatePayload(payload, facetSearchOptionsDefinition)
);
var selectFacetSearchResult = (0, import_toolkit45.createAction)(
  "facetSearch/toggleSelectValue",
  (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition)
);
var excludeFacetSearchResult = (0, import_toolkit45.createAction)(
  "facetSearch/toggleExcludeValue",
  (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition)
);

// src/features/facets/facet-set/facet-set-slice.ts
var facetSetReducer = (0, import_toolkit46.createReducer)(
  getFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerFacet, (state, action) => {
      const { facetId: facetId2 } = action.payload;
      if (facetId2 in state) {
        return;
      }
      state[facetId2] = getFacetSetSliceInitialState(
        buildFacetRequest(action.payload)
      );
    }).addCase(change.fulfilled, (_, action) => {
      if (!action.payload) {
        return;
      }
      if (Object.keys(action.payload.facetSet).length === 0) {
        return;
      }
      return action.payload.facetSet;
    }).addCase(restoreSearchParameters, (state, action) => {
      const f2 = action.payload.f || {};
      const fExcluded = action.payload.fExcluded || {};
      const facetIds = Object.keys(state);
      facetIds.forEach((id) => {
        const { request } = state[id];
        const selectedValues = f2[id] || [];
        const excludedValues = fExcluded[id] || [];
        const activeValueCount = selectedValues.length + excludedValues.length;
        const idleValues = request.currentValues.filter(
          (facetValue) => !selectedValues.includes(facetValue.value) && !excludedValues.includes(facetValue.value)
        );
        request.currentValues = [
          ...selectedValues.map(buildSelectedFacetValueRequest),
          ...excludedValues.map(buildExcludedFacetValueRequest),
          ...idleValues.map(restoreFacetValueToIdleState)
        ];
        request.preventAutoSelect = activeValueCount > 0;
        request.numberOfValues = Math.max(
          activeValueCount,
          request.numberOfValues
        );
      });
    }).addCase(toggleSelectFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.currentValues.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue(facetRequest, selection);
        return;
      }
      const isSelected = existingValue.state === "selected";
      existingValue.previousState = existingValue.state;
      existingValue.state = isSelected ? "idle" : "selected";
      facetRequest.freezeCurrentValues = true;
    }).addCase(toggleExcludeFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.preventAutoSelect = true;
      const existingValue = facetRequest.currentValues.find(
        (req) => req.value === selection.value
      );
      if (!existingValue) {
        insertNewValue(facetRequest, selection);
        return;
      }
      const isExcluded = existingValue.state === "excluded";
      existingValue.previousState = existingValue.state;
      existingValue.state = isExcluded ? "idle" : "excluded";
      facetRequest.freezeCurrentValues = true;
    }).addCase(updateFreezeCurrentValues, (state, action) => {
      const { facetId: facetId2, freezeCurrentValues } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.freezeCurrentValues = freezeCurrentValues;
    }).addCase(deselectAllFacetValues, (state, action) => {
      handleFacetDeselectAll(state[action.payload]?.request);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.values(state).filter((slice) => slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
    }).addCase(deselectAllNonBreadcrumbs, (state) => {
      Object.values(state).filter((slice) => !slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
    }).addCase(
      updateFacetAutoSelection,
      (state, action) => Object.values(state).forEach((slice) => {
        slice.request.preventAutoSelect = !action.payload.allow;
      })
    ).addCase(updateFacetSortCriterion, (state, action) => {
      handleFacetSortCriterionUpdate(state, action.payload);
    }).addCase(updateFacetNumberOfValues, (state, action) => {
      const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
      handleFacetUpdateNumberOfValues(
        state[facetId2]?.request,
        numberOfValues2
      );
    }).addCase(updateFacetIsFieldExpanded, (state, action) => {
      const { facetId: facetId2, isFieldExpanded } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      facetRequest.isFieldExpanded = isFieldExpanded;
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      facets.forEach(
        (facetResponse) => mutateStateFromFacetResponse(
          state[facetResponse.facetId]?.request,
          facetResponse
        )
      );
    }).addCase(fetchFacetValues2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      facets.forEach(
        (facetResponse) => mutateStateFromFacetResponse(
          state[facetResponse.facetId]?.request,
          facetResponse
        )
      );
    }).addCase(selectFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      const { rawValue } = value;
      const { currentValues } = facetRequest;
      const matchingValue = currentValues.find((v) => v.value === rawValue);
      if (matchingValue) {
        matchingValue.state = "selected";
        return;
      }
      const searchResultValue = buildSelectedFacetValueRequest(rawValue);
      insertNewValue(facetRequest, searchResultValue);
      facetRequest.freezeCurrentValues = true;
      facetRequest.preventAutoSelect = true;
    }).addCase(excludeFacetSearchResult, (state, action) => {
      const { facetId: facetId2, value } = action.payload;
      const facetRequest = state[facetId2]?.request;
      if (!facetRequest) {
        return;
      }
      const { rawValue } = value;
      const { currentValues } = facetRequest;
      const matchingValue = currentValues.find((v) => v.value === rawValue);
      if (matchingValue) {
        matchingValue.state = "excluded";
        return;
      }
      const searchResultValue = buildExcludedFacetValueRequest(rawValue);
      insertNewValue(facetRequest, searchResultValue);
      facetRequest.freezeCurrentValues = true;
      facetRequest.preventAutoSelect = true;
    }).addCase(disableFacet, (state, action) => {
      if (!(action.payload in state)) {
        return;
      }
      const { request } = state[action.payload];
      handleFacetDeselectAll(request);
    });
  }
);
function insertNewValue(facetRequest, facetValue) {
  const { currentValues } = facetRequest;
  const firstIdleIndex = currentValues.findIndex((v) => v.state === "idle");
  const indexToInsertAt = firstIdleIndex === -1 ? currentValues.length : firstIdleIndex;
  facetRequest.currentValues.splice(indexToInsertAt, 0, facetValue);
  if (firstIdleIndex > -1) {
    facetRequest.currentValues.pop();
  }
  facetRequest.numberOfValues = facetRequest.currentValues.length;
}
function mutateStateFromFacetResponse(facetRequest, facetResponse) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetResponse.values.map(
    convertFacetValueToRequest
  );
  facetRequest.freezeCurrentValues = false;
  facetRequest.preventAutoSelect = false;
}
var defaultFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "automatic",
  resultsMustMatch: "atLeastOneValue"
};
function buildFacetRequest(config) {
  return {
    ...defaultFacetOptions,
    type: "specific",
    currentValues: [],
    freezeCurrentValues: false,
    isFieldExpanded: false,
    preventAutoSelect: false,
    ...config
  };
}
function convertFacetValueToRequest(facetValue) {
  const { value, state } = facetValue;
  return { value, state };
}
function buildSelectedFacetValueRequest(value) {
  return { value, state: "selected" };
}
function buildExcludedFacetValueRequest(value) {
  return { value, state: "excluded" };
}
function restoreFacetValueToIdleState(facetValue) {
  return { ...facetValue, state: "idle" };
}

// src/features/facets/generic/facet-generic-analytics-actions.ts
var logClearBreadcrumbs = () => makeAnalyticsAction("analytics/facet/deselectAllBreadcrumbs", (client) => {
  return client.makeBreadcrumbResetAll();
});

// src/features/facets/range-facets/date-facet-set/date-facet-actions.ts
var import_bueno46 = require("@coveo/bueno");
var import_toolkit48 = require("@reduxjs/toolkit");

// src/controllers/core/facets/range-facet/date-facet/date-range.ts
function buildDateRange(config) {
  const start = buildDate(config.start, config);
  const end = buildDate(config.end, config);
  const endInclusive = config.endInclusive ?? false;
  const state = config.state ?? "idle";
  return {
    start,
    end,
    endInclusive,
    state
  };
}
function buildDate(rawDate, options) {
  const { dateFormat } = options;
  if (isRelativeDate(rawDate)) {
    validateRelativeDate(rawDate);
    return serializeRelativeDate(rawDate);
  }
  if (typeof rawDate === "string" && isRelativeDateFormat(rawDate)) {
    validateRelativeDate(rawDate);
    return rawDate;
  }
  validateAbsoluteDate(rawDate, dateFormat);
  return formatDateForSearchApi(parseDate(rawDate, dateFormat));
}

// src/features/facets/range-facets/generic/range-facet-actions.ts
var import_bueno44 = require("@coveo/bueno");
var import_toolkit47 = require("@reduxjs/toolkit");
var updateRangeFacetSortCriterion = (0, import_toolkit47.createAction)(
  "rangeFacet/updateSortCriterion",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new import_bueno44.Value({ required: true })
  })
);

// src/features/facets/range-facets/generic/range-facet-validate-payload.ts
var import_bueno45 = require("@coveo/bueno");
var numericFacetValueDefinition = {
  state: requiredNonEmptyString,
  start: new import_bueno45.NumberValue({ required: true }),
  end: new import_bueno45.NumberValue({ required: true }),
  endInclusive: new import_bueno45.BooleanValue({ required: true }),
  numberOfResults: new import_bueno45.NumberValue({ required: true, min: 0 })
};
var dateFacetValueDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new import_bueno45.BooleanValue({ required: true }),
  state: requiredNonEmptyString,
  numberOfResults: new import_bueno45.NumberValue({ required: true, min: 0 })
};
var rangeFacetSelectionPayloadDefinition = (selection) => ({
  facetId: facetIdDefinition,
  selection: typeof selection.start === "string" ? new import_bueno45.RecordValue({ values: dateFacetValueDefinition }) : new import_bueno45.RecordValue({ values: numericFacetValueDefinition })
});

// src/features/facets/range-facets/date-facet-set/date-facet-actions.ts
var dateRangeRequestDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new import_bueno46.BooleanValue({ required: true }),
  state: requiredNonEmptyString
};
var dateFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new import_bueno46.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno46.ArrayValue({ each: new import_bueno46.StringValue() }),
      excluded: new import_bueno46.ArrayValue({ each: new import_bueno46.StringValue() })
    }
  }),
  activeTab: new import_bueno46.StringValue({ required: false }),
  currentValues: new import_bueno46.ArrayValue({
    required: false,
    each: new import_bueno46.RecordValue({ values: dateRangeRequestDefinition })
  }),
  generateAutomaticRanges: new import_bueno46.BooleanValue({ required: true }),
  filterFacetCount: new import_bueno46.BooleanValue({ required: false }),
  injectionDepth: new import_bueno46.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno46.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno46.Value({ required: false }),
  rangeAlgorithm: new import_bueno46.Value({ required: false })
};
function getAbsoluteDate(date) {
  return isRelativeDateFormat(date) ? formatRelativeDateForSearchApi(date) : date;
}
function validateManualDateRanges(options) {
  if (!options.currentValues) {
    return;
  }
  options.currentValues.forEach((value) => {
    const { start, end } = buildDateRange(value);
    if (parseDate(getAbsoluteDate(start)).isAfter(parseDate(getAbsoluteDate(end)))) {
      throw new Error(
        `The start value is greater than the end value for the date range ${value.start} to ${value.end}`
      );
    }
  });
}
var registerDateFacet = (0, import_toolkit48.createAction)(
  "dateFacet/register",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, dateFacetRegistrationOptionsDefinition);
      validateManualDateRanges(payload);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var toggleSelectDateFacetValue = (0, import_toolkit48.createAction)(
  "dateFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno46.RecordValue({ values: dateFacetValueDefinition })
  })
);
var toggleExcludeDateFacetValue = (0, import_toolkit48.createAction)(
  "dateFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno46.RecordValue({ values: dateFacetValueDefinition })
  })
);
var updateDateFacetValues = (0, import_toolkit48.createAction)(
  "dateFacet/updateFacetValues",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, {
        facetId: facetIdDefinition,
        values: new import_bueno46.ArrayValue({
          each: new import_bueno46.RecordValue({ values: dateFacetValueDefinition })
        })
      });
      validateManualDateRanges({ currentValues: payload.values });
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var updateDateFacetSortCriterion = updateRangeFacetSortCriterion;
var deselectAllDateFacetValues = deselectAllFacetValues;

// src/features/facets/range-facets/generic/range-facet-analytics-actions.ts
var getRangeFacetMetadata = (state, { facetId: facetId2, selection }) => {
  const facet = state.dateFacetSet[facetId2] || state.numericFacetSet[facetId2];
  const facetField = facet.request.field;
  const facetTitle = `${facetField}_${facetId2}`;
  return {
    facetId: facetId2,
    facetField,
    facetTitle,
    facetRangeEndInclusive: selection.endInclusive,
    facetRangeEnd: `${selection.end}`,
    facetRangeStart: `${selection.start}`
  };
};
var rangeBreadcrumbFacet = () => ({
  actionCause: "breadcrumbFacet" /* breadcrumbFacet */
});

// src/features/facets/range-facets/date-facet-set/date-facet-analytics-actions.ts
var logDateFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/dateFacet/breadcrumb", (client, state) => {
  validatePayload(
    payload,
    rangeFacetSelectionPayloadDefinition(payload.selection)
  );
  const metadata = getRangeFacetMetadata(state, payload);
  return client.makeBreadcrumbFacet(metadata);
});
var dateBreadcrumbFacet = rangeBreadcrumbFacet;

// src/features/facets/range-facets/date-facet-set/date-facet-selectors.ts
function isDateFacetResponse2(state, response) {
  return !!response && response.facetId in state.dateFacetSet;
}
var dateFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isDateFacetResponse2(state, response)) {
    return response;
  }
  return void 0;
};
var dateFacetSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = dateFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state === "selected");
};
var dateFacetActiveValuesSelector = (state, facetId2) => {
  const facetResponse = dateFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state !== "idle");
};

// src/features/facets/range-facets/date-facet-set/date-facet-set-slice.ts
var import_toolkit49 = require("@reduxjs/toolkit");

// src/features/facets/range-facets/generic/range-facet-reducers.ts
var defaultRangeFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "ascending",
  rangeAlgorithm: "even",
  resultsMustMatch: "atLeastOneValue"
};
function registerRangeFacet(state, slice) {
  const { request } = slice;
  const { facetId: facetId2 } = request;
  if (facetId2 in state) {
    return;
  }
  const numberOfValues2 = calculateNumberOfValues(request);
  request.numberOfValues = numberOfValues2;
  state[facetId2] = slice;
}
function updateRangeValues(state, facetId2, values) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  request.currentValues = values;
  request.numberOfValues = calculateNumberOfValues(request);
}
function toggleSelectRangeValue(state, facetId2, selection) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isSelected = value.state === "selected";
  value.previousState = value.state;
  value.state = isSelected ? "idle" : "selected";
  request.preventAutoSelect = true;
}
function toggleExcludeRangeValue(state, facetId2, selection) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isExcluded = value.state === "excluded";
  value.previousState = value.state;
  value.state = isExcluded ? "idle" : "excluded";
  request.preventAutoSelect = true;
}
function handleRangeFacetDeselectAll(state, facetId2) {
  const facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues.forEach((request) => {
    if (request.state !== "idle") {
      request.previousState = request.state;
    }
    request.state = "idle";
  });
}
function handleRangeFacetSearchParameterRestoration(state, rangeFacets) {
  Object.entries(state).forEach(([facetId2, { request }]) => {
    const rangesToSelect = rangeFacets[facetId2] || [];
    request.currentValues.forEach((range) => {
      const found = !!findRange(rangesToSelect, range);
      if (found) {
        range.state = "selected";
      }
      return range;
    });
    const missingRanges = rangesToSelect.filter(
      (range) => !findRange(request.currentValues, range)
    );
    const currentValues = request.currentValues;
    currentValues.push(...missingRanges);
    request.numberOfValues = Math.max(
      request.numberOfValues,
      currentValues.length
    );
  });
}
function onRangeFacetRequestFulfilled(state, facets, convert) {
  facets.forEach((facetResponse) => {
    const id = facetResponse.facetId;
    const facetRequest = state[id]?.request;
    if (!facetRequest) {
      return;
    }
    const values = convert(facetResponse.values);
    facetRequest.currentValues = values;
    facetRequest.preventAutoSelect = false;
  });
}
function findRange(values, value) {
  const { start, end } = value;
  return values.find((range) => range.start === start && range.end === end);
}
function calculateNumberOfValues(request) {
  const { generateAutomaticRanges: generateAutomaticRanges2, currentValues, numberOfValues: numberOfValues2 } = request;
  return generateAutomaticRanges2 ? Math.max(numberOfValues2, currentValues.length) : currentValues.length;
}

// src/features/facets/range-facets/date-facet-set/date-facet-set-slice.ts
var dateFacetSetReducer = (0, import_toolkit49.createReducer)(
  getDateFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerDateFacet, (state, action) => {
      const { payload } = action;
      const request = buildDateFacetRequest(payload);
      registerRangeFacet(state, getDateFacetSetSliceInitialState(request));
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.dateFacetSet ?? state
    ).addCase(restoreSearchParameters, (state, action) => {
      const df = action.payload.df || {};
      handleRangeFacetSearchParameterRestoration(state, df);
    }).addCase(toggleSelectDateFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleSelectRangeValue(state, facetId2, selection);
    }).addCase(toggleExcludeDateFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleExcludeRangeValue(state, facetId2, selection);
    }).addCase(updateDateFacetValues, (state, action) => {
      const { facetId: facetId2, values } = action.payload;
      updateRangeValues(state, facetId2, values);
    }).addCase(deselectAllDateFacetValues, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.keys(state).forEach((facetId2) => {
        handleRangeFacetDeselectAll(state, facetId2);
      });
    }).addCase(updateDateFacetSortCriterion, (state, action) => {
      handleFacetSortCriterionUpdate(state, action.payload);
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      onRangeFacetRequestFulfilled(state, facets, convertToDateRangeRequests);
    }).addCase(disableFacet, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    });
  }
);
function buildDateFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "dateRange",
    ...config
  };
}
function convertToDateRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-actions.ts
var import_bueno47 = require("@coveo/bueno");
var import_toolkit50 = require("@reduxjs/toolkit");
var numericFacetRequestDefinition = {
  state: requiredNonEmptyString,
  start: new import_bueno47.NumberValue({ required: true }),
  end: new import_bueno47.NumberValue({ required: true }),
  endInclusive: new import_bueno47.BooleanValue({ required: true })
};
var numericFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new import_bueno47.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno47.ArrayValue({ each: new import_bueno47.StringValue() }),
      excluded: new import_bueno47.ArrayValue({ each: new import_bueno47.StringValue() })
    }
  }),
  activeTab: new import_bueno47.StringValue({ required: false }),
  currentValues: new import_bueno47.ArrayValue({
    required: false,
    each: new import_bueno47.RecordValue({ values: numericFacetRequestDefinition })
  }),
  generateAutomaticRanges: new import_bueno47.BooleanValue({ required: true }),
  filterFacetCount: new import_bueno47.BooleanValue({ required: false }),
  injectionDepth: new import_bueno47.NumberValue({ required: false, min: 0 }),
  numberOfValues: new import_bueno47.NumberValue({ required: false, min: 1 }),
  sortCriteria: new import_bueno47.Value({ required: false }),
  rangeAlgorithm: new import_bueno47.Value({ required: false })
};
function validateManualNumericRanges(options) {
  if (!options.currentValues) {
    return;
  }
  options.currentValues.forEach(({ start, end }) => {
    if (start > end) {
      throw new Error(
        `The start value is greater than the end value for the numeric range ${start} to ${end}`
      );
    }
  });
}
var registerNumericFacet = (0, import_toolkit50.createAction)(
  "numericFacet/register",
  (payload) => {
    try {
      validatePayload(payload, numericFacetRegistrationOptionsDefinition);
      validateManualNumericRanges(payload);
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var toggleSelectNumericFacetValue = (0, import_toolkit50.createAction)(
  "numericFacet/toggleSelectValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno47.RecordValue({ values: numericFacetValueDefinition })
  })
);
var toggleExcludeNumericFacetValue = (0, import_toolkit50.createAction)(
  "numericFacet/toggleExcludeValue",
  (payload) => validatePayload(payload, {
    facetId: facetIdDefinition,
    selection: new import_bueno47.RecordValue({ values: numericFacetValueDefinition })
  })
);
var updateNumericFacetValues = (0, import_toolkit50.createAction)(
  "numericFacet/updateFacetValues",
  (payload) => {
    try {
      validatePayloadAndThrow(payload, {
        facetId: facetIdDefinition,
        values: new import_bueno47.ArrayValue({
          each: new import_bueno47.RecordValue({ values: numericFacetValueDefinition })
        })
      });
      validateManualNumericRanges({ currentValues: payload.values });
      return { payload, error: null };
    } catch (error) {
      return { payload, error: serializeSchemaValidationError(error) };
    }
  }
);
var updateNumericFacetSortCriterion = updateRangeFacetSortCriterion;
var deselectAllNumericFacetValues = deselectAllFacetValues;

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-analytics-actions.ts
var logNumericFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/numericFacet/breadcrumb", (client, state) => {
  validatePayload(
    payload,
    rangeFacetSelectionPayloadDefinition(payload.selection)
  );
  const metadata = getRangeFacetMetadata(state, payload);
  return client.makeBreadcrumbFacet(metadata);
});
var numericBreadcrumbFacet = rangeBreadcrumbFacet;

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-selectors.ts
function isNumericFacetResponse(state, response) {
  return !!response && response.facetId in state.numericFacetSet;
}
var numericFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isNumericFacetResponse(state, response)) {
    return response;
  }
  return void 0;
};
var numericFacetActiveValuesSelector = (state, facetId2) => {
  const facetResponse = numericFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state !== "idle");
};
var numericFacetSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = numericFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state === "selected");
};

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-set-slice.ts
var import_toolkit51 = require("@reduxjs/toolkit");
var numericFacetSetReducer = (0, import_toolkit51.createReducer)(
  getNumericFacetSetInitialState(),
  (builder) => {
    builder.addCase(registerNumericFacet, (state, action) => {
      const { payload } = action;
      const request = buildNumericFacetRequest(payload);
      registerRangeFacet(state, getNumericFacetSetSliceInitialState(request));
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.numericFacetSet ?? state
    ).addCase(restoreSearchParameters, (state, action) => {
      const nf = action.payload.nf || {};
      handleRangeFacetSearchParameterRestoration(state, nf);
    }).addCase(toggleSelectNumericFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleSelectRangeValue(state, facetId2, selection);
    }).addCase(toggleExcludeNumericFacetValue, (state, action) => {
      const { facetId: facetId2, selection } = action.payload;
      toggleExcludeRangeValue(state, facetId2, selection);
    }).addCase(updateNumericFacetValues, (state, action) => {
      const { facetId: facetId2, values } = action.payload;
      updateRangeValues(state, facetId2, values);
    }).addCase(deselectAllNumericFacetValues, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.keys(state).forEach((facetId2) => {
        handleRangeFacetDeselectAll(state, facetId2);
      });
    }).addCase(updateNumericFacetSortCriterion, (state, action) => {
      handleFacetSortCriterionUpdate(state, action.payload);
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const facets = action.payload.response.facets;
      onRangeFacetRequestFulfilled(
        state,
        facets,
        convertToNumericRangeRequests
      );
    }).addCase(disableFacet, (state, action) => {
      handleRangeFacetDeselectAll(state, action.payload);
    });
  }
);
function buildNumericFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "numericalRange",
    ...config
  };
}
function convertToNumericRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}

// src/features/static-filter-set/static-filter-set-actions.ts
var import_toolkit52 = require("@reduxjs/toolkit");

// src/features/static-filter-set/static-filter-set-schema.ts
var import_bueno48 = require("@coveo/bueno");
var staticFilterIdSchema = requiredNonEmptyString;
var staticFilterValueSchema = new import_bueno48.RecordValue({
  options: { required: true },
  values: {
    caption: requiredEmptyAllowedString,
    expression: requiredEmptyAllowedString,
    state: new import_bueno48.StringValue({
      constrainTo: ["idle", "selected", "excluded"]
    })
  }
});
var staticFilterValuesSchema = new import_bueno48.ArrayValue({
  required: true,
  each: staticFilterValueSchema
});

// src/features/static-filter-set/static-filter-set-actions.ts
var registerStaticFilter = (0, import_toolkit52.createAction)(
  "staticFilter/register",
  (payload) => {
    const schema = {
      id: staticFilterIdSchema,
      values: staticFilterValuesSchema
    };
    return validatePayload(payload, schema);
  }
);
var toggleSelectStaticFilterValue = (0, import_toolkit52.createAction)(
  "staticFilter/toggleSelect",
  (payload) => {
    const schema = {
      id: staticFilterIdSchema,
      value: staticFilterValueSchema
    };
    return validatePayload(payload, schema);
  }
);
var toggleExcludeStaticFilterValue = (0, import_toolkit52.createAction)(
  "staticFilter/toggleExclude",
  (payload) => {
    const schema = {
      id: staticFilterIdSchema,
      value: staticFilterValueSchema
    };
    return validatePayload(payload, schema);
  }
);
var deselectAllStaticFilterValues = (0, import_toolkit52.createAction)(
  "staticFilter/deselectAllFilterValues",
  (payload) => {
    return validatePayload(payload, staticFilterIdSchema);
  }
);
var logStaticFilterSelect = (metadata) => makeAnalyticsAction(
  "analytics/staticFilter/select",
  (client) => client.makeStaticFilterSelect(metadata)
);
var logStaticFilterDeselect = (metadata) => makeAnalyticsAction(
  "analytics/staticFilter/deselect",
  (client) => client.makeStaticFilterDeselect(metadata)
);
var logStaticFilterClearAll = (metadata) => makeAnalyticsAction(
  "analytics/staticFilter/clearAll",
  (client) => client.makeStaticFilterClearAll(metadata)
);

// src/controllers/controller/headless-controller.ts
function buildController(engine) {
  let prevState;
  const listeners = /* @__PURE__ */ new Map();
  const hasNoListeners = () => listeners.size === 0;
  const hasStateChanged = (currentState) => {
    try {
      const stringifiedState = JSON.stringify(currentState);
      const hasChanged = prevState !== stringifiedState;
      prevState = stringifiedState;
      return hasChanged;
    } catch (e) {
      console.warn(
        'Could not detect if state has changed, check the controller "get state method"',
        e
      );
      return true;
    }
  };
  return {
    subscribe(listener) {
      listener();
      const symbol = Symbol();
      let unsubscribe;
      if (hasNoListeners()) {
        prevState = JSON.stringify(this.state);
        unsubscribe = engine.subscribe(() => {
          if (hasStateChanged(this.state)) {
            listeners.forEach((listener2) => listener2());
          }
        });
      }
      listeners.set(symbol, listener);
      return () => {
        listeners.delete(symbol);
        if (hasNoListeners()) {
          unsubscribe?.();
        }
      };
    },
    get state() {
      return {};
    }
  };
}

// src/controllers/core/breadcrumb-manager/headless-core-breadcrumb-manager.ts
var getBreadcrumbs = (config) => {
  return Object.keys(config.facetSet).map((facetId2) => {
    const values = config.facetValuesSelector(config.engine.state, facetId2).map((selection) => ({
      value: selection,
      deselect: () => {
        if (selection.state === "selected") {
          config.executeToggleSelect({ facetId: facetId2, selection });
        } else if (selection.state === "excluded") {
          config.executeToggleExclude({ facetId: facetId2, selection });
        }
      }
    }));
    return {
      facetId: facetId2,
      field: config.facetSet[facetId2].request.field,
      values
    };
  }).filter((breadcrumb) => breadcrumb.values.length);
};
function buildCoreBreadcrumbManager(engine) {
  const controller = buildController(engine);
  const { dispatch } = engine;
  return {
    ...controller,
    get state() {
      return {
        facetBreadcrumbs: [],
        categoryFacetBreadcrumbs: [],
        numericFacetBreadcrumbs: [],
        dateFacetBreadcrumbs: [],
        staticFilterBreadcrumbs: [],
        hasBreadcrumbs: false
      };
    },
    deselectAll: () => {
      dispatch(deselectAllBreadcrumbs());
    },
    deselectBreadcrumb(value) {
      value.deselect();
    }
  };
}

// src/controllers/breadcrumb-manager/headless-breadcrumb-manager.ts
function buildBreadcrumbManager(engine) {
  if (!loadBreadcrumbManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildCoreBreadcrumbManager(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().facetSet,
      executeToggleSelect: ({ facetId: facetId2, selection }) => {
        dispatch(toggleSelectFacetValue({ facetId: facetId2, selection }));
        dispatch(
          updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false })
        );
        dispatch(
          executeSearch2({
            legacy: logFacetBreadcrumb({
              facetId: facetId2,
              facetValue: selection.value
            }),
            next: breadcrumbFacet()
          })
        );
      },
      executeToggleExclude: ({ facetId: facetId2, selection }) => {
        dispatch(toggleExcludeFacetValue({ facetId: facetId2, selection }));
        dispatch(
          updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false })
        );
        dispatch(
          executeSearch2({
            legacy: logFacetBreadcrumb({
              facetId: facetId2,
              facetValue: selection.value
            }),
            next: breadcrumbFacet()
          })
        );
      },
      facetValuesSelector: facetResponseActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getNumericFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().numericFacetSet,
      executeToggleSelect: (payload) => {
        dispatch(toggleSelectNumericFacetValue(payload));
        dispatch(
          executeSearch2({
            legacy: logNumericFacetBreadcrumb(payload),
            next: numericBreadcrumbFacet()
          })
        );
      },
      executeToggleExclude: (payload) => {
        dispatch(toggleExcludeNumericFacetValue(payload));
        dispatch(
          executeSearch2({
            legacy: logNumericFacetBreadcrumb(payload),
            next: numericBreadcrumbFacet()
          })
        );
      },
      facetValuesSelector: numericFacetActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getDateFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().dateFacetSet,
      executeToggleSelect: (payload) => {
        dispatch(toggleSelectDateFacetValue(payload));
        dispatch(
          executeSearch2({
            legacy: logDateFacetBreadcrumb(payload),
            next: dateBreadcrumbFacet()
          })
        );
      },
      executeToggleExclude: (payload) => {
        dispatch(toggleExcludeDateFacetValue(payload));
        dispatch(
          executeSearch2({
            legacy: logDateFacetBreadcrumb(payload),
            next: dateBreadcrumbFacet()
          })
        );
      },
      facetValuesSelector: dateFacetActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getCategoryFacetBreadcrumbs = () => {
    return Object.keys(getState().categoryFacetSet).map(buildCategoryFacetBreadcrumb).filter((breadcrumb) => breadcrumb.path.length);
  };
  const buildCategoryFacetBreadcrumb = (facetId2) => {
    const path = categoryFacetResponseSelectedValuesSelector(
      getState(),
      facetId2
    );
    return {
      facetId: facetId2,
      field: getState().categoryFacetSet[facetId2].request.field,
      path,
      deselect: () => {
        dispatch(deselectAllCategoryFacetValues(facetId2));
        dispatch(
          executeSearch2({
            legacy: logCategoryFacetBreadcrumb({
              categoryFacetPath: path.map(
                (categoryFacetValue) => categoryFacetValue.value
              ),
              categoryFacetId: facetId2
            }),
            next: categoryBreadcrumbFacet()
          })
        );
      }
    };
  };
  const getStaticFilterBreadcrumbs = () => {
    const set = getState().staticFilterSet ?? {};
    return Object.values(set).map(buildStaticFilterBreadcrumb);
  };
  const buildStaticFilterBreadcrumb = (filter) => {
    const { id, values: filterValues } = filter;
    const values = filterValues.filter((value) => value.state !== "idle").map((value) => buildStaticFilterBreadcrumbValue(id, value));
    return { id, values };
  };
  const buildStaticFilterBreadcrumbValue = (id, value) => {
    return {
      value,
      deselect: () => {
        const { caption, expression } = value;
        if (value.state === "selected") {
          dispatch(toggleSelectStaticFilterValue({ id, value }));
        } else if (value.state === "excluded") {
          dispatch(toggleExcludeStaticFilterValue({ id, value }));
        }
        dispatch(
          executeSearch2({
            legacy: logStaticFilterDeselect({
              staticFilterId: id,
              staticFilterValue: { caption, expression }
            })
          })
        );
      }
    };
  };
  const getAutomaticFacetBreadcrumbs = () => {
    const set = getState().automaticFacetSet?.set ?? {};
    return Object.values(set).map((slice) => buildAutomaticFacetBreadcrumb(slice.response)).filter((breadcrumb) => breadcrumb.values.length > 0);
  };
  const buildAutomaticFacetBreadcrumb = (response) => {
    const { field: field2, label } = response;
    const values = response.values.filter((value) => value.state !== "idle").map((value) => buildAutomaticFacetBreadcrumbValue(field2, value));
    return {
      facetId: field2,
      field: field2,
      label,
      values
    };
  };
  const buildAutomaticFacetBreadcrumbValue = (field2, selection) => {
    return {
      value: selection,
      deselect: () => {
        dispatch(
          toggleSelectAutomaticFacetValue({
            field: field2,
            selection
          })
        );
        dispatch(
          executeSearch2({
            legacy: logFacetBreadcrumb({
              facetId: field2,
              facetValue: selection.value
            }),
            next: breadcrumbFacet()
          })
        );
      }
    };
  };
  function hasBreadcrumbs2() {
    return !![
      ...getFacetBreadcrumbs(),
      ...getNumericFacetBreadcrumbs(),
      ...getDateFacetBreadcrumbs(),
      ...getCategoryFacetBreadcrumbs(),
      ...getStaticFilterBreadcrumbs(),
      ...getAutomaticFacetBreadcrumbs()
    ].length;
  }
  return {
    ...controller,
    get state() {
      return {
        facetBreadcrumbs: getFacetBreadcrumbs(),
        categoryFacetBreadcrumbs: getCategoryFacetBreadcrumbs(),
        numericFacetBreadcrumbs: getNumericFacetBreadcrumbs(),
        dateFacetBreadcrumbs: getDateFacetBreadcrumbs(),
        staticFilterBreadcrumbs: getStaticFilterBreadcrumbs(),
        automaticFacetBreadcrumbs: getAutomaticFacetBreadcrumbs(),
        hasBreadcrumbs: hasBreadcrumbs2()
      };
    },
    deselectAll: () => {
      controller.deselectAll();
      dispatch(
        executeSearch2({
          legacy: logClearBreadcrumbs(),
          next: { actionCause: "breadcrumbResetAll" /* breadcrumbResetAll */ }
        })
      );
    }
  };
}
function loadBreadcrumbManagerReducers(engine) {
  engine.addReducers({
    configuration,
    search: searchReducer,
    facetSet: facetSetReducer,
    numericFacetSet: numericFacetSetReducer,
    dateFacetSet: dateFacetSetReducer,
    categoryFacetSet: categoryFacetSetReducer
  });
  return true;
}

// src/ssr/search/controllers/breadcrumb-manager/headless-breadcrumb-manager.ssr.ts
function defineBreadcrumbManager() {
  return {
    build: (engine) => buildBreadcrumbManager(engine)
  };
}

// src/controllers/core/context/headless-core-context.ts
var import_bueno50 = require("@coveo/bueno");

// src/features/context/context-actions.ts
var import_bueno49 = require("@coveo/bueno");
var import_toolkit53 = require("@reduxjs/toolkit");
var nonEmptyArray = new import_bueno49.ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
var nonEmptyPayload = (contextKey, contextValue) => {
  validatePayload(contextKey, requiredNonEmptyString);
  if ((0, import_bueno49.isString)(contextValue)) {
    validatePayload(contextValue, requiredNonEmptyString);
  } else {
    validatePayload(contextValue, nonEmptyArray);
  }
  return { payload: { contextKey, contextValue } };
};
var setContext = (0, import_toolkit53.createAction)(
  "context/set",
  (payload) => {
    for (const [k, v] of Object.entries(payload)) {
      nonEmptyPayload(k, v);
    }
    return { payload };
  }
);
var addContext = (0, import_toolkit53.createAction)(
  "context/add",
  (payload) => nonEmptyPayload(payload.contextKey, payload.contextValue)
);
var removeContext = (0, import_toolkit53.createAction)(
  "context/remove",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);

// src/features/context/context-slice.ts
var import_toolkit54 = require("@reduxjs/toolkit");
var contextReducer = (0, import_toolkit54.createReducer)(
  getContextInitialState(),
  (builder) => {
    builder.addCase(setContext, (state, action) => {
      state.contextValues = action.payload;
    }).addCase(addContext, (state, action) => {
      state.contextValues[action.payload.contextKey] = action.payload.contextValue;
    }).addCase(removeContext, (state, action) => {
      delete state.contextValues[action.payload];
    }).addCase(change.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      state.contextValues = action.payload.context.contextValues;
    });
  }
);

// src/controllers/core/context/headless-context-reserved-keys.ts
var ReservedContextKeys = ["caseId", "caseNumber"];
var ReservedContextKeysToControllerMap = {
  caseId: "caseContext",
  caseNumber: "caseContext"
};
var ReservedContextKeyError = class extends Error {
  constructor(key) {
    super(
      `The key "${key}" is reserved for internal use. Use ${ReservedContextKeysToControllerMap[key]} to set this value.}`
    );
  }
};
function isReservedContextKey(contextKey) {
  return ReservedContextKeys.includes(contextKey);
}

// src/controllers/core/context/headless-core-context.ts
var initialStateSchema = new import_bueno50.Schema({
  values: new import_bueno50.RecordValue({
    options: { required: false }
  })
});
function buildCoreContext(engine, props = {}) {
  if (!loadContextReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const initialState = validateInitialState(
    engine,
    initialStateSchema,
    props.initialState,
    "buildContext"
  );
  if (initialState.values) {
    dispatch(setContext(initialState.values));
  }
  return {
    ...controller,
    get state() {
      return {
        values: getState().context.contextValues
      };
    },
    set(context) {
      dispatch(setContext(context));
    },
    ...getState().configuration.analytics.analyticsMode === "legacy" ? legacyCoreContext(dispatch) : nextCoreContext(dispatch)
  };
}
var legacyCoreContext = (dispatch) => ({
  add(contextKey, contextValue) {
    dispatch(addContext({ contextKey, contextValue }));
  },
  remove(key) {
    dispatch(removeContext(key));
  }
});
var nextCoreContext = (dispatch) => ({
  add(contextKey, contextValue) {
    if (isReservedContextKey(contextKey)) {
      throw new ReservedContextKeyError(contextKey);
    }
    dispatch(addContext({ contextKey, contextValue }));
  },
  remove(contextKey) {
    if (isReservedContextKey(contextKey)) {
      throw new ReservedContextKeyError(contextKey);
    }
    dispatch(removeContext(contextKey));
  }
});
function loadContextReducers(engine) {
  engine.addReducers({ context: contextReducer });
  return true;
}

// src/controllers/context/headless-context.ts
function buildContext(engine, props) {
  return buildCoreContext(engine, props);
}

// src/ssr/commerce/types/controller-constants.ts
var recommendationOptionKey = "recommendation-internal-options";
var recommendationInternalOptionKey = Symbol.for(
  recommendationOptionKey
);

// src/ssr/common/errors.ts
var MissingControllerProps = class extends Error {
  constructor(controller) {
    super();
    this.name = "MissingControllerProps";
    this.message = `${controller} props are required but were undefined. Ensure they are included when calling \`fetchStaticState\` or \`hydrateStaticState\`.`;
  }
};

// src/ssr/search/controllers/context/headless-context.ssr.ts
function defineContext() {
  return {
    buildWithProps: (engine, props) => {
      if (props === void 0) {
        throw new MissingControllerProps("Context");
      }
      return buildContext(engine, { initialState: props.initialState });
    }
  };
}

// src/features/dictionary-field-context/dictionary-field-context-actions.ts
var import_bueno51 = require("@coveo/bueno");
var import_toolkit55 = require("@reduxjs/toolkit");
var setContext2 = (0, import_toolkit55.createAction)(
  "dictionaryFieldContext/set",
  (payload) => {
    const objSchema = new import_bueno51.RecordValue({ options: { required: true } });
    const objError = validatePayload(payload, objSchema).error;
    if (objError) {
      return { payload, error: objError };
    }
    const values = Object.values(payload);
    const valueSchema = new import_bueno51.ArrayValue({ each: requiredEmptyAllowedString });
    const valuesError = validatePayload(values, valueSchema).error;
    if (valuesError) {
      return { payload, error: valuesError };
    }
    return { payload };
  }
);
var addContext2 = (0, import_toolkit55.createAction)(
  "dictionaryFieldContext/add",
  (payload) => {
    const schema = new import_bueno51.RecordValue({
      options: { required: true },
      values: {
        field: requiredEmptyAllowedString,
        key: requiredEmptyAllowedString
      }
    });
    return validatePayload(
      payload,
      schema
    );
  }
);
var removeContext2 = (0, import_toolkit55.createAction)(
  "dictionaryFieldContext/remove",
  (payload) => {
    return validatePayload(payload, requiredEmptyAllowedString);
  }
);

// src/features/dictionary-field-context/dictionary-field-context-slice.ts
var import_toolkit56 = require("@reduxjs/toolkit");
var dictionaryFieldContextReducer = (0, import_toolkit56.createReducer)(
  getDictionaryFieldContextInitialState(),
  (builder) => {
    builder.addCase(setContext2, (state, action) => {
      state.contextValues = action.payload;
    }).addCase(addContext2, (state, action) => {
      const { field: field2, key } = action.payload;
      state.contextValues[field2] = key;
    }).addCase(removeContext2, (state, action) => {
      delete state.contextValues[action.payload];
    }).addCase(change.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      state.contextValues = action.payload.dictionaryFieldContext.contextValues;
    });
  }
);

// src/controllers/dictionary-field-context/headless-dictionary-field-context.ts
function buildDictionaryFieldContext(engine) {
  if (!loadReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      return {
        values: getState().dictionaryFieldContext.contextValues
      };
    },
    set(context) {
      dispatch(setContext2(context));
    },
    add(field2, key) {
      dispatch(addContext2({ field: field2, key }));
    },
    remove(field2) {
      dispatch(removeContext2(field2));
    }
  };
}
function loadReducers(engine) {
  engine.addReducers({ dictionaryFieldContext: dictionaryFieldContextReducer });
  return true;
}

// src/ssr/search/controllers/dictionary-field-context/headless-dictionary-field-context.ssr.ts
function defineDictionaryFieldContext() {
  return {
    build: (engine) => buildDictionaryFieldContext(engine)
  };
}

// src/features/did-you-mean/did-you-mean-selectors.ts
var hasQueryCorrectionSelector = (state) => state.queryCorrection.correctedQuery !== "" || state.wasCorrectedTo !== "";

// src/features/did-you-mean/did-you-mean-slice.ts
var import_toolkit57 = require("@reduxjs/toolkit");

// src/features/did-you-mean/did-you-mean-state.ts
var emptyLegacyCorrection = () => ({
  correctedQuery: "",
  wordCorrections: [],
  originalQuery: ""
});
var emptyNextCorrection = () => ({
  correctedQuery: "",
  corrections: [],
  originalQuery: ""
});
function getDidYouMeanInitialState() {
  return {
    enableDidYouMean: false,
    wasCorrectedTo: "",
    wasAutomaticallyCorrected: false,
    queryCorrection: emptyLegacyCorrection(),
    originalQuery: "",
    automaticallyCorrectQuery: true,
    queryCorrectionMode: "legacy"
  };
}

// src/features/did-you-mean/did-you-mean-slice-functions.ts
var setToNonEmptyQueryCorrection = (state, correction) => {
  const nonOptionalQueryCorrection = {
    ...emptyNextCorrection(),
    ...correction,
    correctedQuery: correction?.correctedQuery || correction?.corrections[0]?.correctedQuery || ""
  };
  state.queryCorrection = nonOptionalQueryCorrection;
  state.wasCorrectedTo = nonOptionalQueryCorrection.correctedQuery;
};

// src/features/did-you-mean/did-you-mean-slice.ts
var didYouMeanReducer = (0, import_toolkit57.createReducer)(
  getDidYouMeanInitialState(),
  (builder) => {
    builder.addCase(enableDidYouMean, (state) => {
      state.enableDidYouMean = true;
    }).addCase(disableDidYouMean, (state) => {
      state.enableDidYouMean = false;
    }).addCase(enableAutomaticQueryCorrection, (state) => {
      state.automaticallyCorrectQuery = true;
    }).addCase(disableAutomaticQueryCorrection, (state) => {
      state.automaticallyCorrectQuery = false;
    }).addCase(executeSearch2.pending, (state) => {
      state.queryCorrection = emptyLegacyCorrection();
      state.wasAutomaticallyCorrected = false;
      state.wasCorrectedTo = "";
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const { queryCorrection, queryCorrections } = action.payload.response;
      if (state.queryCorrectionMode === "legacy") {
        const nonOptionalQueryCorrections = queryCorrections?.[0] ? queryCorrections[0] : emptyLegacyCorrection();
        state.queryCorrection = nonOptionalQueryCorrections;
      }
      if (state.queryCorrectionMode === "next") {
        setToNonEmptyQueryCorrection(state, queryCorrection);
      }
      state.wasAutomaticallyCorrected = action.payload.automaticallyCorrected;
      state.originalQuery = action.payload.originalQuery;
    }).addCase(applyDidYouMeanCorrection, (state, action) => {
      state.wasCorrectedTo = action.payload;
    }).addCase(setCorrectionMode, (state, action) => {
      state.queryCorrectionMode = action.payload;
    });
  }
);

// src/controllers/core/did-you-mean/headless-core-did-you-mean.ts
function buildCoreDidYouMean(engine, props = {}) {
  if (!loadDidYouMeanReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  dispatch(enableDidYouMean());
  if (props.options?.automaticallyCorrectQuery === false) {
    dispatch(disableAutomaticQueryCorrection());
  }
  dispatch(setCorrectionMode(props.options?.queryCorrectionMode || "next"));
  const getState = () => engine.state;
  const hasQueryCorrection = () => hasQueryCorrectionSelector(getState().didYouMean);
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        originalQuery: state.didYouMean.originalQuery,
        wasCorrectedTo: state.didYouMean.wasCorrectedTo,
        wasAutomaticallyCorrected: state.didYouMean.wasAutomaticallyCorrected,
        queryCorrection: state.didYouMean.queryCorrection,
        hasQueryCorrection: hasQueryCorrection()
      };
    },
    applyCorrection() {
      dispatch(
        applyDidYouMeanCorrection(this.state.queryCorrection.correctedQuery)
      );
    },
    updateQueryCorrectionMode(queryCorrectionMode) {
      dispatch(setCorrectionMode(queryCorrectionMode));
    }
  };
}
function loadDidYouMeanReducers(engine) {
  engine.addReducers({ configuration, didYouMean: didYouMeanReducer });
  return true;
}

// src/controllers/did-you-mean/headless-did-you-mean.ts
function buildDidYouMean(engine, props = {}) {
  const controller = buildCoreDidYouMean(engine, props);
  const { dispatch } = engine;
  return {
    ...controller,
    get state() {
      return controller.state;
    },
    applyCorrection() {
      controller.applyCorrection();
      dispatch(
        executeSearch2({
          legacy: logDidYouMeanClick(),
          next: didYouMeanClick()
        })
      );
    }
  };
}

// src/ssr/search/controllers/did-you-mean/headless-did-you-mean.ssr.ts
function defineDidYouMean() {
  return {
    build: (engine) => buildDidYouMean(engine)
  };
}

// src/features/facet-options/facet-options-slice.ts
var import_toolkit58 = require("@reduxjs/toolkit");
var facetOptionsReducer = (0, import_toolkit58.createReducer)(
  getFacetOptionsInitialState(),
  (builder) => {
    builder.addCase(updateFacetOptions, (state, action) => {
      return { ...state, ...action.payload };
    }).addCase(executeSearch2.fulfilled, (state) => {
      state.freezeFacetOrder = false;
    }).addCase(executeSearch2.rejected, (state) => {
      state.freezeFacetOrder = false;
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.facetOptions ?? state
    ).addCase(registerCategoryFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(registerFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(registerDateFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(registerNumericFacet, (state, action) => {
      const { facetId: facetId2, tabs } = action.payload;
      handleRegisterFacetTabs(tabs, state, facetId2);
    }).addCase(enableFacet, (state, action) => {
      state.facets[action.payload].enabled = true;
    }).addCase(disableFacet, (state, action) => {
      state.facets[action.payload].enabled = false;
    }).addCase(restoreSearchParameters, (state, action) => {
      [
        ...Object.keys(action.payload.f ?? {}),
        ...Object.keys(action.payload.fExcluded ?? {}),
        ...Object.keys(action.payload.cf ?? {}),
        ...Object.keys(action.payload.nf ?? {}),
        ...Object.keys(action.payload.df ?? {})
      ].forEach((facetId2) => {
        if (!(facetId2 in state)) {
          state.facets[facetId2] = getFacetOptionsSliceInitialState();
        }
        state.facets[facetId2].enabled = true;
      });
    });
  }
);
function handleRegisterFacetTabs(tabs, state, facetId2) {
  const newFacetState = {
    ...getFacetOptionsSliceInitialState(),
    tabs: tabs ?? {}
  };
  state.facets[facetId2] = newFacetState;
}

// src/controllers/core/facet-manager/headless-core-facet-manager.ts
function buildCoreFacetManager(engine) {
  if (!loadFacetManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    sort(facets) {
      return sortFacets(facets, this.state.facetIds);
    },
    get state() {
      const facets = getState().search.response.facets;
      const facetIds = facets.map((f2) => f2.facetId);
      return { facetIds };
    }
  };
}
function loadFacetManagerReducers(engine) {
  engine.addReducers({ search: searchReducer, facetOptions: facetOptionsReducer });
  return true;
}

// src/controllers/facet-manager/headless-facet-manager.ts
function buildFacetManager(engine) {
  return buildCoreFacetManager(engine);
}

// src/ssr/search/controllers/facet-manager/headless-facet-manager.ssr.ts
function defineFacetManager() {
  return {
    build: (engine) => buildFacetManager(engine)
  };
}

// src/features/facets/automatic-facet-set/automatic-facet-set-slice.ts
var import_toolkit59 = require("@reduxjs/toolkit");
var automaticFacetSetReducer = (0, import_toolkit59.createReducer)(
  getAutomaticFacetSetInitialState(),
  (builder) => {
    builder.addCase(executeSearch2.fulfilled, (state, action) => {
      state.set = {};
      const facets = action.payload.response.generateAutomaticFacets?.facets;
      facets?.forEach((response) => {
        state.set[response.field] = { response };
      });
    }).addCase(setOptions, (state, action) => {
      if (action.payload.desiredCount) {
        state.desiredCount = action.payload.desiredCount;
      }
      if (action.payload.numberOfValues) {
        state.numberOfValues = action.payload.numberOfValues;
      }
    }).addCase(toggleSelectAutomaticFacetValue, (state, action) => {
      const { field: field2, selection } = action.payload;
      const facet = state.set[field2]?.response;
      if (!facet) {
        return;
      }
      const value = facet.values.find(
        (value2) => value2.value === selection.value
      );
      if (!value) {
        return;
      }
      const isSelected = value.state === "selected";
      value.state = isSelected ? "idle" : "selected";
    }).addCase(deselectAllAutomaticFacetValues, (state, action) => {
      const field2 = action.payload;
      const facet = state.set[field2]?.response;
      if (!facet) {
        return;
      }
      for (const value of facet.values) {
        value.state = "idle";
      }
    }).addCase(restoreSearchParameters, (state, action) => {
      const af = action.payload.af ?? {};
      const currentFields = Object.keys(state.set);
      for (const field2 in af) {
        if (!state.set[field2]) {
          const response = buildTemporaryAutomaticFacetResponse(field2);
          const values = af[field2].map(
            (value) => buildTemporarySelectedFacetValue(value)
          );
          response.values.push(...values);
          state.set[field2] = { response };
        }
      }
      for (const field2 of currentFields) {
        if (!(field2 in af)) {
          const facet = state.set[field2]?.response;
          for (const value of facet.values) {
            value.state = "idle";
          }
        }
      }
      for (const field2 in af) {
        const facet = state.set[field2]?.response;
        if (facet) {
          const stateFacetValues = facet.values;
          const urlFacetValues = new Set(af[field2]);
          for (const value of stateFacetValues) {
            if (urlFacetValues.has(value.value)) {
              value.state = "selected";
              urlFacetValues.delete(value.value);
            } else {
              value.state = "idle";
            }
          }
          for (const value of urlFacetValues) {
            facet.values.push(buildTemporarySelectedFacetValue(value));
          }
        }
      }
    }).addCase(change.fulfilled, (_, action) => {
      if (!action.payload) {
        return;
      }
      if (Object.keys(action.payload.automaticFacetSet.set).length === 0) {
        return;
      }
      return action.payload.automaticFacetSet;
    }).addCase(deselectAllBreadcrumbs, (state) => {
      Object.values(state.set).forEach(({ response }) => {
        response.values.forEach((value) => {
          value.state = "idle";
        });
      });
    });
  }
);
function buildTemporaryAutomaticFacetResponse(field2) {
  return {
    field: field2,
    values: [],
    moreValuesAvailable: false,
    label: "",
    indexScore: 0
  };
}
function buildTemporarySelectedFacetValue(value) {
  return {
    value,
    state: "selected",
    numberOfResults: 0
  };
}

// src/features/facets/facet-set/facet-set-utils.ts
var isFacetValueSelected = (value) => {
  return value.state === "selected";
};
var isFacetValueExcluded = (value) => {
  return value.state === "excluded";
};
var getLegacyAnalyticsActionForToggleFacetSelect = (facetId2, selection) => {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  return isFacetValueSelected(selection) ? logFacetDeselect(payload) : logFacetSelect(payload);
};
var getAnalyticsActionForToggleFacetSelect = (selection) => isFacetValueSelected(selection) ? facetDeselect() : facetSelect();
var getLegacyAnalyticsActionForToggleFacetExclude = (facetId2, selection) => {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  return isFacetValueExcluded(selection) ? logFacetUnexclude(payload) : logFacetExclude(payload);
};
var getAnalyticsActionForToggleFacetExclude = (selection) => isFacetValueExcluded(selection) ? facetUnexclude() : facetExclude();

// src/controllers/facets/automatic-facet/headless-automatic-facet.ts
function buildAutomaticFacet(engine, props) {
  const { dispatch } = engine;
  const controller = buildController(engine);
  const { field: field2 } = props;
  return {
    ...controller,
    toggleSelect(selection) {
      dispatch(toggleSelectAutomaticFacetValue({ field: field2, selection }));
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggleFacetSelect(
            field2,
            selection
          ),
          next: getAnalyticsActionForToggleFacetSelect(selection)
        })
      );
    },
    deselectAll() {
      dispatch(deselectAllAutomaticFacetValues(field2));
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(field2),
          next: facetClearAll()
        })
      );
    },
    get state() {
      const response = engine.state.automaticFacetSet?.set[field2]?.response;
      const defaultState = { field: "", values: [], label: "" };
      return response ? {
        field: response.field,
        label: response.label,
        values: response.values
      } : defaultState;
    }
  };
}

// src/controllers/facets/automatic-facet-generator/headless-automatic-facet-generator-options.ts
function buildOptions(options) {
  return {
    desiredCount: options.desiredCount,
    numberOfValues: options.numberOfValues
  };
}

// src/controllers/facets/automatic-facet-generator/headless-automatic-facet-generator.ts
function buildAutomaticFacetGenerator(engine, props) {
  if (!loadAutomaticFacetGeneratorReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const options = buildOptions(props.options);
  dispatch(setOptions(options));
  const controller = buildController(engine);
  return {
    ...controller,
    get state() {
      const automaticFacets = engine.state.search.response.generateAutomaticFacets?.facets.map(
        (facet) => buildAutomaticFacet(engine, { field: facet.field })
      ) ?? [];
      return {
        automaticFacets
      };
    }
  };
}
function loadAutomaticFacetGeneratorReducers(engine) {
  engine.addReducers({ automaticFacetSet: automaticFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// src/ssr/search/controllers/facets/automatic-facet-generator/headless-automatic-facet-generator.ssr.ts
function defineAutomaticFacetGenerator(props) {
  return {
    build: (engine) => buildAutomaticFacetGenerator(engine, props)
  };
}

// src/features/facets/facet-search-set/category/category-facet-search-set-slice.ts
var import_toolkit71 = require("@reduxjs/toolkit");

// src/features/commerce/facets/facet-search-set/commerce-facet-search-actions.ts
var import_toolkit60 = require("@reduxjs/toolkit");

// src/features/commerce/sort/sort.ts
var import_bueno52 = require("@coveo/bueno");

// src/features/sort/sort.ts
var SortBy2 = /* @__PURE__ */ ((SortBy3) => {
  SortBy3["Relevance"] = "relevance";
  SortBy3["Fields"] = "fields";
  return SortBy3;
})(SortBy2 || {});
var SortDirection = /* @__PURE__ */ ((SortDirection2) => {
  SortDirection2["Ascending"] = "asc";
  SortDirection2["Descending"] = "desc";
  return SortDirection2;
})(SortDirection || {});

// src/features/commerce/sort/sort.ts
var sortCriterionDefinition = new import_bueno52.RecordValue({
  options: {
    required: false
  },
  values: {
    by: new import_bueno52.EnumValue({ enum: SortBy2, required: true }),
    fields: new import_bueno52.ArrayValue({
      each: new import_bueno52.RecordValue({
        values: {
          field: new import_bueno52.StringValue({ required: true }),
          direction: new import_bueno52.EnumValue({ enum: SortDirection }),
          displayName: new import_bueno52.StringValue()
        }
      })
    })
  }
});

// src/api/commerce/commerce-api-client.ts
var isErrorResponse2 = (r) => {
  return r.error !== void 0;
};
function getCommerceApiBaseUrl(organizationId, environment = "prod") {
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  return `${platformEndpoint}/rest/organizations/${organizationId}/commerce/v2`;
}

// src/features/commerce/context/cart/cart-state.ts
var getProductsFromCartState = (state) => getProductsFromCart(state.cartItems, state.cart);
function getProductsFromCart(items, itemMap) {
  const productsMap = items.reduce(
    (acc, key) => {
      const { productId, quantity } = itemMap[key];
      if (!(productId in acc)) {
        acc[productId] = {
          productId,
          quantity: 0
        };
      }
      acc[productId].quantity += quantity;
      return acc;
    },
    {}
  );
  return [...Object.values(productsMap)];
}

// src/features/commerce/common/base-commerce-api-request-builder.ts
var buildBaseCommerceAPIRequest = (state, navigatorContext) => {
  const { view, location, custom, ...restOfContext } = state.commerceContext;
  return {
    accessToken: state.configuration.accessToken,
    url: state.configuration.commerce.apiBaseUrl ?? getCommerceApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    organizationId: state.configuration.organizationId,
    trackingId: state.configuration.analytics.trackingId,
    ...restOfContext,
    ...state.configuration.analytics.enabled ? { clientId: navigatorContext.clientId } : {},
    context: {
      user: {
        ...location,
        ...navigatorContext.userAgent ? { userAgent: navigatorContext.userAgent } : {}
      },
      view: {
        ...view,
        ...navigatorContext.referrer ? { referrer: navigatorContext.referrer } : {}
      },
      capture: navigatorContext.capture ?? (state.configuration.analytics.enabled && navigatorContext.clientId !== ""),
      cart: getProductsFromCartState(state.cart),
      source: getAnalyticsSource(state.configuration.analytics),
      ...custom ? { custom } : {}
    }
  };
};

// src/features/commerce/common/paginated-commerce-api-request-builder.ts
var buildPaginatedCommerceAPIRequest = (state, navigatorContext, slotId) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    ...effectivePagination(state, slotId)
  };
};
var effectivePagination = (state, slotId) => {
  const effectiveSlice = slotId ? state.commercePagination?.recommendations[slotId] : state.commercePagination?.principal;
  return effectiveSlice && {
    page: effectiveSlice.page,
    ...effectiveSlice.perPage && {
      perPage: effectiveSlice.perPage
    }
  };
};

// src/features/commerce/common/filterable-commerce-api-request-builder.ts
var buildFilterableCommerceAPIRequest = (state, navigatorContext) => {
  return {
    ...buildPaginatedCommerceAPIRequest(state, navigatorContext),
    facets: [...getFacets3(state)],
    ...state.commerceSort && {
      sort: getSort(state.commerceSort.appliedSort)
    }
  };
};
function getFacets3(state) {
  if (!state.facetOrder || !state.commerceFacetSet) {
    return [];
  }
  return state.facetOrder.filter((facetId2) => state.commerceFacetSet?.[facetId2]).map((facetId2) => {
    return state.manualNumericFacetSet?.[facetId2]?.manualRange ? {
      facetId: facetId2,
      field: facetId2,
      numberOfValues: 1,
      isFieldExpanded: false,
      preventAutoSelect: true,
      type: "numericalRange",
      values: [state.manualNumericFacetSet[facetId2].manualRange],
      initialNumberOfValues: 1
    } : state.commerceFacetSet[facetId2].request;
  }).filter((facet) => facet && facet.values.length > 0);
}
function getSort(appliedSort) {
  if (appliedSort.by === "relevance" /* Relevance */) {
    return {
      sortCriteria: "relevance" /* Relevance */
    };
  } else {
    return {
      sortCriteria: "fields" /* Fields */,
      fields: appliedSort.fields.map(({ name, direction }) => ({
        field: name,
        direction
      }))
    };
  }
}

// src/features/commerce/facets/facet-search-set/category/commerce-category-facet-search-request-builder.ts
var buildCategoryFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  const baseFacetQuery = state.categoryFacetSearchSet[facetId2].options.query;
  const facetQuery = `*${baseFacetQuery}*`;
  const categoryFacet = state.commerceFacetSet[getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2)]?.request;
  const path = categoryFacet && isCategoryFacetRequest2(categoryFacet) ? categoryFacet && getPathToSelectedCategoryFacetItem(categoryFacet) : [];
  const ignorePaths = path.length ? [path] : [];
  const query2 = isFieldSuggestionsRequest ? baseFacetQuery : state.commerceQuery?.query;
  const numberOfValues2 = state.categoryFacetSearchSet[facetId2].options.numberOfValues;
  const {
    url,
    accessToken,
    organizationId,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    ...restOfCommerceAPIRequest
  } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    ignorePaths,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};
function isCategoryFacetRequest2(request) {
  return request.type === "hierarchical";
}
var getPathToSelectedCategoryFacetItem = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.values[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};

// src/features/commerce/facets/facet-search-set/regular/commerce-regular-facet-search-request-builder.ts
var buildFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  const baseFacetQuery = state.facetSearchSet[facetId2].options.query;
  const numberOfValues2 = state.facetSearchSet[facetId2].options.numberOfValues;
  const facetQuery = `*${baseFacetQuery}*`;
  const query2 = !isFieldSuggestionsRequest ? state.commerceQuery?.query : baseFacetQuery;
  const {
    url,
    accessToken,
    organizationId,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    ...restOfCommerceAPIRequest
  } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};

// src/features/commerce/facets/facet-search-set/commerce-facet-search-actions.ts
var getExecuteFacetSearchThunkPayloadCreator = (isFieldSuggestionsRequest) => async ({ facetId: facetId2, facetSearchType }, { getState, extra: { validatePayload: validatePayload2, navigatorContext, apiClient } }) => {
  const state = getState();
  validatePayload2(facetId2, requiredNonEmptyString);
  const req = isRegularFacetSearchState(state, facetId2) || isRegularFieldSuggestionsState(state, facetId2) ? buildFacetSearchRequest(
    facetId2,
    state,
    isFieldSuggestionsRequest,
    navigatorContext
  ) : buildCategoryFacetSearchRequest(
    facetId2,
    state,
    isFieldSuggestionsRequest,
    navigatorContext
  );
  const response = await apiClient.facetSearch(req, facetSearchType);
  return { facetId: facetId2, response };
};
var executeCommerceFacetSearch = (0, import_toolkit60.createAsyncThunk)(
  "commerce/facetSearch/executeSearch",
  getExecuteFacetSearchThunkPayloadCreator(false)
);
var executeCommerceFieldSuggest = (0, import_toolkit60.createAsyncThunk)(
  "commerce/facetSearch/facetFieldSuggest",
  getExecuteFacetSearchThunkPayloadCreator(true)
);
var isRegularFacetSearchState = (s, facetId2) => {
  return "facetSearchSet" in s && s.facetSearchSet[facetId2] !== void 0 && s.commerceFacetSet[facetId2] !== void 0;
};
var isRegularFieldSuggestionsState = (s, facetId2) => {
  if (!("fieldSuggestionsOrder" in s)) {
    return false;
  }
  return s.fieldSuggestionsOrder.some(
    (facet) => facet.facetId === facetId2 && facet.type === "regular"
  );
};
var commerceFieldSuggestionNamespace = "field_suggestion:";
function getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2.slice(commerceFieldSuggestionNamespace.length) : facetId2;
}
function getFacetIdWithCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2 : `${commerceFieldSuggestionNamespace}${facetId2}`;
}

// src/features/commerce/product-listing/product-listing-actions.ts
var import_bueno54 = require("@coveo/bueno");
var import_toolkit62 = require("@reduxjs/toolkit");

// src/features/commerce/pagination/pagination-selectors.ts
var perPagePrincipalSelector = (state) => state.commercePagination?.principal.perPage || 0;
var totalEntriesPrincipalSelector = (state) => state.commercePagination?.principal.totalEntries || 0;

// src/features/commerce/product-listing/product-listing-selectors.ts
var import_bueno53 = require("@coveo/bueno");
var import_toolkit61 = require("@reduxjs/toolkit");

// src/app/state-key.ts
var stateKeyDescription = "coveo-headless-internal-state";
var stateKey = Symbol.for(stateKeyDescription);

// src/features/commerce/product-listing/product-listing-selectors.ts
var numberOfProductsSelector = (state) => state.productListing?.results.length || state.productListing?.products.length || 0;
var moreProductsAvailableSelector = (0, import_toolkit61.createSelector)(
  (state) => ({
    total: totalEntriesPrincipalSelector(state),
    current: numberOfProductsSelector(state)
  }),
  ({ current, total }) => current < total
);

// src/features/commerce/product-listing/product-listing-actions.ts
var fetchProductListing = (0, import_toolkit62.createAsyncThunk)(
  "commerce/productListing/fetch",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
    const fetched = await apiClient.getProductListing({
      ...request,
      enableResults: Boolean(payload?.enableResults)
    });
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var fetchMoreProducts = (0, import_toolkit62.createAsyncThunk)(
  "commerce/productListing/fetchMoreProducts",
  async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const moreProductsAvailable = moreProductsAvailableSelector(state);
    if (!moreProductsAvailable) {
      return null;
    }
    const perPage = perPagePrincipalSelector(state);
    const numberOfProducts = numberOfProductsSelector(state);
    const nextPageToRequest = numberOfProducts / perPage;
    const fetched = await apiClient.getProductListing({
      ...buildFilterableCommerceAPIRequest(state, navigatorContext),
      enableResults: Boolean(payload?.enableResults),
      page: nextPageToRequest
    });
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var promoteChildToParentDefinition = {
  child: new import_bueno54.RecordValue({
    options: { required: true },
    values: {
      permanentid: new import_bueno54.StringValue({ required: true })
    }
  })
};
var promoteChildToParent = (0, import_toolkit62.createAction)(
  "commerce/productListing/promoteChildToParent",
  (payload) => validatePayload(payload, promoteChildToParentDefinition)
);

// src/features/commerce/query-suggest/query-suggest-actions.ts
var import_bueno55 = require("@coveo/bueno");
var import_toolkit63 = require("@reduxjs/toolkit");

// src/features/commerce/query-suggest/query-suggest-request-builder.ts
var buildQuerySuggestRequest = (id, state, navigatorContext) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    query: state.querySet[id]
  };
};

// src/features/commerce/query-suggest/query-suggest-actions.ts
var clearQuerySuggest = (0, import_toolkit63.createAction)(
  "commerce/querySuggest/clear",
  (payload) => validatePayload(payload, { id: requiredNonEmptyString })
);
var fetchQuerySuggestions = (0, import_toolkit63.createAsyncThunk)(
  "commerce/querySuggest/fetch",
  async (payload, {
    getState,
    rejectWithValue,
    extra: { apiClient, validatePayload: validatePayload2, navigatorContext }
  }) => {
    validatePayload2(payload, {
      id: requiredNonEmptyString
    });
    const state = getState();
    const request = buildQuerySuggestRequest(
      payload.id,
      state,
      navigatorContext
    );
    const response = await apiClient.querySuggest(request);
    if (isErrorResponse2(response)) {
      return rejectWithValue(response.error);
    }
    return {
      id: payload.id,
      query: request.query,
      ...response.success
    };
  }
);
var registerQuerySuggest = (0, import_toolkit63.createAction)(
  "commerce/querySuggest/register",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    count: new import_bueno55.NumberValue({ min: 0 })
  })
);
var selectQuerySuggestion = (0, import_toolkit63.createAction)(
  "commerce/querySuggest/selectSuggestion",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    expression: requiredEmptyAllowedString
  })
);

// src/features/commerce/search/search-actions.ts
var import_bueno62 = require("@coveo/bueno");
var import_toolkit69 = require("@reduxjs/toolkit");

// src/features/commerce/facets/core-facet/core-facet-actions.ts
var import_bueno56 = require("@coveo/bueno");
var import_toolkit64 = require("@reduxjs/toolkit");
var updateCoreFacetNumberOfValues = (0, import_toolkit64.createAction)(
  "commerce/facets/core/updateNumberOfValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    numberOfValues: new import_bueno56.NumberValue({ required: true, min: 1 })
  })
);
var updateCoreFacetIsFieldExpanded = (0, import_toolkit64.createAction)(
  "commerce/facets/core/updateIsFieldExpanded",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    isFieldExpanded: new import_bueno56.BooleanValue({ required: true })
  })
);
var clearAllCoreFacets = (0, import_toolkit64.createAction)("commerce/facets/core/clearAll");
var deleteAllCoreFacets = (0, import_toolkit64.createAction)(
  "commerce/facets/core/deleteAll"
);
var deselectAllValuesInCoreFacet = (0, import_toolkit64.createAction)(
  "commerce/facets/core/deselectAllValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString
  })
);
var updateCoreFacetFreezeCurrentValues = (0, import_toolkit64.createAction)(
  "commerce/facets/core/updateFreezeCurrentValues",
  (payload) => validatePayload(payload, {
    facetId: requiredNonEmptyString,
    freezeCurrentValues: new import_bueno56.BooleanValue({ required: true })
  })
);
var updateAutoSelectionForAllCoreFacets = (0, import_toolkit64.createAction)(
  "commerce/facets/core/updateAutoSelectionForAll",
  (payload) => validatePayload(payload, {
    allow: new import_bueno56.BooleanValue({ required: true })
  })
);

// src/features/commerce/pagination/pagination-actions.ts
var import_bueno57 = require("@coveo/bueno");
var import_toolkit65 = require("@reduxjs/toolkit");
var slotIdDefinition = {
  slotId: nonRequiredEmptyAllowedString
};
var setPageSizeDefinition = {
  ...slotIdDefinition,
  pageSize: new import_bueno57.NumberValue({ required: true, min: 0 })
};
var setPageSize = (0, import_toolkit65.createAction)(
  "commerce/pagination/setPageSize",
  (payload) => validatePayload(payload, setPageSizeDefinition)
);
var selectPageDefinition = {
  ...slotIdDefinition,
  page: new import_bueno57.NumberValue({ required: true, min: 0 })
};
var selectPage = (0, import_toolkit65.createAction)(
  "commerce/pagination/selectPage",
  (payload) => validatePayload(payload, selectPageDefinition)
);
var nextPage2 = (0, import_toolkit65.createAction)(
  "commerce/pagination/nextPage",
  (payload) => validatePayload(payload, slotIdDefinition)
);
var previousPage2 = (0, import_toolkit65.createAction)(
  "commerce/pagination/previousPage",
  (payload) => validatePayload(payload, slotIdDefinition)
);
var registerRecommendationsSlotPagination = (0, import_toolkit65.createAction)(
  "commerce/pagination/registerRecommendationsSlot",
  (payload) => validatePayload(payload, {
    slotId: requiredNonEmptyString
  })
);

// src/features/commerce/query/query-actions.ts
var import_bueno58 = require("@coveo/bueno");
var import_toolkit66 = require("@reduxjs/toolkit");
var updateQuery2 = (0, import_toolkit66.createAction)(
  "commerce/query/update",
  (payload) => validatePayload(payload, {
    query: new import_bueno58.StringValue()
  })
);

// src/features/commerce/search/search-actions-thunk-processor.ts
var import_bueno61 = require("@coveo/bueno");

// src/features/commerce/triggers/triggers-actions.ts
var import_bueno59 = require("@coveo/bueno");
var import_toolkit67 = require("@reduxjs/toolkit");
var updateIgnoreQueryTrigger2 = (0, import_toolkit67.createAction)(
  "commerce/triggers/query/updateIgnore",
  (payload) => validatePayload(payload, {
    q: new import_bueno59.StringValue({ emptyAllowed: true, required: true })
  })
);
var applyQueryTriggerModification2 = (0, import_toolkit67.createAction)(
  "commerce/triggers/query/applyModification",
  (payload) => validatePayload(
    payload,
    new import_bueno59.RecordValue({
      values: { originalQuery: nonEmptyString, modification: nonEmptyString }
    })
  )
);

// src/features/commerce/search/search-selectors.ts
var import_bueno60 = require("@coveo/bueno");
var import_toolkit68 = require("@reduxjs/toolkit");

// src/features/parameter-manager/parameter-manager-selectors.ts
function getQ(section, querySelector2, initialState) {
  if (section === void 0) {
    return {};
  }
  const q = querySelector2(section);
  const shouldInclude = q !== initialState;
  return shouldInclude ? { q } : {};
}
function getSortCriteria(section, sortCriteriaSelector, initialState) {
  if (section === void 0) {
    return {};
  }
  const sortCriteria = sortCriteriaSelector(section);
  const shouldInclude = sortCriteria !== initialState;
  return shouldInclude ? { sortCriteria } : {};
}
function getFacets4(section, facetIsEnabled2, valuesSelector, out) {
  if (section === void 0) {
    return {};
  }
  const facets = Object.entries(section).filter(([facetId2]) => facetIsEnabled2(facetId2)).map(([facetId2, { request }]) => {
    const selectedValues = valuesSelector(request);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(facets).length ? { [out]: facets } : {};
}
function getTab(section, tabSelector, initialState) {
  if (section === void 0) {
    return {};
  }
  const tab = tabSelector(section);
  const shouldInclude = tab !== initialState;
  return shouldInclude ? { tab } : {};
}

// src/features/commerce/search/search-selectors.ts
var numberOfProductsSelector2 = (state) => state.commerceSearch?.products.length || 0;
var moreProductsAvailableSelector2 = (0, import_toolkit68.createSelector)(
  (state) => ({
    total: totalEntriesPrincipalSelector(state),
    current: numberOfProductsSelector2(state)
  }),
  ({ current, total }) => current < total
);
var querySelector = (state) => state.commerceQuery?.query ?? "";
var queryExecutedFromResponseSelector = (state, response) => {
  if (!(0, import_bueno60.isNullOrUndefined)(response.queryCorrection?.correctedQuery)) {
    return response.queryCorrection.correctedQuery;
  }
  return querySelector(state);
};

// src/features/commerce/search/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor3 = class {
  constructor(config) {
    this.config = config;
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  async fetchFromAPI(request) {
    const startedAt = Date.now();
    const response = await this.extra.apiClient.search(request);
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().commerceQuery.query || "";
    return {
      response,
      duration,
      queryExecuted,
      requestExecuted: request,
      enableResults: Boolean(
        "enableResults" in request && request.enableResults
      )
    };
  }
  processSuccessResponse(fetched) {
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      originalQuery: this.getCurrentQuery()
    };
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse2(fetched.response)) {
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { queryCorrection } = successResponse;
    const shouldExecuteQueryCorrection = !(0, import_bueno61.isNullOrUndefined)(queryCorrection) && !(0, import_bueno61.isNullOrUndefined)(queryCorrection.correctedQuery);
    if (!shouldExecuteQueryCorrection) {
      return null;
    }
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery ?? "");
    return {
      ...fetched,
      response: {
        ...successResponse
      },
      queryExecuted: queryExecutedFromResponseSelector(state, successResponse),
      originalQuery: originalQuery ?? ""
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger2({ q: "" }));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(
      correctedQuery,
      fetched.enableResults
    );
    if (isErrorResponse2(retried.response)) {
      return this.rejectWithValue(retried.response.error);
    }
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      originalQuery
    };
  }
  async automaticallyRetryQueryWithTriggerModification(modified, enableResults) {
    this.dispatch(
      applyQueryTriggerModification2({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI({
      ...buildFilterableCommerceAPIRequest(
        this.getState(),
        this.navigatorContext
      ),
      query: modified,
      enableResults: Boolean(enableResults)
    });
    return fetched;
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
  getState() {
    return this.config.getState();
  }
  get navigatorContext() {
    return this.config.extra.navigatorContext;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.commerceQuery.query !== void 0 ? state.commerceQuery.query : "";
  }
  getSuccessResponse(fetched) {
    if (isErrorResponse2(fetched.response)) {
      return null;
    }
    return fetched.response.success;
  }
  get extra() {
    return this.config.extra;
  }
  onUpdateQueryForCorrection(modification) {
    this.dispatch(updateQuery2({ query: modification }));
  }
};

// src/features/commerce/search/search-actions.ts
var executeSearch3 = (0, import_toolkit69.createAsyncThunk)("commerce/search/executeSearch", async (payload = {}, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const query2 = querySelector(state);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    enableResults: Boolean(payload?.enableResults)
  });
  return processor.process(fetchedResponse);
});
var fetchMoreProducts2 = (0, import_toolkit69.createAsyncThunk)("commerce/search/fetchMoreProducts", async (payload = {}, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const moreProductsAvailable = moreProductsAvailableSelector2(state);
  if (!moreProductsAvailable) {
    return null;
  }
  const perPage = perPagePrincipalSelector(state);
  const numberOfProducts = numberOfProductsSelector2(state);
  const nextPageToRequest = numberOfProducts / perPage;
  const query2 = querySelector(state);
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    page: nextPageToRequest,
    enableResults: Boolean(payload?.enableResults)
  });
  return processor.process(fetchedResponse);
});
var prepareForSearchWithQuery2 = (0, import_toolkit69.createAsyncThunk)("commerce/search/prepareForSearchWithQuery", (payload, thunk) => {
  const { dispatch } = thunk;
  validatePayload(payload, {
    query: new import_bueno62.StringValue(),
    clearFilters: new import_bueno62.BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deleteAllCoreFacets());
  }
  dispatch(updateAutoSelectionForAllCoreFacets({ allow: true }));
  dispatch(
    updateQuery2({
      query: payload.query
    })
  );
  dispatch(selectPage({ page: 0 }));
});
var fetchInstantProducts = (0, import_toolkit69.createAsyncThunk)(
  "commerce/search/fetchInstantProducts",
  async (payload, { getState, rejectWithValue, extra }) => {
    const state = getState();
    const { apiClient, navigatorContext } = extra;
    const { q } = payload;
    const fetched = await apiClient.productSuggestions({
      ...buildBaseCommerceAPIRequest(state, navigatorContext),
      query: q
    });
    if (isErrorResponse2(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: { ...fetched.success, products: fetched.success.products }
    };
  }
);
var promoteChildToParentDefinition2 = {
  child: new import_bueno62.RecordValue({
    options: { required: true },
    values: {
      permanentid: new import_bueno62.StringValue({ required: true })
    }
  })
};
var promoteChildToParent2 = (0, import_toolkit69.createAction)(
  "commerce/search/promoteChildToParent",
  (payload) => validatePayload(payload, promoteChildToParentDefinition2)
);

// src/features/facets/facet-search-set/facet-search-reducer-helpers.ts
function handleFacetSearchRegistration(state, payload, buildEmptyResponse3) {
  const { facetId: facetId2 } = payload;
  if (state[facetId2]) {
    return;
  }
  const isLoading = false;
  const options = { ...defaultFacetSearchOptions, ...payload };
  const response = buildEmptyResponse3();
  state[facetId2] = {
    options,
    isLoading,
    response,
    initialNumberOfValues: options.numberOfValues,
    requestId: ""
  };
}
function handleFacetSearchUpdate(state, payload) {
  const { facetId: facetId2, ...rest } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.options = { ...search.options, ...rest };
}
function handleFacetSearchPending(state, facetId2, requestId) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = requestId;
  search.isLoading = true;
}
function handleFacetSearchRejected(state, facetId2) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.isLoading = false;
}
function handleFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  search.response = response;
}
function handleCommerceFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFacetFieldSuggestionsFulfilled(state, payload, requestId, buildEmptyResponse3) {
  const { facetId: facetId2, response } = payload;
  const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(facetId2);
  let search = state[namespacedFacetId];
  if (!search) {
    handleFacetSearchRegistration(
      state,
      { facetId: namespacedFacetId },
      buildEmptyResponse3
    );
    search = state[namespacedFacetId];
  } else if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(state, payload, requestId, buildEmptyResponse3) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    if (fieldSuggestionFacet.facetId in state || fieldSuggestionFacet.type !== "regular") {
      continue;
    }
    state[fieldSuggestionFacet.facetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse3(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(state, payload, requestId, buildEmptyResponse3) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(
      fieldSuggestionFacet.facetId
    );
    if (namespacedFacetId in state || fieldSuggestionFacet.type !== "hierarchical") {
      continue;
    }
    state[namespacedFacetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse3(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleFacetSearchClear(state, payload, buildEmptyResponse3) {
  const { facetId: facetId2 } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = "";
  search.isLoading = false;
  search.response = buildEmptyResponse3();
  search.options.numberOfValues = search.initialNumberOfValues;
  search.options.query = defaultFacetSearchOptions.query;
}
function handleFacetSearchSetClear(state, buildEmptyResponse3) {
  Object.keys(state).forEach(
    (facetId2) => handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse3)
  );
}
var defaultFacetSearchOptions = {
  captions: {},
  numberOfValues: 10,
  query: ""
};

// src/features/facets/facet-search-set/generic/generic-facet-search-actions.ts
var import_toolkit70 = require("@reduxjs/toolkit");

// src/features/facets/facet-search-set/category/category-facet-search-request-builder.ts
var buildCategoryFacetSearchRequest2 = async (id, state, navigatorContext, isFieldSuggestionsRequest) => {
  const options = state.categoryFacetSearchSet[id].options;
  const categoryFacet = state.categoryFacetSet[id].request;
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = options;
  const { field: field2, delimitingCharacter: delimitingCharacter2, basePath: basePath2, filterFacetCount: filterFacetCount2 } = categoryFacet;
  const path = getPathToSelectedCategoryFacetItem2(categoryFacet);
  const ignorePaths = path.length ? [path] : [];
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    basePath: basePath2,
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    delimitingCharacter: delimitingCharacter2,
    ignorePaths,
    filterFacetCount: filterFacetCount2,
    type: "hierarchical",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest2(state, navigatorContext)).request
    }
  };
};
var getPathToSelectedCategoryFacetItem2 = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.currentValues[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};

// src/features/facets/facet-search-set/specific/specific-facet-search-request-builder.ts
var buildSpecificFacetSearchRequest = async (id, state, navigatorContext, isFieldSuggestionsRequest) => {
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = state.facetSearchSet[id].options;
  const { field: field2, currentValues, filterFacetCount: filterFacetCount2 } = state.facetSet[id].request;
  const ignoreValues = currentValues.filter((v) => v.state !== "idle").map((facetValue) => facetValue.value);
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    ignoreValues,
    filterFacetCount: filterFacetCount2,
    type: "specific",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest2(state, navigatorContext)).request
    }
  };
};

// src/features/facets/facet-search-set/generic/generic-facet-search-actions.ts
var getExecuteFacetSearchThunkPayloadCreator2 = (isFieldSuggestionsRequest) => async (facetId2, { getState, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  const state = getState();
  let req;
  validatePayload2(facetId2, requiredNonEmptyString);
  if (isSpecificFacetSearchState(state, facetId2)) {
    req = await buildSpecificFacetSearchRequest(
      facetId2,
      state,
      navigatorContext,
      isFieldSuggestionsRequest
    );
  } else {
    req = await buildCategoryFacetSearchRequest2(
      facetId2,
      state,
      navigatorContext,
      isFieldSuggestionsRequest
    );
  }
  const response = await apiClient.facetSearch(req);
  return { facetId: facetId2, response };
};
var executeFacetSearch = (0, import_toolkit70.createAsyncThunk)("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator2(false));
var executeFieldSuggest = (0, import_toolkit70.createAsyncThunk)("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator2(true));
var clearFacetSearch = (0, import_toolkit70.createAction)(
  "facetSearch/clearResults",
  (payload) => validatePayload(payload, { facetId: facetIdDefinition })
);
var isSpecificFacetSearchState = (s, facetId2) => {
  return s.facetSearchSet !== void 0 && s.facetSet !== void 0 && s.facetSet[facetId2] !== void 0;
};

// src/features/facets/facet-search-set/category/category-facet-search-set-state.ts
function getCategoryFacetSearchSetInitialState() {
  return {};
}

// src/features/facets/facet-search-set/category/category-facet-search-set-slice.ts
var categoryFacetSearchSetReducer = (0, import_toolkit71.createReducer)(
  getCategoryFacetSearchSetInitialState(),
  (builder) => {
    builder.addCase(registerCategoryFacetSearch, (state, action) => {
      const payload = action.payload;
      handleFacetSearchRegistration(state, payload, buildEmptyResponse);
    }).addCase(updateFacetSearch, (state, action) => {
      handleFacetSearchUpdate(state, action.payload);
    }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeFacetSearch.pending, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(facetId2)
      );
    }).addCase(executeFacetSearch.rejected, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
      handleCommerceFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
      handleCommerceFacetFieldSuggestionsFulfilled(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse
      );
    }).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
      handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse
      );
    }).addCase(executeFacetSearch.fulfilled, (state, action) => {
      handleFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(clearFacetSearch, (state, { payload: { facetId: facetId2 } }) => {
      handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse);
    }).addCase(
      fetchProductListing.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse)
    ).addCase(
      executeSearch3.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse)
    ).addCase(executeSearch2.fulfilled, (state) => {
      handleFacetSearchSetClear(state, buildEmptyResponse);
    });
  }
);
function buildEmptyResponse() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}

// src/controllers/core/facets/_common/facet-id-generator.ts
function generateFacetId(config, logger) {
  const { field: field2, state } = config;
  if (!isFieldUsedAsFacetId(config)) {
    return field2;
  }
  const prefix = `${field2}_`;
  const id = calculateId(prefix, state);
  logWarningMessage(field2, logger);
  return `${prefix}${id}`;
}
function isFieldUsedAsFacetId(config) {
  const { field: field2, state } = config;
  const sets = extractFacetSets(state);
  return sets.some((set) => set && field2 in set);
}
function calculateId(prefix, state) {
  const sets = extractFacetSets(state);
  const keys = sets.map((set) => Object.keys(set || {})).reduce((all, current) => all.concat(current), []);
  return findMaxId(keys, prefix) + 1;
}
function extractFacetSets(state) {
  const { facetSet, numericFacetSet, dateFacetSet, categoryFacetSet } = state;
  return [facetSet, numericFacetSet, dateFacetSet, categoryFacetSet];
}
function findMaxId(keys, prefix) {
  const defaultId = 0;
  const ids = keys.map((key) => {
    const stringId = key.split(prefix)[1];
    const id = parseInt(stringId, 10);
    return Number.isNaN(id) ? defaultId : id;
  });
  const lastNumber = ids.sort().pop();
  return lastNumber ?? defaultId;
}
function logWarningMessage(field2, logger) {
  const message = `A facet with field "${field2}" already exists.
  To avoid unexpected behaviour, configure the #id option on the facet controller.`;
  logger.warn(message);
}

// src/controllers/core/facets/_common/facet-id-determinor.ts
function determineFacetId(engine, config) {
  const { state, logger } = engine;
  const { field: field2, facetId: facetId2 } = config;
  return facetId2 || generateFacetId({ field: field2, state }, logger);
}

// src/controllers/core/facets/category-facet/headless-core-category-facet-options.ts
var import_bueno63 = require("@coveo/bueno");

// src/features/facets/category-facet-set/interfaces/request.ts
var categoryFacetSortCriteria = [
  "alphanumeric",
  "occurrences"
];

// src/controllers/core/facets/category-facet/headless-core-category-facet-options.ts
var categoryFacetOptionsSchema = new import_bueno63.Schema({
  field,
  tabs: new import_bueno63.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno63.ArrayValue({ each: new import_bueno63.StringValue() }),
      excluded: new import_bueno63.ArrayValue({ each: new import_bueno63.StringValue() })
    }
  }),
  basePath,
  delimitingCharacter,
  facetId,
  facetSearch,
  filterByBasePath,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new import_bueno63.StringValue({
    constrainTo: categoryFacetSortCriteria
  })
});

// src/controllers/core/facets/category-facet/headless-core-category-facet.ts
function buildCoreCategoryFacet(engine, props) {
  if (!loadCategoryFacetReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const registrationOptions = {
    ...defaultCategoryFacetOptions,
    ...omit("facetSearch", props.options),
    field: props.options.field,
    facetId: facetId2,
    tabs,
    activeTab
  };
  const options = {
    facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
    ...registrationOptions
  };
  validateOptions(
    engine,
    categoryFacetOptionsSchema,
    options,
    "buildCategoryFacet"
  );
  const getRequest = () => {
    return categoryFacetRequestSelector(engine.state, facetId2);
  };
  const getResponse = () => {
    return categoryFacetResponseSelector(engine.state, facetId2);
  };
  const getIsLoading = () => isFacetLoadingResponseSelector(engine.state);
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  dispatch(registerCategoryFacet(registrationOptions));
  return {
    ...controller,
    toggleSelect(selection) {
      const retrieveCount = options.numberOfValues;
      dispatch(
        toggleSelectCategoryFacetValue({ facetId: facetId2, selection, retrieveCount })
      );
      dispatch(updateFacetOptions());
    },
    deselectAll() {
      dispatch(deselectAllCategoryFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateCategoryFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      const request = getRequest();
      return request.sortCriteria === criterion;
    },
    showMoreValues() {
      const { numberOfValues: increment } = options;
      const { activeValue, valuesAsTrees } = this.state;
      const numberOfValues2 = (activeValue?.children.length ?? valuesAsTrees.length) + increment;
      dispatch(updateCategoryFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetOptions());
    },
    showLessValues() {
      const { numberOfValues: numberOfValues2 } = options;
      dispatch(updateCategoryFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetOptions());
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = getResponse();
      const isLoading = getIsLoading();
      const enabled = getIsEnabled();
      const valuesAsTrees = response?.values ?? [];
      const isHierarchical = valuesAsTrees.some((value) => value.children.length > 0) ?? false;
      const { parents, values } = partitionIntoParentsAndValues(response?.values);
      const selectedValueAncestry = findActiveValueAncestry(valuesAsTrees);
      const activeValue = selectedValueAncestry.length ? selectedValueAncestry[selectedValueAncestry.length - 1] : void 0;
      const hasActiveValues = !!activeValue;
      const canShowMoreValues = activeValue?.moreValuesAvailable ?? response?.moreValuesAvailable ?? false;
      const canShowLessValues = activeValue ? activeValue.children.length > options.numberOfValues : valuesAsTrees.length > options.numberOfValues;
      return {
        facetId: facetId2,
        parents,
        selectedValueAncestry,
        values,
        isHierarchical,
        valuesAsTrees,
        activeValue,
        isLoading,
        hasActiveValues,
        canShowMoreValues,
        canShowLessValues,
        sortCriteria: request.sortCriteria,
        enabled
      };
    }
  };
}
function loadCategoryFacetReducers(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    facetOptions: facetOptionsReducer,
    configuration,
    search: searchReducer
  });
  return true;
}

// src/controllers/core/facets/facet-search/facet-search.ts
function buildGenericFacetSearch(engine, props) {
  const dispatch = engine.dispatch;
  const {
    options,
    getFacetSearch,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  } = props;
  const { facetId: facetId2 } = options;
  return {
    /** Updates the facet search query.
     * @param text The new query.
     */
    updateText(text) {
      dispatch(
        updateFacetSearch({
          facetId: facetId2,
          query: text,
          numberOfValues: getFacetSearch().initialNumberOfValues
        })
      );
    },
    /** Increases number of results returned by numberOfResults */
    showMoreResults() {
      const { initialNumberOfValues, options: options2 } = getFacetSearch();
      dispatch(
        updateFacetSearch({
          facetId: facetId2,
          numberOfValues: options2.numberOfValues + initialNumberOfValues
        })
      );
      dispatch(
        props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2)
      );
    },
    /** Executes a facet search to update the values.*/
    search() {
      dispatch(
        props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2)
      );
    },
    /** Resets the query and empties the values. */
    clear() {
      dispatch(clearFacetSearch({ facetId: facetId2 }));
    },
    /**
     * Updates the facet value captions.
     * @param captions - A dictionary that maps index field values to facet value display names.
     */
    updateCaptions(captions2) {
      dispatch(
        updateFacetSearch({
          facetId: facetId2,
          captions: captions2
        })
      );
    },
    get state() {
      const { response, isLoading, options: options2 } = getFacetSearch();
      const { query: query2 } = options2;
      const values = response.values;
      return {
        ...response,
        values,
        isLoading,
        query: query2
      };
    }
  };
}

// src/controllers/core/facets/facet-search/category/headless-category-facet-search.ts
function buildCoreCategoryFacetSearch(engine, props) {
  const { dispatch } = engine;
  const options = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => "state" in engine ? engine.state.categoryFacetSearchSet[facetId2] : engine[stateKey].categoryFacetSearchSet[facetId2];
  dispatch(registerCategoryFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: props.executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator: props.executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    select(value) {
      dispatch(
        selectCategoryFacetSearchResult({
          facetId: facetId2,
          value
        })
      );
      props.select(value);
    },
    get state() {
      return genericFacetSearch.state;
    }
  };
}

// src/controllers/facets/category-facet/headless-category-facet-search.ts
function buildCategoryFacetSearch(engine, props) {
  const {
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator,
    select: propsSelect,
    isForFieldSuggestions
  } = props;
  const { dispatch } = engine;
  const options = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => engine.state.categoryFacetSearchSet[facetId2];
  const coreFacetSearch = buildCoreCategoryFacetSearch(engine, {
    options: {
      ...options
    },
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator,
    select: propsSelect,
    isForFieldSuggestions
  });
  dispatch(registerCategoryFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest
  });
  return {
    ...genericFacetSearch,
    ...coreFacetSearch,
    get state() {
      return {
        ...genericFacetSearch.state,
        ...coreFacetSearch.state
      };
    }
  };
}

// src/controllers/facets/category-facet/headless-category-facet.ts
function buildCategoryFacet(engine, props) {
  if (!loadCategoryFacetReducers2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreCategoryFacet(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: {
      facetId: getFacetId(),
      ...props.options.facetSearch
    },
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest,
    select: (value) => {
      dispatch(updateFacetOptions());
      dispatch(
        executeSearch2({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: value.rawValue
          }),
          next: facetSelect()
        })
      );
    },
    isForFieldSuggestions: false
  });
  const { state: _state, ...restOfFacetSearch } = facetSearch2;
  return {
    ...coreController,
    facetSearch: restOfFacetSearch,
    toggleSelect(selection) {
      coreController.toggleSelect(selection);
      dispatch(
        executeSearch2({
          legacy: getLegacyToggleSelectAnalyticsAction(getFacetId(), selection),
          next: getToggleSelectAnalyticsAction(selection)
        })
      );
    },
    deselectAll() {
      coreController.deselectAll();
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(getFacetId()),
          next: facetClearAll()
        })
      );
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(
        executeSearch2({
          legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
        })
      );
    },
    showMoreValues() {
      coreController.showMoreValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowMore(getFacetId()) }));
    },
    showLessValues() {
      coreController.showLessValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowLess(getFacetId()) }));
    },
    get state() {
      return {
        ...coreController.state,
        facetSearch: facetSearch2.state
      };
    }
  };
}
function loadCategoryFacetReducers2(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    configuration,
    search: searchReducer
  });
  return true;
}
function getLegacyToggleSelectAnalyticsAction(facetId2, selection) {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  const isSelected = selection.state === "selected";
  return isSelected ? logFacetDeselect(payload) : logFacetSelect(payload);
}
function getToggleSelectAnalyticsAction(selection) {
  const isSelected = selection.state === "selected";
  return isSelected ? facetDeselect() : facetSelect();
}

// src/ssr/search/controllers/facets/category-facet/headless-category-facet.ssr.ts
function defineCategoryFacet(props) {
  return {
    build: (engine) => buildCategoryFacet(engine, props)
  };
}

// src/features/facets/facet-search-set/specific/specific-facet-search-set-slice.ts
var import_toolkit73 = require("@reduxjs/toolkit");

// src/features/commerce/context/context-actions.ts
var import_toolkit72 = require("@reduxjs/toolkit");

// src/features/commerce/context/context-validation.ts
var import_bueno64 = require("@coveo/bueno");
var currencies = Intl.supportedValuesOf("currency");
var currencyDefinition = new import_bueno64.StringValue({
  required: true,
  emptyAllowed: false,
  constrainTo: currencies
});
var viewDefinition = {
  url: requiredNonEmptyString
};
var locationDefinition = {
  latitude: new import_bueno64.NumberValue({ min: -90, max: 90, required: true }),
  longitude: new import_bueno64.NumberValue({ min: -180, max: 180, required: true })
};
var customDefinition = {
  custom: new import_bueno64.RecordValue({
    options: { required: false }
  })
};
var contextDefinition = {
  language: requiredNonEmptyString,
  country: requiredNonEmptyString,
  currency: currencyDefinition,
  view: new import_bueno64.RecordValue({
    options: { required: true },
    values: viewDefinition
  }),
  location: new import_bueno64.RecordValue({
    options: { required: false },
    values: locationDefinition
  }),
  custom: new import_bueno64.RecordValue({
    options: { required: false }
  })
};
var contextSchema = new import_bueno64.Schema(contextDefinition);

// src/features/commerce/context/context-actions.ts
var setContext3 = (0, import_toolkit72.createAction)(
  "commerce/context/set",
  (payload) => validatePayload(payload, contextDefinition)
);
var setView = (0, import_toolkit72.createAction)(
  "commerce/context/setView",
  (payload) => validatePayload(payload, viewDefinition)
);
var setLocation = (0, import_toolkit72.createAction)(
  "commerce/context/setLocation",
  (payload) => validatePayload(payload, locationDefinition)
);
var setCustom = (0, import_toolkit72.createAction)(
  "commerce/context/setCustom",
  (payload) => validatePayload({ custom: payload }, customDefinition)
);

// src/features/facets/facet-search-set/specific/specific-facet-search-set-state.ts
function getFacetSearchSetInitialState() {
  return {};
}

// src/features/facets/facet-search-set/specific/specific-facet-search-set-slice.ts
var specificFacetSearchSetReducer = (0, import_toolkit73.createReducer)(
  getFacetSearchSetInitialState(),
  (builder) => {
    builder.addCase(registerFacetSearch, (state, action) => {
      const payload = action.payload;
      handleFacetSearchRegistration(state, payload, buildEmptyResponse2);
    }).addCase(updateFacetSearch, (state, action) => {
      handleFacetSearchUpdate(state, action.payload);
    }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchPending(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(facetId2),
        action.meta.requestId
      );
    }).addCase(executeFacetSearch.pending, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchPending(state, facetId2, action.meta.requestId);
    }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
      const { facetId: facetId2 } = action.meta.arg;
      handleFacetSearchRejected(
        state,
        getFacetIdWithCommerceFieldSuggestionNamespace(facetId2)
      );
    }).addCase(executeFacetSearch.rejected, (state, action) => {
      const facetId2 = action.meta.arg;
      handleFacetSearchRejected(state, facetId2);
    }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
      handleCommerceFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
      handleCommerceFacetFieldSuggestionsFulfilled(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse2
      );
    }).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
      handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(
        state,
        action.payload,
        action.meta.requestId,
        buildEmptyResponse2
      );
    }).addCase(executeFacetSearch.fulfilled, (state, action) => {
      handleFacetSearchFulfilled(
        state,
        action.payload,
        action.meta.requestId
      );
    }).addCase(clearFacetSearch, (state, { payload }) => {
      handleFacetSearchClear(state, payload, buildEmptyResponse2);
    }).addCase(executeSearch2.fulfilled, (state) => {
      handleFacetSearchSetClear(state, buildEmptyResponse2);
    }).addCase(
      fetchProductListing.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)
    ).addCase(
      executeSearch3.fulfilled,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)
    ).addCase(
      setView,
      (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)
    );
  }
);
function buildEmptyResponse2() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}

// src/features/facets/facet-set/facet-set-controller-actions.ts
var import_bueno65 = require("@coveo/bueno");
var import_toolkit74 = require("@reduxjs/toolkit");
var definition = {
  facetId: facetIdDefinition,
  selection: new import_bueno65.RecordValue({ values: facetValueDefinition })
};
var executeToggleFacetSelect = (0, import_toolkit74.createAsyncThunk)("facet/executeToggleSelect", ({ facetId: facetId2, selection }, thunk) => {
  const {
    dispatch,
    extra: { validatePayload: validatePayload2 }
  } = thunk;
  validatePayload2({ facetId: facetId2, selection }, definition);
  dispatch(toggleSelectFacetValue({ facetId: facetId2, selection }));
  dispatch(updateFacetOptions());
});
var executeToggleFacetExclude = (0, import_toolkit74.createAsyncThunk)("facet/executeToggleExclude", ({ facetId: facetId2, selection }, thunk) => {
  const {
    dispatch,
    extra: { validatePayload: validatePayload2 }
  } = thunk;
  validatePayload2({ facetId: facetId2, selection }, definition);
  dispatch(toggleExcludeFacetValue({ facetId: facetId2, selection }));
  dispatch(updateFacetOptions());
});

// src/controllers/core/facets/facet/headless-core-facet-options.ts
var import_bueno66 = require("@coveo/bueno");

// src/features/facets/facet-api/request.ts
var facetResultsMustMatch = [
  "allValues",
  "atLeastOneValue"
];

// src/features/facets/facet-set/interfaces/request.ts
var facetSortCriteria = [
  "score",
  "alphanumeric",
  "alphanumericDescending",
  "occurrences",
  "automatic",
  "alphanumericNatural",
  "alphanumericNaturalDescending"
];

// src/controllers/core/facets/facet/headless-core-facet-options.ts
var facetOptionsSchema = new import_bueno66.Schema({
  facetId,
  tabs: new import_bueno66.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno66.ArrayValue({ each: new import_bueno66.StringValue() }),
      excluded: new import_bueno66.ArrayValue({ each: new import_bueno66.StringValue() })
    }
  }),
  field,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new import_bueno66.StringValue({ constrainTo: facetSortCriteria }),
  resultsMustMatch: new import_bueno66.StringValue({ constrainTo: facetResultsMustMatch }),
  facetSearch
});

// src/controllers/core/facets/facet/headless-core-facet.ts
function buildCoreFacet(engine, props, optionsSchema9 = facetOptionsSchema) {
  if (!loadFacetReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const controller = buildController(engine);
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const registrationOptions = {
    ...defaultFacetOptions,
    ...omit("facetSearch", props.options),
    field: props.options.field,
    facetId: facetId2,
    tabs,
    activeTab
  };
  const options = {
    facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
    ...registrationOptions
  };
  validateOptions(engine, optionsSchema9, options, "buildFacet");
  const getRequest = () => facetRequestSelector(engine.state, facetId2);
  const getResponse = () => facetResponseSelector(engine.state, facetId2);
  const getIsLoading = () => isFacetLoadingResponseSelector(engine.state);
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  const getNumberOfActiveValues = () => {
    const { currentValues } = getRequest();
    return currentValues.filter((v) => v.state !== "idle").length;
  };
  const computeCanShowLessValues = () => {
    const { currentValues } = getRequest();
    const initialNumberOfValues = options.numberOfValues;
    const hasIdleValues = !!currentValues.find((v) => v.state === "idle");
    return initialNumberOfValues < currentValues.length && hasIdleValues;
  };
  dispatch(registerFacet(registrationOptions));
  return {
    ...controller,
    toggleSelect: (selection) => dispatch(executeToggleFacetSelect({ facetId: options.facetId, selection })),
    toggleExclude: (selection) => dispatch(
      executeToggleFacetExclude({ facetId: options.facetId, selection })
    ),
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleExclude: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleExclude(selection);
    },
    isValueSelected: isFacetValueSelected,
    isValueExcluded: isFacetValueExcluded,
    deselectAll() {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    showMoreValues() {
      const numberInState = getRequest().numberOfValues;
      const initialNumberOfValues = options.numberOfValues;
      const numberToNextMultipleOfConfigured = initialNumberOfValues - numberInState % initialNumberOfValues;
      const numberOfValues2 = numberInState + numberToNextMultipleOfConfigured;
      dispatch(updateFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: true }));
      dispatch(updateFacetOptions());
    },
    showLessValues() {
      const initialNumberOfValues = options.numberOfValues;
      const newNumberOfValues = Math.max(
        initialNumberOfValues,
        getNumberOfActiveValues()
      );
      dispatch(
        updateFacetNumberOfValues({ facetId: facetId2, numberOfValues: newNumberOfValues })
      );
      dispatch(updateFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: false }));
      dispatch(updateFacetOptions());
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = getResponse();
      const isLoading = getIsLoading();
      const enabled = getIsEnabled();
      let sortCriterion;
      if (typeof request.sortCriteria === "object") {
        sortCriterion = request.sortCriteria.order === "descending" ? "alphanumericDescending" : "alphanumeric";
      } else {
        sortCriterion = request.sortCriteria;
      }
      const values = response ? response.values : [];
      const hasActiveValues = values.some(
        (facetValue) => facetValue.state !== "idle"
      );
      const canShowMoreValues = response ? response.moreValuesAvailable : false;
      const resultsMustMatch = request.resultsMustMatch;
      return {
        label: response?.label,
        facetId: facetId2,
        tabs,
        values,
        sortCriterion,
        resultsMustMatch,
        isLoading,
        hasActiveValues,
        canShowMoreValues,
        canShowLessValues: computeCanShowLessValues(),
        enabled
      };
    }
  };
}
function loadFacetReducers(engine) {
  engine.addReducers({ facetSet: facetSetReducer, facetOptions: facetOptionsReducer, configuration, facetSearchSet: specificFacetSearchSetReducer });
  return true;
}

// src/controllers/core/facets/facet-search/specific/headless-facet-search.ts
function buildFacetSearch(engine, props) {
  const { dispatch } = engine;
  const {
    options,
    select: propsSelect,
    exclude: propsExclude,
    isForFieldSuggestions,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  } = props;
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => "state" in engine ? engine.state.facetSearchSet[facetId2] : engine[stateKey].facetSearchSet[facetId2];
  dispatch(registerFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    /**
     * Selects the provided value.
     * @param result A single specificFacetSearchResult object
     */
    select(value) {
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value.
     * @param result A single specificFacetSearchResult object
     */
    exclude(value) {
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    /**
     * Selects the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleSelect(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleExclude(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    get state() {
      const { values } = genericFacetSearch.state;
      return {
        ...genericFacetSearch.state,
        values: values.map(({ count, displayValue, rawValue }) => ({
          count,
          displayValue,
          rawValue
        }))
      };
    }
  };
}

// src/controllers/facets/facet/headless-facet-options.ts
var import_bueno67 = require("@coveo/bueno");
var facetOptionsSchema2 = new import_bueno67.Schema({
  facetId,
  field,
  tabs: new import_bueno67.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno67.ArrayValue({ each: new import_bueno67.StringValue() }),
      excluded: new import_bueno67.ArrayValue({ each: new import_bueno67.StringValue() })
    }
  }),
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new import_bueno67.StringValue({ constrainTo: facetSortCriteria }),
  resultsMustMatch: new import_bueno67.StringValue({ constrainTo: facetResultsMustMatch }),
  facetSearch,
  allowedValues,
  hasBreadcrumbs,
  customSort
});

// src/controllers/facets/facet/headless-facet.ts
function buildFacet(engine, props) {
  if (!loadFacetReducers2(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const coreController = buildCoreFacet(
    engine,
    {
      ...props,
      options: {
        ...props.options,
        ...props.options.allowedValues && {
          allowedValues: {
            type: "simple",
            values: props.options.allowedValues
          }
        }
      }
    },
    facetOptionsSchema2
  );
  const getFacetId = () => coreController.state.facetId;
  const createFacetSearch = () => {
    const { facetSearch: facetSearch3 } = props.options;
    return buildFacetSearch(engine, {
      options: { facetId: getFacetId(), ...facetSearch3 },
      select: (value) => {
        dispatch(updateFacetOptions());
        dispatch(
          executeSearch2({
            legacy: logFacetSelect({
              facetId: getFacetId(),
              facetValue: value.rawValue
            }),
            next: facetSelect()
          })
        );
      },
      exclude: (value) => {
        dispatch(updateFacetOptions());
        dispatch(
          executeSearch2({
            legacy: logFacetExclude({
              facetId: getFacetId(),
              facetValue: value.rawValue
            }),
            next: facetExclude()
          })
        );
      },
      isForFieldSuggestions: false,
      executeFacetSearchActionCreator: executeFacetSearch,
      executeFieldSuggestActionCreator: executeFieldSuggest
    });
  };
  const facetSearch2 = createFacetSearch();
  const { state: _state, ...restOfFacetSearch } = facetSearch2;
  return {
    ...coreController,
    facetSearch: restOfFacetSearch,
    toggleSelect(selection) {
      coreController.toggleSelect(selection);
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggleFacetSelect(
            getFacetId(),
            selection
          ),
          next: getAnalyticsActionForToggleFacetSelect(selection)
        })
      );
    },
    toggleExclude(selection) {
      coreController.toggleExclude(selection);
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggleFacetExclude(
            getFacetId(),
            selection
          ),
          next: getAnalyticsActionForToggleFacetExclude(selection)
        })
      );
    },
    deselectAll() {
      coreController.deselectAll();
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(getFacetId()),
          next: facetClearAll()
        })
      );
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(
        executeSearch2({
          legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
        })
      );
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    showMoreValues() {
      coreController.showMoreValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowMore(getFacetId()) }));
    },
    showLessValues() {
      coreController.showLessValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowLess(getFacetId()) }));
    },
    get state() {
      return {
        ...coreController.state,
        facetSearch: facetSearch2.state
      };
    }
  };
}
function loadFacetReducers2(engine) {
  engine.addReducers({ facetSet: facetSetReducer, configuration, facetSearchSet: specificFacetSearchSetReducer, search: searchReducer });
  return true;
}

// src/ssr/search/controllers/facets/facet/headless-facet.ssr.ts
function defineFacet(props) {
  return {
    build: (engine) => buildFacet(engine, props)
  };
}

// src/features/facets/range-facets/generic/range-facet-utils.ts
var isRangeFacetValueSelected = (selection) => {
  return selection.state === "selected";
};
var isRangeFacetValueExcluded = (selection) => {
  return selection.state === "excluded";
};
var getLegacyAnalyticsActionForToggleRangeFacetSelect = (facetId2, selection) => {
  const facetValue = `${selection.start}..${selection.end}`;
  const payload = { facetId: facetId2, facetValue };
  return isRangeFacetValueSelected(selection) ? logFacetDeselect(payload) : logFacetSelect(payload);
};
var getAnalyticsActionForToggleFacetSelect2 = (selection) => {
  return isRangeFacetValueSelected(selection) ? facetDeselect() : facetSelect();
};
var getLegacyAnalyticsActionForToggleRangeFacetExclude = (facetId2, selection) => {
  const facetValue = `${selection.start}..${selection.end}`;
  const payload = { facetId: facetId2, facetValue };
  return isRangeFacetValueExcluded(selection) ? logFacetUnexclude(payload) : logFacetExclude(payload);
};

// src/features/facets/range-facets/date-facet-set/date-facet-controller-actions.ts
var import_bueno68 = require("@coveo/bueno");
var import_toolkit76 = require("@reduxjs/toolkit");

// src/features/facets/range-facets/generic/range-facet-controller-actions.ts
var import_toolkit75 = require("@reduxjs/toolkit");
var executeToggleRangeFacetSelect = (0, import_toolkit75.createAction)(
  "rangeFacet/executeToggleSelect",
  (payload) => validatePayload(
    payload,
    rangeFacetSelectionPayloadDefinition(payload.selection)
  )
);
var executeToggleRangeFacetExclude = (0, import_toolkit75.createAction)(
  "rangeFacet/executeToggleExclude",
  (payload) => validatePayload(
    payload,
    rangeFacetSelectionPayloadDefinition(payload.selection)
  )
);

// src/features/facets/range-facets/date-facet-set/date-facet-controller-actions.ts
var definition2 = {
  facetId: facetIdDefinition,
  selection: new import_bueno68.RecordValue({ values: dateFacetValueDefinition })
};
var executeToggleDateFacetSelect = (0, import_toolkit76.createAsyncThunk)(
  "dateFacet/executeToggleSelect",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition2);
    dispatch(toggleSelectDateFacetValue(payload));
    dispatch(executeToggleRangeFacetSelect(payload));
    dispatch(updateFacetOptions());
  }
);
var executeToggleDateFacetExclude = (0, import_toolkit76.createAsyncThunk)(
  "dateFacet/executeToggleExclude",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition2);
    dispatch(toggleExcludeDateFacetValue(payload));
    dispatch(executeToggleRangeFacetExclude(payload));
    dispatch(updateFacetOptions());
  }
);

// src/controllers/core/facets/range-facet/core-range-facet-utils.ts
function assertRangeFacetOptions(options, controllerName) {
  if (!options.generateAutomaticRanges && options.currentValues === void 0) {
    const message = `currentValues should be specified for ${controllerName} when generateAutomaticRanges is false.`;
    throw new Error(message);
  }
}

// src/controllers/core/facets/range-facet/headless-core-range-facet.ts
function buildCoreRangeFacet(engine, props) {
  const { facetId: facetId2, getRequest } = props;
  const controller = buildController(engine);
  const dispatch = engine.dispatch;
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    isValueSelected: isRangeFacetValueSelected,
    isValueExcluded: isRangeFacetValueExcluded,
    deselectAll() {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateRangeFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = baseFacetResponseSelector(engine.state, facetId2);
      const sortCriterion = request.sortCriteria;
      const resultsMustMatch = request.resultsMustMatch;
      const values = response ? response.values : [];
      const isLoading = isFacetLoadingResponseSelector(engine.state);
      const enabled = getIsEnabled();
      const hasActiveValues = values.some(
        (facetValue) => facetValue.state !== "idle"
      );
      const domain = response?.domain;
      return {
        facetId: facetId2,
        values,
        sortCriterion,
        resultsMustMatch,
        hasActiveValues,
        isLoading,
        enabled,
        domain
      };
    }
  };
}

// src/controllers/core/facets/range-facet/date-facet/headless-date-facet-options.ts
var import_bueno69 = require("@coveo/bueno");

// src/features/facets/facet-api/value.ts
var facetValueStates = [
  "idle",
  "selected",
  "excluded"
];

// src/features/facets/range-facets/generic/interfaces/request.ts
var rangeFacetSortCriteria = [
  "ascending",
  "descending"
];
var rangeFacetRangeAlgorithm = [
  "even",
  "equiprobable"
];

// src/controllers/core/facets/range-facet/date-facet/headless-date-facet-options.ts
var dateRangeRequestDefinition2 = {
  start: new import_bueno69.StringValue(),
  end: new import_bueno69.StringValue(),
  endInclusive: new import_bueno69.BooleanValue(),
  state: new import_bueno69.StringValue({ constrainTo: facetValueStates })
};
var dateFacetOptionsSchema = new import_bueno69.Schema({
  facetId,
  field,
  tabs: new import_bueno69.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno69.ArrayValue({ each: new import_bueno69.StringValue() }),
      excluded: new import_bueno69.ArrayValue({ each: new import_bueno69.StringValue() })
    }
  }),
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new import_bueno69.ArrayValue({
    each: new import_bueno69.RecordValue({ values: dateRangeRequestDefinition2 })
  }),
  sortCriteria: new import_bueno69.StringValue({ constrainTo: rangeFacetSortCriteria }),
  rangeAlgorithm: new import_bueno69.StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});
function validateDateFacetOptions(engine, options) {
  validateOptions(engine, dateFacetOptionsSchema, options, "buildDateFacet");
  validateManualDateRanges(options);
}

// src/controllers/core/facets/range-facet/date-facet/headless-core-date-facet.ts
function buildCoreDateFacet(engine, props) {
  if (!loadDateFacetReducers(engine)) {
    throw loadReducerError;
  }
  assertRangeFacetOptions(props.options, "buildDateFacet");
  const dispatch = engine.dispatch;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    currentValues: [],
    ...props.options,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateDateFacetOptions(engine, options);
  dispatch(registerDateFacet(options));
  const rangeFacet = buildCoreRangeFacet(
    engine,
    {
      facetId: facetId2,
      getRequest: () => engine.state.dateFacetSet[facetId2].request
    }
  );
  return {
    ...rangeFacet,
    toggleSelect: (selection) => dispatch(executeToggleDateFacetSelect({ facetId: facetId2, selection })),
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    toggleExclude: (selection) => dispatch(executeToggleDateFacetExclude({ facetId: facetId2, selection })),
    toggleSingleExclude: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleExclude(selection);
    },
    get state() {
      return rangeFacet.state;
    }
  };
}
function loadDateFacetReducers(engine) {
  engine.addReducers({ configuration, search: searchReducer, dateFacetSet: dateFacetSetReducer, facetOptions: facetOptionsReducer });
  return true;
}

// src/controllers/facets/range-facet/date-facet/headless-date-facet.ts
function buildDateFacet(engine, props) {
  const coreController = buildCoreDateFacet(engine, props);
  const dispatch = engine.dispatch;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    deselectAll() {
      coreController.deselectAll();
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(getFacetId()),
          next: facetClearAll()
        })
      );
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(
        executeSearch2({
          legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
        })
      );
    },
    toggleSelect: (selection) => {
      coreController.toggleSelect(selection);
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggleRangeFacetSelect(
            getFacetId(),
            selection
          ),
          next: getAnalyticsActionForToggleFacetSelect2(selection)
        })
      );
    },
    toggleExclude: (selection) => {
      coreController.toggleExclude(selection);
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggleRangeFacetExclude(
            getFacetId(),
            selection
          )
        })
      );
    },
    get state() {
      return coreController.state;
    }
  };
}

// src/ssr/search/controllers/facets/range-facet/date-facet/headless-date-facet.ssr.ts
function defineDateFacet(props) {
  return {
    build: (engine) => buildDateFacet(engine, props)
  };
}

// src/controllers/core/facets/range-facet/date-facet/headless-core-date-filter.ts
function buildCoreDateFilter(engine, props) {
  if (!loadDateFilterReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    ...props.options,
    currentValues: props.initialState?.range ? [{ ...props.initialState.range, endInclusive: true, state: "selected" }] : [],
    generateAutomaticRanges: false,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateDateFacetOptions(engine, options);
  dispatch(registerDateFacet(options));
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    clear: () => {
      dispatch(
        updateDateFacetValues({
          facetId: facetId2,
          values: []
        })
      );
      dispatch(updateFacetOptions());
    },
    setRange: (range) => {
      const facetValue = {
        ...range,
        state: "selected",
        numberOfResults: 0,
        endInclusive: true
      };
      const updateFacetValuesAction = updateDateFacetValues({
        facetId: facetId2,
        values: [facetValue]
      });
      if (updateFacetValuesAction.error) {
        return false;
      }
      dispatch(updateFacetValuesAction);
      dispatch(updateFacetOptions());
      return true;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const isLoading = isFacetLoadingResponseSelector(getState());
      const enabled = getIsEnabled();
      const selectedRanges = dateFacetSelectedValuesSelector(
        getState(),
        facetId2
      );
      const range = selectedRanges.length ? selectedRanges[0] : void 0;
      return {
        facetId: facetId2,
        isLoading,
        range,
        enabled
      };
    }
  };
}
function loadDateFilterReducer(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}

// src/controllers/facets/range-facet/date-facet/headless-date-filter.ts
function buildDateFilter(engine, props) {
  if (!loadDateFilterReducer2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreDateFilter(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    clear: () => {
      coreController.clear();
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(getFacetId()),
          next: facetClearAll()
        })
      );
    },
    setRange: (range) => {
      const success = coreController.setRange(range);
      if (success) {
        dispatch(
          executeSearch2({
            legacy: logFacetSelect({
              facetId: getFacetId(),
              facetValue: `${range.start}..${range.end}`
            }),
            next: facetSelect()
          })
        );
      }
      return success;
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadDateFilterReducer2(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// src/ssr/search/controllers/facets/range-facet/date-facet/headless-date-filter.ssr.ts
function defineDateFilter(props) {
  return {
    build: (engine) => buildDateFilter(engine, props)
  };
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-controller-actions.ts
var import_bueno70 = require("@coveo/bueno");
var import_toolkit77 = require("@reduxjs/toolkit");
var definition3 = {
  facetId: facetIdDefinition,
  selection: new import_bueno70.RecordValue({ values: numericFacetValueDefinition })
};
var executeToggleNumericFacetSelect = (0, import_toolkit77.createAsyncThunk)(
  "numericFacet/executeToggleSelect",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition3);
    dispatch(toggleSelectNumericFacetValue(payload));
    dispatch(executeToggleRangeFacetSelect(payload));
    dispatch(updateFacetOptions());
  }
);
var executeToggleNumericFacetExclude = (0, import_toolkit77.createAsyncThunk)(
  "numericFacet/executeToggleExclude",
  (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
    validatePayload2(payload, definition3);
    dispatch(toggleExcludeNumericFacetValue(payload));
    dispatch(executeToggleRangeFacetExclude(payload));
    dispatch(updateFacetOptions());
  }
);

// src/controllers/core/facets/range-facet/numeric-facet/headless-numeric-facet-options.ts
var import_bueno71 = require("@coveo/bueno");
var numericRangeRequestDefinition = {
  start: new import_bueno71.NumberValue(),
  end: new import_bueno71.NumberValue(),
  endInclusive: new import_bueno71.BooleanValue(),
  state: new import_bueno71.StringValue({ constrainTo: facetValueStates })
};
var numericFacetOptionsSchema = new import_bueno71.Schema({
  facetId,
  tabs: new import_bueno71.RecordValue({
    options: {
      required: false
    },
    values: {
      included: new import_bueno71.ArrayValue({ each: new import_bueno71.StringValue() }),
      excluded: new import_bueno71.ArrayValue({ each: new import_bueno71.StringValue() })
    }
  }),
  field,
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new import_bueno71.ArrayValue({
    each: new import_bueno71.RecordValue({ values: numericRangeRequestDefinition })
  }),
  sortCriteria: new import_bueno71.StringValue({ constrainTo: rangeFacetSortCriteria }),
  resultsMustMatch: new import_bueno71.StringValue({ constrainTo: facetResultsMustMatch }),
  rangeAlgorithm: new import_bueno71.StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});
function validateNumericFacetOptions(engine, options) {
  validateOptions(
    engine,
    numericFacetOptionsSchema,
    options,
    "buildNumericFacet"
  );
  validateManualNumericRanges(options);
}

// src/controllers/core/facets/range-facet/numeric-facet/numeric-range.ts
function buildNumericRange(config) {
  return {
    endInclusive: false,
    state: "idle",
    ...config
  };
}

// src/controllers/core/facets/range-facet/numeric-facet/headless-core-numeric-facet.ts
function buildCoreNumericFacet(engine, props) {
  if (!loadNumericFacetReducers(engine)) {
    throw loadReducerError;
  }
  assertRangeFacetOptions(props.options, "buildNumericFacet");
  const dispatch = engine.dispatch;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    currentValues: [],
    ...props.options,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateNumericFacetOptions(engine, options);
  dispatch(registerNumericFacet(options));
  const rangeFacet = buildCoreRangeFacet(engine, {
    facetId: facetId2,
    getRequest: () => engine.state.numericFacetSet[facetId2].request
  });
  return {
    ...rangeFacet,
    toggleSelect: (selection) => dispatch(executeToggleNumericFacetSelect({ facetId: facetId2, selection })),
    toggleSingleSelect(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    get state() {
      return rangeFacet.state;
    }
  };
}
function loadNumericFacetReducers(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}

// src/controllers/facets/range-facet/numeric-facet/headless-numeric-facet.ts
function buildNumericFacet(engine, props) {
  if (!loadNumericFacetReducers2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreNumericFacet(engine, props);
  const dispatch = engine.dispatch;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    deselectAll() {
      coreController.deselectAll();
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(getFacetId()),
          next: facetClearAll()
        })
      );
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(
        executeSearch2({
          legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
        })
      );
    },
    toggleSelect: (selection) => {
      coreController.toggleSelect(selection);
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggleRangeFacetSelect(
            getFacetId(),
            selection
          ),
          next: getAnalyticsActionForToggleFacetSelect2(selection)
        })
      );
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadNumericFacetReducers2(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// src/ssr/search/controllers/facets/range-facet/numeric-facet/headless-numeric-facet.ssr.ts
function defineNumericFacet(props) {
  return {
    build: (engine) => buildNumericFacet(engine, props)
  };
}

// src/controllers/core/facets/range-facet/numeric-facet/headless-core-numeric-filter.ts
function buildCoreNumericFilter(engine, props) {
  if (!loadNumericFilterReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    ...props.options,
    currentValues: props.initialState?.range ? [{ ...props.initialState.range, endInclusive: true, state: "selected" }] : [],
    generateAutomaticRanges: false,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateNumericFacetOptions(engine, options);
  dispatch(registerNumericFacet(options));
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    clear: () => {
      dispatch(
        updateNumericFacetValues({
          facetId: facetId2,
          values: []
        })
      );
      dispatch(updateFacetOptions());
    },
    setRange: (range) => {
      const facetValue = {
        ...range,
        state: "selected",
        numberOfResults: 0,
        endInclusive: true
      };
      const updateFacetValuesAction = updateNumericFacetValues({
        facetId: facetId2,
        values: [facetValue]
      });
      if (updateFacetValuesAction.error) {
        return false;
      }
      dispatch(updateFacetValuesAction);
      dispatch(updateFacetOptions());
      return true;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const isLoading = isFacetLoadingResponseSelector(getState());
      const enabled = getIsEnabled();
      const selectedRanges = numericFacetSelectedValuesSelector(
        getState(),
        facetId2
      );
      const range = selectedRanges.length ? selectedRanges[0] : void 0;
      return {
        facetId: facetId2,
        isLoading,
        range,
        enabled
      };
    }
  };
}
function loadNumericFilterReducer(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}

// src/controllers/facets/range-facet/numeric-facet/headless-numeric-filter.ts
function buildNumericFilter(engine, props) {
  if (!loadNumericFilterReducer2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreNumericFilter(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    clear: () => {
      coreController.clear();
      dispatch(
        executeSearch2({
          legacy: logFacetClearAll(getFacetId()),
          next: facetClearAll()
        })
      );
    },
    setRange: (range) => {
      const success = coreController.setRange(range);
      if (success) {
        dispatch(
          executeSearch2({
            legacy: logFacetSelect({
              facetId: getFacetId(),
              facetValue: `${range.start}..${range.end}`
            }),
            next: facetSelect()
          })
        );
      }
      return success;
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadNumericFilterReducer2(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// src/ssr/search/controllers/facets/range-facet/numeric-facet/headless-numeric-filter.ssr.ts
function defineNumericFilter(props) {
  return {
    build: (engine) => buildNumericFilter(engine, props)
  };
}

// src/controllers/field-suggestions/category-facet/headless-category-field-suggestions.ts
function buildCategoryFieldSuggestions(engine, props) {
  if (!loadCategoryFieldSuggestionsReducers(engine)) {
    throw loadReducerError;
  }
  const { facetSearch: facetSearchOptions, ...facetOptions } = props.options.facet;
  const facetId2 = determineFacetId(engine, facetOptions);
  engine.dispatch(
    registerCategoryFacet({
      ...defaultCategoryFacetOptions,
      ...facetOptions,
      facetId: facetId2
    })
  );
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: { ...facetSearchOptions, facetId: facetId2 },
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest,
    select: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(
        executeSearch2({
          legacy: logFacetSelect({ facetId: facetId2, facetValue: value.rawValue }),
          next: facetSelect()
        })
      );
    },
    isForFieldSuggestions: true
  });
  const controller = buildController(engine);
  return {
    ...controller,
    ...facetSearch2,
    updateText: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    get state() {
      return facetSearch2.state;
    }
  };
}
function loadCategoryFieldSuggestionsReducers(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    configuration,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    search: searchReducer
  });
  return true;
}

// src/ssr/search/controllers/field-suggestions/category-facet/headless-category-field-suggestions.ssr.ts
function defineCategoryFieldSuggestions(props) {
  return {
    build: (engine) => buildCategoryFieldSuggestions(engine, props)
  };
}

// src/controllers/field-suggestions/facet/headless-field-suggestions.ts
function buildFieldSuggestions(engine, props) {
  if (!loadFieldSuggestionsReducers(engine)) {
    throw loadReducerError;
  }
  const {
    facetSearch: facetSearchOptions,
    allowedValues: allowedValues2,
    ...facetOptions
  } = props.options.facet;
  const facetId2 = determineFacetId(engine, facetOptions);
  engine.dispatch(
    registerFacet({
      ...defaultFacetOptions,
      ...facetOptions,
      facetId: facetId2,
      ...allowedValues2 && {
        allowedValues: {
          type: "simple",
          values: allowedValues2
        }
      }
    })
  );
  const facetSearch2 = buildFacetSearch(engine, {
    options: { ...facetSearchOptions, facetId: facetId2 },
    select: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(
        executeSearch2({
          legacy: logFacetSelect({ facetId: facetId2, facetValue: value.rawValue }),
          next: facetSelect()
        })
      );
    },
    exclude: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(
        executeSearch2({
          legacy: logFacetExclude({ facetId: facetId2, facetValue: value.rawValue }),
          next: facetExclude()
        })
      );
    },
    isForFieldSuggestions: true,
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest
  });
  const controller = buildController(engine);
  return {
    ...controller,
    ...facetSearch2,
    updateText: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    get state() {
      return facetSearch2.state;
    }
  };
}
function loadFieldSuggestionsReducers(engine) {
  engine.addReducers({ facetSet: facetSetReducer, configuration, facetSearchSet: specificFacetSearchSetReducer, search: searchReducer });
  return true;
}

// src/ssr/search/controllers/field-suggestions/facet/headless-field-suggestions.ssr.ts
function defineFieldSuggestions(props) {
  return {
    build: (engine) => buildFieldSuggestions(engine, props)
  };
}

// src/features/folding/folding-actions.ts
var import_bueno72 = require("@coveo/bueno");
var import_toolkit78 = require("@reduxjs/toolkit");
var foldingOptionsSchemaDefinition = {
  collectionField: new import_bueno72.StringValue({ emptyAllowed: false, required: false }),
  parentField: new import_bueno72.StringValue({ emptyAllowed: false, required: false }),
  childField: new import_bueno72.StringValue({ emptyAllowed: false, required: false }),
  numberOfFoldedResults: new import_bueno72.NumberValue({ min: 0, required: false })
};
var registerFolding = (0, import_toolkit78.createAction)(
  "folding/register",
  (payload) => validatePayload(payload, foldingOptionsSchemaDefinition)
);
var loadCollection = (0, import_toolkit78.createAsyncThunk)(
  "folding/loadCollection",
  async (collectionId, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const sharedWithSearchRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest2(state) : buildSearchAndFoldingLoadCollectionRequest(state, navigatorContext);
    const response = await apiClient.search(
      {
        ...sharedWithSearchRequest,
        q: getQForHighlighting(state),
        enableQuerySyntax: true,
        cq: `@${state.folding.fields.collection}="${collectionId}"`,
        filterField: state.folding.fields.collection,
        childField: state.folding.fields.parent,
        parentField: state.folding.fields.child,
        filterFieldRange: 100
      },
      { origin: "foldingCollection" }
    );
    if (isErrorResponse(response)) {
      return rejectWithValue(response.error);
    }
    return {
      collectionId,
      results: response.success.results,
      searchUid: response.success.searchUid,
      rootResult: state.folding.collections[collectionId].result
    };
  }
);
function getQForHighlighting(state) {
  if (state.query.q === "") {
    return "";
  }
  return state.query.enableQuerySyntax ? `${state.query.q} OR @uri` : `( <@- ${state.query.q} -@> ) OR @uri`;
}

// src/features/folding/folding-analytics-actions.ts
var logShowMoreFoldedResults = (result) => makeAnalyticsAction("analytics/folding/showMore", (client, state) => {
  validateResultPayload(result);
  return client.makeShowMoreFoldedResults(
    partialDocumentInformation(result, state),
    documentIdentifier(result)
  );
});
var logShowLessFoldedResults = () => makeAnalyticsAction("analytics/folding/showLess", (client) => {
  return client.makeShowLessFoldedResults();
});
var foldedResultAnalyticsClient = {
  logShowMoreFoldedResults,
  logShowLessFoldedResults
};

// src/controllers/core/folded-result-list/headless-core-folded-result-list.ts
var import_bueno75 = require("@coveo/bueno");

// src/features/folding/folding-slice.ts
var import_toolkit79 = require("@reduxjs/toolkit");

// src/features/folding/folding-state.ts
var getFoldingInitialState = () => ({
  enabled: false,
  fields: {
    collection: "foldingcollection",
    parent: "foldingparent",
    child: "foldingchild"
  },
  filterFieldRange: 2,
  collections: {}
});

// src/features/folding/folding-slice.ts
function getCollectionField(result, fields) {
  return result.raw[fields.collection];
}
function getParentField(result, fields) {
  return result.raw[fields.parent];
}
function getChildField(result, fields) {
  const rawValue = result.raw[fields.child];
  if (isArray(rawValue)) {
    return rawValue[0];
  }
  return rawValue;
}
function areDefinedAndEqual(value1, value2) {
  return (value1 || value2) !== void 0 && value1 === value2;
}
function resolveChildrenFromFields(parent, results, fields, resolvedAncestors = []) {
  const sourceChildValue = getChildField(parent, fields);
  if (!sourceChildValue) {
    return [];
  }
  if (resolvedAncestors.indexOf(sourceChildValue) !== -1) {
    return [];
  }
  return results.filter((result) => {
    const isSameResultAsSource = getChildField(result, fields) === getChildField(parent, fields);
    const isChildOfSource = getParentField(result, fields) === sourceChildValue;
    return isChildOfSource && !isSameResultAsSource;
  }).map((result) => {
    const extendedResult = { ...result, searchUid: parent.searchUid };
    return {
      result: extendedResult,
      children: resolveChildrenFromFields(extendedResult, results, fields, [
        ...resolvedAncestors,
        sourceChildValue
      ])
    };
  });
}
function resolveRootFromFields(results, fields) {
  return results.find((result) => {
    const hasNoParent = getParentField(result, fields) === void 0;
    const isParentOfItself = areDefinedAndEqual(
      getParentField(result, fields),
      getChildField(result, fields)
    );
    return hasNoParent || isParentOfItself;
  });
}
function resolveRootFromParentResult(result) {
  if (result.parentResult) {
    return resolveRootFromParentResult(result.parentResult);
  }
  return result;
}
function createCollectionFromResult(relevantResult, fields, searchUid, rootResult) {
  const resultsInCollection = getAllIncludedResultsFrom(relevantResult);
  const resultToUseAsRoot = rootResult ?? resolveRootFromFields(resultsInCollection, fields) ?? resolveRootFromParentResult(relevantResult);
  const extendedResultToUseAsRoot = { ...resultToUseAsRoot, searchUid };
  return {
    result: extendedResultToUseAsRoot,
    children: resolveChildrenFromFields(
      extendedResultToUseAsRoot,
      resultsInCollection,
      fields
    ),
    // To understand why "1" instead of "0", see here : https://coveord.atlassian.net/browse/SEARCHAPI-11075. totalNumberOfChildResults is off by 1 by the index design.
    moreResultsAvailable: relevantResult.totalNumberOfChildResults > 1,
    isLoadingMoreResults: false
  };
}
function createCollections(results, fields, searchUid, rootResult) {
  const collections = {};
  results.forEach((result) => {
    const collectionId = getCollectionField(result, fields);
    if (!collectionId) {
      return;
    }
    if (!getChildField(result, fields) && !result.parentResult) {
      return;
    }
    collections[collectionId] = createCollectionFromResult(
      result,
      fields,
      searchUid,
      rootResult
    );
  });
  return collections;
}
function tryGetCollectionFromStateOrThrow(state, collectionId) {
  if (!state.collections[collectionId]) {
    throw new Error(
      `Missing collection ${collectionId} from ${Object.keys(
        state.collections
      )}: Folding most probably in an invalid state...`
    );
  }
  return state.collections[collectionId];
}
var foldingReducer = (0, import_toolkit79.createReducer)(
  getFoldingInitialState(),
  (builder) => builder.addCase(executeSearch2.fulfilled, (state, { payload }) => {
    state.collections = state.enabled ? createCollections(
      payload.response.results,
      state.fields,
      payload.response.searchUid
    ) : {};
  }).addCase(fetchPage2.fulfilled, (state, { payload }) => {
    state.collections = state.enabled ? createCollections(
      payload.response.results,
      state.fields,
      payload.response.searchUid
    ) : {};
  }).addCase(fetchMoreResults2.fulfilled, (state, { payload }) => {
    state.collections = state.enabled ? {
      ...state.collections,
      ...createCollections(
        payload.response.results,
        state.fields,
        payload.response.searchUid
      )
    } : {};
  }).addCase(
    registerFolding,
    (state, { payload }) => state.enabled ? state : {
      enabled: true,
      collections: {},
      fields: {
        collection: payload.collectionField ?? state.fields.collection,
        parent: payload.parentField ?? state.fields.parent,
        child: payload.childField ?? state.fields.child
      },
      filterFieldRange: payload.numberOfFoldedResults ?? state.filterFieldRange
    }
  ).addCase(loadCollection.pending, (state, { meta }) => {
    const collectionId = meta.arg;
    tryGetCollectionFromStateOrThrow(
      state,
      collectionId
    ).isLoadingMoreResults = true;
  }).addCase(loadCollection.rejected, (state, { meta }) => {
    const collectionId = meta.arg;
    tryGetCollectionFromStateOrThrow(
      state,
      collectionId
    ).isLoadingMoreResults = false;
  }).addCase(
    loadCollection.fulfilled,
    (state, { payload: { collectionId, results, rootResult, searchUid } }) => {
      const newCollections = createCollections(
        results,
        state.fields,
        searchUid,
        rootResult
      );
      if (!newCollections || !newCollections[collectionId]) {
        throw new Error(
          `Unable to create collection ${collectionId} from received results: ${JSON.stringify(
            results
          )}. Folding most probably in an invalid state... `
        );
      }
      state.collections[collectionId] = newCollections[collectionId];
      state.collections[collectionId].moreResultsAvailable = false;
    }
  )
);

// src/features/query/query-slice.ts
var import_toolkit81 = require("@reduxjs/toolkit");

// src/features/query-suggest/query-suggest-actions.ts
var import_bueno73 = require("@coveo/bueno");
var import_toolkit80 = require("@reduxjs/toolkit");
var idDefinition = {
  id: requiredNonEmptyString
};
var registerQuerySuggest2 = (0, import_toolkit80.createAction)(
  "querySuggest/register",
  (payload) => validatePayload(payload, {
    ...idDefinition,
    count: new import_bueno73.NumberValue({ min: 0 })
  })
);
var unregisterQuerySuggest = (0, import_toolkit80.createAction)(
  "querySuggest/unregister",
  (payload) => validatePayload(payload, idDefinition)
);
var selectQuerySuggestion2 = (0, import_toolkit80.createAction)(
  "querySuggest/selectSuggestion",
  (payload) => validatePayload(payload, {
    ...idDefinition,
    expression: requiredEmptyAllowedString
  })
);
var clearQuerySuggest2 = (0, import_toolkit80.createAction)(
  "querySuggest/clear",
  (payload) => validatePayload(payload, idDefinition)
);
var fetchQuerySuggestions2 = (0, import_toolkit80.createAsyncThunk)(
  "querySuggest/fetch",
  async (payload, {
    getState,
    rejectWithValue,
    extra: { apiClient, validatePayload: validatePayload2, navigatorContext }
  }) => {
    validatePayload2(payload, idDefinition);
    const id = payload.id;
    const request = await buildQuerySuggestRequest2(
      id,
      getState(),
      navigatorContext
    );
    const response = await apiClient.querySuggest(request);
    if (isErrorResponse(response)) {
      return rejectWithValue(response.error);
    }
    return {
      id,
      q: request.q,
      ...response.success
    };
  }
);
var buildQuerySuggestRequest2 = async (id, s, navigatorContext) => {
  return {
    accessToken: s.configuration.accessToken,
    organizationId: s.configuration.organizationId,
    url: s.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      s.configuration.organizationId,
      s.configuration.environment
    ),
    count: s.querySuggest[id].count,
    q: s.querySet[id],
    locale: s.configuration.search.locale,
    timezone: s.configuration.search.timezone,
    actionsHistory: s.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : [],
    ...s.context && { context: s.context.contextValues },
    ...s.pipeline && { pipeline: s.pipeline },
    ...s.searchHub && { searchHub: s.searchHub },
    tab: s.configuration.analytics.originLevel2,
    ...s.configuration.analytics.enabled && {
      ...s.configuration.analytics.enabled && s.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams2(
        s.configuration.analytics
      ) : fromAnalyticsStateToAnalyticsParams(
        s.configuration.analytics,
        navigatorContext
      )
    },
    ...s.configuration.search.authenticationProviders.length && {
      authentication: s.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/query/query-slice.ts
var queryReducer = (0, import_toolkit81.createReducer)(
  getQueryInitialState(),
  (builder) => builder.addCase(updateQuery, (state, action) => ({ ...state, ...action.payload })).addCase(applyDidYouMeanCorrection, (state, action) => {
    state.q = action.payload;
  }).addCase(selectQuerySuggestion2, (state, action) => {
    state.q = action.payload.expression;
  }).addCase(
    change.fulfilled,
    (state, action) => action.payload?.query ?? state
  ).addCase(restoreSearchParameters, (state, action) => {
    state.q = action.payload.q ?? state.q;
    state.enableQuerySyntax = action.payload.enableQuerySyntax ?? state.enableQuerySyntax;
  })
);

// src/controllers/core/result-list/headless-core-result-list.ts
var import_bueno74 = require("@coveo/bueno");

// src/features/fields/fields-actions.ts
var import_toolkit82 = require("@reduxjs/toolkit");
var registerFieldsToInclude = (0, import_toolkit82.createAction)(
  "fields/registerFieldsToInclude",
  (payload) => validatePayload(payload, nonEmptyStringArray)
);
var enableFetchAllFields = (0, import_toolkit82.createAction)("fields/fetchall/enable");
var disableFetchAllFields = (0, import_toolkit82.createAction)("fields/fetchall/disable");
var fetchFieldsDescription = (0, import_toolkit82.createAsyncThunk)("fields/fetchDescription", async (_, { extra, getState, rejectWithValue }) => {
  const state = getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const { apiBaseUrl } = state.configuration.search;
  const descriptions = await extra.apiClient.fieldDescriptions({
    accessToken,
    organizationId,
    url: apiBaseUrl ?? getSearchApiBaseUrl(organizationId, environment)
  });
  if (isErrorResponse(descriptions)) {
    return rejectWithValue(descriptions.error);
  }
  return descriptions.success.fields;
});

// src/features/fields/fields-slice.ts
var import_toolkit83 = require("@reduxjs/toolkit");

// src/features/fields/fields-state.ts
var MinimumFieldsToInclude = [
  "author",
  "language",
  "urihash",
  "objecttype",
  "collection",
  "source",
  "permanentid"
];
var DefaultFieldsToInclude = [
  ...MinimumFieldsToInclude,
  "date",
  "filetype",
  "parents"
];
var EcommerceDefaultFieldsToInclude = [
  ...DefaultFieldsToInclude,
  "ec_price",
  "ec_name",
  "ec_description",
  "ec_brand",
  "ec_category",
  "ec_item_group_id",
  "ec_shortdesc",
  "ec_thumbnails",
  "ec_images",
  "ec_promo_price",
  "ec_in_stock",
  "ec_rating"
];
var getFieldsInitialState = () => ({
  fieldsToInclude: MinimumFieldsToInclude,
  fetchAllFields: false,
  fieldsDescription: []
});

// src/features/fields/fields-slice.ts
var fieldsReducer = (0, import_toolkit83.createReducer)(
  getFieldsInitialState(),
  (builder) => builder.addCase(registerFieldsToInclude, (state, action) => {
    state.fieldsToInclude = [
      ...new Set(state.fieldsToInclude.concat(action.payload))
    ];
  }).addCase(enableFetchAllFields, (state) => {
    state.fetchAllFields = true;
  }).addCase(disableFetchAllFields, (state) => {
    state.fetchAllFields = false;
  }).addCase(fetchFieldsDescription.fulfilled, (state, { payload }) => {
    state.fieldsDescription = payload;
  }).addCase(registerFolding, (state, { payload }) => {
    const defaultFields = getFoldingInitialState().fields;
    state.fieldsToInclude.push(
      payload.collectionField ?? defaultFields.collection,
      payload.parentField ?? defaultFields.parent,
      payload.childField ?? defaultFields.child
    );
  })
);

// src/controllers/core/status/headless-core-status.ts
function buildCoreStatus(engine) {
  if (!loadSearchStateReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        hasError: state.search.error !== null,
        isLoading: state.search.isLoading,
        hasResults: !!state.search.results.length,
        firstSearchExecuted: firstSearchExecutedSelector(state)
      };
    }
  };
}
function loadSearchStateReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}

// src/controllers/core/result-list/headless-core-result-list.ts
var optionsSchema2 = new import_bueno74.Schema({
  fieldsToInclude: new import_bueno74.ArrayValue({
    required: false,
    each: new import_bueno74.StringValue({
      required: true,
      emptyAllowed: false
    })
  })
});
function buildCoreResultList(engine, props) {
  if (!loadResultListReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const status = buildCoreStatus(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options = validateOptions(
    engine,
    optionsSchema2,
    props?.options,
    "buildCoreResultList"
  );
  if (options.fieldsToInclude) {
    dispatch(registerFieldsToInclude(options.fieldsToInclude));
  }
  const moreResultsAvailable = () => engine.state.search.results.length < engine.state.search.response.totalCountFiltered;
  let lastFetchCompleted = 0;
  let consecutiveFetches = 0;
  const maxConsecutiveFetches = 5;
  const minDelayBetweenFetches = 200;
  let errorLogged = false;
  const triggerFetchMoreResult = async () => {
    if (engine.state.search.isLoading) {
      return;
    }
    if (!moreResultsAvailable()) {
      engine.logger.info(
        "No more results are available for the result list to fetch."
      );
      return;
    }
    const delayBetweenFetches = Date.now() - lastFetchCompleted;
    if (delayBetweenFetches < minDelayBetweenFetches) {
      consecutiveFetches++;
      if (consecutiveFetches >= maxConsecutiveFetches) {
        lastFetchCompleted = Date.now();
        !errorLogged && engine.logger.error(
          `The result list method "fetchMoreResults" execution prevented because it has been triggered consecutively ${maxConsecutiveFetches} times, with little delay. Please verify the conditions under which the function is called.`
        );
        errorLogged = true;
        return;
      }
    } else {
      consecutiveFetches = 0;
    }
    errorLogged = false;
    if (props?.fetchMoreResultsActionCreator) {
      await dispatch(props?.fetchMoreResultsActionCreator());
      lastFetchCompleted = Date.now();
    }
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...status.state,
        results: state.search.results,
        moreResultsAvailable: moreResultsAvailable(),
        searchResponseId: state.search.searchResponseId
      };
    },
    fetchMoreResults: triggerFetchMoreResult
  };
}
function loadResultListReducers(engine) {
  engine.addReducers({ search: searchReducer, configuration, fields: fieldsReducer });
  return true;
}

// src/controllers/core/folded-result-list/headless-core-folded-result-list.ts
var optionsSchema3 = new import_bueno75.Schema(
  foldingOptionsSchemaDefinition
);
function buildCoreFoldedResultList(engine, props, analyticsClient) {
  if (!loadFoldingReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildCoreResultList(engine, props);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options = props.options?.folding ? validateOptions(
    engine,
    optionsSchema3,
    props.options.folding,
    "buildFoldedResultList"
  ) : {};
  dispatch(registerFolding({ ...options }));
  return {
    ...controller,
    loadCollection: (collection) => {
      dispatch(
        props.loadCollectionActionCreator(
          collection.result.raw[engine.state.folding.fields.collection]
        )
      );
      dispatch(analyticsClient.logShowMoreFoldedResults(collection.result));
    },
    logShowMoreFoldedResults: (result) => {
      dispatch(analyticsClient.logShowMoreFoldedResults(result));
    },
    logShowLessFoldedResults: () => {
      dispatch(analyticsClient.logShowLessFoldedResults());
    },
    findResultById(collection) {
      return searchForResult(
        this.state.results,
        (r) => r.result.uniqueId === collection.result.uniqueId
      );
    },
    findResultByCollection(collection) {
      return searchForResult(
        this.state.results,
        (r) => r.result.raw.foldingcollection === collection.result.raw.foldingcollection
      );
    },
    get state() {
      const state = getState();
      return {
        ...controller.state,
        results: controller.state.results.map((result) => {
          const collectionId = result.raw[state.folding.fields.collection];
          if (!collectionId || !state.folding.collections[collectionId]) {
            return {
              result,
              moreResultsAvailable: false,
              isLoadingMoreResults: false,
              children: []
            };
          }
          return state.folding.collections[collectionId];
        })
      };
    }
  };
}
function loadFoldingReducer(engine) {
  engine.addReducers({ search: searchReducer, configuration: configurationReducer, folding: foldingReducer, query: queryReducer });
  return true;
}
function searchForResult(results, compareCb) {
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    if (compareCb(result)) {
      return result;
    }
    if (result.children.length) {
      const childResult = searchForResult(result.children, compareCb);
      if (childResult) {
        return childResult;
      }
    }
  }
  return null;
}

// src/controllers/folded-result-list/headless-folded-result-list.ts
function buildFoldedResultList(engine, props = {}) {
  const foldedResultList = buildCoreFoldedResultList(
    engine,
    {
      ...props,
      loadCollectionActionCreator: loadCollection,
      fetchMoreResultsActionCreator: fetchMoreResults2
    },
    foldedResultAnalyticsClient
  );
  return {
    ...foldedResultList,
    get state() {
      return foldedResultList.state;
    }
  };
}

// src/ssr/search/controllers/folded-result-list/headless-folded-result-list.ssr.ts
function defineFoldedResultList(props) {
  return {
    build: (engine) => buildFoldedResultList(engine, props)
  };
}

// src/controllers/history-manager/headless-history-manager.ts
var import_bueno78 = require("@coveo/bueno");

// src/features/facets/facet-order/facet-order-slice.ts
var import_toolkit86 = require("@reduxjs/toolkit");

// src/features/commerce/product-listing-parameters/product-listing-parameters-actions.ts
var import_toolkit84 = require("@reduxjs/toolkit");

// src/features/commerce/parameters/parameters-schema.ts
var import_bueno76 = require("@coveo/bueno");
var parametersDefinition = {
  f: new import_bueno76.RecordValue(),
  fExcluded: new import_bueno76.RecordValue(),
  lf: new import_bueno76.RecordValue(),
  cf: new import_bueno76.RecordValue(),
  nf: new import_bueno76.RecordValue(),
  nfExcluded: new import_bueno76.RecordValue(),
  mnf: new import_bueno76.RecordValue(),
  mnfExcluded: new import_bueno76.RecordValue(),
  df: new import_bueno76.RecordValue(),
  dfExcluded: new import_bueno76.RecordValue(),
  sortCriteria: new import_bueno76.RecordValue(),
  page: new import_bueno76.NumberValue({ min: 0 }),
  perPage: new import_bueno76.NumberValue({ min: 1 })
};

// src/features/commerce/product-listing-parameters/product-listing-parameters-actions.ts
var restoreProductListingParameters = (0, import_toolkit84.createAction)(
  "commerce/productListingParameters/restore",
  (payload) => validatePayload(payload, parametersDefinition)
);

// src/features/commerce/search-parameters/search-parameters-actions.ts
var import_toolkit85 = require("@reduxjs/toolkit");

// src/features/commerce/search-parameters/search-parameters-schema.ts
var import_bueno77 = require("@coveo/bueno");
var searchParametersDefinition2 = {
  q: new import_bueno77.StringValue(),
  ...parametersDefinition
};

// src/features/commerce/search-parameters/search-parameters-actions.ts
var restoreSearchParameters2 = (0, import_toolkit85.createAction)(
  "commerce/searchParameters/restore",
  (payload) => validatePayload(payload, searchParametersDefinition2)
);

// src/features/facets/facet-order/facet-order-slice.ts
var facetOrderReducer = (0, import_toolkit86.createReducer)(
  getFacetOrderInitialState(),
  (builder) => {
    builder.addCase(executeSearch2.fulfilled, handleQueryFulfilled).addCase(fetchProductListing.fulfilled, handleQueryFulfilled).addCase(executeSearch3.fulfilled, handleQueryFulfilled).addCase(restoreSearchParameters2, handleRestoreParameters).addCase(restoreProductListingParameters, handleRestoreParameters).addCase(change.fulfilled, (state, action) => {
      return action.payload?.facetOrder ?? state;
    }).addCase(setView, () => getFacetOrderInitialState()).addCase(setContext3, () => getFacetOrderInitialState());
  }
);
function handleQueryFulfilled(_, action) {
  return action.payload.response.facets.map(
    (facet) => facet.facetId
  );
}
function handleRestoreParameters(_, action) {
  return [
    ...Object.keys(action.payload.f ?? {}),
    ...Object.keys(action.payload.lf ?? {}),
    ...Object.keys(action.payload.nf ?? {}),
    ...Object.keys(action.payload.df ?? {}),
    ...Object.keys(action.payload.cf ?? {}),
    ...Object.keys(action.payload.mnf ?? {})
  ];
}

// src/features/history/history-analytics-actions.ts
var logNavigateForward = () => makeAnalyticsAction(
  "history/analytics/forward",
  (client) => client.makeSearchEvent("historyForward")
  // TODO: Need to create this event natively in coveo.analytics to remove cast
);
var logNavigateBackward = () => makeAnalyticsAction(
  "history/analytics/backward",
  (client) => client.makeSearchEvent("historyBackward")
  // TODO: Need to create this event natively in coveo.analytics to remove cast
);
var logNoResultsBack = () => makeAnalyticsAction(
  "history/analytics/noresultsback",
  (client) => client.makeNoResultsBack()
);

// src/features/history/history-slice.ts
var import_toolkit87 = require("@reduxjs/toolkit");

// src/app/undoable.ts
var MAX_PAST_HISTORY_ENTRY_COUNT = 10;
var makeHistory = (state) => ({
  past: [],
  present: state,
  future: []
});
var undo2 = (state) => {
  const { past, present, future } = state;
  if (!present) {
    return state;
  }
  if (past.length === 0) {
    return state;
  }
  const previous = past[past.length - 1];
  const newPast = past.slice(0, past.length - 1);
  return {
    past: newPast,
    present: previous,
    future: [present, ...future]
  };
};
var redo2 = (state) => {
  const { past, present, future } = state;
  if (!present) {
    return state;
  }
  if (future.length === 0) {
    return state;
  }
  const next = future[0];
  const newFuture = future.slice(1);
  return {
    past: [...past, present],
    present: next,
    future: newFuture
  };
};
var updateHistory = (options) => {
  const { action, state, reducer } = options;
  const { past, present } = state;
  const newPresent = reducer(present, action);
  if (!present) {
    return makeHistory(newPresent);
  }
  if (present === newPresent) {
    return state;
  }
  return {
    past: [...past, present].slice(-MAX_PAST_HISTORY_ENTRY_COUNT),
    present: newPresent,
    future: []
  };
};
var undoable = (options) => {
  const { actionTypes, reducer } = options;
  const emptyHistoryState = makeHistory();
  return (state = emptyHistoryState, action) => {
    switch (action.type) {
      case actionTypes.undo:
        return undo2(state);
      case actionTypes.redo:
        return redo2(state);
      case actionTypes.snapshot:
        return updateHistory({
          state,
          reducer,
          action
        });
      default:
        return state;
    }
  };
};

// src/utils/compare-utils.ts
var import_fast_equals = require("fast-equals");
function arrayEqual(firstArray, secondArray, isEqual2 = (first, second) => first === second) {
  return firstArray.length === secondArray.length && firstArray.findIndex((val, i) => !isEqual2(secondArray[i], val)) === -1;
}
function checkUnionEquality(set1, set2) {
  const unionSet = /* @__PURE__ */ new Set([...set1, ...set2]);
  return unionSet.size === set1.size && unionSet.size === set2.size;
}
function arrayEqualAnyOrder(firstArray, secondArray) {
  if (firstArray.length !== secondArray.length) {
    return false;
  }
  return firstArray.every(
    (firstVal) => secondArray.findIndex(
      (secondVal) => deepEqualAnyOrder(firstVal, secondVal)
    ) !== -1
  );
}
var arrayEqualStrictlyDifferentOrder = (firstArray, secondArray) => {
  const set1 = new Set(firstArray);
  const set2 = new Set(secondArray);
  if (set1.size !== set2.size) {
    return false;
  }
  if (set1.size === 1) {
    return firstArray[0] === secondArray[0];
  }
  if (checkUnionEquality(set1, set2)) {
    const arr1 = [...set1];
    const arr2 = [...set2];
    return !arr1.every((value, idx) => arr2[idx] === value);
  }
  return false;
};
var deepEqualAnyOrder = (0, import_fast_equals.createCustomEqual)({
  createCustomConfig: (config) => {
    return {
      ...config,
      areArraysEqual: arrayEqualAnyOrder
    };
  }
});

// src/features/history/history-slice.ts
var historyReducer = (0, import_toolkit87.createReducer)(
  getHistoryInitialState(),
  (builder) => {
    builder.addCase(
      snapshot,
      (state, action) => isEqual(state, action.payload) ? void 0 : action.payload
    );
  }
);
var isEqual = (current, next) => {
  return isContextEqual(current.context, next.context) && isDictionaryFieldContextEqual(
    current.dictionaryFieldContext,
    next.dictionaryFieldContext
  ) && isAdvancedSearchQueriesEqual(
    current.advancedSearchQueries,
    next.advancedSearchQueries
  ) && isTabSetEqual(current.tabSet, next.tabSet) && isStaticFilterSetEqual(current.staticFilterSet, next.staticFilterSet) && isFacetsEqual(current.facetSet, next.facetSet) && isFacetsEqual(current.dateFacetSet, next.dateFacetSet) && isFacetsEqual(current.numericFacetSet, next.numericFacetSet) && isAutomaticFacetsEqual(current.automaticFacetSet, next.automaticFacetSet) && isCategoryFacetsEqual(current.categoryFacetSet, next.categoryFacetSet) && isPaginationEqual(current.pagination, next.pagination) && isQueryEqual(current.query, next.query) && isSortEqual(current, next) && isPipelineEqual(current.pipeline, next.pipeline) && isSearchHubEqual(current.searchHub, next.searchHub) && isFacetOrderEqual(current.facetOrder, next.facetOrder) && isDebugEqual(current.debug, next.debug);
};
var isContextEqual = (current, next) => JSON.stringify(current.contextValues) === JSON.stringify(next.contextValues);
var isDictionaryFieldContextEqual = (current, next) => JSON.stringify(current.contextValues) === JSON.stringify(next.contextValues);
var isTabSetEqual = (current, next) => {
  const currentTab = findActiveTab(current);
  const nextTab = findActiveTab(next);
  return currentTab?.id === nextTab?.id;
};
var findActiveTab = (tabSet) => {
  return Object.values(tabSet).find((tab) => tab.isActive);
};
var isStaticFilterSetEqual = (current, next) => {
  for (const [id, filter] of Object.entries(next)) {
    if (!current[id]) {
      return false;
    }
    const currentValues = getActiveStaticFilterValues(current[id]);
    const nextValues = getActiveStaticFilterValues(filter);
    if (JSON.stringify(currentValues) !== JSON.stringify(nextValues)) {
      return false;
    }
  }
  return true;
};
var getActiveStaticFilterValues = (filter) => {
  return filter.values.filter((value) => value.state !== "idle");
};
var isFacetsEqual = (current, next) => {
  for (const [key, value] of Object.entries(next)) {
    if (!current[key]) {
      return false;
    }
    const currentSelectedValues = current[key].request.currentValues.filter((value2) => value2.state !== "idle");
    const nextSelectedValues = value.request.currentValues.filter((value2) => value2.state !== "idle");
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
var isCategoryFacetsEqual = (current, next) => {
  for (const [key, value] of Object.entries(next)) {
    if (!current[key]) {
      return false;
    }
    const currentSelectedValues = findActiveValueAncestry(
      current[key]?.request.currentValues
    ).map(({ value: value2 }) => value2);
    const nextSelectedValues = findActiveValueAncestry(
      value?.request.currentValues
    ).map(({ value: value2 }) => value2);
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
var isAutomaticFacetsEqual = (current, next) => {
  for (const [key, value] of Object.entries(next.set)) {
    if (!current.set[key]) {
      return false;
    }
    const currentSelectedValues = current.set[key].response.values.filter((value2) => value2.state !== "idle");
    const nextSelectedValues = value.response.values.filter(
      (value2) => value2.state !== "idle"
    );
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
var isPaginationEqual = (current, next) => current.firstResult === next.firstResult && current.numberOfResults === next.numberOfResults;
var isQueryEqual = (current, next) => JSON.stringify(current) === JSON.stringify(next);
var isAdvancedSearchQueriesEqual = (current, next) => JSON.stringify(current) === JSON.stringify(next);
var isSortEqual = (current, next) => current.sortCriteria === next.sortCriteria;
var isPipelineEqual = (current, next) => current === next;
var isSearchHubEqual = (current, next) => current === next;
var isFacetOrderEqual = (current, next) => arrayEqual(current, next);
var isDebugEqual = (current, next) => current === next;
var history = undoable({
  actionTypes: {
    redo: redo.type,
    undo: undo.type,
    snapshot: snapshot.type
  },
  reducer: historyReducer
});

// src/controllers/history-manager/headless-history-manager.ts
function buildHistoryManager(engine) {
  if (!loadHistoryManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const canGoBack = (state) => {
    return state.past.length > 0 && !(0, import_bueno78.isNullOrUndefined)(state.present);
  };
  return {
    ...controller,
    // TODO: https://coveord.atlassian.net/browse/KIT-2969:
    // Should be able to get rid of this local optimization following history management change
    subscribe(listener) {
      listener();
      let previous = JSON.stringify(getState().history.present);
      const strictListener = () => {
        const current = JSON.stringify(getState().history.present);
        const hasChanged = previous !== current;
        if (hasChanged) {
          previous = current;
          listener();
        }
      };
      return engine.subscribe(() => strictListener());
    },
    get state() {
      return getState().history;
    },
    async back() {
      if (!canGoBack(this.state)) {
        return;
      }
      await dispatch(back());
      dispatch(
        executeSearch2({
          legacy: logNavigateBackward()
        })
      );
    },
    async forward() {
      if (!this.state.future.length || !this.state.present) {
        return;
      }
      await dispatch(forward());
      dispatch(
        executeSearch2({
          legacy: logNavigateForward()
        })
      );
    },
    async backOnNoResults() {
      if (!canGoBack(this.state)) {
        return;
      }
      await dispatch(back());
      dispatch(
        executeSearch2({
          legacy: logNoResultsBack()
        })
      );
    }
  };
}
function loadHistoryManagerReducers(engine) {
  engine.addReducers({ history, configuration, facetOrder: facetOrderReducer });
  return true;
}

// src/ssr/search/controllers/history-manager/headless-history-manager.ssr.ts
function defineHistoryManager() {
  return {
    build: (engine) => buildHistoryManager(engine)
  };
}

// src/features/instant-items/instant-items-state.ts
function hasExpired(cached) {
  if (!cached) {
    return false;
  }
  return cached.expiresAt && Date.now() >= cached.expiresAt;
}

// src/features/instant-results/instant-results-slice.ts
var import_toolkit88 = require("@reduxjs/toolkit");

// src/features/instant-items/instant-items-slice.ts
var registerInstantItem = (payload, state) => {
  const { id } = payload;
  if (state[id]) {
    return;
  }
  state[id] = { q: "", cache: {} };
  return state;
};
var updateInstantItemQuery = (payload, state) => {
  const { q, id } = payload;
  if (!q) {
    return;
  }
  state[id].q = q;
};
var clearExpiredItems = (payload, state) => {
  const { id } = payload;
  Object.entries(state[id].cache).forEach(([q, cached]) => {
    if (hasExpired(cached)) {
      delete state[id].cache[q];
    }
  });
};
var fetchItemsPending = (payload, state, toSetEmptyIfNotFound) => {
  for (const id in state) {
    for (const query2 in state[id].cache) {
      state[id].cache[query2].isActive = false;
    }
  }
  if (!getCached(payload, state)) {
    makeEmptyCache(payload, state, toSetEmptyIfNotFound);
    return;
  }
  const cached = getCached(payload, state);
  cached.isLoading = true;
  cached.isActive = true;
  cached.error = null;
};
var fetchItemsFulfilled = (payload, state, toAddToCache) => {
  const { id, q, searchUid, cacheTimeout, totalCountFiltered, duration } = payload;
  state[id].cache[q] = {
    ...getCached(payload, state),
    ...toAddToCache,
    isActive: true,
    searchUid,
    isLoading: false,
    error: null,
    expiresAt: cacheTimeout ? cacheTimeout + Date.now() : 0,
    totalCountFiltered,
    duration
  };
};
var fetchItemsRejected = (payload, state) => {
  const { id, q, error } = payload;
  state[id].cache[q].error = error || null;
  state[id].cache[q].isLoading = false;
  state[id].cache[q].isActive = false;
};
var getCached = (payload, state) => {
  const { q, id } = payload;
  return state[id].cache[q] || null;
};
var makeEmptyCache = (payload, state, setToEmpty) => {
  const { q, id } = payload;
  state[id].cache[q] = {
    isLoading: true,
    error: null,
    expiresAt: 0,
    isActive: true,
    searchUid: "",
    totalCountFiltered: 0,
    duration: 0,
    ...setToEmpty
  };
};

// src/features/instant-results/instant-results-state.ts
function getInstantResultsInitialState() {
  return {};
}

// src/features/instant-results/instant-results-slice.ts
var instantResultsReducer = (0, import_toolkit88.createReducer)(
  getInstantResultsInitialState(),
  (builder) => {
    builder.addCase(registerInstantResults, (state, action) => {
      registerInstantItem(action.payload, state);
    });
    builder.addCase(updateInstantResultsQuery, (state, action) => {
      updateInstantItemQuery(action.payload, state);
    });
    builder.addCase(clearExpiredResults, (state, action) => {
      clearExpiredItems(action.payload, state);
    });
    builder.addCase(fetchInstantResults2.pending, (state, action) => {
      fetchItemsPending(action.meta.arg, state, { results: [] });
    });
    builder.addCase(fetchInstantResults2.fulfilled, (state, action) => {
      const results = action.payload.results.map((result) => ({
        ...result,
        searchUid: action.payload.searchUid
      }));
      fetchItemsFulfilled({ ...action.payload, ...action.meta.arg }, state, {
        results
      });
    });
    builder.addCase(fetchInstantResults2.rejected, (state, action) => {
      fetchItemsRejected(action.meta.arg, state);
    });
  }
);

// src/controllers/instant-results/instant-results-options.ts
var import_bueno79 = require("@coveo/bueno");
var instantResultsOptionDefinitions = {
  searchBoxId: nonEmptyString,
  maxResultsPerQuery: new import_bueno79.NumberValue({
    required: true,
    min: 1
  }),
  cacheTimeout: new import_bueno79.NumberValue()
};
var instantResultsOptionsSchema = new import_bueno79.Schema(instantResultsOptionDefinitions);

// src/controllers/instant-results/instant-results.ts
function buildInstantResults(engine, props) {
  if (!loadInstantResultsReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options = {
    searchBoxId: props.options.searchBoxId || randomID("instant-results-"),
    cacheTimeout: props.options.cacheTimeout || 6e4,
    maxResultsPerQuery: props.options.maxResultsPerQuery
  };
  validateOptions(
    engine,
    instantResultsOptionsSchema,
    options,
    "buildInstantResults"
  );
  const searchBoxId = options.searchBoxId;
  dispatch(registerInstantResults({ id: searchBoxId }));
  const getStateForSearchBox = () => getState().instantResults[searchBoxId];
  const getCached2 = (q) => getStateForSearchBox().cache[q];
  const getQ2 = () => getStateForSearchBox().q;
  const getResults = () => {
    const cached = getCached2(getQ2());
    if (!cached) {
      return [];
    }
    if (cached.isLoading) {
      return [];
    }
    return cached.results;
  };
  return {
    ...controller,
    updateQuery(q) {
      if (!q) {
        return;
      }
      const cached = getCached2(q);
      if (!cached || !cached.isLoading && (cached.error || hasExpired(cached))) {
        dispatch(
          fetchInstantResults2({
            id: searchBoxId,
            q,
            maxResultsPerQuery: options.maxResultsPerQuery,
            cacheTimeout: options.cacheTimeout
          })
        );
      }
      dispatch(updateInstantResultsQuery({ id: searchBoxId, q }));
    },
    clearExpired() {
      dispatch(
        clearExpiredResults({
          id: searchBoxId
        })
      );
    },
    get state() {
      const q = getQ2();
      const cached = getCached2(q);
      return {
        q,
        isLoading: cached?.isLoading || false,
        error: cached?.error || null,
        results: getResults()
      };
    }
  };
}
function loadInstantResultsReducers(engine) {
  engine.addReducers({ instantResults: instantResultsReducer });
  return true;
}

// src/ssr/search/controllers/instant-results/instant-results.ssr.ts
function defineInstantResults(props) {
  return {
    build: (engine) => buildInstantResults(engine, props)
  };
}

// src/features/pagination/pagination-slice.ts
var import_toolkit89 = require("@reduxjs/toolkit");
var paginationReducer = (0, import_toolkit89.createReducer)(
  getPaginationInitialState(),
  (builder) => {
    builder.addCase(registerNumberOfResults, (state, action) => {
      const page = determineCurrentPage(state);
      const newNumberOfResults = action.payload;
      state.defaultNumberOfResults = state.numberOfResults = newNumberOfResults;
      state.firstResult = calculateFirstResult(page, newNumberOfResults);
    }).addCase(updateNumberOfResults, (state, action) => {
      state.numberOfResults = action.payload;
      state.firstResult = 0;
    }).addCase(updateActiveTab, (state) => {
      state.firstResult = 0;
    }).addCase(registerPage, (state, action) => {
      const page = action.payload;
      state.firstResult = calculateFirstResult(page, state.numberOfResults);
    }).addCase(updatePage, (state, action) => {
      const page = action.payload;
      state.firstResult = calculateFirstResult(page, state.numberOfResults);
    }).addCase(previousPage, (state) => {
      const page = determineCurrentPage(state);
      const previousPage3 = Math.max(page - 1, minimumPage);
      state.firstResult = calculateFirstResult(
        previousPage3,
        state.numberOfResults
      );
    }).addCase(nextPage, (state) => {
      const page = determineCurrentPage(state);
      const maxPage = determineMaxPage(state);
      const nextPage3 = Math.min(page + 1, maxPage);
      state.firstResult = calculateFirstResult(
        nextPage3,
        state.numberOfResults
      );
    }).addCase(change.fulfilled, (state, action) => {
      if (action.payload) {
        state.numberOfResults = action.payload.pagination.numberOfResults;
        state.firstResult = action.payload.pagination.firstResult;
      }
    }).addCase(restoreSearchParameters, (state, action) => {
      state.firstResult = action.payload.firstResult ?? state.firstResult;
      state.numberOfResults = action.payload.numberOfResults ?? state.defaultNumberOfResults;
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const { response } = action.payload;
      state.totalCountFiltered = response.totalCountFiltered;
    }).addCase(fetchPage2.fulfilled, (state, action) => {
      const { response } = action.payload;
      state.totalCountFiltered = response.totalCountFiltered;
    }).addCase(deselectAllFacetValues, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleExcludeDateFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleExcludeFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleExcludeNumericFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(excludeFacetSearchResult, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleSelectFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(deselectAllCategoryFacetValues, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleSelectCategoryFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(selectCategoryFacetSearchResult, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleSelectDateFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleSelectNumericFacetValue, (state) => {
      handlePaginationReset(state);
    }).addCase(deselectAllBreadcrumbs, (state) => {
      handlePaginationReset(state);
    }).addCase(updateDateFacetValues, (state) => {
      handlePaginationReset(state);
    }).addCase(updateNumericFacetValues, (state) => {
      handlePaginationReset(state);
    }).addCase(selectFacetSearchResult, (state) => {
      handlePaginationReset(state);
    }).addCase(toggleSelectAutomaticFacetValue, (state) => {
      handlePaginationReset(state);
    });
  }
);
function handlePaginationReset(state) {
  state.firstResult = getPaginationInitialState().firstResult;
}
function determineCurrentPage(state) {
  const { firstResult, numberOfResults } = state;
  return calculatePage(firstResult, numberOfResults);
}
function determineMaxPage(state) {
  const { totalCountFiltered, numberOfResults } = state;
  return calculateMaxPage(totalCountFiltered, numberOfResults);
}
function calculateFirstResult(page, numberOfResults) {
  return (page - 1) * numberOfResults;
}
function calculatePage(firstResult, numberOfResults) {
  return Math.round(firstResult / numberOfResults) + 1;
}
function calculateMaxPage(totalCountFiltered, numberOfResults) {
  const totalCount = Math.min(
    totalCountFiltered,
    maximumNumberOfResultsFromIndex
  );
  return Math.ceil(totalCount / numberOfResults);
}

// src/features/pagination/pagination-selectors.ts
function firstResultSelector(state) {
  return state.pagination.firstResult;
}
function numberOfResultsSelector(state) {
  return state.pagination.numberOfResults;
}
function totalCountFilteredSelector(state) {
  return state.pagination.totalCountFiltered;
}
var currentPageSelector = (state) => {
  const firstResult = firstResultSelector(state);
  const numberOfResults = numberOfResultsSelector(state);
  return calculatePage(firstResult, numberOfResults);
};
var maxPageSelector = (state) => {
  const totalCountFiltered = totalCountFilteredSelector(state);
  const numberOfResults = numberOfResultsSelector(state);
  return calculateMaxPage(totalCountFiltered, numberOfResults);
};
var currentPagesSelector = (state, desiredNumberOfPages) => {
  const page = currentPageSelector(state);
  const maxPage = maxPageSelector(state);
  let range = buildRange(page, desiredNumberOfPages);
  range = shiftRightIfNeeded(range);
  range = shiftLeftIfNeeded(range, maxPage);
  return buildCurrentPages(range);
};
function buildRange(page, desiredNumberOfPages) {
  const isEven = desiredNumberOfPages % 2 === 0;
  const leftCapacity = Math.floor(desiredNumberOfPages / 2);
  const rightCapacity = isEven ? leftCapacity - 1 : leftCapacity;
  const start = page - leftCapacity;
  const end = page + rightCapacity;
  return { start, end };
}
function shiftRightIfNeeded(range) {
  const leftExcess = Math.max(minimumPage - range.start, 0);
  const start = range.start + leftExcess;
  const end = range.end + leftExcess;
  return { start, end };
}
function shiftLeftIfNeeded(range, maxPage) {
  const rightExcess = Math.max(range.end - maxPage, 0);
  const start = Math.max(range.start - rightExcess, minimumPage);
  const end = range.end - rightExcess;
  return { start, end };
}
function buildCurrentPages(range) {
  const currentPages = [];
  for (let counter = range.start; counter <= range.end; ++counter) {
    currentPages.push(counter);
  }
  return currentPages;
}

// src/features/pagination/pagination-analytics-actions.ts
var logPagerResize = () => makeAnalyticsAction(
  "analytics/pager/resize",
  (client, state) => client.makePagerResize({
    currentResultsPerPage: state.pagination?.numberOfResults || getPaginationInitialState().numberOfResults
  })
);
var logPageNumber = () => makeAnalyticsAction(
  "analytics/pager/number",
  (client, state) => client.makePagerNumber({
    pagerNumber: currentPageSelector(state)
  })
);
var logPageNext = () => makeAnalyticsAction(
  "analytics/pager/next",
  (client, state) => client.makePagerNext({
    pagerNumber: currentPageSelector(state)
  })
);
var logPagePrevious = () => makeAnalyticsAction(
  "analytics/pager/previous",
  (client, state) => client.makePagerPrevious({
    pagerNumber: currentPageSelector(state)
  })
);
var browseResults = () => ({
  actionCause: "browseResults" /* browseResults */
});

// src/controllers/core/pager/headless-core-pager.ts
var import_bueno80 = require("@coveo/bueno");
var optionsSchema4 = new import_bueno80.Schema({
  numberOfPages: new import_bueno80.NumberValue({ default: 5, min: 0 })
});
var initialStateSchema2 = new import_bueno80.Schema({
  page: new import_bueno80.NumberValue({ min: 1 })
});
function buildCorePager(engine, props = {}) {
  if (!loadPagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const options = validateOptions(
    engine,
    optionsSchema4,
    props.options,
    "buildPager"
  );
  const initialState = validateInitialState(
    engine,
    initialStateSchema2,
    props.initialState,
    "buildPager"
  );
  const page = initialState.page;
  if (page) {
    dispatch(registerPage(page));
  }
  const getCurrentPage = () => {
    return currentPageSelector(engine.state);
  };
  const getCurrentPages = () => {
    const { numberOfPages } = options;
    return currentPagesSelector(engine.state, numberOfPages);
  };
  const getMaxPage = () => {
    return maxPageSelector(engine.state);
  };
  return {
    ...controller,
    get state() {
      const currentPage = getCurrentPage();
      const maxPage = getMaxPage();
      const hasPreviousPage = currentPage > minimumPage && maxPage > 0;
      const hasNextPage = currentPage < maxPage;
      return {
        currentPage,
        currentPages: getCurrentPages(),
        maxPage,
        hasPreviousPage,
        hasNextPage
      };
    },
    selectPage(page2) {
      dispatch(updatePage(page2));
    },
    nextPage() {
      dispatch(nextPage());
    },
    previousPage() {
      dispatch(previousPage());
    },
    isCurrentPage(page2) {
      return page2 === this.state.currentPage;
    }
  };
}
function loadPagerReducers(engine) {
  engine.addReducers({ configuration, pagination: paginationReducer });
  return true;
}

// src/controllers/pager/headless-pager.ts
function buildPager(engine, props = {}) {
  const { dispatch } = engine;
  const pager = buildCorePager(engine, props);
  return {
    ...pager,
    get state() {
      return pager.state;
    },
    selectPage(page) {
      pager.selectPage(page);
      dispatch(fetchPage2({ legacy: logPageNumber(), next: browseResults() }));
    },
    nextPage() {
      pager.nextPage();
      dispatch(fetchPage2({ legacy: logPageNext(), next: browseResults() }));
    },
    previousPage() {
      pager.previousPage();
      dispatch(fetchPage2({ legacy: logPagePrevious(), next: browseResults() }));
    }
  };
}

// src/ssr/search/controllers/pager/headless-pager.ssr.ts
function definePager(props) {
  return {
    build: (engine) => buildPager(engine, props)
  };
}

// src/controllers/core/query-error/headless-core-query-error.ts
function buildCoreQueryError(engine) {
  if (!loadQueryErrorReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      return {
        hasError: getState().search.error !== null,
        error: getState().search.error
      };
    }
  };
}
function loadQueryErrorReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}

// src/controllers/query-error/headless-query-error.ts
function buildQueryError(engine) {
  return buildCoreQueryError(engine);
}

// src/ssr/search/controllers/query-error/headless-query-error.ssr.ts
function defineQueryError() {
  return {
    build: (engine) => buildQueryError(engine)
  };
}

// src/controllers/core/query-summary/headless-core-query-summary.ts
function buildCoreQuerySummary(engine) {
  if (!loadQuerySummaryReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const searchStatus = buildCoreStatus(engine);
  const getState = () => engine.state;
  const durationInSeconds = () => {
    const inSeconds = getState().search.duration / 1e3;
    return Math.round((inSeconds + Number.EPSILON) * 100) / 100;
  };
  return {
    ...controller,
    get state() {
      return {
        ...searchStatus.state,
        durationInMilliseconds: getState().search.duration,
        durationInSeconds: durationInSeconds(),
        firstResult: getState().pagination.firstResult + 1,
        hasDuration: getState().search.duration !== 0,
        hasQuery: getState().search.queryExecuted !== "",
        lastResult: getState().pagination.firstResult + getState().search.results.length,
        query: getState().search.queryExecuted,
        total: getState().pagination.totalCountFiltered
      };
    }
  };
}
function loadQuerySummaryReducers(engine) {
  engine.addReducers({ search: searchReducer, pagination: paginationReducer });
  return true;
}

// src/controllers/query-summary/headless-query-summary.ts
function buildQuerySummary(engine) {
  return buildCoreQuerySummary(engine);
}

// src/ssr/search/controllers/query-summary/headless-query-summary.ssr.ts
function defineQuerySummary() {
  return {
    build: (engine) => buildQuerySummary(engine)
  };
}

// src/features/result-preview/result-preview-actions.ts
var import_bueno81 = require("@coveo/bueno");
var import_toolkit90 = require("@reduxjs/toolkit");

// src/features/result-preview/result-preview-request-builder.ts
async function buildResultPreviewRequest(state, options) {
  const { search, accessToken, organizationId } = state.configuration;
  const q = state.query?.q || "";
  return {
    url: search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    accessToken,
    organizationId,
    enableNavigation: false,
    q,
    ...options,
    requestedOutputSize: options.requestedOutputSize || 0,
    ...search.authenticationProviders.length && {
      authentication: search.authenticationProviders.join(",")
    }
  };
}

// src/features/result-preview/result-preview-actions.ts
var fetchResultContent = (0, import_toolkit90.createAsyncThunk)(
  "resultPreview/fetchResultContent",
  async (options, { extra, getState, rejectWithValue }) => {
    const state = getState();
    const req = await buildResultPreviewRequest(state, options);
    const res = await extra.apiClient.html(req);
    if (isErrorResponse(res)) {
      return rejectWithValue(res.error);
    }
    return {
      content: res.success,
      uniqueId: options.uniqueId
    };
  }
);
var nextPreview = (0, import_toolkit90.createAction)("resultPreview/next");
var previousPreview = (0, import_toolkit90.createAction)("resultPreview/previous");
var preparePreviewPagination = (0, import_toolkit90.createAction)(
  "resultPreview/prepare",
  (payload) => validatePayload(payload, { results: new import_bueno81.ArrayValue({ required: true }) })
);
var MAX_GET_LENGTH = 2048;
var updateContentURL = (0, import_toolkit90.createAsyncThunk)(
  "resultPreview/updateContentURL",
  async (options, { getState, extra }) => {
    const state = getState();
    const contentURL = buildContentURL(
      await options.buildResultPreviewRequest(state, {
        uniqueId: options.uniqueId,
        requestedOutputSize: options.requestedOutputSize
      }),
      options.path
    );
    if (contentURL?.length > MAX_GET_LENGTH) {
      extra.logger.error(
        `The content URL was truncated as it exceeds the maximum allowed length of ${MAX_GET_LENGTH} characters.`
      );
    }
    return {
      contentURL
    };
  }
);

// src/features/result-preview/result-preview-analytics-actions.ts
var logDocumentQuickview = (result) => {
  return makeAnalyticsAction({
    prefix: "analytics/resultPreview/open",
    __legacy__getBuilder: (client, state) => {
      validateResultPayload(result);
      const info = partialDocumentInformation(result, state);
      const id = documentIdentifier(result);
      return client.makeDocumentQuickview(info, id);
    },
    analyticsType: "itemClick",
    analyticsPayloadBuilder: (state) => {
      const docInfo = partialDocumentInformation(result, state);
      const docId = documentIdentifier(result);
      return {
        responseId: result.searchUid ?? "",
        position: docInfo.documentPosition,
        itemMetadata: {
          uniqueFieldName: docId.contentIDKey,
          uniqueFieldValue: docId.contentIDValue,
          title: docInfo.documentTitle,
          author: docInfo.documentAuthor,
          url: docInfo.documentUrl
        }
      };
    }
  });
};

// src/features/result-preview/result-preview-slice.ts
var import_toolkit91 = require("@reduxjs/toolkit");

// src/features/result-preview/result-preview-state.ts
function getResultPreviewInitialState() {
  return {
    uniqueId: "",
    content: "",
    isLoading: false,
    position: -1,
    resultsWithPreview: []
  };
}

// src/features/result-preview/result-preview-slice.ts
var resetPreviewContentState = (state) => {
  const { content, isLoading, uniqueId, contentURL } = getResultPreviewInitialState();
  state.content = content;
  state.isLoading = isLoading;
  state.uniqueId = uniqueId;
  state.contentURL = contentURL;
};
var getUniqueIdsOfResultsWithHTMLVersion = (results) => results.filter((r) => r.hasHtmlVersion).map((r) => r.uniqueId);
var resultPreviewReducer = (0, import_toolkit91.createReducer)(
  getResultPreviewInitialState(),
  (builder) => {
    builder.addCase(fetchResultContent.pending, (state) => {
      state.isLoading = true;
    }).addCase(fetchResultContent.fulfilled, (state, action) => {
      const { content, uniqueId } = action.payload;
      state.position = state.resultsWithPreview.indexOf(uniqueId);
      state.content = content;
      state.uniqueId = uniqueId;
      state.isLoading = false;
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      resetPreviewContentState(state);
      state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(
        action.payload.response.results
      );
    }).addCase(fetchMoreResults2.fulfilled, (state, action) => {
      resetPreviewContentState(state);
      state.resultsWithPreview = state.resultsWithPreview.concat(
        getUniqueIdsOfResultsWithHTMLVersion(action.payload.response.results)
      );
    }).addCase(fetchPage2.fulfilled, resetPreviewContentState).addCase(preparePreviewPagination, (state, action) => {
      state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(
        action.payload.results
      );
    }).addCase(nextPreview, (state) => {
      if (state.isLoading) {
        return;
      }
      let newPos = state.position + 1;
      if (newPos > state.resultsWithPreview.length - 1) {
        newPos = 0;
      }
      state.position = newPos;
    }).addCase(previousPreview, (state) => {
      if (state.isLoading) {
        return;
      }
      let newPos = state.position - 1;
      if (newPos < 0) {
        newPos = state.resultsWithPreview.length - 1;
      }
      state.position = newPos;
    }).addCase(updateContentURL.fulfilled, (state, action) => {
      state.contentURL = action.payload.contentURL;
    });
  }
);

// src/controllers/core/quickview/headless-core-quickview.ts
function buildCoreQuickview(engine, props, buildResultPreviewRequest2, path, fetchResultContentCallback) {
  if (!loadQuickviewReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const controller = buildController(engine);
  const { result, maximumPreviewSize } = props.options;
  const getUniqueIdFromPosition = () => {
    const { resultsWithPreview, position } = getState().resultPreview;
    return resultsWithPreview[position];
  };
  const onFetchContent = (uniqueId) => {
    dispatch(
      updateContentURL({
        uniqueId,
        requestedOutputSize: maximumPreviewSize,
        buildResultPreviewRequest: buildResultPreviewRequest2,
        path
      })
    );
    if (!props.options.onlyContentURL) {
      dispatch(
        fetchResultContent({
          uniqueId,
          requestedOutputSize: maximumPreviewSize
        })
      );
    }
    if (fetchResultContentCallback) {
      fetchResultContentCallback();
    }
  };
  return {
    ...controller,
    fetchResultContent() {
      onFetchContent(result.uniqueId);
    },
    next() {
      dispatch(nextPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    previous() {
      dispatch(previousPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    get state() {
      const state = getState();
      const resultHasPreview = result.hasHtmlVersion;
      const preview = state.resultPreview;
      const content = result.uniqueId === preview.uniqueId ? preview.content : "";
      const isLoading = preview.isLoading;
      const contentURL = preview.contentURL;
      const currentResultUniqueId = getUniqueIdFromPosition();
      return {
        content,
        resultHasPreview,
        isLoading,
        contentURL,
        currentResultUniqueId
      };
    }
  };
}
function loadQuickviewReducers(engine) {
  engine.addReducers({ configuration, resultPreview: resultPreviewReducer });
  return true;
}

// src/controllers/quickview/headless-quickview.ts
function buildQuickview(engine, props) {
  if (!loadSearchQuickviewReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getResults = () => getState().search.results;
  const fetchResultContentCallback = () => {
    engine.dispatch(logDocumentQuickview(props.options.result));
  };
  const path = "/html";
  const core = buildCoreQuickview(
    engine,
    props,
    buildResultPreviewRequest,
    path,
    fetchResultContentCallback
  );
  dispatch(preparePreviewPagination({ results: getResults() }));
  return {
    ...core,
    get state() {
      return {
        ...core.state,
        currentResult: getResults().findIndex(
          (r) => r.uniqueId === core.state.currentResultUniqueId
        ) + 1,
        totalResults: getResults().length
      };
    }
  };
}
function loadSearchQuickviewReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}

// src/ssr/search/controllers/quickview/headless-quickview.ssr.ts
function defineQuickview(props) {
  return {
    build: (engine) => buildQuickview(engine, props)
  };
}

// src/features/recent-queries/recent-queries-analytics-actions.ts
var logClearRecentQueries = () => makeAnalyticsAction("analytics/recentQueries/clear", (client) => {
  return client.makeClearRecentQueries();
});
var logRecentQueryClick = () => makeAnalyticsAction("analytics/recentQueries/click", (client) => {
  return client.makeRecentQueryClick();
});

// src/controllers/core/recent-queries-list/headless-core-recent-queries-list.ts
var import_bueno83 = require("@coveo/bueno");

// src/features/recent-queries/recent-queries-actions.ts
var import_bueno82 = require("@coveo/bueno");
var import_toolkit92 = require("@reduxjs/toolkit");
var registerRecentQueriesPayloadDefinition = {
  queries: new import_bueno82.ArrayValue({
    required: true,
    each: new import_bueno82.StringValue({ emptyAllowed: false })
  }),
  maxLength: new import_bueno82.NumberValue({ required: true, min: 1, default: 10 })
};
var registerRecentQueries = (0, import_toolkit92.createAction)(
  "recentQueries/registerRecentQueries",
  (payload) => validatePayload(payload, registerRecentQueriesPayloadDefinition)
);
var clearRecentQueries = (0, import_toolkit92.createAction)(
  "recentQueries/clearRecentQueries"
);

// src/features/recent-queries/recent-queries-slice.ts
var import_toolkit93 = require("@reduxjs/toolkit");

// src/features/recent-queries/recent-queries-state.ts
function getRecentQueriesInitialState() {
  return {
    queries: [],
    maxLength: 10
  };
}

// src/features/recent-queries/recent-queries-slice.ts
var recentQueriesReducer = (0, import_toolkit93.createReducer)(
  getRecentQueriesInitialState(),
  (builder) => {
    builder.addCase(registerRecentQueries, handleRegisterQueries).addCase(clearRecentQueries, handleClearRecentQueries).addCase(executeSearch2.fulfilled, (state, action) => {
      const query2 = action.payload.queryExecuted;
      const results = action.payload.response.results;
      if (!query2.length || !results.length) {
        return;
      }
      handleExecuteSearchFulfilled(query2, state);
    });
  }
);
function handleRegisterQueries(state, action) {
  state.queries = Array.from(
    new Set(action.payload.queries.map((query2) => query2.trim().toLowerCase()))
  ).slice(0, action.payload.maxLength);
  state.maxLength = action.payload.maxLength;
}
function handleClearRecentQueries(state) {
  state.queries = [];
}
function handleExecuteSearchFulfilled(query2, state) {
  const cleanNewQuery = query2.trim().toLowerCase();
  if (cleanNewQuery === "") {
    return;
  }
  const previousQueries = Array.from(
    new Set(
      state.queries.filter(
        (query3) => query3.trim().toLowerCase() !== cleanNewQuery
      )
    )
  ).slice(0, state.maxLength - 1);
  state.queries = [cleanNewQuery, ...previousQueries];
}

// src/controllers/core/recent-queries-list/headless-core-recent-queries-list.ts
var defaultRecentQueriesState = {
  queries: []
};
var defaultRecentQueriesOptions = {
  maxLength: 10,
  clearFilters: true
};
var initialStateSchema3 = new import_bueno83.Schema({
  queries: new import_bueno83.ArrayValue({ required: true })
});
var optionsSchema5 = new import_bueno83.Schema({
  maxLength: new import_bueno83.NumberValue({ required: true, min: 1 }),
  clearFilters: new import_bueno83.BooleanValue()
});
function validateRecentQueriesProps(engine, props) {
  validateOptions(
    engine,
    optionsSchema5,
    props?.options,
    "buildRecentQueriesList"
  );
  validateInitialState(
    engine,
    initialStateSchema3,
    props?.initialState,
    "buildRecentQueriesList"
  );
}
function buildCoreRecentQueriesList(engine, props) {
  if (!loadRecentQueriesListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const registrationOptions = {
    ...defaultRecentQueriesOptions,
    ...props?.options
  };
  const registrationState = {
    ...defaultRecentQueriesState,
    ...props?.initialState
  };
  validateRecentQueriesProps(engine, {
    options: registrationOptions,
    initialState: registrationState
  });
  const options = {
    queries: registrationState.queries,
    maxLength: registrationOptions.maxLength
  };
  dispatch(registerRecentQueries(options));
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...state.recentQueries,
        analyticsEnabled: state.configuration.analytics.enabled
      };
    },
    clear() {
      dispatch(clearRecentQueries());
    },
    updateRecentQueries(queries) {
      const errorMessage = new import_bueno83.ArrayValue({
        required: true,
        each: new import_bueno83.StringValue({ required: true }),
        min: 1
      }).validate(queries);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      dispatch(
        registerRecentQueries({
          queries,
          maxLength: registrationOptions.maxLength
        })
      );
    },
    executeRecentQuery(index) {
      const errorMessage = new import_bueno83.NumberValue({
        required: true,
        min: 0,
        max: this.state.queries.length
      }).validate(index);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      const queryOptions = {
        q: this.state.queries[index],
        clearFilters: registrationOptions.clearFilters
      };
      if ((0, import_bueno83.isBoolean)(engine.state.query?.enableQuerySyntax)) {
        queryOptions.enableQuerySyntax = engine.state.query.enableQuerySyntax;
      }
      dispatch(prepareForSearchWithQuery(queryOptions));
    }
  };
}
function loadRecentQueriesListReducer(engine) {
  engine.addReducers({ search: searchReducer, recentQueries: recentQueriesReducer, query: queryReducer });
  return true;
}

// src/controllers/recent-queries-list/headless-recent-queries-list.ts
function buildRecentQueriesList(engine, props) {
  const coreController = buildCoreRecentQueriesList(engine, props);
  const { dispatch } = engine;
  return {
    ...coreController,
    get state() {
      return coreController.state;
    },
    clear() {
      dispatch(logClearRecentQueries());
      coreController.clear();
    },
    executeRecentQuery(index) {
      coreController.executeRecentQuery(index);
      dispatch(
        executeSearch2({
          legacy: logRecentQueryClick(),
          next: { actionCause: "recentQueriesClick" /* recentQueriesClick */ }
        })
      );
    }
  };
}

// src/ssr/search/controllers/recent-queries-list/headless-recent-queries-list.ssr.ts
function defineRecentQueriesList(props) {
  return {
    build: (engine) => buildRecentQueriesList(engine, props)
  };
}

// src/controllers/recent-results-list/headless-recent-results-list.ts
var import_bueno85 = require("@coveo/bueno");

// src/features/recent-results/recent-results-actions.ts
var import_bueno84 = require("@coveo/bueno");
var import_toolkit94 = require("@reduxjs/toolkit");
var registerRecentResultsPayloadDefinition = {
  results: new import_bueno84.ArrayValue({
    required: true,
    each: new import_bueno84.RecordValue({ values: resultPartialDefinition })
  }),
  maxLength: new import_bueno84.NumberValue({ required: true, min: 1, default: 10 })
};
var registerRecentResults = (0, import_toolkit94.createAction)(
  "recentResults/registerRecentResults",
  (payload) => validatePayload(payload, registerRecentResultsPayloadDefinition)
);
var pushRecentResult = (0, import_toolkit94.createAction)(
  "recentResults/pushRecentResult",
  (payload) => {
    validateResultPayload(payload);
    return {
      payload
    };
  }
);
var clearRecentResults = (0, import_toolkit94.createAction)(
  "recentResults/clearRecentResults"
);

// src/features/recent-results/recent-results-analytics-actions.ts
var logClearRecentResults = () => makeAnalyticsAction(
  "analytics/recentResults/clear",
  (client) => client.makeClearRecentResults()
);

// src/features/recent-results/recent-results-slice.ts
var import_toolkit95 = require("@reduxjs/toolkit");

// src/features/recent-results/recent-results-state.ts
function getRecentResultsInitialState() {
  return {
    results: [],
    maxLength: 10
  };
}

// src/features/recent-results/recent-results-slice.ts
var recentResultsReducer = (0, import_toolkit95.createReducer)(
  getRecentResultsInitialState(),
  (builder) => {
    builder.addCase(registerRecentResults, (state, action) => {
      state.results = action.payload.results.slice(
        0,
        action.payload.maxLength
      );
      state.maxLength = action.payload.maxLength;
    }).addCase(clearRecentResults, (state) => {
      state.results = [];
    }).addCase(pushRecentResult, (state, action) => {
      const result = action.payload;
      state.results = state.results.filter(
        (r) => r.uniqueId !== result.uniqueId
      );
      const remaining = state.results.slice(0, state.maxLength - 1);
      state.results = [result, ...remaining];
    });
  }
);

// src/controllers/recent-results-list/headless-recent-results-list.ts
var defaultRecentResultsProps = {
  initialState: {
    results: []
  },
  options: {
    maxLength: 10
  }
};
var initialStateSchema4 = new import_bueno85.Schema({
  results: new import_bueno85.ArrayValue({ required: true })
});
var optionsSchema6 = new import_bueno85.Schema({
  maxLength: new import_bueno85.NumberValue({ required: true, min: 1 })
});
function validateRecentResultsProps(engine, props) {
  validateOptions(
    engine,
    optionsSchema6,
    props?.options,
    "buildRecentResultsList"
  );
  validateInitialState(
    engine,
    initialStateSchema4,
    props?.initialState,
    "buildRecentResultsList"
  );
}
function buildRecentResultsList(engine, props) {
  if (!loadRecentResultsListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const registrationProps = {
    ...defaultRecentResultsProps,
    ...props
  };
  validateRecentResultsProps(engine, registrationProps);
  const options = {
    results: registrationProps.initialState.results,
    maxLength: registrationProps.options.maxLength
  };
  dispatch(registerRecentResults(options));
  return {
    ...controller,
    get state() {
      return getState().recentResults;
    },
    clear() {
      dispatch(logClearRecentResults());
      dispatch(clearRecentResults());
    }
  };
}
function loadRecentResultsListReducer(engine) {
  engine.addReducers({ recentResults: recentResultsReducer });
  return true;
}

// src/ssr/search/controllers/recent-results-list/headless-recent-results-list.ssr.ts
function defineRecentResultsList(props) {
  return {
    build: (engine) => buildRecentResultsList(engine, props)
  };
}

// src/controllers/relevance-inspector/headless-relevance-inspector.ts
var import_bueno86 = require("@coveo/bueno");

// src/features/debug/ranking-info-parser.ts
var parseRankingInfo = (value) => {
  const REGEX_EXTRACT_DOCUMENT_WEIGHTS = /Document weights:\n((?:.)*?)\n+/g;
  const REGEX_EXTRACT_TERMS_WEIGHTS = /Terms weights:\n((?:.|\n)*)\n+/g;
  const REGEX_EXTRACT_TOTAL_WEIGHTS = /Total weight: ([0-9]+)/g;
  if (!value) {
    return null;
  }
  const docWeightsRegexResult = REGEX_EXTRACT_DOCUMENT_WEIGHTS.exec(value);
  const termsWeightRegexResult = REGEX_EXTRACT_TERMS_WEIGHTS.exec(value);
  const totalWeightRegexResult = REGEX_EXTRACT_TOTAL_WEIGHTS.exec(value);
  const qreWeights = parseQREWeights(value);
  const documentWeights = parseWeights(
    docWeightsRegexResult ? docWeightsRegexResult[1] : null
  );
  const termsWeight = parseTermsWeights(termsWeightRegexResult);
  const totalWeight = totalWeightRegexResult ? Number(totalWeightRegexResult[1]) : null;
  return {
    documentWeights,
    termsWeight,
    totalWeight,
    qreWeights
  };
};
var parseWeights = (value) => {
  const REGEX_EXTRACT_LIST_OF_WEIGHTS = /(\w+(?:\s\w+)*): ([-0-9]+)/g;
  const REGEX_EXTRACT_WEIGHT_GROUP = /^(\w+(?:\s\w+)*): ([-0-9]+)$/;
  if (!value) {
    return null;
  }
  const listOfWeight = value.match(REGEX_EXTRACT_LIST_OF_WEIGHTS);
  if (!listOfWeight) {
    return null;
  }
  const weights = {};
  for (const weight of listOfWeight) {
    const weightGroup = weight.match(REGEX_EXTRACT_WEIGHT_GROUP);
    if (weightGroup) {
      const weightAppliedOn = weightGroup[1];
      const weightValue = weightGroup[2];
      weights[weightAppliedOn] = Number(weightValue);
    }
  }
  return weights;
};
var matchExec = (value, regex) => {
  const results = [];
  let arr;
  while (true) {
    arr = regex.exec(value);
    if (arr === null) {
      break;
    }
    results.push(arr);
  }
  return results;
};
var parseTermsWeights = (termsWeight) => {
  const REGEX_EXTRACT_GROUP_OF_TERMS = /((?:[^:]+: [0-9]+, [0-9]+; )+)\n((?:\w+: [0-9]+; )+)/g;
  const REGEX_EXTRACT_SINGLE_TERM = /([^:]+): ([0-9]+), ([0-9]+); /g;
  if (!termsWeight || !termsWeight[1]) {
    return null;
  }
  const listOfTerms = matchExec(termsWeight[1], REGEX_EXTRACT_GROUP_OF_TERMS);
  if (!listOfTerms) {
    return null;
  }
  const terms = {};
  for (const term of listOfTerms) {
    const listOfWords = matchExec(term[1], REGEX_EXTRACT_SINGLE_TERM);
    const words = {};
    for (const word of listOfWords) {
      words[word[1]] = {
        Correlation: Number(word[2]),
        "TF-IDF": Number(word[3])
      };
    }
    const weights = parseWeights(term[2]);
    terms[Object.keys(words).join(", ")] = {
      terms: words,
      Weights: weights
    };
  }
  return terms;
};
var parseQREWeights = (value) => {
  const REGEX_EXTRACT_QRE_WEIGHTS = /(Expression:\s".*")\sScore:\s(?!0)([-0-9]+)\n+/g;
  let qreWeightsRegexResult = REGEX_EXTRACT_QRE_WEIGHTS.exec(value);
  const qreWeights = [];
  while (qreWeightsRegexResult) {
    qreWeights.push({
      expression: qreWeightsRegexResult[1],
      score: parseInt(qreWeightsRegexResult[2], 10)
    });
    qreWeightsRegexResult = REGEX_EXTRACT_QRE_WEIGHTS.exec(value);
  }
  return qreWeights;
};

// src/features/debug/debug-selectors.ts
function rankingInformationSelector(state) {
  const results = state.search.response.results;
  return results.map((result) => {
    const ranking = parseRankingInfo(result.rankingInfo);
    return {
      result,
      ranking
    };
  });
}

// src/controllers/relevance-inspector/headless-relevance-inspector.ts
var initialStateSchema5 = new import_bueno86.Schema({
  enabled: new import_bueno86.BooleanValue({ default: false })
});
function buildRelevanceInspector(engine, props = {}) {
  if (!loadRelevanceInspectorReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const initialState = validateInitialState(
    engine,
    initialStateSchema5,
    props.initialState,
    "buildRelevanceInspector"
  );
  if (initialState.enabled) {
    dispatch(enableDebug());
  }
  const warnProductionEnvironment = (flag) => {
    engine.logger.warn(
      `Flag [ ${flag} ] is now activated. This should *not* be used in any production environment as it negatively impact performance.`
    );
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      const isEnabled = state.debug;
      if (!state.debug) {
        return { isEnabled };
      }
      const {
        executionReport,
        basicExpression,
        advancedExpression,
        constantExpression,
        userIdentities,
        rankingExpressions
      } = state.search.response;
      const { fieldsDescription, fetchAllFields } = state.fields;
      return {
        isEnabled,
        rankingInformation: rankingInformationSelector(state),
        executionReport,
        expressions: {
          basicExpression,
          advancedExpression,
          constantExpression
        },
        userIdentities,
        rankingExpressions,
        fieldsDescription,
        fetchAllFields
      };
    },
    enable() {
      dispatch(enableDebug());
      warnProductionEnvironment("debug");
    },
    disable() {
      dispatch(disableDebug());
      dispatch(disableFetchAllFields());
    },
    enableFetchAllFields() {
      dispatch(enableFetchAllFields());
      warnProductionEnvironment("fetchAllFields");
    },
    disableFetchAllFields() {
      dispatch(disableFetchAllFields());
    },
    fetchFieldsDescription() {
      !this.state.isEnabled && dispatch(enableDebug());
      dispatch(fetchFieldsDescription());
      warnProductionEnvironment("fieldsDescription");
      engine.logger.warn(
        `For production environment, please specify the necessary fields either when instantiating a ResultList controller, or by dispatching a registerFieldsToInclude action.
        
        https://docs.coveo.com/en/headless/latest/reference/interfaces/Search.ResultListOptions.html
        https://docs.coveo.com/en/headless/latest/reference/interfaces/Search.FieldActionCreators.html#registerfieldstoinclude`
      );
    }
  };
}
function loadRelevanceInspectorReducers(engine) {
  engine.addReducers({
    debug: debugReducer,
    search: searchReducer,
    configuration,
    fields: fieldsReducer
  });
  return true;
}

// src/ssr/search/controllers/relevance-inspector/headless-relevance-inspector.ssr.ts
function defineRelevanceInspector(props) {
  return {
    build: (engine) => buildRelevanceInspector(engine, props)
  };
}

// src/controllers/result-list/headless-result-list.ts
function buildResultList(engine, props) {
  return buildCoreResultList(engine, {
    ...props,
    fetchMoreResultsActionCreator: fetchMoreResults2
  });
}

// src/ssr/search/controllers/result-list/headless-result-list.ssr.ts
function defineResultList(props) {
  return {
    build: (engine) => buildResultList(engine, props)
  };
}

// src/controllers/core/results-per-page/headless-core-results-per-page.ts
var import_bueno87 = require("@coveo/bueno");
var initialStateSchema6 = new import_bueno87.Schema({
  numberOfResults: new import_bueno87.NumberValue({ min: 0 })
});
function buildCoreResultsPerPage(engine, props = {}) {
  if (!loadResultsPerPageReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const validated = validateInitialState(
    engine,
    initialStateSchema6,
    props.initialState,
    "buildResultsPerPage"
  );
  const num = validated.numberOfResults;
  if (num !== void 0) {
    dispatch(registerNumberOfResults(num));
  }
  return {
    ...controller,
    get state() {
      return {
        numberOfResults: getState().pagination.numberOfResults
      };
    },
    set(num2) {
      dispatch(updateNumberOfResults(num2));
    },
    isSetTo(num2) {
      return num2 === this.state.numberOfResults;
    }
  };
}
function loadResultsPerPageReducers(engine) {
  engine.addReducers({ pagination: paginationReducer, configuration });
  return true;
}

// src/controllers/results-per-page/headless-results-per-page.ts
function buildResultsPerPage(engine, props = {}) {
  if (!loadResultsPerPageReducers2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreResultsPerPage(engine, props);
  const { dispatch } = engine;
  return {
    ...coreController,
    get state() {
      return {
        ...coreController.state
      };
    },
    set(num) {
      coreController.set(num);
      dispatch(fetchPage2({ legacy: logPagerResize(), next: browseResults() }));
    }
  };
}
function loadResultsPerPageReducers2(engine) {
  engine.addReducers({ pagination: paginationReducer, configuration });
  return true;
}

// src/ssr/search/controllers/results-per-page/headless-results-per-page.ssr.ts
function defineResultsPerPage(props) {
  return {
    build: (engine) => buildResultsPerPage(engine, props)
  };
}

// src/features/query/query-analytics-actions.ts
var logSearchboxSubmit = () => makeAnalyticsAction(
  "analytics/searchbox/submit",
  (client) => client.makeSearchboxSubmit()
);
var searchboxSubmit = () => ({
  actionCause: "searchboxSubmit" /* searchboxSubmit */
});

// src/features/query-set/query-set-actions.ts
var import_toolkit96 = require("@reduxjs/toolkit");
var querySetDefinition = {
  id: requiredNonEmptyString,
  query: requiredEmptyAllowedString
};
var registerQuerySetQuery = (0, import_toolkit96.createAction)(
  "querySet/register",
  (payload) => validatePayload(payload, querySetDefinition)
);
var updateQuerySetQuery = (0, import_toolkit96.createAction)(
  "querySet/update",
  (payload) => validatePayload(payload, querySetDefinition)
);

// src/features/query-set/query-set-slice.ts
var import_bueno88 = require("@coveo/bueno");
var import_toolkit98 = require("@reduxjs/toolkit");

// src/features/commerce/query-set/query-set-actions.ts
var import_toolkit97 = require("@reduxjs/toolkit");
var registerQuerySetQuery2 = (0, import_toolkit97.createAction)(
  "commerce/querySet/register",
  (payload) => validatePayload(payload, querySetDefinition)
);
var updateQuerySetQuery2 = (0, import_toolkit97.createAction)(
  "commerce/querySet/update",
  (payload) => validatePayload(payload, querySetDefinition)
);

// src/features/query-set/query-set-slice.ts
var querySetReducer = (0, import_toolkit98.createReducer)(
  getQuerySetInitialState(),
  (builder) => {
    builder.addCase(
      registerQuerySetQuery,
      (state, action) => registerQuery(state, action.payload)
    ).addCase(
      registerQuerySetQuery2,
      (state, action) => registerQuery(state, action.payload)
    ).addCase(updateQuerySetQuery, (state, action) => {
      const { id, query: query2 } = action.payload;
      updateQuery3(state, id, query2);
    }).addCase(updateQuerySetQuery2, (state, action) => {
      const { id, query: query2 } = action.payload;
      updateQuery3(state, id, query2);
    }).addCase(selectQuerySuggestion2, (state, action) => {
      const { id, expression } = action.payload;
      updateQuery3(state, id, expression);
    }).addCase(selectQuerySuggestion, (state, action) => {
      const { id, expression } = action.payload;
      updateQuery3(state, id, expression);
    }).addCase(executeSearch3.fulfilled, (state, action) => {
      const { queryExecuted } = action.payload;
      updateAllQuerySetQuery(state, queryExecuted);
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      const { queryExecuted } = action.payload;
      updateAllQuerySetQuery(state, queryExecuted);
    }).addCase(restoreSearchParameters, handleRestoreSearchParameters).addCase(restoreSearchParameters2, handleRestoreSearchParameters).addCase(change.fulfilled, (state, action) => {
      if (!action.payload) {
        return;
      }
      for (const [id, query2] of Object.entries(action.payload.querySet)) {
        updateQuery3(state, id, query2);
      }
    });
  }
);
function handleRestoreSearchParameters(state, action) {
  if (!(0, import_bueno88.isNullOrUndefined)(action.payload.q)) {
    updateAllQuerySetQuery(state, action.payload.q);
  }
}
function updateAllQuerySetQuery(state, query2) {
  Object.keys(state).forEach((id) => {
    state[id] = query2;
  });
}
var updateQuery3 = (state, id, query2) => {
  if (id in state) {
    state[id] = query2;
  }
};
var registerQuery = (state, actionPayload) => {
  const { id, query: query2 } = actionPayload;
  if (id in state) {
    return;
  }
  state[id] = query2;
};

// src/features/query-suggest/query-suggest-analytics-actions.ts
var logQuerySuggestionClick = (payload) => makeAnalyticsAction("analytics/querySuggest", (client, state) => {
  const metadata = buildOmniboxSuggestionMetadata(state, payload);
  return client.makeOmniboxAnalytics(metadata);
});
var omniboxAnalytics = () => ({
  actionCause: "omniboxAnalytics" /* omniboxAnalytics */
});
function buildOmniboxSuggestionMetadata(state, payload) {
  const { id, suggestion } = payload;
  const querySuggest = state.querySuggest?.[id];
  if (!querySuggest) {
    throw new Error(
      `Unable to determine the query suggest analytics metadata to send because no query suggest with id "${id}" was found. Please check the sent #id.`
    );
  }
  const suggestions = querySuggest.completions.map(
    (completion) => completion.expression
  );
  const lastIndex = querySuggest.partialQueries.length - 1;
  const partialQuery = querySuggest.partialQueries[lastIndex] || "";
  const querySuggestResponseId = querySuggest.responseId;
  return {
    suggestionRanking: suggestions.indexOf(suggestion),
    partialQuery,
    partialQueries: querySuggest.partialQueries,
    suggestions,
    querySuggestResponseId
  };
}

// src/features/query-suggest/query-suggest-slice.ts
var import_toolkit99 = require("@reduxjs/toolkit");

// src/features/query-suggest/query-suggest-state.ts
var getQuerySuggestSetInitialState = () => ({});

// src/features/query-suggest/query-suggest-slice.ts
var querySuggestReducer = (0, import_toolkit99.createReducer)(
  getQuerySuggestSetInitialState(),
  (builder) => builder.addCase(registerQuerySuggest2, (state, action) => {
    handleRegisterQuerySuggest(state, action.payload);
  }).addCase(registerQuerySuggest, (state, action) => {
    handleRegisterQuerySuggest(state, action.payload);
  }).addCase(unregisterQuerySuggest, (state, action) => {
    delete state[action.payload.id];
  }).addCase(fetchQuerySuggestions2.pending, handleFetchPending).addCase(fetchQuerySuggestions2.fulfilled, (state, action) => {
    const querySuggest = state[action.meta.arg.id];
    if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
      return;
    }
    const { q } = action.payload;
    if (q) {
      querySuggest.partialQueries.push(
        q.replace(/;/, encodeURIComponent(";"))
      );
    }
    querySuggest.responseId = action.payload.responseId;
    querySuggest.completions = action.payload.completions;
    querySuggest.isLoading = false;
    querySuggest.error = null;
  }).addCase(fetchQuerySuggestions2.rejected, handleFetchRejected).addCase(fetchQuerySuggestions.pending, handleFetchPending).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
    const querySuggest = state[action.meta.arg.id];
    if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
      return;
    }
    const { query: query2 } = action.payload;
    if (query2) {
      querySuggest.partialQueries.push(
        query2.replace(/;/, encodeURIComponent(";"))
      );
    }
    querySuggest.responseId = action.payload.responseId;
    querySuggest.completions = action.payload.completions.map(
      (completion) => ({
        expression: completion.expression,
        highlighted: completion.highlighted,
        score: 0,
        executableConfidence: 0
      })
    );
    querySuggest.isLoading = false;
    querySuggest.error = null;
  }).addCase(fetchQuerySuggestions.rejected, handleFetchRejected).addCase(clearQuerySuggest2, (state, action) => {
    handleClearQuerySuggest(state, action.payload);
  }).addCase(clearQuerySuggest, (state, action) => {
    handleClearQuerySuggest(state, action.payload);
  }).addCase(setError, (state, action) => {
    Object.keys(state).forEach((slotId) => {
      const slot = state[slotId];
      if (slot) {
        slot.error = action.payload;
        slot.isLoading = false;
      }
    });
  })
);
function handleRegisterQuerySuggest(state, payload) {
  const id = payload.id;
  if (id in state) {
    return;
  }
  state[id] = buildQuerySuggest(payload);
}
function buildQuerySuggest(config) {
  return {
    id: "",
    completions: [],
    responseId: "",
    count: 5,
    currentRequestId: "",
    error: null,
    partialQueries: [],
    isLoading: false,
    ...config
  };
}
function handleFetchPending(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.currentRequestId = action.meta.requestId;
  querySuggest.isLoading = true;
}
function handleFetchRejected(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.error = action.payload || null;
  querySuggest.isLoading = false;
}
function handleClearQuerySuggest(state, payload) {
  const querySuggest = state[payload.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.responseId = "";
  querySuggest.completions = [];
  querySuggest.partialQueries = [];
}

// src/utils/highlight.ts
var import_bueno89 = require("@coveo/bueno");
function getHighlightedSuggestion(suggestion, options) {
  suggestion = escapeHtml(suggestion);
  return suggestion.replace(
    /\[(.*?)\]|\{(.*?)\}|\((.*?)\)/g,
    (part, notMatched, matched, corrected) => {
      if (notMatched) {
        return suggestionWithDelimiters(notMatched, options.notMatchDelimiters);
      }
      if (matched) {
        return suggestionWithDelimiters(matched, options.exactMatchDelimiters);
      }
      if (corrected) {
        return suggestionWithDelimiters(
          corrected,
          options.correctionDelimiters
        );
      }
      return part;
    }
  );
}
function suggestionWithDelimiters(suggestion, delimiters) {
  if (delimiters) {
    return delimiters.open + suggestion + delimiters.close;
  }
  return suggestion;
}
function escapeHtml(str) {
  const mapOfCharToEscape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };
  const source = `(?:${Object.keys(mapOfCharToEscape).join("|")})`;
  const testRegexp = RegExp(source);
  const replaceRegexp = RegExp(source, "g");
  return testRegexp.test(str) ? str.replace(replaceRegexp, (substring) => mapOfCharToEscape[substring]) : str;
}

// src/controllers/core/search-box/headless-core-search-box-options.ts
var import_bueno90 = require("@coveo/bueno");
var defaultSearchBoxOptions = {
  enableQuerySyntax: false,
  numberOfSuggestions: 5,
  clearFilters: true
};
var openCloseDelimitersDefinition = {
  open: new import_bueno90.StringValue(),
  close: new import_bueno90.StringValue()
};
var searchBoxOptionDefinitions = {
  id: requiredNonEmptyString,
  numberOfSuggestions: new import_bueno90.NumberValue({ min: 0 }),
  enableQuerySyntax: new import_bueno90.BooleanValue(),
  highlightOptions: new import_bueno90.RecordValue({
    values: {
      notMatchDelimiters: new import_bueno90.RecordValue({
        values: openCloseDelimitersDefinition
      }),
      exactMatchDelimiters: new import_bueno90.RecordValue({
        values: openCloseDelimitersDefinition
      }),
      correctionDelimiters: new import_bueno90.RecordValue({
        values: openCloseDelimitersDefinition
      })
    }
  }),
  clearFilters: new import_bueno90.BooleanValue()
};
var searchBoxOptionsSchema = new import_bueno90.Schema(
  searchBoxOptionDefinitions
);

// src/controllers/core/search-box/headless-core-search-box.ts
function buildCoreSearchBox(engine, props) {
  if (!loadSearchBoxReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const id = props.options?.id || randomID("search_box");
  const options = {
    id,
    highlightOptions: { ...props.options?.highlightOptions },
    ...defaultSearchBoxOptions,
    ...props.options
  };
  validateOptions(engine, searchBoxOptionsSchema, options, "buildSearchBox");
  dispatch(registerQuerySetQuery({ id, query: engine.state.query.q }));
  if (options.numberOfSuggestions) {
    dispatch(
      registerQuerySuggest2({
        id,
        count: options.numberOfSuggestions
      })
    );
  }
  if (options.enableQuerySyntax) {
    dispatch(updateQuery({ enableQuerySyntax: options.enableQuerySyntax }));
  }
  const getValue = () => engine.state.querySet[options.id];
  const performSearch = async (analytics) => {
    const { enableQuerySyntax, clearFilters } = options;
    dispatch(
      prepareForSearchWithQuery({
        q: getValue(),
        enableQuerySyntax,
        clearFilters
      })
    );
    if (props.isNextAnalyticsReady) {
      dispatch(props.executeSearchActionCreator(analytics));
    } else {
      dispatch(props.executeSearchActionCreator(analytics.legacy));
    }
  };
  return {
    ...controller,
    updateText(value) {
      dispatch(updateQuerySetQuery({ id, query: value }));
      this.showSuggestions();
    },
    clear() {
      dispatch(updateQuerySetQuery({ id, query: "" }));
      dispatch(clearQuerySuggest2({ id }));
    },
    showSuggestions() {
      if (options.numberOfSuggestions) {
        dispatch(props.fetchQuerySuggestionsActionCreator({ id }));
      }
    },
    selectSuggestion(value) {
      dispatch(selectQuerySuggestion2({ id, expression: value }));
      performSearch({
        legacy: logQuerySuggestionClick({ id, suggestion: value }),
        next: omniboxAnalytics()
      }).then(() => {
        dispatch(clearQuerySuggest2({ id }));
      });
    },
    submit(legacyAnalytics = logSearchboxSubmit(), nextAnalytics) {
      performSearch({ legacy: legacyAnalytics, next: nextAnalytics });
      dispatch(clearQuerySuggest2({ id }));
    },
    get state() {
      const state = getState();
      const querySuggest = state.querySuggest[options.id];
      const suggestions = getSuggestions(
        querySuggest,
        options.highlightOptions
      );
      const isLoadingSuggestions = querySuggest ? querySuggest.isLoading : false;
      return {
        searchBoxId: id,
        value: getValue(),
        suggestions,
        isLoading: state.search.isLoading,
        isLoadingSuggestions
      };
    }
  };
}
function getSuggestions(state, highlightOptions) {
  if (!state) {
    return [];
  }
  return state.completions.map((completion) => ({
    highlightedValue: getHighlightedSuggestion(
      completion.highlighted,
      highlightOptions
    ),
    rawValue: completion.expression
  }));
}
function loadSearchBoxReducers(engine) {
  engine.addReducers({ query: queryReducer, querySuggest: querySuggestReducer, configuration, querySet: querySetReducer, search: searchReducer });
  return true;
}

// src/controllers/search-box/headless-search-box.ts
function buildSearchBox(engine, props = {}) {
  const searchBox = buildCoreSearchBox(engine, {
    ...props,
    executeSearchActionCreator: executeSearch2,
    fetchQuerySuggestionsActionCreator: fetchQuerySuggestions2,
    isNextAnalyticsReady: true
  });
  return {
    ...searchBox,
    submit() {
      searchBox.submit(logSearchboxSubmit(), searchboxSubmit());
    },
    get state() {
      return searchBox.state;
    }
  };
}

// src/ssr/search/controllers/search-box/headless-search-box.ssr.ts
function defineSearchBox(props) {
  return {
    build: (engine) => buildSearchBox(engine, props)
  };
}

// src/features/sort-criteria/sort-criteria-analytics-actions.ts
var logResultsSort = () => makeAnalyticsAction(
  "analytics/sort/results",
  (client, state) => client.makeResultsSort({
    resultsSortBy: state.sortCriteria || getSortCriteriaInitialState()
  })
);
var resultsSort = () => ({
  actionCause: "resultsSort" /* resultsSort */
});

// src/features/search-parameters/search-parameter-analytics-actions.ts
function legacyLogParametersChange(previousParameters, newParameters) {
  if (previousParameters.q !== newParameters.q) {
    return logSearchboxSubmit();
  }
  if (previousParameters.sortCriteria !== newParameters.sortCriteria) {
    return logResultsSort();
  }
  if (previousParameters.firstResult !== newParameters.firstResult) {
    return logPageNumber();
  }
  if (previousParameters.numberOfResults !== newParameters.numberOfResults) {
    return logPagerResize();
  }
  if (areFacetParamsNotEqual(previousParameters.f, newParameters.f)) {
    return legacyLogFacetAnalyticsAction(previousParameters.f, newParameters.f);
  }
  if (areFacetParamsNotEqual(
    previousParameters.fExcluded,
    newParameters.fExcluded
  )) {
    return legacyLogFacetAnalyticsAction(
      previousParameters.fExcluded,
      newParameters.fExcluded,
      true
    );
  }
  if (areFacetParamsNotEqual(previousParameters.cf, newParameters.cf)) {
    return legacyLogFacetAnalyticsAction(
      previousParameters.cf,
      newParameters.cf
    );
  }
  if (areFacetParamsNotEqual(previousParameters.af, newParameters.af)) {
    return legacyLogFacetAnalyticsAction(
      previousParameters.af,
      newParameters.af
    );
  }
  if (areFacetParamsNotEqual(previousParameters.nf, newParameters.nf)) {
    return legacyLogRangeFacetAnalyticsAction(
      previousParameters.nf,
      newParameters.nf
    );
  }
  if (areFacetParamsNotEqual(previousParameters.df, newParameters.df)) {
    return legacyLogRangeFacetAnalyticsAction(
      previousParameters.df,
      newParameters.df
    );
  }
  return logInterfaceChange();
}
function legacyLogFacetAnalyticsAction(previousFacets = {}, newFacets = {}, excluded = false) {
  const previousIds = Object.keys(previousFacets);
  const newIds = Object.keys(newFacets);
  const removedIds = previousIds.filter((id) => !newIds.includes(id));
  if (removedIds.length) {
    const facetId2 = removedIds[0];
    switch (true) {
      case previousFacets[facetId2].length > 1:
        return logFacetClearAll(facetId2);
      case excluded:
        return logFacetUnexclude({
          facetId: facetId2,
          facetValue: previousFacets[facetId2][0]
        });
      default:
        return logFacetDeselect({
          facetId: facetId2,
          facetValue: previousFacets[facetId2][0]
        });
    }
  }
  const addedIds = newIds.filter((id) => !previousIds.includes(id));
  if (addedIds.length) {
    const facetId2 = addedIds[0];
    return excluded ? logFacetExclude({
      facetId: facetId2,
      facetValue: newFacets[facetId2][0]
    }) : logFacetSelect({
      facetId: facetId2,
      facetValue: newFacets[facetId2][0]
    });
  }
  const facetIdWithDifferentValues = newIds.find(
    (key) => newFacets[key].filter(
      (facetValue) => previousFacets[key].includes(facetValue)
    )
  );
  if (!facetIdWithDifferentValues) {
    return logInterfaceChange();
  }
  const previousValues = previousFacets[facetIdWithDifferentValues];
  const newValues = newFacets[facetIdWithDifferentValues];
  const addedValues = newValues.filter(
    (value) => !previousValues.includes(value)
  );
  if (addedValues.length) {
    return excluded ? logFacetExclude({
      facetId: facetIdWithDifferentValues,
      facetValue: addedValues[0]
    }) : logFacetSelect({
      facetId: facetIdWithDifferentValues,
      facetValue: addedValues[0]
    });
  }
  const removedValues = previousValues.filter(
    (value) => !newValues.includes(value)
  );
  if (removedValues.length) {
    return excluded ? logFacetUnexclude({
      facetId: facetIdWithDifferentValues,
      facetValue: removedValues[0]
    }) : logFacetDeselect({
      facetId: facetIdWithDifferentValues,
      facetValue: removedValues[0]
    });
  }
  return logInterfaceChange();
}
function legacyLogRangeFacetAnalyticsAction(previousFacets = {}, newFacets = {}) {
  return legacyLogFacetAnalyticsAction(
    parseRangeFacetParams(previousFacets),
    parseRangeFacetParams(newFacets)
  );
}
function parametersChange(previousParameters, newParameters) {
  if (previousParameters.q !== newParameters.q) {
    return searchboxSubmit();
  }
  if (previousParameters.sortCriteria !== newParameters.sortCriteria) {
    return resultsSort();
  }
  if (areFacetParamsNotEqual(previousParameters.f, newParameters.f)) {
    return facetAction(previousParameters.f, newParameters.f);
  }
  if (areFacetParamsNotEqual(
    previousParameters.fExcluded,
    newParameters.fExcluded
  )) {
    return facetAction(
      previousParameters.fExcluded,
      newParameters.fExcluded,
      true
    );
  }
  if (areFacetParamsNotEqual(previousParameters.cf, newParameters.cf)) {
    return facetAction(previousParameters.cf, newParameters.cf);
  }
  if (areFacetParamsNotEqual(previousParameters.af, newParameters.af)) {
    return facetAction(previousParameters.af, newParameters.af);
  }
  if (areFacetParamsNotEqual(previousParameters.nf, newParameters.nf)) {
    return facetAction(
      parseRangeFacetParams(previousParameters.nf),
      parseRangeFacetParams(newParameters.nf)
    );
  }
  if (areFacetParamsNotEqual(previousParameters.df, newParameters.df)) {
    return facetAction(
      parseRangeFacetParams(previousParameters.df),
      parseRangeFacetParams(newParameters.df)
    );
  }
  return interfaceChange();
}
function areFacetParamsNotEqual(previousFacetParams = {}, newFacetParams = {}) {
  return JSON.stringify(previousFacetParams) !== JSON.stringify(newFacetParams);
}
function facetAction(previousFacets = {}, newFacets = {}, excluded = false) {
  const previousIds = Object.keys(previousFacets);
  const newIds = Object.keys(newFacets);
  const removedIds = previousIds.filter((id) => !newIds.includes(id));
  if (removedIds.length) {
    const facetId2 = removedIds[0];
    return previousFacets[facetId2].length > 1 ? facetClearAll() : facetDeselect();
  }
  const addedIds = newIds.filter((id) => !previousIds.includes(id));
  if (addedIds.length) {
    return excluded ? facetExclude() : facetSelect();
  }
  const facetIdWithDifferentValues = newIds.find(
    (key) => newFacets[key].filter(
      (facetValue) => previousFacets[key].includes(facetValue)
    )
  );
  if (!facetIdWithDifferentValues) {
    return interfaceChange();
  }
  const previousValues = previousFacets[facetIdWithDifferentValues];
  const newValues = newFacets[facetIdWithDifferentValues];
  const addedValues = newValues.filter(
    (value) => !previousValues.includes(value)
  );
  if (addedValues.length) {
    return excluded ? facetExclude() : facetSelect();
  }
  const removedValues = previousValues.filter(
    (value) => !newValues.includes(value)
  );
  if (removedValues.length) {
    return facetDeselect();
  }
  return interfaceChange();
}
function parseRangeFacetParams(facetsParams = {}) {
  const formattedParams = {};
  Object.keys(facetsParams).forEach((key) => {
    formattedParams[key] = facetsParams[key].map(
      (facetValue) => `${facetValue.start}..${facetValue.end}`
    );
  });
  return formattedParams;
}

// src/controllers/core/search-parameter-manager/headless-core-search-parameter-manager.ts
var import_bueno91 = require("@coveo/bueno");

// src/features/search-parameters/search-parameter-selectors.ts
function initialSearchParameterSelector(state) {
  return {
    q: getQueryInitialState().q,
    enableQuerySyntax: getQueryInitialState().enableQuerySyntax,
    aq: state.advancedSearchQueries?.defaultFilters.aq ?? getAdvancedSearchQueriesInitialState().defaultFilters.aq,
    cq: state.advancedSearchQueries?.defaultFilters.cq ?? getAdvancedSearchQueriesInitialState().defaultFilters.cq,
    firstResult: getPaginationInitialState().firstResult,
    numberOfResults: state.pagination?.defaultNumberOfResults ?? getPaginationInitialState().defaultNumberOfResults,
    sortCriteria: getSortCriteriaInitialState(),
    f: {},
    fExcluded: {},
    cf: {},
    nf: {},
    df: {},
    debug: getDebugInitialState(),
    sf: {},
    tab: "",
    af: {},
    mnf: {}
  };
}

// src/controllers/core/search-parameter-manager/headless-core-search-parameter-manager.ts
var initialStateSchema7 = new import_bueno91.Schema({
  parameters: new import_bueno91.RecordValue({
    options: { required: true },
    values: searchParametersDefinition
  })
});
function buildCoreSearchParameterManager(engine, props) {
  const { dispatch } = engine;
  const controller = buildController(engine);
  validateInitialState(
    engine,
    initialStateSchema7,
    props.initialState,
    "buildSearchParameterManager"
  );
  const parametersWithValidTab = ensureTabIsValid(
    engine.state.tabSet,
    props.initialState.parameters
  );
  dispatch(restoreSearchParameters(parametersWithValidTab));
  return {
    ...controller,
    synchronize(parameters) {
      const enrichedParametersWithValidTab = ensureTabIsValid(
        engine.state.tabSet,
        enrichParameters(engine, parameters)
      );
      dispatch(restoreSearchParameters(enrichedParametersWithValidTab));
    },
    get state() {
      const parameters = getCoreActiveSearchParameters(engine);
      return { parameters };
    }
  };
}
function enrichParameters(engine, parameters) {
  return {
    ...initialSearchParameterSelector(engine.state),
    ...parameters
  };
}
function ensureTabIsValid(tabSet, parameters) {
  if (parameters.tab && tabSet) {
    const tabExists = Object.values(tabSet).some(
      (tab) => tab.id === parameters.tab
    );
    const currentActiveTab = Object.values(tabSet).find((tab) => tab.isActive);
    if (!tabExists && currentActiveTab) {
      return { ...parameters, tab: currentActiveTab.id };
    } else if (!tabExists) {
      return { ...parameters, tab: "" };
    }
  }
  return parameters;
}
function getCoreActiveSearchParameters(engine) {
  const state = engine.state;
  return {
    ...getQ(state.query, (s) => s.q, getQueryInitialState().q),
    ...getTab(
      state.tabSet,
      (tabSet) => {
        const activeTab = Object.values(tabSet ?? {}).find(
          (tab) => tab.isActive
        );
        return activeTab ? activeTab.id : Object.keys(tabSet ?? {})[0];
      },
      state.tabSet ? Object.keys(state.tabSet)[0] : ""
    ),
    ...getSortCriteria(
      state.sortCriteria,
      (sortCriteria) => sortCriteria,
      getSortCriteriaInitialState()
    ),
    ...getFacets4(state.facetSet, facetIsEnabled(state), getSelectedValues, "f"),
    ...getFacets4(
      state.facetSet,
      facetIsEnabled(state),
      getExcludedValues,
      "fExcluded"
    ),
    ...getCategoryFacets(state),
    ...getNumericFacets(state),
    ...getDateFacets(state),
    ...getAutomaticFacets4(state)
  };
}
function facetIsEnabled(state) {
  return (facetId2) => {
    return state.facetOptions?.facets[facetId2]?.enabled ?? true;
  };
}
function getSelectedValues(request) {
  return request.currentValues.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getSelectedRangeValues(request) {
  return request.currentValues.filter((fv) => fv.state === "selected");
}
function getExcludedValues(request) {
  return request.currentValues.filter((fv) => fv.state === "excluded").map((fv) => fv.value);
}
function getCategoryFacets(state) {
  return getFacets4(
    state.categoryFacetSet,
    facetIsEnabled(state),
    (request) => findActiveValueAncestry(request.currentValues).map((v) => v.value),
    "cf"
  );
}
function getNumericFacets(state) {
  return getFacets4(
    state.numericFacetSet,
    facetIsEnabled(state),
    getSelectedRangeValues,
    "nf"
  );
}
function getDateFacets(state) {
  return getFacets4(
    state.dateFacetSet,
    facetIsEnabled(state),
    getSelectedRangeValues,
    "df"
  );
}
function getAutomaticFacets4(state) {
  const set = state.automaticFacetSet?.set;
  if (set === void 0) {
    return {};
  }
  const af = Object.entries(set).map(([facetId2, { response }]) => {
    const selectedValues = getSelectedResponseValues(response);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(af).length ? { af } : {};
}
function getSelectedResponseValues(response) {
  return response.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}

// src/controllers/search-parameter-manager/headless-search-parameter-manager.ts
function buildSearchParameterManager(engine, props) {
  const { dispatch } = engine;
  const controller = buildCoreSearchParameterManager(engine, props);
  return {
    ...controller,
    synchronize(parameters) {
      const activeParams = getActiveSearchParameters(engine);
      const oldParams = enrichParameters(engine, activeParams);
      const newParams = enrichParameters(engine, parameters);
      if (deepEqualAnyOrder(oldParams, newParams)) {
        return;
      }
      controller.synchronize(parameters);
      dispatch(
        executeSearch2({
          legacy: legacyLogParametersChange(oldParams, newParams),
          next: parametersChange(oldParams, newParams)
        })
      );
    },
    get state() {
      const parameters = getActiveSearchParameters(engine);
      return { parameters };
    }
  };
}
function getActiveSearchParameters(engine) {
  const state = engine.state;
  return {
    ...getCoreActiveSearchParameters(engine),
    ...getEnableQuerySyntax(state),
    ...getAq(state),
    ...getCq(state),
    ...getFirstResult(state),
    ...getNumberOfResults(state),
    ...getDebug(state),
    ...getStaticFilters(state)
  };
}
function getEnableQuerySyntax(state) {
  if (state.query === void 0) {
    return {};
  }
  const enableQuerySyntax = state.query.enableQuerySyntax;
  const shouldInclude = enableQuerySyntax !== void 0 && enableQuerySyntax !== getQueryInitialState().enableQuerySyntax;
  return shouldInclude ? { enableQuerySyntax } : {};
}
function getAq(state) {
  if (state.advancedSearchQueries === void 0) {
    return {};
  }
  const { aq, defaultFilters } = state.advancedSearchQueries;
  const shouldInclude = aq !== defaultFilters.aq;
  return shouldInclude ? { aq } : {};
}
function getCq(state) {
  if (state.advancedSearchQueries === void 0) {
    return {};
  }
  const { cq, defaultFilters } = state.advancedSearchQueries;
  const shouldInclude = cq !== defaultFilters.cq;
  return shouldInclude ? { cq } : {};
}
function getFirstResult(state) {
  if (state.pagination === void 0) {
    return {};
  }
  const firstResult = state.pagination.firstResult;
  const shouldInclude = firstResult !== getPaginationInitialState().firstResult;
  return shouldInclude ? { firstResult } : {};
}
function getNumberOfResults(state) {
  if (state.pagination === void 0) {
    return {};
  }
  const { numberOfResults, defaultNumberOfResults } = state.pagination;
  const shouldInclude = numberOfResults !== defaultNumberOfResults;
  return shouldInclude ? { numberOfResults } : {};
}
function getStaticFilters(state) {
  if (state.staticFilterSet === void 0) {
    return {};
  }
  const sf = Object.entries(state.staticFilterSet).map(([id, filter]) => {
    const selectedCaptions = getSelectedStaticFilterCaptions(filter.values);
    return selectedCaptions.length ? { [id]: selectedCaptions } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(sf).length ? { sf } : {};
}
function getSelectedStaticFilterCaptions(values) {
  return values.filter((v) => v.state === "selected").map((v) => v.caption);
}
function getDebug(state) {
  if (state.debug === void 0) {
    return {};
  }
  const debug = state.debug;
  const shouldInclude = debug !== getDebugInitialState();
  return shouldInclude ? { debug } : {};
}

// src/features/advanced-search-queries/advanced-search-queries-slice.ts
var import_bueno93 = require("@coveo/bueno");
var import_toolkit101 = require("@reduxjs/toolkit");

// src/features/advanced-search-queries/advanced-search-queries-actions.ts
var import_bueno92 = require("@coveo/bueno");
var import_toolkit100 = require("@reduxjs/toolkit");
var optionalAndPossiblyEmpty = () => new import_bueno92.StringValue({ required: false, emptyAllowed: true });
var updateAdvancedSearchQueries = (0, import_toolkit100.createAction)(
  "advancedSearchQueries/update",
  (payload) => validatePayload(payload, {
    aq: optionalAndPossiblyEmpty(),
    cq: optionalAndPossiblyEmpty(),
    lq: optionalAndPossiblyEmpty(),
    dq: optionalAndPossiblyEmpty()
  })
);
var registerAdvancedSearchQueries = (0, import_toolkit100.createAction)(
  "advancedSearchQueries/register",
  (payload) => validatePayload(payload, {
    aq: optionalAndPossiblyEmpty(),
    cq: optionalAndPossiblyEmpty(),
    lq: optionalAndPossiblyEmpty(),
    dq: optionalAndPossiblyEmpty()
  })
);

// src/features/advanced-search-queries/advanced-search-queries-slice.ts
var advancedSearchQueriesReducer = (0, import_toolkit101.createReducer)(
  getAdvancedSearchQueriesInitialState(),
  (builder) => {
    builder.addCase(updateAdvancedSearchQueries, (state, action) => {
      const { aq, cq, lq, dq } = action.payload;
      if (!(0, import_bueno93.isUndefined)(aq)) {
        state.aq = aq;
        state.aqWasSet = true;
      }
      if (!(0, import_bueno93.isUndefined)(cq)) {
        state.cq = cq;
        state.cqWasSet = true;
      }
      if (!(0, import_bueno93.isUndefined)(lq)) {
        state.lq = lq;
        state.lqWasSet = true;
      }
      if (!(0, import_bueno93.isUndefined)(dq)) {
        state.dq = dq;
        state.dqWasSet = true;
      }
    }).addCase(registerAdvancedSearchQueries, (state, action) => {
      const { aq, cq, lq, dq } = action.payload;
      if (!(0, import_bueno93.isUndefined)(aq)) {
        state.defaultFilters.aq = aq;
        if (!state.aqWasSet) {
          state.aq = aq;
        }
      }
      if (!(0, import_bueno93.isUndefined)(cq)) {
        state.defaultFilters.cq = cq;
        if (!state.cqWasSet) {
          state.cq = cq;
        }
      }
      if (!(0, import_bueno93.isUndefined)(lq)) {
        state.defaultFilters.lq = lq;
        if (!state.lqWasSet) {
          state.lq = lq;
        }
      }
      if (!(0, import_bueno93.isUndefined)(dq)) {
        state.defaultFilters.dq = dq;
        if (!state.dqWasSet) {
          state.dq = dq;
        }
      }
    }).addCase(
      change.fulfilled,
      (state, action) => action.payload?.advancedSearchQueries ?? state
    ).addCase(restoreSearchParameters, (state, action) => {
      const { aq, cq } = action.payload;
      if (!(0, import_bueno93.isUndefined)(aq)) {
        state.aq = aq;
        state.aqWasSet = true;
      }
      if (!(0, import_bueno93.isUndefined)(cq)) {
        state.cq = cq;
        state.cqWasSet = true;
      }
    });
  }
);

// src/features/sort-criteria/sort-criteria-slice.ts
var import_toolkit103 = require("@reduxjs/toolkit");

// src/features/sort-criteria/sort-criteria-actions.ts
var import_bueno94 = require("@coveo/bueno");
var import_toolkit102 = require("@reduxjs/toolkit");
var criterionDefinition2 = {
  by: new import_bueno94.EnumValue({ enum: SortBy, required: true })
};
var registerSortCriterion = (0, import_toolkit102.createAction)(
  "sortCriteria/register",
  (payload) => validate2(payload)
);
var updateSortCriterion = (0, import_toolkit102.createAction)(
  "sortCriteria/update",
  (payload) => validate2(payload)
);
var validate2 = (payload) => {
  if ((0, import_bueno94.isArray)(payload)) {
    payload.forEach((p) => validatePayload(p, criterionDefinition2));
    return { payload };
  }
  return validatePayload(payload, criterionDefinition2);
};

// src/features/sort-criteria/sort-criteria-slice.ts
var sortCriteriaReducer = (0, import_toolkit103.createReducer)(
  getSortCriteriaInitialState(),
  (builder) => {
    builder.addCase(
      registerSortCriterion,
      (_, action) => buildCriterionExpression(action.payload)
    ).addCase(
      updateSortCriterion,
      (_, action) => buildCriterionExpression(action.payload)
    ).addCase(change.fulfilled, (state, action) => {
      return action.payload?.sortCriteria ?? state;
    }).addCase(restoreSearchParameters, (state, action) => {
      return action.payload.sortCriteria ?? state;
    });
  }
);

// src/features/static-filter-set/static-filter-set-slice.ts
var import_toolkit104 = require("@reduxjs/toolkit");
var staticFilterSetReducer = (0, import_toolkit104.createReducer)(
  getStaticFilterSetInitialState(),
  (builder) => builder.addCase(registerStaticFilter, (state, action) => {
    const filter = action.payload;
    const { id } = filter;
    if (id in state) {
      return;
    }
    state[id] = filter;
  }).addCase(toggleSelectStaticFilterValue, (state, action) => {
    const { id, value } = action.payload;
    const filter = state[id];
    if (!filter) {
      return;
    }
    const target = filter.values.find((v) => v.caption === value.caption);
    if (!target) {
      return;
    }
    const isSelected = target.state === "selected";
    target.state = isSelected ? "idle" : "selected";
  }).addCase(toggleExcludeStaticFilterValue, (state, action) => {
    const { id, value } = action.payload;
    const filter = state[id];
    if (!filter) {
      return;
    }
    const target = filter.values.find((v) => v.caption === value.caption);
    if (!target) {
      return;
    }
    const isExcluded = target.state === "excluded";
    target.state = isExcluded ? "idle" : "excluded";
  }).addCase(deselectAllStaticFilterValues, (state, action) => {
    const id = action.payload;
    const filter = state[id];
    if (!filter) {
      return;
    }
    filter.values.forEach((v) => {
      v.state = "idle";
    });
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.values(state).forEach((filter) => {
      filter.values.forEach((v) => {
        v.state = "idle";
      });
    });
  }).addCase(restoreSearchParameters, (state, action) => {
    const sf = action.payload.sf || {};
    Object.entries(state).forEach(([id, filter]) => {
      const selected = sf[id] || [];
      filter.values.forEach((value) => {
        value.state = selected.includes(value.caption) ? "selected" : "idle";
      });
    });
  })
);

// src/features/tab-set/tab-set-slice.ts
var import_bueno95 = require("@coveo/bueno");
var import_toolkit105 = require("@reduxjs/toolkit");
var tabSetReducer = (0, import_toolkit105.createReducer)(
  getTabSetInitialState(),
  (builder) => {
    builder.addCase(registerTab, (state, action) => {
      const tab = action.payload;
      const { id } = tab;
      if (id in state) {
        return;
      }
      state[id] = { ...tab, isActive: false };
    }).addCase(updateActiveTab, (state, action) => {
      const id = action.payload;
      activateTabIfIdExists(state, id);
    }).addCase(restoreTab, (state, action) => {
      const id = action.payload;
      activateTabIfIdExists(state, id);
    }).addCase(change.fulfilled, (state, action) => {
      return action.payload?.tabSet ?? state;
    }).addCase(restoreSearchParameters, (state, action) => {
      const id = action.payload.tab;
      if (!(0, import_bueno95.isNullOrUndefined)(id)) {
        Object.keys(state).forEach((tabId) => {
          state[tabId].isActive = tabId === id;
        });
      }
    });
  }
);
function activateTabIfIdExists(state, id) {
  const hasId = id in state;
  if (!hasId) {
    return;
  }
  Object.keys(state).forEach((tabId) => {
    state[tabId].isActive = tabId === id;
  });
}

// src/ssr/search/controllers/search-parameter-manager/headless-search-parameter-manager.ssr.ts
function defineSearchParameterManager() {
  return {
    buildWithProps: (engine, props) => {
      if (props === void 0) {
        throw new MissingControllerProps("SearchParameterManager");
      }
      if (!loadSearchParameterManagerReducers(engine)) {
        throw loadReducerError;
      }
      return buildSearchParameterManager(engine, {
        initialState: props.initialState
      });
    }
  };
}
function loadSearchParameterManagerReducers(engine) {
  engine.addReducers({
    advancedSearchQueries: advancedSearchQueriesReducer,
    automaticFacetSet: automaticFacetSetReducer,
    categoryFacetSet: categoryFacetSetReducer,
    configuration: configurationReducer,
    dateFacetSet: dateFacetSetReducer,
    debug: debugReducer,
    facetOptions: facetOptionsReducer,
    facetSet: facetSetReducer,
    numericFacetSet: numericFacetSetReducer,
    pagination: paginationReducer,
    query: queryReducer,
    sortCriteria: sortCriteriaReducer,
    staticFilterSet: staticFilterSetReducer,
    tabSet: tabSetReducer
  });
  return true;
}

// src/controllers/search-status/headless-search-status.ts
function buildSearchStatus(engine) {
  return buildCoreStatus(engine);
}

// src/ssr/search/controllers/search-status/headless-search-status.ssr.ts
function defineSearchStatus() {
  return {
    build: (engine) => buildSearchStatus(engine)
  };
}

// src/features/question-answering/question-answering-document-id.ts
var import_bueno96 = require("@coveo/bueno");
var uniqueIdentifierPayloadDefinition = () => new import_bueno96.RecordValue({
  values: {
    questionAnswerId: requiredNonEmptyString
  },
  options: { required: true }
});
var inlineLinkPayloadDefinition = () => new import_bueno96.RecordValue({
  values: {
    linkText: requiredEmptyAllowedString,
    linkURL: requiredEmptyAllowedString
  },
  options: { required: true }
});
function validateQuestionAnsweringActionCreatorPayload(payload) {
  return validatePayload(
    payload,
    uniqueIdentifierPayloadDefinition()
  );
}

// src/features/question-answering/question-answering-selectors.ts
function answerSourceSelector(state, documentIdentifier2) {
  const documentId = documentIdentifier2 ?? state.search?.questionAnswer?.documentId;
  return documentId && state.search && resultFromFieldSelector(
    state,
    documentId.contentIdKey,
    documentId.contentIdValue
  );
}
function relatedQuestionSelector(state, questionAnswerId) {
  const index = state.questionAnswering?.relatedQuestions.findIndex(
    (relatedQuestion) => relatedQuestion.questionAnswerId === questionAnswerId
  ) ?? -1;
  if (index === -1) {
    return null;
  }
  const searchQuestionState = state.search?.questionAnswer?.relatedQuestions?.[index];
  return searchQuestionState ?? null;
}

// src/features/question-answering/question-answering-analytics-actions.ts
var logExpandSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/expand",
  __legacy__getBuilder: (client) => {
    return client.makeExpandSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "expand",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logCollapseSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/collapse",
  __legacy__getBuilder: (client) => {
    return client.makeCollapseSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "collapse",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logLikeSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/like",
  __legacy__getBuilder: (client) => {
    return client.makeLikeSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "like",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logDislikeSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/dislike",
  __legacy__getBuilder: (client) => {
    return client.makeDislikeSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "dislike",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetSource = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/source/open",
  __legacy__getBuilder: (client, state) => {
    const result = answerSourceSelector(state);
    return client.makeOpenSmartSnippetSource(
      partialDocumentInformation(result, state),
      documentIdentifier(result)
    );
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetInlineLink = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(payload, inlineLinkPayloadDefinition());
    const result = answerSourceSelector(state);
    if (!result) {
      return null;
    }
    return client.makeOpenSmartSnippetInlineLink(
      partialDocumentInformation(result, state),
      {
        ...documentIdentifier(result),
        ...payload
      }
    );
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetFeedbackModal = () => makeAnalyticsAction(
  "analytics/smartSnippet/feedbackModal/open",
  (client) => client.makeOpenSmartSnippetFeedbackModal()
);
var logCloseSmartSnippetFeedbackModal = () => makeAnalyticsAction(
  "analytics/smartSnippet/feedbackModal/close",
  (client) => client.makeCloseSmartSnippetFeedbackModal()
);
var smartSnippetFeedbackMap = {
  does_not_answer: "doesNotAnswer",
  partially_answers: "partiallyAnswers",
  was_not_a_question: "wasNotAQuestion"
};
var logSmartSnippetFeedback = (feedback) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/sendFeedback",
  __legacy__getBuilder: (client) => {
    return client.makeSmartSnippetFeedbackReason(feedback);
  },
  analyticsType: "SmartSnippets.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        responseId: searchUid,
        snippetType: "SmartSnippet",
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        },
        reason: smartSnippetFeedbackMap[feedback]
      };
    }
  }
});
var logSmartSnippetDetailedFeedback = (details) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/sendFeedback",
  __legacy__getBuilder: (client) => {
    return client.makeSmartSnippetFeedbackReason("other", details);
  },
  analyticsType: "SmartSnippets.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        responseId: searchUid,
        snippetType: "SmartSnippet",
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        },
        reason: "other",
        additionalNotes: details
      };
    }
  }
});
var logExpandSmartSnippetSuggestion = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/expand",
  __legacy__getBuilder: (client, state) => {
    validateQuestionAnsweringActionCreatorPayload(payload);
    const relatedQuestion = relatedQuestionSelector(
      state,
      payload.questionAnswerId
    );
    if (!relatedQuestion) {
      return null;
    }
    return client.makeExpandSmartSnippetSuggestion({
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(
      state,
      payload.questionAnswerId
    );
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        action: "expand",
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
var logCollapseSmartSnippetSuggestion = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/collapse",
  __legacy__getBuilder: (client, state) => {
    validateQuestionAnsweringActionCreatorPayload(payload);
    const relatedQuestion = relatedQuestionSelector(
      state,
      payload.questionAnswerId
    );
    if (!relatedQuestion) {
      return null;
    }
    return client.makeCollapseSmartSnippetSuggestion({
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(
      state,
      payload.questionAnswerId
    );
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        action: "collapse",
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetSuggestionSource = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(payload, uniqueIdentifierPayloadDefinition());
    const relatedQuestion = relatedQuestionSelector(
      state,
      payload.questionAnswerId
    );
    if (!relatedQuestion) {
      return null;
    }
    const source = answerSourceSelector(state, relatedQuestion.documentId);
    if (!source) {
      return null;
    }
    return client.makeOpenSmartSnippetSuggestionSource(
      partialDocumentInformation(source, state),
      {
        question: relatedQuestion.question,
        answerSnippet: relatedQuestion.answerSnippet,
        documentId: relatedQuestion.documentId
      }
    );
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(
      state,
      payload.questionAnswerId
    );
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetSuggestionInlineLink = (identifier, link) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(identifier, uniqueIdentifierPayloadDefinition());
    validatePayload(link, inlineLinkPayloadDefinition());
    const relatedQuestion = relatedQuestionSelector(
      state,
      identifier.questionAnswerId
    );
    if (!relatedQuestion) {
      return null;
    }
    const source = answerSourceSelector(state, relatedQuestion.documentId);
    if (!source) {
      return null;
    }
    return client.makeOpenSmartSnippetSuggestionInlineLink(
      partialDocumentInformation(source, state),
      {
        question: relatedQuestion.question,
        answerSnippet: relatedQuestion.answerSnippet,
        documentId: relatedQuestion.documentId,
        linkText: link.linkText,
        linkURL: link.linkURL
      }
    );
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(
      state,
      identifier.questionAnswerId
    );
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
var smartSnippetAnalyticsClient = {
  logExpandSmartSnippet,
  logCollapseSmartSnippet,
  logLikeSmartSnippet,
  logDislikeSmartSnippet,
  logOpenSmartSnippetSource,
  logOpenSmartSnippetInlineLink,
  logOpenSmartSnippetFeedbackModal,
  logCloseSmartSnippetFeedbackModal,
  logSmartSnippetFeedback,
  logSmartSnippetDetailedFeedback,
  logExpandSmartSnippetSuggestion,
  logCollapseSmartSnippetSuggestion,
  logOpenSmartSnippetSuggestionSource
};

// src/features/question-answering/question-answering-actions.ts
var import_toolkit106 = require("@reduxjs/toolkit");
var expandSmartSnippet = (0, import_toolkit106.createAction)("smartSnippet/expand");
var collapseSmartSnippet = (0, import_toolkit106.createAction)("smartSnippet/collapse");
var likeSmartSnippet = (0, import_toolkit106.createAction)("smartSnippet/like");
var dislikeSmartSnippet = (0, import_toolkit106.createAction)("smartSnippet/dislike");
var openFeedbackModal = (0, import_toolkit106.createAction)(
  "smartSnippet/feedbackModal/open"
);
var closeFeedbackModal = (0, import_toolkit106.createAction)(
  "smartSnippet/feedbackModal/close"
);
var expandSmartSnippetRelatedQuestion = (0, import_toolkit106.createAction)(
  "smartSnippet/related/expand",
  (payload) => validateQuestionAnsweringActionCreatorPayload(payload)
);
var collapseSmartSnippetRelatedQuestion = (0, import_toolkit106.createAction)(
  "smartSnippet/related/collapse",
  (payload) => validateQuestionAnsweringActionCreatorPayload(payload)
);

// src/features/question-answering/question-answering-slice.ts
var import_toolkit107 = require("@reduxjs/toolkit");

// src/features/question-answering/question-answering-state.ts
var getQuestionAnsweringInitialState = () => ({
  liked: false,
  disliked: false,
  expanded: false,
  feedbackModalOpen: false,
  relatedQuestions: []
});

// src/features/question-answering/question-answering-slice.ts
var findRelatedQuestionIdx = (relatedQuestions, identifier) => relatedQuestions.findIndex(
  (relatedQuestion) => relatedQuestion.questionAnswerId === identifier.questionAnswerId
);
function hashQuestionAnswer({
  question,
  answerSnippet,
  documentId: { contentIdKey, contentIdValue }
}) {
  return getObjectHash({
    question,
    answerSnippet,
    contentIdKey,
    contentIdValue
  });
}
function buildQuestionAnsweringRelatedQuestionState(responseQuestionAnswer, currentState) {
  const id = hashQuestionAnswer(responseQuestionAnswer);
  if (currentState && id === currentState.questionAnswerId) {
    return currentState;
  }
  return {
    contentIdKey: responseQuestionAnswer.documentId.contentIdKey,
    contentIdValue: responseQuestionAnswer.documentId.contentIdValue,
    expanded: false,
    questionAnswerId: id
  };
}
var questionAnsweringReducer = (0, import_toolkit107.createReducer)(
  getQuestionAnsweringInitialState(),
  (builder) => builder.addCase(expandSmartSnippet, (state) => {
    state.expanded = true;
  }).addCase(collapseSmartSnippet, (state) => {
    state.expanded = false;
  }).addCase(likeSmartSnippet, (state) => {
    state.liked = true;
    state.disliked = false;
    state.feedbackModalOpen = false;
  }).addCase(dislikeSmartSnippet, (state) => {
    state.liked = false;
    state.disliked = true;
  }).addCase(openFeedbackModal, (state) => {
    state.feedbackModalOpen = true;
  }).addCase(closeFeedbackModal, (state) => {
    state.feedbackModalOpen = false;
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const relatedQuestions = action.payload.response.questionAnswer.relatedQuestions.map(
      (relatedQuestion, i) => buildQuestionAnsweringRelatedQuestionState(
        relatedQuestion,
        state.relatedQuestions[i]
      )
    );
    const questionAnswerId = hashQuestionAnswer(
      action.payload.response.questionAnswer
    );
    if (state.questionAnswerId === questionAnswerId) {
      return {
        ...state,
        relatedQuestions
      };
    }
    return {
      ...getQuestionAnsweringInitialState(),
      relatedQuestions,
      questionAnswerId
    };
  }).addCase(
    expandSmartSnippetRelatedQuestion,
    (state, action) => {
      const idx = findRelatedQuestionIdx(
        state.relatedQuestions,
        action.payload
      );
      if (idx === -1) {
        return;
      }
      state.relatedQuestions[idx].expanded = true;
    }
  ).addCase(collapseSmartSnippetRelatedQuestion, (state, action) => {
    const idx = findRelatedQuestionIdx(
      state.relatedQuestions,
      action.payload
    );
    if (idx === -1) {
      return;
    }
    state.relatedQuestions[idx].expanded = false;
  })
);

// src/controllers/core/interactive-result/headless-core-interactive-result.ts
function buildInteractiveResultCore(engine, props, action) {
  if (!loadInteractiveResultCoreReducers(engine)) {
    throw loadReducerError;
  }
  const defaultDelay = 1e3;
  const options = {
    selectionDelay: defaultDelay,
    debounceWait: defaultDelay,
    ...props.options
  };
  let longPressTimer;
  return {
    select: debounce(action, options.debounceWait, { isImmediate: true }),
    beginDelayedSelect() {
      longPressTimer = setTimeout(action, options.selectionDelay);
    },
    cancelPendingSelect() {
      longPressTimer && clearTimeout(longPressTimer);
    }
  };
}
function loadInteractiveResultCoreReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}

// src/controllers/core/smart-snippet/headless-core-smart-snippet.ts
function buildCoreSmartSnippet(engine, analyticsClient, props) {
  if (!loadSmartSnippetReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  const getResult = () => answerSourceSelector(getState());
  let lastSearchResponseId = null;
  const interactiveResult = buildInteractiveResultCore(
    engine,
    { options: { selectionDelay: props?.options?.selectionDelay } },
    () => {
      const result = getResult();
      if (!result) {
        lastSearchResponseId = null;
        return;
      }
      const { searchResponseId } = getState().search;
      if (lastSearchResponseId === searchResponseId) {
        return;
      }
      lastSearchResponseId = searchResponseId;
      engine.dispatch(analyticsClient.logOpenSmartSnippetSource());
      engine.dispatch(pushRecentResult(result));
    }
  );
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        question: state.search.questionAnswer.question,
        answer: state.search.questionAnswer.answerSnippet,
        documentId: state.search.questionAnswer.documentId,
        expanded: state.questionAnswering.expanded,
        answerFound: state.search.questionAnswer.answerSnippet !== "",
        liked: state.questionAnswering.liked,
        disliked: state.questionAnswering.disliked,
        feedbackModalOpen: state.questionAnswering.feedbackModalOpen,
        source: getResult()
      };
    },
    expand() {
      engine.dispatch(analyticsClient.logExpandSmartSnippet());
      engine.dispatch(expandSmartSnippet());
    },
    collapse() {
      engine.dispatch(analyticsClient.logCollapseSmartSnippet());
      engine.dispatch(collapseSmartSnippet());
    },
    like() {
      engine.dispatch(analyticsClient.logLikeSmartSnippet());
      engine.dispatch(likeSmartSnippet());
    },
    dislike() {
      engine.dispatch(analyticsClient.logDislikeSmartSnippet());
      engine.dispatch(dislikeSmartSnippet());
    },
    openFeedbackModal() {
      engine.dispatch(analyticsClient.logOpenSmartSnippetFeedbackModal());
      engine.dispatch(openFeedbackModal());
    },
    closeFeedbackModal() {
      engine.dispatch(analyticsClient.logCloseSmartSnippetFeedbackModal());
      engine.dispatch(closeFeedbackModal());
    },
    sendFeedback(feedback) {
      engine.dispatch(analyticsClient.logSmartSnippetFeedback(feedback));
      engine.dispatch(closeFeedbackModal());
    },
    sendDetailedFeedback(details) {
      engine.dispatch(analyticsClient.logSmartSnippetDetailedFeedback(details));
      engine.dispatch(closeFeedbackModal());
    },
    selectSource() {
      interactiveResult.select();
    },
    beginDelayedSelectSource() {
      interactiveResult.beginDelayedSelect();
    },
    cancelPendingSelectSource() {
      interactiveResult.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetReducers(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// src/controllers/smart-snippet/headless-smart-snippet-interactive-inline-links.ts
function buildSmartSnippetInteractiveInlineLinks(engine, props) {
  if (!loadSmartSnippetInteractiveInlineLinksReducer(engine)) {
    throw loadReducerError;
  }
  const getState = () => engine.state;
  const clickedRelatedQuestions = /* @__PURE__ */ new Set();
  const inlineLinkWasClicked = (linkId) => {
    if (clickedRelatedQuestions.has(linkId)) {
      return true;
    }
    clickedRelatedQuestions.add(linkId);
    return false;
  };
  let lastSearchResponseId = null;
  const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
    if (lastSearchResponseId !== currentSearchResponseId) {
      lastSearchResponseId = currentSearchResponseId;
      interactiveResultsPerInlineLink = {};
      clickedRelatedQuestions.clear();
    }
  };
  const buildInlineLinkInteractiveResult = (link, linkId, questionAnswerId) => buildInteractiveResultCore(
    engine,
    { options: { selectionDelay: props?.options?.selectionDelay } },
    () => {
      if (inlineLinkWasClicked(linkId)) {
        return;
      }
      engine.dispatch(
        questionAnswerId ? logOpenSmartSnippetSuggestionInlineLink({ questionAnswerId }, link) : logOpenSmartSnippetInlineLink(link)
      );
    }
  );
  let interactiveResultsPerInlineLink = {};
  const getInteractiveResult = (link, questionAnswerId) => {
    const { searchResponseId } = getState().search;
    resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
    const linkId = getObjectHash({ ...link, questionAnswerId });
    if (linkId in interactiveResultsPerInlineLink) {
      return interactiveResultsPerInlineLink[linkId];
    }
    interactiveResultsPerInlineLink[linkId] = buildInlineLinkInteractiveResult(
      link,
      linkId,
      questionAnswerId
    );
    return interactiveResultsPerInlineLink[linkId];
  };
  return {
    selectInlineLink(link, questionAnswerId) {
      getInteractiveResult(link, questionAnswerId)?.select();
    },
    beginDelayedSelectInlineLink(link, questionAnswerId) {
      getInteractiveResult(link, questionAnswerId)?.beginDelayedSelect();
    },
    cancelPendingSelectInlineLink(link, questionAnswerId) {
      getInteractiveResult(link, questionAnswerId)?.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetInteractiveInlineLinksReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// src/controllers/smart-snippet/headless-smart-snippet.ts
function buildSmartSnippet(engine, props) {
  warnIfUsingNextAnalyticsModeForServiceFeature(
    engine.state.configuration.analytics.analyticsMode
  );
  const smartSnippet = buildCoreSmartSnippet(
    engine,
    smartSnippetAnalyticsClient,
    props
  );
  const interactiveInlineLinks = buildSmartSnippetInteractiveInlineLinks(
    engine,
    { options: { selectionDelay: props?.options?.selectionDelay } }
  );
  return {
    ...smartSnippet,
    get state() {
      return smartSnippet.state;
    },
    selectInlineLink(link) {
      interactiveInlineLinks.selectInlineLink(link);
    },
    beginDelayedSelectInlineLink(link) {
      interactiveInlineLinks.beginDelayedSelectInlineLink(link);
    },
    cancelPendingSelectInlineLink(link) {
      interactiveInlineLinks.cancelPendingSelectInlineLink(link);
    }
  };
}

// src/ssr/search/controllers/smart-snippet/headless-smart-snippet.ssr.ts
function defineSmartSnippet(props) {
  return {
    build: (engine) => buildSmartSnippet(engine, props)
  };
}

// src/controllers/core/smart-snippet-questions-list/headless-core-smart-snippet-questions-list.ts
function buildCoreSmartSnippetQuestionsList(engine, analyticsClient) {
  if (!loadSmartSnippetQuestionsListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  const getResult = (identifier) => {
    const { contentIdKey, contentIdValue } = identifier;
    return engine.state.search.results.find(
      (result) => getResultProperty(result, contentIdKey) === contentIdValue
    );
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        questions: state.search.questionAnswer.relatedQuestions.map(
          (relatedQuestion, i) => ({
            question: relatedQuestion.question,
            answer: relatedQuestion.answerSnippet,
            documentId: relatedQuestion.documentId,
            questionAnswerId: state.questionAnswering.relatedQuestions[i].questionAnswerId,
            expanded: state.questionAnswering.relatedQuestions[i].expanded,
            source: getResult(relatedQuestion.documentId)
          })
        )
      };
    },
    expand(identifier) {
      const payload = { questionAnswerId: identifier };
      engine.dispatch(analyticsClient.logExpandSmartSnippetSuggestion(payload));
      engine.dispatch(expandSmartSnippetRelatedQuestion(payload));
    },
    collapse(identifier) {
      const payload = { questionAnswerId: identifier };
      engine.dispatch(
        analyticsClient.logCollapseSmartSnippetSuggestion(payload)
      );
      engine.dispatch(collapseSmartSnippetRelatedQuestion(payload));
    }
  };
}
function loadSmartSnippetQuestionsListReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// src/controllers/smart-snippet-questions-list/headless-smart-snippet-interactive-questions.ts
function buildSmartSnippetInteractiveQuestions(engine, props) {
  if (!loadSmartSnippetInteractiveQuestionsReducer(engine)) {
    throw loadReducerError;
  }
  const getState = () => engine.state;
  const getSource = (questionAnswerId) => {
    const state = getState();
    const questionAnswer = relatedQuestionSelector(state, questionAnswerId);
    if (!questionAnswer) {
      return null;
    }
    return answerSourceSelector(state, questionAnswer.documentId);
  };
  const clickedRelatedQuestions = /* @__PURE__ */ new Set();
  const relatedQuestionWasClicked = (questionAnswerId) => {
    if (clickedRelatedQuestions.has(questionAnswerId)) {
      return true;
    }
    clickedRelatedQuestions.add(questionAnswerId);
    return false;
  };
  let lastSearchResponseId = null;
  const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
    if (lastSearchResponseId !== currentSearchResponseId) {
      lastSearchResponseId = currentSearchResponseId;
      interactiveResultsPerRelatedQuestion = {};
      clickedRelatedQuestions.clear();
    }
  };
  const buildRelatedQuestionInteractiveResult = (source, questionAnswerId) => buildInteractiveResultCore(
    engine,
    { options: { selectionDelay: props?.options?.selectionDelay } },
    () => {
      if (relatedQuestionWasClicked(questionAnswerId)) {
        return;
      }
      engine.dispatch(
        logOpenSmartSnippetSuggestionSource({
          questionAnswerId
        })
      );
      engine.dispatch(pushRecentResult(source));
    }
  );
  let interactiveResultsPerRelatedQuestion = {};
  const getInteractiveResult = (questionAnswerId) => {
    const { searchResponseId } = getState().search;
    resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
    const source = getSource(questionAnswerId);
    if (!source) {
      return null;
    }
    if (questionAnswerId in interactiveResultsPerRelatedQuestion) {
      return interactiveResultsPerRelatedQuestion[questionAnswerId];
    }
    interactiveResultsPerRelatedQuestion[questionAnswerId] = buildRelatedQuestionInteractiveResult(source, questionAnswerId);
    return interactiveResultsPerRelatedQuestion[questionAnswerId];
  };
  return {
    selectSource(questionAnswerId) {
      getInteractiveResult(questionAnswerId)?.select();
    },
    beginDelayedSelectSource(questionAnswerId) {
      getInteractiveResult(questionAnswerId)?.beginDelayedSelect();
    },
    cancelPendingSelectSource(questionAnswerId) {
      getInteractiveResult(questionAnswerId)?.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetInteractiveQuestionsReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// src/controllers/smart-snippet-questions-list/headless-smart-snippet-questions-list.ts
function buildSmartSnippetQuestionsList(engine, props) {
  warnIfUsingNextAnalyticsModeForServiceFeature(
    engine.state.configuration.analytics.analyticsMode
  );
  const smartSnippetQuestionList = buildCoreSmartSnippetQuestionsList(
    engine,
    smartSnippetAnalyticsClient
  );
  const interactiveInlineLinks = buildSmartSnippetInteractiveInlineLinks(
    engine,
    {
      options: { selectionDelay: props?.options?.selectionDelay }
    }
  );
  const interactiveQuestions = buildSmartSnippetInteractiveQuestions(engine, {
    options: { selectionDelay: props?.options?.selectionDelay }
  });
  return {
    ...smartSnippetQuestionList,
    get state() {
      return smartSnippetQuestionList.state;
    },
    selectSource(identifier) {
      interactiveQuestions.selectSource(identifier);
    },
    beginDelayedSelectSource(identifier) {
      interactiveQuestions.beginDelayedSelectSource(identifier);
    },
    cancelPendingSelectSource(identifier) {
      interactiveQuestions.cancelPendingSelectSource(identifier);
    },
    selectInlineLink(identifier, link) {
      interactiveInlineLinks.selectInlineLink(link, identifier);
    },
    beginDelayedSelectInlineLink(identifier, link) {
      interactiveInlineLinks.beginDelayedSelectInlineLink(link, identifier);
    },
    cancelPendingSelectInlineLink(identifier, link) {
      interactiveInlineLinks.cancelPendingSelectInlineLink(link, identifier);
    }
  };
}

// src/ssr/search/controllers/smart-snippet-questions-list/headless-smart-snippet-questions-list.ssr.ts
function defineSmartSnippetQuestionsList(props) {
  return {
    build: (engine) => buildSmartSnippetQuestionsList(engine, props)
  };
}

// src/controllers/core/sort/headless-core-sort.ts
var import_bueno97 = require("@coveo/bueno");
function validateSortInitialState(engine, state) {
  if (!state) {
    return;
  }
  const schema = new import_bueno97.Schema({
    criterion: new import_bueno97.ArrayValue({ each: criterionDefinition })
  });
  const criterion = getCriterionAsArray(state);
  const initialState = { ...state, criterion };
  validateInitialState(engine, schema, initialState, "buildSort");
}
function getCriterionAsArray(state) {
  if (!state.criterion) {
    return [];
  }
  return (0, import_bueno97.isArray)(state.criterion) ? state.criterion : [state.criterion];
}
function buildCoreSort(engine, props) {
  if (!loadSortReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  validateSortInitialState(engine, props.initialState);
  const criterion = props.initialState?.criterion;
  if (criterion) {
    dispatch(registerSortCriterion(criterion));
  }
  return {
    ...controller,
    sortBy(criterion2) {
      dispatch(updateSortCriterion(criterion2));
      dispatch(updatePage(1));
    },
    isSortedBy(criterion2) {
      return this.state.sortCriteria === buildCriterionExpression(criterion2);
    },
    get state() {
      return {
        sortCriteria: getState().sortCriteria
      };
    }
  };
}
function loadSortReducers(engine) {
  engine.addReducers({ configuration, sortCriteria: sortCriteriaReducer });
  return true;
}

// src/controllers/sort/headless-sort.ts
function buildSort(engine, props = {}) {
  const { dispatch } = engine;
  const sort = buildCoreSort(engine, props);
  const search = () => dispatch(
    executeSearch2({
      legacy: logResultsSort(),
      next: resultsSort()
    })
  );
  return {
    ...sort,
    get state() {
      return sort.state;
    },
    sortBy(criterion) {
      sort.sortBy(criterion);
      search();
    }
  };
}

// src/ssr/search/controllers/sort/headless-sort.ssr.ts
function defineSort(props) {
  return {
    build: (engine) => buildSort(engine, props)
  };
}

// src/features/standalone-search-box-set/standalone-search-box-set-actions.ts
var import_bueno98 = require("@coveo/bueno");
var import_toolkit108 = require("@reduxjs/toolkit");

// src/api/common/trigger.ts
function isRedirectTrigger(trigger) {
  return trigger.type === "redirect";
}

// src/api/search/plan/plan-endpoint.ts
var ExecutionPlan = class {
  constructor(response) {
    this.response = response;
  }
  /**
   * Gets the final value of the basic expression (`q`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get basicExpression() {
    return this.response.parsedInput.basicExpression;
  }
  /**
   * Gets the final value of the large expression (`lq`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get largeExpression() {
    return this.response.parsedInput.largeExpression;
  }
  /**
   * Gets the URL to redirect the browser to, if the search request satisfies the condition of a `redirect` trigger rule in the query pipeline.
   *
   * Returns `null` otherwise.
   */
  get redirectionUrl() {
    const redirects = this.response.preprocessingOutput.triggers.filter(isRedirectTrigger);
    return redirects.length ? redirects[0].content : null;
  }
};

// src/features/standalone-search-box-set/standalone-search-box-set-actions.ts
var registerStandaloneSearchBox = (0, import_toolkit108.createAction)(
  "standaloneSearchBox/register",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    redirectionUrl: requiredNonEmptyString,
    overwrite: new import_bueno98.BooleanValue({ required: false })
  })
);
var updateStandaloneSearchBoxRedirectionUrl = (0, import_toolkit108.createAction)(
  "standaloneSearchBox/updateRedirectionUrl",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString,
    redirectionUrl: requiredNonEmptyString
  })
);
var resetStandaloneSearchBox = (0, import_toolkit108.createAction)(
  "standaloneSearchBox/reset",
  (payload) => validatePayload(payload, {
    id: requiredNonEmptyString
  })
);
var updateAnalyticsToSearchFromLink = (0, import_toolkit108.createAction)(
  "standaloneSearchBox/updateAnalyticsToSearchFromLink",
  (payload) => validatePayload(payload, { id: requiredNonEmptyString })
);
var updateAnalyticsToOmniboxFromLink = (0, import_toolkit108.createAction)(
  "standaloneSearchBox/updateAnalyticsToOmniboxFromLink"
);
var fetchRedirectUrl = (0, import_toolkit108.createAsyncThunk)(
  "standaloneSearchBox/fetchRedirect",
  async (payload, {
    dispatch,
    getState,
    rejectWithValue,
    extra: { apiClient, validatePayload: validatePayload2, navigatorContext }
  }) => {
    validatePayload2(payload, { id: new import_bueno98.StringValue({ emptyAllowed: false }) });
    const request = await buildPlanRequest(getState(), navigatorContext);
    const response = await apiClient.plan(request);
    if (isErrorResponse(response)) {
      return rejectWithValue(response.error);
    }
    const { redirectionUrl } = new ExecutionPlan(response.success);
    if (redirectionUrl) {
      dispatch(logRedirect(redirectionUrl));
    }
    return redirectionUrl || "";
  }
);
var logRedirect = (url) => makeAnalyticsAction(
  "analytics/standaloneSearchBox/redirect",
  (client) => client.makeTriggerRedirect({ redirectedTo: url })
);
var buildPlanRequest = async (state, navigatorContext) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    timezone: state.configuration.search.timezone,
    q: state.query.q,
    ...state.context && { context: state.context.contextValues },
    ...state.pipeline && { pipeline: state.pipeline },
    ...state.searchHub && { searchHub: state.searchHub },
    ...state.configuration.analytics.enabled && state.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams2(
      state.configuration.analytics
    ) : fromAnalyticsStateToAnalyticsParams(
      state.configuration.analytics,
      navigatorContext
    ),
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/standalone-search-box-set/standalone-search-box-set-slice.ts
var import_toolkit109 = require("@reduxjs/toolkit");

// src/features/standalone-search-box-set/standalone-search-box-set-state.ts
function getStandaloneSearchBoxSetInitialState() {
  return {};
}

// src/features/standalone-search-box-set/standalone-search-box-set-slice.ts
var standaloneSearchBoxSetReducer = (0, import_toolkit109.createReducer)(
  getStandaloneSearchBoxSetInitialState(),
  (builder) => builder.addCase(registerStandaloneSearchBox, (state, action) => {
    const { id, redirectionUrl, overwrite } = action.payload;
    if (!overwrite && id in state) {
      return;
    }
    state[id] = buildStandaloneSearchBoxEntry(redirectionUrl);
  }).addCase(resetStandaloneSearchBox, (state, action) => {
    const { id } = action.payload;
    const searchBox = state[id];
    if (searchBox) {
      state[id] = buildStandaloneSearchBoxEntry(
        searchBox.defaultRedirectionUrl
      );
      return;
    }
  }).addCase(updateStandaloneSearchBoxRedirectionUrl, (state, action) => {
    const { id, redirectionUrl } = action.payload;
    if (!(id in state)) {
      return;
    }
    state[id] = buildStandaloneSearchBoxEntry(redirectionUrl);
  }).addCase(fetchRedirectUrl.pending, (state, action) => {
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.isLoading = true;
  }).addCase(fetchRedirectUrl.fulfilled, (state, action) => {
    const url = action.payload;
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.redirectTo = url ? url : searchBox.defaultRedirectionUrl;
    searchBox.isLoading = false;
  }).addCase(fetchRedirectUrl.rejected, (state, action) => {
    const searchBox = state[action.meta.arg.id];
    if (!searchBox) {
      return;
    }
    searchBox.isLoading = false;
  }).addCase(updateAnalyticsToSearchFromLink, (state, action) => {
    const searchBox = state[action.payload.id];
    if (!searchBox) {
      return;
    }
    searchBox.analytics.cause = "searchFromLink";
  }).addCase(updateAnalyticsToOmniboxFromLink, (state, action) => {
    const searchBox = state[action.payload.id];
    if (!searchBox) {
      return;
    }
    searchBox.analytics.cause = "omniboxFromLink";
    searchBox.analytics.metadata = action.payload.metadata;
  })
);
function buildStandaloneSearchBoxEntry(defaultRedirectionUrl) {
  return {
    defaultRedirectionUrl,
    redirectTo: "",
    isLoading: false,
    analytics: {
      cause: "",
      metadata: null
    }
  };
}

// src/controllers/standalone-search-box/headless-standalone-search-box-options.ts
var import_bueno99 = require("@coveo/bueno");
var standaloneSearchBoxSchema = new import_bueno99.Schema({
  ...searchBoxOptionDefinitions,
  redirectionUrl: new import_bueno99.StringValue({
    required: true,
    emptyAllowed: false
  }),
  overwrite: new import_bueno99.BooleanValue({
    required: false
  })
});

// src/controllers/standalone-search-box/headless-standalone-search-box.ts
function buildStandaloneSearchBox(engine, props) {
  if (!loadStandaloneSearchBoxReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const id = props.options.id || randomID("standalone_search_box");
  const options = {
    id,
    highlightOptions: { ...props.options.highlightOptions },
    ...defaultSearchBoxOptions,
    ...{ overwrite: false },
    ...props.options
  };
  validateOptions(
    engine,
    standaloneSearchBoxSchema,
    options,
    "buildStandaloneSearchBox"
  );
  const searchBox = buildSearchBox(engine, { options });
  dispatch(
    registerStandaloneSearchBox({
      id,
      redirectionUrl: options.redirectionUrl,
      overwrite: options.overwrite
    })
  );
  return {
    ...searchBox,
    updateText(value) {
      searchBox.updateText(value);
      dispatch(updateAnalyticsToSearchFromLink({ id }));
    },
    selectSuggestion(value) {
      const metadata = buildOmniboxSuggestionMetadata(getState(), {
        id,
        suggestion: value
      });
      dispatch(selectQuerySuggestion2({ id, expression: value }));
      dispatch(updateAnalyticsToOmniboxFromLink({ id, metadata }));
      this.submit();
    },
    afterRedirection() {
      dispatch(resetStandaloneSearchBox({ id }));
    },
    updateRedirectUrl(url) {
      dispatch(
        updateStandaloneSearchBoxRedirectionUrl({ id, redirectionUrl: url })
      );
    },
    submit() {
      dispatch(
        updateQuery({
          q: this.state.value,
          enableQuerySyntax: options.enableQuerySyntax
        })
      );
      dispatch(fetchRedirectUrl({ id }));
    },
    get state() {
      const state = getState();
      const standaloneSearchBoxState = state.standaloneSearchBoxSet[id];
      return {
        ...searchBox.state,
        isLoading: standaloneSearchBoxState.isLoading,
        redirectTo: standaloneSearchBoxState.redirectTo,
        analytics: standaloneSearchBoxState.analytics
      };
    }
  };
}
function loadStandaloneSearchBoxReducers(engine) {
  engine.addReducers({
    standaloneSearchBoxSet: standaloneSearchBoxSetReducer,
    configuration,
    query: queryReducer,
    querySuggest: querySuggestReducer
  });
  return true;
}

// src/ssr/search/controllers/standalone-search-box/headless-standalone-search-box.ssr.ts
function defineStandaloneSearchBox(props) {
  return {
    build: (engine) => buildStandaloneSearchBox(engine, props)
  };
}

// src/controllers/static-filter/headless-static-filter.ts
var import_bueno100 = require("@coveo/bueno");

// src/controllers/static-filter/static-filter-value.ts
function buildStaticFilterValue(config) {
  return {
    state: "idle",
    ...config
  };
}

// src/controllers/static-filter/headless-static-filter.ts
var optionsSchema7 = new import_bueno100.Schema({
  id: staticFilterIdSchema,
  values: staticFilterValuesSchema
});
function buildStaticFilter(engine, props) {
  if (!loadReducers2(engine)) {
    throw loadReducerError;
  }
  validateOptions(engine, optionsSchema7, props.options, "buildStaticFilter");
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const { id } = props.options;
  dispatch(registerStaticFilter(props.options));
  return {
    ...controller,
    toggleSelect(value) {
      dispatch(toggleSelectStaticFilterValue({ id, value }));
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggledValue(id, value)
        })
      );
    },
    toggleSingleSelect(value) {
      if (value.state === "idle") {
        dispatch(deselectAllStaticFilterValues(id));
      }
      dispatch(toggleSelectStaticFilterValue({ id, value }));
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggledValue(id, value)
        })
      );
    },
    toggleExclude(value) {
      dispatch(toggleExcludeStaticFilterValue({ id, value }));
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggledValue(id, value)
        })
      );
    },
    toggleSingleExclude(value) {
      if (value.state === "idle") {
        dispatch(deselectAllStaticFilterValues(id));
      }
      dispatch(toggleExcludeStaticFilterValue({ id, value }));
      dispatch(
        executeSearch2({
          legacy: getLegacyAnalyticsActionForToggledValue(id, value)
        })
      );
    },
    deselectAll() {
      dispatch(deselectAllStaticFilterValues(id));
      dispatch(
        executeSearch2({
          legacy: logStaticFilterClearAll({ staticFilterId: id })
        })
      );
    },
    isValueSelected(value) {
      return value.state === "selected";
    },
    isValueExcluded(value) {
      return value.state === "excluded";
    },
    get state() {
      const values = getState().staticFilterSet[id]?.values || [];
      const hasActiveValues = values.some((value) => value.state !== "idle");
      return {
        id,
        values,
        hasActiveValues
      };
    }
  };
}
function loadReducers2(engine) {
  engine.addReducers({ staticFilterSet: staticFilterSetReducer });
  return true;
}
function getLegacyAnalyticsActionForToggledValue(id, value) {
  const { caption, expression, state } = value;
  const analytics = state === "idle" ? logStaticFilterSelect : logStaticFilterDeselect;
  return analytics({
    staticFilterId: id,
    staticFilterValue: { caption, expression }
  });
}

// src/ssr/search/controllers/static-filter/headless-static-filter.ssr.ts
function defineStaticFilter(props) {
  return {
    build: (engine) => buildStaticFilter(engine, props)
  };
}

// src/controllers/core/tab/headless-core-tab.ts
var import_bueno101 = require("@coveo/bueno");
var optionsSchema8 = new import_bueno101.Schema({
  expression: requiredEmptyAllowedString,
  id: requiredNonEmptyString,
  clearFiltersOnTabChange: new import_bueno101.BooleanValue()
});
var initialStateSchema8 = new import_bueno101.Schema({
  isActive: new import_bueno101.BooleanValue()
});
function buildCoreTab(engine, props) {
  assertIdNotEqualToDefaultOriginLevel2(props.options.id);
  if (!loadTabReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  validateOptions(engine, optionsSchema8, props.options, "buildTab");
  const initialState = validateInitialState(
    engine,
    initialStateSchema8,
    props.initialState,
    "buildTab"
  );
  const { id, expression } = props.options;
  dispatch(registerTab({ id, expression }));
  const isFirstTab = Object.keys(engine.state.tabSet).length === 1;
  if (isFirstTab) {
    initialState.isActive = true;
  }
  if (initialState.isActive) {
    dispatch(updateActiveTab(id));
  }
  return {
    ...controller,
    select() {
      if (props.options.clearFiltersOnTabChange) {
        dispatch(
          prepareForSearchWithQuery({
            q: "",
            clearFilters: true
          })
        );
      }
      dispatch(updateActiveTab(id));
    },
    get state() {
      const isActive = engine.state.tabSet[id]?.isActive;
      return {
        isActive
      };
    }
  };
}
function loadTabReducers(engine) {
  engine.addReducers({ configuration, tabSet: tabSetReducer });
  return true;
}
function assertIdNotEqualToDefaultOriginLevel2(id) {
  const defaultOriginLevel2 = getConfigurationInitialState().analytics.originLevel2;
  if (id === defaultOriginLevel2) {
    throw new Error(
      `The #id option on the Tab controller cannot use the reserved value "${defaultOriginLevel2}". Please specify a different value.`
    );
  }
}

// src/controllers/tab/headless-tab.ts
function buildTab(engine, props) {
  const { dispatch } = engine;
  const tab = buildCoreTab(engine, props);
  const search = () => dispatch(
    executeSearch2({
      legacy: logInterfaceChange(),
      next: interfaceChange()
    })
  );
  return {
    ...tab,
    get state() {
      return tab.state;
    },
    select() {
      tab.select();
      search();
    }
  };
}

// src/ssr/search/controllers/tab/headless-tab.ssr.ts
function defineTab(props) {
  return {
    build: (engine) => buildTab(engine, props)
  };
}

// src/controllers/core/tab-manager/headless-core-tab-manager.ts
var import_toolkit110 = require("@reduxjs/toolkit");
function buildCoreTabManager(engine) {
  if (!loadTabReducers2(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const currentTab = (0, import_toolkit110.createSelector)(
    (state) => state.tabSet,
    (state) => {
      const activeTab = Object.values(state).find((tab) => tab.isActive);
      return activeTab?.id ?? "";
    }
  );
  return {
    ...controller,
    get state() {
      return { activeTab: currentTab(engine.state) };
    }
  };
}
function loadTabReducers2(engine) {
  engine.addReducers({ tabSet: tabSetReducer });
  return true;
}

// src/controllers/tab-manager/headless-tab-manager.ts
function buildTabManager(engine) {
  const tabManager = buildCoreTabManager(engine);
  return {
    ...tabManager,
    get state() {
      return tabManager.state;
    }
  };
}

// src/ssr/search/controllers/tab-manager/headless-tab-manager.ssr.ts
function defineTabManager() {
  return {
    build: (engine) => buildTabManager(engine)
  };
}

// src/features/triggers/triggers-slice.ts
var import_toolkit111 = require("@reduxjs/toolkit");

// src/features/triggers/triggers-slice-functions.ts
function handleFetchItemsPending(state) {
  state.query = "";
  state.queryModification = {
    originalQuery: "",
    newQuery: "",
    queryToIgnore: state.queryModification.queryToIgnore
  };
  return state;
}
function handleFetchItemsFulfilled(state, triggers) {
  const redirectTriggers = [];
  const queryTriggers = [];
  const executeTriggers = [];
  const notifyTriggers = [];
  triggers.forEach((trigger) => {
    switch (trigger.type) {
      case "redirect":
        redirectTriggers.push(trigger.content);
        break;
      case "query":
        queryTriggers.push(trigger.content);
        break;
      case "execute":
        executeTriggers.push({
          functionName: trigger.content.name,
          params: trigger.content.params
        });
        break;
      case "notify":
        notifyTriggers.push(trigger.content);
        break;
    }
  });
  state.redirectTo = redirectTriggers[0] ?? "";
  state.query = state.queryModification.newQuery;
  state.executions = executeTriggers;
  state.notifications = notifyTriggers;
  return state;
}
function handleApplyQueryTriggerModification(state, payload) {
  state.queryModification = { ...payload, queryToIgnore: "" };
  return state;
}
function handleUpdateIgnoreQueryTrigger(state, payload) {
  state.queryModification.queryToIgnore = payload;
  return state;
}

// src/features/triggers/triggers-state.ts
var getTriggerInitialState = () => ({
  redirectTo: "",
  query: "",
  executions: [],
  notifications: [],
  queryModification: { originalQuery: "", newQuery: "", queryToIgnore: "" }
});

// src/features/triggers/triggers-slice.ts
var triggerReducer = (0, import_toolkit111.createReducer)(
  getTriggerInitialState(),
  (builder) => builder.addCase(executeSearch2.pending, handleFetchItemsPending).addCase(
    executeSearch2.fulfilled,
    (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)
  ).addCase(
    applyQueryTriggerModification,
    (state, action) => handleApplyQueryTriggerModification(state, action.payload)
  ).addCase(
    updateIgnoreQueryTrigger,
    (state, action) => handleUpdateIgnoreQueryTrigger(state, action.payload)
  )
);

// src/controllers/triggers/headless-execute-trigger.ts
function buildExecuteTrigger(engine) {
  if (!loadExecuteTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousExecutions = getState().triggers.executions;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(
          this.state.executions,
          previousExecutions,
          (first, second) => first.functionName === second.functionName && arrayEqual(first.params, second.params)
        );
        previousExecutions = this.state.executions;
        if (hasChanged && this.state.executions.length) {
          listener();
          dispatch(logTriggerExecute());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        executions: getState().triggers.executions
      };
    }
  };
}
function loadExecuteTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}

// src/ssr/search/controllers/triggers/headless-execute-trigger.ssr.ts
function defineExecuteTrigger() {
  return {
    build: (engine) => buildExecuteTrigger(engine)
  };
}

// src/controllers/core/triggers/headless-core-notify-trigger.ts
function buildCoreNotifyTrigger(engine, props) {
  const logNotifyTrigger2 = props.options.logNotifyTriggerActionCreator;
  if (!loadNotifyTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousNotifications = getState().triggers.notifications;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(
          previousNotifications,
          this.state.notifications
        );
        previousNotifications = this.state.notifications;
        if (hasChanged) {
          listener();
          dispatch(logNotifyTrigger2());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        notifications: getState().triggers.notifications
      };
    }
  };
}
function loadNotifyTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}

// src/controllers/triggers/headless-notify-trigger.ts
function buildNotifyTrigger(engine) {
  return buildCoreNotifyTrigger(engine, {
    options: {
      logNotifyTriggerActionCreator: logNotifyTrigger
    }
  });
}

// src/ssr/search/controllers/triggers/headless-notify-trigger.ssr.ts
function defineNotifyTrigger() {
  return {
    build: (engine) => buildNotifyTrigger(engine)
  };
}

// src/controllers/triggers/headless-query-trigger.ts
function buildQueryTrigger(engine) {
  if (!loadQueryTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const modification = () => getState().triggers.queryModification.newQuery;
  const originalQuery = () => getState().triggers.queryModification.originalQuery;
  return {
    ...controller,
    get state() {
      return {
        newQuery: modification(),
        originalQuery: originalQuery(),
        wasQueryModified: modification() !== ""
      };
    },
    undo() {
      dispatch(updateIgnoreQueryTrigger(modification()));
      dispatch(updateQuery({ q: originalQuery() }));
      dispatch(
        executeSearch2({
          legacy: logUndoTriggerQuery({
            undoneQuery: modification()
          })
        })
      );
    }
  };
}
function loadQueryTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer, query: queryReducer });
  return true;
}

// src/ssr/search/controllers/triggers/headless-query-trigger.ssr.ts
function defineQueryTrigger() {
  return {
    build: (engine) => buildQueryTrigger(engine)
  };
}

// src/controllers/triggers/headless-redirection-trigger.ts
function buildRedirectionTrigger(engine) {
  if (!loadRedirectionReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousRedirectTo = getState().triggers.redirectTo;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = previousRedirectTo !== this.state.redirectTo;
        previousRedirectTo = this.state.redirectTo;
        if (hasChanged && this.state.redirectTo) {
          listener();
          dispatch(logTriggerRedirect());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        redirectTo: getState().triggers.redirectTo
      };
    }
  };
}
function loadRedirectionReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}

// src/ssr/search/controllers/triggers/headless-redirection-trigger.ssr.ts
function defineRedirectionTrigger() {
  return {
    build: (engine) => buildRedirectionTrigger(engine)
  };
}

// src/controllers/url-manager/headless-url-manager.ts
var import_bueno103 = require("@coveo/bueno");

// src/features/search-parameters/search-parameter-serializer.ts
var import_bueno102 = require("@coveo/bueno");
var rangeDelimiterExclusive = "..";
var rangeDelimiterInclusive = "...";
var facetSearchParamRegex = /^(f|fExcluded|cf|nf|df|sf|af|mnf)-(.+)$/;
var supportedFacetParameters = {
  f: true,
  fExcluded: true,
  cf: true,
  sf: true,
  af: true,
  nf: true,
  df: true,
  mnf: true
};
var delimiter = "&";
var equal = "=";
function buildSearchParameterSerializer() {
  return { serialize: serialize(serializePair), deserialize };
}
function keyHasObjectValue(key) {
  return key in supportedFacetParameters;
}
function isValidBasicKey(key) {
  const supportedBasicParameters = {
    q: true,
    aq: true,
    cq: true,
    enableQuerySyntax: true,
    firstResult: true,
    numberOfResults: true,
    sortCriteria: true,
    debug: true,
    tab: true
  };
  return key in supportedBasicParameters;
}
function isRangeFacetKey(key) {
  const supportedRangeFacetParameters = {
    nf: true,
    df: true,
    mnf: true
  };
  const isRangeFacet = key in supportedRangeFacetParameters;
  return keyHasObjectValue(key) && isRangeFacet;
}
function isValidKey(key) {
  return isValidBasicKey(key) || keyHasObjectValue(key);
}
var serialize = (pairSerializer) => (obj) => {
  return Object.entries(obj).map(pairSerializer).filter((str) => str).join(delimiter);
};
function serializePair(pair) {
  const [key, val] = pair;
  if (!isValidKey(key)) {
    return "";
  }
  if (keyHasObjectValue(key) && !isRangeFacetKey(key)) {
    return isFacetObject(val) ? serializeFacets(key, val) : "";
  }
  if (key === "nf" || key === "df") {
    return isRangeFacetObject(val) ? serializeRangeFacets(key, val) : "";
  }
  return serializeSpecialCharacters(key, val);
}
function serializeSpecialCharacters(key, val) {
  return `${key}${equal}${encodeURIComponent(
    val
  )}`;
}
function isFacetObject(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isValidValue = (v) => typeof v === "string";
  return allEntriesAreValid(obj, isValidValue);
}
function isRangeFacetObject(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isRangeValue = (v) => isObject2(v) && "start" in v && "end" in v;
  return allEntriesAreValid(obj, isRangeValue);
}
function isObject2(obj) {
  return !!(obj && typeof obj === "object");
}
function allEntriesAreValid(obj, isValidValue) {
  const invalidEntries = Object.entries(obj).filter((entry) => {
    const values = entry[1];
    return !Array.isArray(values) || !values.every(isValidValue);
  });
  return invalidEntries.length === 0;
}
function serializeFacets(key, facets) {
  return Object.entries(facets).map(
    ([facetId2, values]) => `${key}-${facetId2}${equal}${values.map((value) => encodeURIComponent(value)).join(",")}`
  ).join(delimiter);
}
function serializeRangeFacets(key, facets) {
  return Object.entries(facets).map(([facetId2, ranges]) => {
    const value = ranges.map(
      ({ start, end, endInclusive }) => `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`
    ).join(",");
    return `${key}-${facetId2}${equal}${value}`;
  }).join(delimiter);
}
function deserialize(fragment) {
  const parts = fragment.split(delimiter);
  const keyValuePairs = parts.map((part) => splitOnFirstEqual(part)).map((parts2) => preprocessObjectPairs(parts2)).filter(isValidPair).map((pair) => cast(pair));
  return keyValuePairs.reduce((acc, pair) => {
    const [key, val] = pair;
    if (keyHasObjectValue(key)) {
      const mergedValues = { ...acc[key], ...val };
      return { ...acc, [key]: mergedValues };
    }
    return { ...acc, [key]: val };
  }, {});
}
function splitOnFirstEqual(str) {
  const [first, ...rest] = str.split(equal);
  const second = rest.join(equal);
  return [first, second];
}
function preprocessObjectPairs(pair, regex = facetSearchParamRegex) {
  const [key, val] = pair;
  const result = regex.exec(key);
  if (!result) {
    return pair;
  }
  const paramKey = result[1];
  const id = result[2];
  const values = val.split(",");
  const processedValues = processObjectValues(paramKey, values);
  const obj = { [id]: processedValues };
  return [paramKey, JSON.stringify(obj)];
}
function processObjectValues(key, values) {
  if (key === "nf" || key === "mnf") {
    return buildNumericRanges(values, "selected");
  }
  if (key === "df") {
    return buildDateRanges(values, "selected");
  }
  return values;
}
function buildNumericRanges(ranges, state) {
  const numericRanges = [];
  for (const range of ranges) {
    const { startAsString, endAsString, isEndInclusive } = splitRangeValueAsStringByDelimiter(range);
    const start = parseFloat(startAsString);
    const end = parseFloat(endAsString);
    if (!Number.isFinite(start) || !Number.isFinite(end)) {
      continue;
    }
    numericRanges.push(
      buildNumericRange({ start, end, state, endInclusive: isEndInclusive })
    );
  }
  return numericRanges;
}
function isValidDateRangeValue(date) {
  try {
    if (isSearchApiDate(date)) {
      validateAbsoluteDate(date, API_DATE_FORMAT);
      return true;
    }
    if (isRelativeDateFormat(date)) {
      validateRelativeDate(date);
      return true;
    }
    return false;
  } catch (_) {
    return false;
  }
}
function buildDateRanges(ranges, state) {
  const dateRanges = [];
  for (const range of ranges) {
    const { isEndInclusive, startAsString, endAsString } = splitRangeValueAsStringByDelimiter(range);
    if (!isValidDateRangeValue(startAsString) || !isValidDateRangeValue(endAsString)) {
      continue;
    }
    dateRanges.push(
      buildDateRange({
        start: startAsString,
        end: endAsString,
        state,
        endInclusive: isEndInclusive
      })
    );
  }
  return dateRanges;
}
function isValidPair(pair) {
  const validKey = isValidKey(pair[0]);
  const lengthOfTwo = pair.length === 2;
  return validKey && lengthOfTwo;
}
function cast(pair, decode = true) {
  const [key, value] = pair;
  if (key === "enableQuerySyntax") {
    return [key, value === "true"];
  }
  if (key === "debug") {
    return [key, value === "true"];
  }
  if (key === "firstResult") {
    return [key, parseInt(value)];
  }
  if (key === "numberOfResults") {
    return [key, parseInt(value)];
  }
  if (keyHasObjectValue(key)) {
    return [key, castUnknownObject(value)];
  }
  return [key, decode ? decodeURIComponent(value) : value];
}
function castUnknownObject(value) {
  const jsonParsed = JSON.parse(value);
  const ret = {};
  Object.entries(jsonParsed).forEach((entry) => {
    const [id, values] = entry;
    ret[id] = values.map((v) => (0, import_bueno102.isString)(v) ? decodeURIComponent(v) : v);
  });
  return ret;
}
function splitRangeValueAsStringByDelimiter(str) {
  const isEndInclusive = str.indexOf(rangeDelimiterInclusive) !== -1;
  const [startAsString, endAsString] = str.split(
    isEndInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive
  );
  return {
    isEndInclusive,
    startAsString,
    endAsString
  };
}

// src/controllers/url-manager/headless-url-manager.ts
var initialStateSchema9 = new import_bueno103.Schema({
  fragment: new import_bueno103.StringValue()
});
function buildUrlManager(engine, props) {
  let lastRequestId;
  function updateLastRequestId() {
    lastRequestId = engine.state.search.requestId;
  }
  function hasRequestIdChanged() {
    return lastRequestId !== engine.state.search.requestId;
  }
  if (!loadUrlManagerReducers(engine)) {
    throw loadReducerError;
  }
  validateInitialState(
    engine,
    initialStateSchema9,
    props.initialState,
    "buildUrlManager"
  );
  const controller = buildController(engine);
  let previousFragment = props.initialState.fragment;
  updateLastRequestId();
  const searchParameterManager = buildSearchParameterManager(engine, {
    initialState: {
      parameters: deserializeFragment(previousFragment)
    }
  });
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const newFragment = this.state.fragment;
        if (!areFragmentsEquivalent(previousFragment, newFragment) && hasRequestIdChanged()) {
          previousFragment = newFragment;
          listener();
        }
        updateLastRequestId();
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        fragment: buildSearchParameterSerializer().serialize(
          searchParameterManager.state.parameters
        )
      };
    },
    synchronize(fragment) {
      previousFragment = fragment;
      const parameters = deserializeFragment(fragment);
      searchParameterManager.synchronize(parameters);
    }
  };
}
function areFragmentsEquivalent(fragment1, fragment2) {
  if (fragment1 === fragment2) {
    return true;
  }
  const params1 = deserializeFragment(fragment1);
  const params2 = deserializeFragment(fragment2);
  return deepEqualAnyOrder(params1, params2);
}
function deserializeFragment(fragment) {
  return buildSearchParameterSerializer().deserialize(fragment);
}
function loadUrlManagerReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}

// src/ssr/search/controllers/url-manager/headless-url-manager.ssr.ts
var defineUrlManager = () => ({
  buildWithProps: (engine, props) => {
    if (props === void 0) {
      throw new MissingControllerProps("UrlManager");
    }
    return buildUrlManager(engine, { initialState: props.initialState });
  }
});

// src/features/configuration/configuration-actions-loader.ts
function loadConfigurationActions(engine) {
  engine.addReducers({ configuration });
  return {
    disableAnalytics,
    enableAnalytics,
    setOriginLevel2,
    setOriginLevel3,
    updateAnalyticsConfiguration,
    updateBasicConfiguration
  };
}

// src/ssr/common/access-token-manager.ts
function createAccessTokenManager(initialToken) {
  const tokenChangeCallbacks = /* @__PURE__ */ new Set();
  let queuedToken = null;
  let currentAccessToken = initialToken;
  return {
    /**
     * Gets the current access token.
     */
    getAccessToken() {
      return currentAccessToken;
    },
    /**
     * Sets the access token, updating both configuration and active engines.
     */
    setAccessToken(accessToken) {
      currentAccessToken = accessToken;
      if (tokenChangeCallbacks.size > 0) {
        tokenChangeCallbacks.forEach((callback) => {
          callback(accessToken);
        });
        queuedToken = null;
      } else {
        queuedToken = accessToken;
      }
    },
    /**
     * Registers a callback function to be invoked when the access token changes.
     * If there's a queued token, the callback will be invoked immediately.
     */
    registerCallback(callback) {
      tokenChangeCallbacks.add(callback);
      if (queuedToken) {
        callback(queuedToken);
        queuedToken = null;
      }
    }
  };
}

// src/ssr/common/augment-preprocess-request.ts
var AUGMENTED_MARKER = Symbol("augmentedWithForwardedFor");
function augmentPreprocessRequestWithForwardedFor(options) {
  const originalPreprocessRequest = options.preprocessRequest;
  if (originalPreprocessRequest?.[AUGMENTED_MARKER]) {
    return originalPreprocessRequest;
  }
  const augmentedFunction = async (request, clientOrigin, metadata) => {
    if (!isBrowser2()) {
      const headers = new Headers(request.headers);
      const forwardedFor = options.navigatorContextProvider?.()?.forwardedFor;
      if (forwardedFor) {
        headers.set("x-forwarded-for", forwardedFor);
      } else {
        const logger = buildLogger(options.loggerOptions);
        logger.warn(
          "[WARNING] Unable to set x-forwarded-for header. Make sure to set the 'forwardedFor' property in the navigator context provider."
        );
      }
      request.headers = headers;
    }
    if (originalPreprocessRequest) {
      return originalPreprocessRequest(request, clientOrigin, metadata);
    }
    return request;
  };
  augmentedFunction[AUGMENTED_MARKER] = true;
  return augmentedFunction;
}

// src/ssr/common/controller-utils.ts
function buildControllerFromDefinition({
  definition: definition4,
  engine,
  props
}) {
  return "build" in definition4 ? definition4.build(engine) : definition4.buildWithProps(engine, props);
}
function buildControllerDefinitions({
  definitionsMap,
  engine,
  propsMap
}) {
  return mapObject(
    definitionsMap,
    (definition4, key) => buildControllerFromDefinition({
      definition: definition4,
      engine,
      props: propsMap?.[key]
    })
  );
}
function createStaticState({
  searchAction,
  controllers
}) {
  return {
    controllers: mapObject(controllers, (controller) => ({
      state: clone(controller.state)
    })),
    searchAction: clone(searchAction)
  };
}
function composeFunction(parentFunction, children) {
  const newFunction = (...params) => parentFunction(...params);
  for (const [key, value] of Object.entries(children)) {
    newFunction[key] = value;
  }
  return newFunction;
}

// src/ssr/search/engine/search-engine.ssr.ts
function isSearchCompletedAction(action) {
  return /^search\/executeSearch\/(fulfilled|rejected)$/.test(
    action.type
  );
}
function buildSSRSearchEngine(options) {
  const { middleware, promise } = createWaitForActionMiddleware(
    isSearchCompletedAction
  );
  const searchEngine = buildSearchEngine({
    ...options,
    middlewares: [...options.middlewares ?? [], middleware]
  });
  return {
    ...searchEngine,
    get state() {
      return searchEngine.state;
    },
    waitForSearchCompletedAction() {
      return promise;
    }
  };
}
function defineSearchEngine(options) {
  const { controllers: controllerDefinitions, ...engineOptions } = options;
  const tokenManager = createAccessTokenManager(
    engineOptions.configuration.accessToken
  );
  const getOptions = () => {
    return engineOptions;
  };
  const setNavigatorContextProvider = (navigatorContextProvider) => {
    engineOptions.navigatorContextProvider = navigatorContextProvider;
  };
  const getAccessToken = () => tokenManager.getAccessToken();
  const setAccessToken = (accessToken) => {
    engineOptions.configuration.accessToken = accessToken;
    tokenManager.setAccessToken(accessToken);
  };
  const build = async (...[buildOptions2]) => {
    const logger = buildLogger(options.loggerOptions);
    if (!getOptions().navigatorContextProvider) {
      logger.warn(
        "[WARNING] Missing navigator context in server-side code. Make sure to set it with `setNavigatorContextProvider` before calling fetchStaticState()"
      );
    }
    const engine = buildSSRSearchEngine(
      buildOptions2?.extend ? await buildOptions2.extend(getOptions()) : getOptions()
    );
    const updateEngineConfiguration = (accessToken) => {
      const { updateBasicConfiguration: updateBasicConfiguration2 } = loadConfigurationActions(engine);
      engine.dispatch(
        updateBasicConfiguration2({
          accessToken
        })
      );
    };
    tokenManager.registerCallback(updateEngineConfiguration);
    const controllers = buildControllerDefinitions({
      definitionsMap: controllerDefinitions ?? {},
      engine,
      propsMap: buildOptions2 && "controllers" in buildOptions2 ? buildOptions2.controllers : {}
    });
    return {
      engine,
      controllers
    };
  };
  const fetchStaticState = composeFunction(
    async (...params) => {
      engineOptions.configuration.preprocessRequest = augmentPreprocessRequestWithForwardedFor({
        preprocessRequest: engineOptions.configuration.preprocessRequest,
        navigatorContextProvider: engineOptions.navigatorContextProvider,
        loggerOptions: engineOptions.loggerOptions
      });
      const buildResult = await build(...params);
      const staticState = await fetchStaticState.fromBuildResult({
        buildResult
      });
      return staticState;
    },
    {
      fromBuildResult: async (...params) => {
        const [
          {
            buildResult: { engine, controllers }
          }
        ] = params;
        engine.executeFirstSearch();
        return createStaticState({
          searchAction: await engine.waitForSearchCompletedAction(),
          controllers
        });
      }
    }
  );
  const hydrateStaticState = composeFunction(
    async (...params) => {
      const buildResult = await build(...params);
      const staticState = await hydrateStaticState.fromBuildResult({
        buildResult,
        searchAction: params[0].searchAction
      });
      return staticState;
    },
    {
      fromBuildResult: async (...params) => {
        const [
          {
            buildResult: { engine, controllers },
            searchAction
          }
        ] = params;
        engine.dispatch(searchAction);
        await engine.waitForSearchCompletedAction();
        return { engine, controllers };
      }
    }
  );
  return {
    build,
    fetchStaticState,
    hydrateStaticState,
    setNavigatorContextProvider,
    getAccessToken,
    setAccessToken
  };
}

// src/features/advanced-search-queries/advanced-search-queries-actions-loader.ts
function loadAdvancedSearchQueryActions(engine) {
  engine.addReducers({ advancedSearchQueries: advancedSearchQueriesReducer });
  return {
    updateAdvancedSearchQueries,
    registerAdvancedSearchQueries
  };
}

// src/features/result/result-analytics-actions.ts
var logDocumentOpen = (result) => makeAnalyticsAction({
  prefix: "analytics/result/open",
  __legacy__getBuilder: (client, state) => {
    validateResultPayload(result);
    return client.makeDocumentOpen(
      partialDocumentInformation(result, state),
      documentIdentifier(result)
    );
  },
  analyticsType: "itemClick",
  analyticsPayloadBuilder: (state) => {
    const docInfo = partialDocumentInformation(result, state);
    const docId = documentIdentifier(result);
    return {
      responseId: result.searchUid ?? "",
      position: docInfo.documentPosition,
      itemMetadata: {
        uniqueFieldName: docId.contentIDKey,
        uniqueFieldValue: docId.contentIDValue,
        title: docInfo.documentTitle,
        author: docInfo.documentAuthor,
        url: docInfo.documentUrl
      }
    };
  }
});

// src/features/analytics/click-analytics-actions-loader.ts
function loadClickAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logDocumentOpen,
    logOpenSmartSnippetSource,
    logOpenSmartSnippetSuggestionSource,
    logOpenSmartSnippetInlineLink,
    logOpenSmartSnippetSuggestionInlineLink
  };
}

// src/features/analytics/generic-analytics-actions-loader.ts
function loadGenericAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logSearchEvent,
    logClickEvent,
    logCustomEvent
  };
}

// src/features/analytics/search-analytics-actions-loader.ts
function loadSearchAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logClearBreadcrumbs,
    logInterfaceLoad,
    logSearchFromLink,
    logOmniboxFromLink,
    logInterfaceChange,
    logDidYouMeanClick,
    logCategoryFacetBreadcrumb,
    logFacetBreadcrumb,
    logFacetClearAll,
    logFacetUnexclude,
    logFacetExclude,
    logFacetDeselect,
    logFacetSelect,
    logFacetShowLess,
    logFacetShowMore,
    logFacetUpdateSort,
    logDateFacetBreadcrumb,
    logNumericFacetBreadcrumb,
    logNavigateBackward,
    logNavigateForward,
    logPageNext,
    logPageNumber,
    logPagePrevious,
    logPagerResize,
    logSearchboxSubmit,
    logQuerySuggestionClick,
    logResultsSort,
    logDislikeSmartSnippet,
    logLikeSmartSnippet,
    logOpenSmartSnippetFeedbackModal,
    logCloseSmartSnippetFeedbackModal,
    logSmartSnippetFeedback,
    logSmartSnippetDetailedFeedback,
    logExpandSmartSnippet,
    logCollapseSmartSnippet,
    logExpandSmartSnippetSuggestion,
    logCollapseSmartSnippetSuggestion,
    logNoResultsBack,
    logStaticFilterSelect,
    logStaticFilterDeselect,
    logStaticFilterClearAll,
    logTriggerQuery,
    logUndoTriggerQuery,
    logNotifyTrigger,
    logTriggerRedirect,
    logTriggerExecute
  };
}

// src/features/breadcrumb/breadcrumb-actions-loader.ts
function loadBreadcrumbActions(engine) {
  engine.addReducers({});
  return {
    deselectAllBreadcrumbs,
    deselectAllNonBreadcrumbs
  };
}

// src/features/configuration/search-configuration-actions-loader.ts
function loadSearchConfigurationActions(engine) {
  engine.addReducers({ configuration, pipeline: pipelineReducer, searchHub: searchHubReducer });
  return {
    updateSearchConfiguration
  };
}

// src/features/context/context-actions-loader.ts
function loadContextActions(engine) {
  engine.addReducers({ context: contextReducer });
  return {
    addContext,
    removeContext,
    setContext
  };
}

// src/features/debug/debug-actions-loader.ts
function loadDebugActions(engine) {
  engine.addReducers({ debug: debugReducer });
  return {
    disableDebug,
    enableDebug
  };
}

// src/features/dictionary-field-context/dictionary-field-context-actions-loader.ts
function loadDictionaryFieldContextActions(engine) {
  engine.addReducers({ dictionaryFieldContext: dictionaryFieldContextReducer });
  return {
    addContext: addContext2,
    removeContext: removeContext2,
    setContext: setContext2
  };
}

// src/features/did-you-mean/did-you-mean-actions-loader.ts
function loadDidYouMeanActions(engine) {
  engine.addReducers({ didYouMean: didYouMeanReducer, query: queryReducer });
  return {
    applyDidYouMeanCorrection,
    disableDidYouMean,
    enableDidYouMean,
    enableAutomaticQueryCorrection,
    disableAutomaticQueryCorrection,
    setCorrectionMode
  };
}

// src/features/excerpt-length/excerpt-length-slice.ts
var import_toolkit113 = require("@reduxjs/toolkit");

// src/features/excerpt-length/excerpt-length-actions.ts
var import_bueno104 = require("@coveo/bueno");
var import_toolkit112 = require("@reduxjs/toolkit");
var setExcerptLength = (0, import_toolkit112.createAction)(
  "excerptLength/set",
  (length) => validatePayload(length, new import_bueno104.NumberValue({ min: 0, required: true }))
);

// src/features/excerpt-length/excerpt-length-state.ts
function getExcerptLengthInitialState() {
  return {
    length: void 0
  };
}

// src/features/excerpt-length/excerpt-length-slice.ts
var excerptLengthReducer = (0, import_toolkit113.createReducer)(
  getExcerptLengthInitialState(),
  (builder) => {
    builder.addCase(setExcerptLength, (state, action) => {
      state.length = action.payload;
    });
  }
);

// src/features/excerpt-length/excerpt-length-actions-loader.ts
function loadExcerptLengthActions(engine) {
  engine.addReducers({ excerptLength: excerptLengthReducer });
  return {
    setExcerptLength
  };
}

// src/features/facet-options/facet-options-actions-loader.ts
function loadFacetOptionsActions(engine) {
  engine.addReducers({ facetOptions: facetOptionsReducer });
  return {
    updateFacetOptions,
    enableFacet,
    disableFacet
  };
}

// src/features/facets/category-facet-set/category-facet-set-actions-loader.ts
function loadCategoryFacetSetActions(engine) {
  engine.addReducers({ categoryFacetSet: categoryFacetSetReducer });
  return {
    deselectAllCategoryFacetValues,
    registerCategoryFacet,
    toggleSelectCategoryFacetValue,
    updateCategoryFacetNumberOfValues,
    updateCategoryFacetSortCriterion,
    updateFacetAutoSelection,
    updateCategoryFacetBasePath
  };
}

// src/features/facets/facet-set/facet-set-actions-loader.ts
function loadFacetSetActions(engine) {
  engine.addReducers({ facetSet: facetSetReducer });
  return {
    deselectAllFacetValues,
    registerFacet,
    toggleSelectFacetValue,
    toggleExcludeFacetValue,
    updateFacetIsFieldExpanded,
    updateFacetNumberOfValues,
    updateFacetSortCriterion,
    updateFreezeCurrentValues,
    updateFacetAutoSelection
  };
}

// src/features/facets/range-facets/date-facet-set/date-facet-actions-loader.ts
function loadDateFacetSetActions(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer });
  return {
    deselectAllDateFacetValues,
    registerDateFacet,
    toggleSelectDateFacetValue,
    toggleExcludeDateFacetValue,
    updateDateFacetSortCriterion,
    updateDateFacetValues
  };
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-actions-loader.ts
function loadNumericFacetSetActions(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer });
  return {
    deselectAllNumericFacetValues,
    registerNumericFacet,
    toggleSelectNumericFacetValue,
    toggleExcludeNumericFacetValue,
    updateNumericFacetSortCriterion,
    updateNumericFacetValues
  };
}

// src/features/fields/fields-actions-loader.ts
function loadFieldActions(engine) {
  engine.addReducers({ fields: fieldsReducer });
  return {
    registerFieldsToInclude,
    enableFetchAllFields,
    disableFetchAllFields,
    fetchFieldsDescription
  };
}

// src/features/folding/folding-actions-loader.ts
function loadFoldingActions(engine) {
  engine.addReducers({ folding: foldingReducer });
  return {
    registerFolding,
    loadCollection
  };
}

// src/features/generated-answer/generated-answer-slice.ts
var import_toolkit114 = require("@reduxjs/toolkit");

// src/features/generated-answer/generated-answer-state.ts
function getGeneratedAnswerInitialState() {
  return {
    id: "",
    isVisible: true,
    isEnabled: true,
    isLoading: false,
    isStreaming: false,
    citations: [],
    liked: false,
    disliked: false,
    responseFormat: {
      contentFormat: ["text/plain"]
    },
    feedbackModalOpen: false,
    feedbackSubmitted: false,
    fieldsToIncludeInCitations: [],
    isAnswerGenerated: false,
    expanded: false,
    cannotAnswer: false,
    answerApiQueryParams: void 0,
    answerId: void 0,
    answerGenerationMode: "automatic"
  };
}

// src/features/generated-answer/utils/generated-answer-citation-utils.ts
function filterOutDuplicatedCitations(citations) {
  const citationUris = /* @__PURE__ */ new Set();
  return citations.filter((citation) => {
    const isCitationUriUnique = !citationUris.has(citation.uri);
    if (isCitationUriUnique) {
      citationUris.add(citation.uri);
    }
    return isCitationUriUnique;
  });
}

// src/features/generated-answer/generated-answer-slice.ts
var generatedAnswerReducer = (0, import_toolkit114.createReducer)(
  getGeneratedAnswerInitialState(),
  (builder) => builder.addCase(setIsVisible, (state, { payload }) => {
    state.isVisible = payload;
  }).addCase(setIsEnabled2, (state, { payload }) => {
    state.isEnabled = payload;
  }).addCase(setId, (state, { payload }) => {
    state.id = payload.id;
  }).addCase(updateMessage, (state, { payload }) => {
    state.isLoading = false;
    state.isStreaming = true;
    if (!state.answer) {
      state.answer = "";
    }
    state.answer += payload.textDelta;
    delete state.error;
  }).addCase(updateCitations, (state, { payload }) => {
    state.isLoading = false;
    state.isStreaming = true;
    state.citations = filterOutDuplicatedCitations([
      ...state.citations,
      ...payload.citations
    ]);
    delete state.error;
  }).addCase(updateError, (state, { payload }) => {
    state.isLoading = false;
    state.isStreaming = false;
    state.error = {
      ...payload,
      isRetryable: payload.code === RETRYABLE_STREAM_ERROR_CODE
    };
    state.citations = [];
    delete state.answer;
  }).addCase(likeGeneratedAnswer, (state) => {
    state.liked = true;
    state.disliked = false;
  }).addCase(dislikeGeneratedAnswer, (state) => {
    state.liked = false;
    state.disliked = true;
  }).addCase(openGeneratedAnswerFeedbackModal, (state) => {
    state.feedbackModalOpen = true;
  }).addCase(closeGeneratedAnswerFeedbackModal, (state) => {
    state.feedbackModalOpen = false;
  }).addCase(sendGeneratedAnswerFeedback, (state) => {
    state.feedbackSubmitted = true;
  }).addCase(resetAnswer, (state) => {
    return {
      ...getGeneratedAnswerInitialState(),
      ...state.answerConfigurationId ? { answerConfigurationId: state.answerConfigurationId } : {},
      responseFormat: state.responseFormat,
      fieldsToIncludeInCitations: state.fieldsToIncludeInCitations,
      isVisible: state.isVisible,
      id: state.id
    };
  }).addCase(setIsLoading, (state, { payload }) => {
    state.isLoading = payload;
  }).addCase(setIsStreaming, (state, { payload }) => {
    state.isStreaming = payload;
  }).addCase(setAnswerContentFormat, (state, { payload }) => {
    state.answerContentFormat = payload;
  }).addCase(updateResponseFormat, (state, { payload }) => {
    state.responseFormat = payload;
  }).addCase(registerFieldsToIncludeInCitations, (state, action) => {
    state.fieldsToIncludeInCitations = [
      ...new Set(state.fieldsToIncludeInCitations.concat(action.payload))
    ];
  }).addCase(setIsAnswerGenerated, (state, { payload }) => {
    state.isAnswerGenerated = payload;
  }).addCase(expandGeneratedAnswer, (state) => {
    state.expanded = true;
  }).addCase(collapseGeneratedAnswer, (state) => {
    state.expanded = false;
  }).addCase(updateAnswerConfigurationId, (state, { payload }) => {
    state.answerConfigurationId = payload;
  }).addCase(setCannotAnswer, (state, { payload }) => {
    state.cannotAnswer = payload;
  }).addCase(setAnswerApiQueryParams, (state, { payload }) => {
    state.answerApiQueryParams = payload;
  }).addCase(setAnswerId2, (state, { payload }) => {
    state.answerId = payload;
  }).addCase(setAnswerGenerationMode, (state, { payload }) => {
    state.answerGenerationMode = payload;
  })
);

// src/features/generated-answer/generated-answer-actions-loader.ts
function loadGeneratedAnswerActions(engine) {
  engine.addReducers({ generatedAnswer: generatedAnswerReducer });
  return {
    generateAnswer,
    resetAnswer,
    setAnswerGenerationMode
  };
}

// src/features/history/history-actions-loader.ts
function loadHistoryActions(engine) {
  engine.addReducers({ history, facetOrder: facetOrderReducer });
  return {
    back,
    forward
  };
}

// src/features/instant-results/instant-results-actions-loader.ts
function loadInstantResultsActions(engine) {
  engine.addReducers({ instantResults: instantResultsReducer });
  return {
    registerInstantResults,
    updateInstantResultsQuery,
    clearExpiredResults
  };
}

// src/features/pagination/pagination-actions-loader.ts
function loadPaginationActions(engine) {
  engine.addReducers({ pagination: paginationReducer });
  return {
    nextPage,
    previousPage,
    registerNumberOfResults,
    registerPage,
    updateNumberOfResults,
    updatePage
  };
}

// src/features/pipeline/pipeline-actions-loader.ts
function loadPipelineActions(engine) {
  engine.addReducers({ pipeline: pipelineReducer });
  return {
    setPipeline
  };
}

// src/features/query/query-actions-loader.ts
function loadQueryActions(engine) {
  engine.addReducers({ query: queryReducer });
  return {
    updateQuery
  };
}

// src/features/query-set/query-set-actions-loader.ts
function loadQuerySetActions(engine) {
  engine.addReducers({ querySet: querySetReducer });
  return {
    registerQuerySetQuery,
    updateQuerySetQuery
  };
}

// src/features/query-suggest/query-suggest-actions-loader.ts
function loadQuerySuggestActions(engine) {
  engine.addReducers({ querySuggest: querySuggestReducer, querySet: querySetReducer });
  return {
    clearQuerySuggest: clearQuerySuggest2,
    fetchQuerySuggestions: fetchQuerySuggestions2,
    registerQuerySuggest: registerQuerySuggest2,
    selectQuerySuggestion: selectQuerySuggestion2
  };
}

// src/features/question-answering/question-answering-actions-loader.ts
function loadQuestionAnsweringActions(engine) {
  engine.addReducers({ questionAnswering: questionAnsweringReducer });
  return {
    collapseSmartSnippet,
    expandSmartSnippet,
    dislikeSmartSnippet,
    likeSmartSnippet,
    openFeedbackModal,
    closeFeedbackModal,
    expandSmartSnippetRelatedQuestion,
    collapseSmartSnippetRelatedQuestion
  };
}

// src/features/recent-queries/recent-queries-actions-loader.ts
function loadRecentQueriesActions(engine) {
  engine.addReducers({ recentQueries: recentQueriesReducer });
  return {
    registerRecentQueries,
    clearRecentQueries
  };
}

// src/features/recent-results/recent-results-actions-loader.ts
function loadRecentResultsActions(engine) {
  engine.addReducers({ recentResults: recentResultsReducer });
  return {
    registerRecentResults,
    clearRecentResults,
    pushRecentResult
  };
}

// src/features/result-preview/result-preview-actions-loader.ts
function loadResultPreviewActions(engine) {
  engine.addReducers({ resultPreview: resultPreviewReducer });
  return {
    fetchResultContent,
    updateContentURL,
    nextPreview,
    previousPreview,
    preparePreviewPagination
  };
}

// src/features/templates/templates-manager.ts
var import_bueno105 = require("@coveo/bueno");
var templateSchema = new import_bueno105.Schema({
  content: new import_bueno105.Value({ required: true }),
  conditions: new import_bueno105.Value({ required: true }),
  priority: new import_bueno105.NumberValue({ required: false, default: 0, min: 0 }),
  fields: new import_bueno105.ArrayValue({
    required: false,
    each: requiredNonEmptyString
  })
});
function buildTemplatesManager() {
  const templates = [];
  const validateTemplate = (template) => {
    const validated = templateSchema.validate(template);
    const areConditionsValid = template.conditions.every(
      (condition) => condition instanceof Function
    );
    if (!areConditionsValid) {
      throw new import_bueno105.SchemaValidationError(
        "Each template condition should be a function that takes a Result or Product as an argument and returns a boolean"
      );
    }
    return validated;
  };
  return {
    registerTemplates(...newTemplates) {
      newTemplates.forEach((template) => {
        const templatesWithDefault = {
          ...validateTemplate(template),
          fields: template.fields || []
        };
        templates.push(templatesWithDefault);
      });
      templates.sort((a, b) => b.priority - a.priority);
    },
    selectTemplate(item) {
      const template = templates.find(
        (template2) => template2.conditions.every((condition) => condition(item))
      );
      return template ? template.content : null;
    },
    selectLinkTemplate(item) {
      const template = templates.find(
        (template2) => template2.conditions.every((condition) => condition(item))
      );
      return template ? template.linkContent : null;
    }
  };
}

// src/features/result-templates/result-templates-manager.ts
function buildResultTemplatesManager(engine) {
  if (!loadResultTemplatesManagerReducers(engine)) {
    throw loadReducerError;
  }
  const {
    registerTemplates: coreRegisterTemplates,
    selectTemplate,
    selectLinkTemplate
  } = buildTemplatesManager();
  return {
    registerTemplates: (...newTemplates) => {
      coreRegisterTemplates(...newTemplates);
      const fields = [];
      newTemplates.forEach((template) => {
        template.fields && fields.push(...template.fields);
      });
      engine.dispatch(registerFieldsToInclude(fields));
    },
    selectTemplate,
    selectLinkTemplate
  };
}
function loadResultTemplatesManagerReducers(engine) {
  engine.addReducers({ fields: fieldsReducer });
  return true;
}

// src/features/search/search-actions-loader.ts
function loadSearchActions(engine) {
  engine.addReducers({ search: searchReducer });
  return {
    executeSearch,
    fetchMoreResults,
    fetchFacetValues,
    fetchPage,
    fetchInstantResults
  };
}

// src/features/search-hub/search-hub-actions-loader.ts
function loadSearchHubActions(engine) {
  engine.addReducers({ searchHub: searchHubReducer });
  return { setSearchHub };
}

// src/features/search-parameters/search-parameter-serializer.ssr.ts
var import_bueno107 = require("@coveo/bueno");

// src/features/search-parameters/search-parameter-utils.ts
var import_bueno106 = require("@coveo/bueno");
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function addFacetValuesToSearchParams(facetId2, paramKey) {
  return (searchParams, valueArray) => {
    if (paramKey in searchParams) {
      const record = searchParams[paramKey] ?? {};
      record[facetId2] = [...record[facetId2] ?? [], ...valueArray];
      searchParams[paramKey] = record;
    } else {
      searchParams[paramKey] = { [facetId2]: valueArray };
    }
  };
}
function isValidSearchParam(key) {
  return facetSearchParamRegex.exec(key) !== null || isValidBasicKey(key);
}
function isFacetPair(pair) {
  const [key, value] = pair;
  const isValidKey2 = keyHasObjectValue(key);
  const isValidValue = isFacetObject(value);
  return isValidKey2 && isValidValue;
}
function isRangeFacetPair(pair) {
  const [key, value] = pair;
  const isValidKey2 = key === "nf" || key === "df";
  const isValidValue = isRangeFacetObject(value);
  return isValidKey2 && isValidValue;
}
function extendSearchParameters(searchParams, key, value) {
  if ((0, import_bueno106.isNullOrUndefined)(value)) {
    return;
  }
  if (isValidBasicKey(key) && typeof value === "string" && !isEmptyString(value)) {
    const [k, v] = cast([key, value], false);
    searchParams[k] = v;
    return;
  }
  const result = facetSearchParamRegex.exec(key);
  if (result) {
    const paramKey = result[1];
    const facetId2 = result[2];
    if (!keyHasObjectValue(paramKey)) {
      return;
    }
    const add = addFacetValuesToSearchParams(facetId2, paramKey);
    const range = paramKey === "nf" ? buildNumericRanges(toArray(value), "selected") : paramKey === "df" ? buildDateRanges(toArray(value), "selected") : toArray(value);
    add(searchParams, range);
  }
}

// src/features/search-parameters/search-parameter-serializer.ssr.ts
function buildSSRSearchParameterSerializer() {
  return { toSearchParameters, serialize: serialize2 };
}
function toSearchParameters(urlSearchParams) {
  const searchParameters = {};
  const add = (key, value) => extendSearchParameters(searchParameters, key, value);
  if (urlSearchParams instanceof URLSearchParams) {
    urlSearchParams.forEach((value, key) => add(key, value));
  } else {
    Object.entries(urlSearchParams).forEach(([key, value]) => add(key, value));
  }
  return searchParameters;
}
function serialize2(searchParameters, initialUrl) {
  const { searchParams } = initialUrl;
  const previousState = wipeSearchParamsFromUrl(searchParams);
  Object.entries(searchParameters).forEach(
    ([key, value]) => isValidKey(key) && applyToUrlSearchParam(searchParams, previousState, [key, value])
  );
  return initialUrl.href;
}
function wipeSearchParamsFromUrl(urlSearchParams) {
  const previousSearchParams = {};
  const keysToDelete = [];
  urlSearchParams.forEach((value, key) => {
    if (value !== void 0 && isValidSearchParam(key)) {
      previousSearchParams[key] = [...previousSearchParams[key] || [], value];
      keysToDelete.push(key);
    }
  });
  for (const key of keysToDelete) {
    urlSearchParams.delete(key);
  }
  return previousSearchParams;
}
function applyToUrlSearchParam(urlSearchParams, previousState, pair) {
  if ((0, import_bueno107.isNullOrUndefined)(pair[1])) {
    return;
  }
  if (isFacetPair(pair)) {
    applyFacetValuesToSearchParams(urlSearchParams, previousState, pair);
    return;
  }
  if (isRangeFacetPair(pair)) {
    applyRangeFacetValuesToSearchParams(urlSearchParams, pair);
    return;
  }
  urlSearchParams.set(pair[0], `${pair[1]}`);
}
function applyFacetValuesToSearchParams(urlSearchParams, previousState, [key, value]) {
  Object.entries(value).forEach(([facetId2, facetValues]) => {
    const id = `${key}-${facetId2}`;
    const previousFacetValues = previousState[id] ?? [];
    if (arrayEqualStrictlyDifferentOrder(previousFacetValues, value[facetId2])) {
      previousFacetValues.forEach((v) => urlSearchParams.append(id, v));
      return;
    }
    urlSearchParams.delete(id);
    facetValues.forEach((v) => urlSearchParams.append(id, v));
  });
}
function applyRangeFacetValuesToSearchParams(urlSearchParams, [key, value]) {
  Object.entries(value).forEach(([facetId2, facetValues]) => {
    const id = `${key}-${facetId2}`;
    urlSearchParams.delete(id);
    facetValues.forEach(
      ({ start, end, endInclusive }) => urlSearchParams.append(
        id,
        `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`
      )
    );
  });
}

// src/features/sort-criteria/criteria-parser.ts
function parseCriterion(criterion) {
  const { by, order } = criterion;
  switch (by) {
    case "relevancy" /* Relevancy */:
      return buildRelevanceSortCriterion();
    case "qre" /* QRE */:
      return buildQueryRankingExpressionSortCriterion();
    case "nosort" /* NoSort */:
      return buildNoSortCriterion();
    case "date" /* Date */:
      if (!order) {
        throw new Error(
          'An order (i.e., ascending or descending) should be specified for a sort criterion sorted by "date"'
        );
      }
      return buildDateSortCriterion(order);
    default:
      if (!order) {
        throw new Error(
          `An order (i.e., ascending or descending) should be specified for a sort criterion sorted by a field, such as "${by}"`
        );
      }
      return buildFieldSortCriterion(by, order);
  }
}
function isSortOrder(order) {
  return order === void 0 || order === "ascending" /* Ascending */ || order === "descending" /* Descending */;
}
function parseCriterionExpression(expression) {
  const criteria = expression.split(",");
  const wrongFormatError = new Error(
    `Wrong criterion expression format for "${expression}"`
  );
  if (!criteria.length) {
    throw wrongFormatError;
  }
  return criteria.map((criterion) => {
    const criterionValues = criterion.trim().split(" ");
    const by = criterionValues[0].toLowerCase();
    const order = criterionValues[1]?.toLowerCase();
    if (criterionValues.length > 2) {
      throw wrongFormatError;
    }
    if (by === "") {
      throw wrongFormatError;
    }
    if (!isSortOrder(order)) {
      throw new Error(
        `Wrong criterion sort order "${order}" in expression "${expression}". Order should either be "${"ascending" /* Ascending */}" or "${"descending" /* Descending */}"`
      );
    }
    return parseCriterion({ by, order });
  });
}

// src/features/sort-criteria/sort-criteria-actions-loader.ts
function loadSortCriteriaActions(engine) {
  engine.addReducers({ sortCriteria: sortCriteriaReducer });
  return {
    registerSortCriterion,
    updateSortCriterion
  };
}

// src/features/standalone-search-box-set/standalone-search-box-set-actions-loader.ts
function loadStandaloneSearchBoxSetActions(engine) {
  engine.addReducers({ standaloneSearchBoxSet: standaloneSearchBoxSetReducer });
  return {
    registerStandaloneSearchBox,
    fetchRedirectUrl,
    updateStandaloneSearchBoxRedirectionUrl,
    updateAnalyticsToSearchFromLink,
    updateAnalyticsToOmniboxFromLink,
    resetStandaloneSearchBox
  };
}

// src/features/static-filter-set/static-filter-set-actions-loader.ts
function loadStaticFilterSetActions(engine) {
  engine.addReducers({ staticFilterSet: staticFilterSetReducer });
  return {
    registerStaticFilter,
    toggleSelectStaticFilterValue,
    toggleExcludeStaticFilterValue,
    deselectAllStaticFilterValues
  };
}

// src/features/tab-set/tab-set-actions-loader.ts
function loadTabSetActions(engine) {
  engine.addReducers({ tabSet: tabSetReducer });
  return {
    registerTab,
    updateActiveTab
  };
}

// src/utils/query-expression/common/negatable.ts
function getNegationPrefix(config) {
  return config.negate ? "NOT " : "";
}

// src/utils/query-expression/common/operator.ts
function getOperatorSymbol(operator) {
  const dictionary = {
    contains: "=",
    differentThan: "<>",
    fuzzyMatch: "~=",
    greaterThan: ">",
    greaterThanOrEqual: ">=",
    isExactly: "==",
    lowerThan: "<",
    lowerThanOrEqual: "<=",
    phoneticMatch: "%=",
    regexMatch: "/=",
    wildcardMatch: "*="
  };
  return dictionary[operator];
}

// src/utils/query-expression/date-field/date-field.ts
function buildDateField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const operator = getOperatorSymbol(config.operator);
      const prefix = getNegationPrefix(config);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}

// src/utils/query-expression/date-range-field/date-range-field.ts
function buildDateRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}

// src/utils/query-expression/exact-match/exact-match.ts
function buildExactMatch(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { expression } = config;
      return `${prefix}"${expression}"`;
    }
  };
}

// src/utils/query-expression/field-exists/field-exists.ts
function buildFieldExists(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2 } = config;
      return `${prefix}@${field2}`;
    }
  };
}

// src/utils/query-expression/keyword/keyword.ts
function buildKeyword(config) {
  return {
    toQuerySyntax() {
      const { expression, negate } = config;
      return negate ? `NOT (${expression})` : expression;
    }
  };
}

// src/utils/query-expression/near/near.ts
function buildNear(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { startTerm, otherTerms } = config;
      const otherTermsExpression = buildOtherTerms(otherTerms);
      const expression = `${startTerm} ${otherTermsExpression}`;
      return config.negate ? `${prefix}(${expression})` : expression;
    }
  };
}
function buildOtherTerms(terms) {
  return terms.map((term) => {
    const { endTerm, maxKeywordsBetween } = term;
    return `near:${maxKeywordsBetween} ${endTerm}`;
  }).join(" ");
}

// src/utils/query-expression/numeric-field/numeric-field.ts
function buildNumericField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}

// src/utils/query-expression/numeric-range-field/numeric-range-field.ts
function buildNumericRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}

// src/utils/query-expression/query-extension/query-extension.ts
function buildQueryExtension(config) {
  return {
    toQuerySyntax() {
      const { name, parameters } = config;
      const argumentExpression = buildParameters(parameters);
      return `$${name}(${argumentExpression})`;
    }
  };
}
function buildParameters(params) {
  return Object.entries(params).map((entry) => {
    const [name, value] = entry;
    const formatted = typeof value === "string" ? value : value.toQuerySyntax();
    return `${name}: ${formatted}`;
  }).join(", ");
}

// src/utils/query-expression/string-facet-field/string-facet-field.ts
function buildStringFacetField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, operator, value } = config;
      const symbol = getOperatorSymbol(operator);
      const formattedValue = operator === "fuzzyMatch" ? ` $quoteVar(value: ${value})` : `("${value}")`;
      return `${prefix}@${field2}${symbol}${formattedValue}`;
    }
  };
}

// src/utils/query-expression/string-field/string-field.ts
function buildStringField(config) {
  return {
    toQuerySyntax() {
      const { field: field2 } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      const processed = config.values.map((value) => `"${value}"`);
      const values = processed.length === 1 ? processed[0] : `(${processed.join(",")})`;
      return `${prefix}@${field2}${operator}${values}`;
    }
  };
}

// src/utils/query-expression/query-expression.ts
function buildQueryExpression() {
  const parts = [];
  let booleanOperator = "and";
  return {
    addExpression(expression) {
      parts.push(expression);
      return this;
    },
    addKeyword(expression) {
      parts.push(buildKeyword(expression));
      return this;
    },
    addNear(expression) {
      parts.push(buildNear(expression));
      return this;
    },
    addExactMatch(expression) {
      parts.push(buildExactMatch(expression));
      return this;
    },
    addFieldExists(expression) {
      parts.push(buildFieldExists(expression));
      return this;
    },
    addStringField(expression) {
      parts.push(buildStringField(expression));
      return this;
    },
    addStringFacetField(expression) {
      parts.push(buildStringFacetField(expression));
      return this;
    },
    addNumericField(expression) {
      parts.push(buildNumericField(expression));
      return this;
    },
    addNumericRangeField(expression) {
      parts.push(buildNumericRangeField(expression));
      return this;
    },
    addDateField(expression) {
      parts.push(buildDateField(expression));
      return this;
    },
    addDateRangeField(expression) {
      parts.push(buildDateRangeField(expression));
      return this;
    },
    addQueryExtension(expression) {
      parts.push(buildQueryExtension(expression));
      return this;
    },
    joinUsing(operator) {
      booleanOperator = operator;
      return this;
    },
    toQuerySyntax() {
      const symbol = getBooleanOperatorSymbol(booleanOperator);
      const expression = parts.map((part) => part.toQuerySyntax()).join(`) ${symbol} (`);
      return parts.length <= 1 ? expression : `(${expression})`;
    }
  };
}
function getBooleanOperatorSymbol(operator) {
  return operator === "and" ? "AND" : "OR";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DefaultFieldsToInclude,
  EcommerceDefaultFieldsToInclude,
  MinimumFieldsToInclude,
  ResultTemplatesHelpers,
  SortBy,
  SortOrder,
  VERSION,
  baseFacetResponseSelector,
  buildCriterionExpression,
  buildDateRange,
  buildDateSortCriterion,
  buildFieldSortCriterion,
  buildNoSortCriterion,
  buildNumericRange,
  buildQueryExpression,
  buildQueryRankingExpressionSortCriterion,
  buildRelevanceSortCriterion,
  buildResultTemplatesManager,
  buildSSRSearchParameterSerializer,
  buildSearchParameterSerializer,
  buildStaticFilterValue,
  currentPageSelector,
  currentPagesSelector,
  defineAutomaticFacetGenerator,
  defineBreadcrumbManager,
  defineCategoryFacet,
  defineCategoryFieldSuggestions,
  defineContext,
  defineDateFacet,
  defineDateFilter,
  defineDictionaryFieldContext,
  defineDidYouMean,
  defineExecuteTrigger,
  defineFacet,
  defineFacetManager,
  defineFieldSuggestions,
  defineFoldedResultList,
  defineHistoryManager,
  defineInstantResults,
  defineNotifyTrigger,
  defineNumericFacet,
  defineNumericFilter,
  definePager,
  defineQueryError,
  defineQuerySummary,
  defineQueryTrigger,
  defineQuickview,
  defineRecentQueriesList,
  defineRecentResultsList,
  defineRedirectionTrigger,
  defineRelevanceInspector,
  defineResultList,
  defineResultsPerPage,
  defineSearchBox,
  defineSearchEngine,
  defineSearchParameterManager,
  defineSearchStatus,
  defineSmartSnippet,
  defineSmartSnippetQuestionsList,
  defineSort,
  defineStandaloneSearchBox,
  defineStaticFilter,
  defineTab,
  defineTabManager,
  defineUrlManager,
  deserializeRelativeDate,
  facetRequestSelector,
  facetResponseSelectedValuesSelector,
  facetResponseSelector,
  getAnalyticsNextApiBaseUrl,
  getOrganizationEndpoint,
  getSampleSearchEngineConfiguration,
  loadAdvancedSearchQueryActions,
  loadBreadcrumbActions,
  loadCategoryFacetSetActions,
  loadClickAnalyticsActions,
  loadConfigurationActions,
  loadContextActions,
  loadDateFacetSetActions,
  loadDebugActions,
  loadDictionaryFieldContextActions,
  loadDidYouMeanActions,
  loadExcerptLengthActions,
  loadFacetOptionsActions,
  loadFacetSetActions,
  loadFieldActions,
  loadFoldingActions,
  loadGeneratedAnswerActions,
  loadGenericAnalyticsActions,
  loadHistoryActions,
  loadInstantResultsActions,
  loadNumericFacetSetActions,
  loadPaginationActions,
  loadPipelineActions,
  loadQueryActions,
  loadQuerySetActions,
  loadQuerySuggestActions,
  loadQuestionAnsweringActions,
  loadRecentQueriesActions,
  loadRecentResultsActions,
  loadResultPreviewActions,
  loadSearchActions,
  loadSearchAnalyticsActions,
  loadSearchConfigurationActions,
  loadSearchHubActions,
  loadSortCriteriaActions,
  loadStandaloneSearchBoxSetActions,
  loadStaticFilterSetActions,
  loadTabSetActions,
  maxPageSelector,
  parseCriterionExpression,
  validateRelativeDate
});
