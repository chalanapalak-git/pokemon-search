/**
 * @license
 *
 * Copyright 2026 Coveo Solutions Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *       http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/case-assist.index.ts
var case_assist_index_exports = {};
__export(case_assist_index_exports, {
  ResultTemplatesHelpers: () => ResultTemplatesHelpers,
  buildCaseAssistEngine: () => buildCaseAssistEngine,
  buildCaseField: () => buildCaseField,
  buildCaseInput: () => buildCaseInput,
  buildController: () => buildController,
  buildDocumentSuggestion: () => buildDocumentSuggestionList,
  buildDocumentSuggestionList: () => buildDocumentSuggestionList,
  buildInteractiveResult: () => buildCaseAssistInteractiveResult,
  buildQuickview: () => buildCaseAssistQuickview,
  getAnalyticsNextApiBaseUrl: () => getAnalyticsNextApiBaseUrl,
  getOrganizationEndpoint: () => getOrganizationEndpoint,
  loadCaseAssistAnalyticsActions: () => loadCaseAssistAnalyticsActions,
  loadCaseFieldActions: () => loadCaseFieldActions,
  loadCaseInputActions: () => loadCaseInputActions,
  loadDocumentSuggestionActions: () => loadDocumentSuggestionActions,
  loadGenericAnalyticsActions: () => loadGenericAnalyticsActions
});
module.exports = __toCommonJS(case_assist_index_exports);

// src/api/platform-client.ts
var import_exponential_backoff = require("exponential-backoff");

// src/utils/errors.ts
var loadReducerError = new Error("Failed to load reducers.");
var UnauthorizedTokenError = class extends Error {
  constructor() {
    super();
    this.name = "UnauthorizedTokenError";
    this.message = "The token being used to perform the request is unauthorized. It may be expired or invalid.";
  }
};
var DisconnectedError = class extends Error {
  constructor(url, statusCode) {
    super();
    __publicField(this, "statusCode");
    this.name = "Disconnected";
    this.message = `Client could not connect to the following URL: ${url}`;
    this.statusCode = statusCode ?? 0;
  }
};

// src/utils/utils.ts
function isArray(value) {
  return Array.isArray(value);
}
function removeDuplicates(arr, predicate) {
  return [
    ...arr.reduce((map, item) => {
      const key = predicate(item);
      map.has(key) || map.set(key, item);
      return map;
    }, /* @__PURE__ */ new Map()).values()
  ];
}
var doNotTrackValues = /* @__PURE__ */ new Set(["1", 1, "yes", true]);
function doNotTrack() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  const nav = navigator;
  const win = window;
  return [
    nav.globalPrivacyControl,
    nav.doNotTrack,
    nav.msDoNotTrack,
    win.doNotTrack
  ].some((value) => doNotTrackValues.has(value));
}
function fromEntries(values) {
  const newObject = {};
  for (const [key, value] of values) {
    newObject[key] = value;
  }
  return newObject;
}
function clone(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (!value) {
    return value;
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (_) {
    return value;
  }
}
function debounce(func, wait, options = {}) {
  let timeoutId;
  return (...args) => {
    const shouldCallImmediately = options.isImmediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = void 0;
      if (!options.isImmediate) {
        func.apply(void 0, args);
      }
    }, wait);
    if (shouldCallImmediately) {
      return func.apply(void 0, args);
    }
  };
}

// src/api/form-url-encoder.ts
function encodeAsFormUrl(obj) {
  const body = [];
  for (const property in obj) {
    const key = encodeURIComponent(property);
    const value = encodeURIComponent(obj[property]);
    body.push(`${key}=${value}`);
  }
  return body.join("&");
}
function canBeFormUrlEncoded(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (!obj) {
    return false;
  }
  return Object.values(obj).every(isPrimitive);
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}

// src/api/platform-client.ts
function isThrottled(status) {
  return status === 429;
}
var PlatformClient = class _PlatformClient {
  static async call(options) {
    const defaultRequestOptions = buildDefaultRequestOptions(options);
    const { logger } = options;
    const requestInfo = await _PlatformClient.preprocessRequest(
      defaultRequestOptions,
      options
    );
    logger.info(requestInfo, "Platform request");
    const { url, ...requestData } = requestInfo;
    const request = async () => {
      const response = await fetch(url, requestData);
      if (isThrottled(response.status)) {
        throw response;
      }
      return response;
    };
    try {
      const response = await (0, import_exponential_backoff.backOff)(request, {
        startingDelay: 100,
        timeMultiple: 2,
        maxDelay: 800,
        numOfAttempts: 4,
        jitter: "full",
        retry: async (e) => {
          const shouldRetry = e && isThrottled(e.status);
          if (shouldRetry) {
            logger.info("Platform retrying request");
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
          return shouldRetry;
        }
      });
      switch (response.status) {
        case 419:
        case 401:
          logger.info("Platform renewing token");
          throw new UnauthorizedTokenError();
        case 404:
          throw new DisconnectedError(url, response.status);
        default:
          logger.info({ response, requestInfo }, "Platform response");
          return response;
      }
    } catch (error) {
      if (error.message === "Failed to fetch") {
        return new DisconnectedError(url);
      }
      return error;
    }
  }
  static async preprocessRequest(defaultRequestOptions, options) {
    const { origin, preprocessRequest, logger, requestMetadata } = options;
    const { signal: _signal, ...withoutSignal } = defaultRequestOptions;
    const untaintedOutput = clone(withoutSignal);
    try {
      const processedRequest = await preprocessRequest(
        defaultRequestOptions,
        origin,
        requestMetadata
      );
      return {
        ...defaultRequestOptions,
        ...processedRequest
      };
    } catch (e) {
      logger.error(
        e,
        "Platform request preprocessing failed. Returning default request options."
      );
    }
    return untaintedOutput;
  }
};
function getOrganizationEndpoint(organizationId, environment = "prod", endpointType = "platform") {
  const environmentSuffix = environment === "prod" ? "" : environment;
  const endpointTypePart = endpointType === "platform" ? "" : `.${endpointType}`;
  return `https://${organizationId}${endpointTypePart}.org${environmentSuffix}.coveo.com`;
}
function getSearchApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(
    organizationId,
    environment
  );
  return `${organizationEndpoint}/rest/search/v2`;
}
function getAnalyticsNextApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(
    organizationId,
    environment,
    "analytics"
  );
  return `${organizationEndpoint}/rest/organizations/${organizationId}/events/v1`;
}
function buildDefaultRequestOptions(options) {
  const { url, method, requestParams, contentType, accessToken, signal } = options;
  const isMethodWithBody = options.method === "POST" || options.method === "PUT";
  const body = encodeBody(requestParams, contentType);
  return {
    url,
    method,
    headers: {
      "Content-Type": contentType,
      Authorization: `Bearer ${accessToken}`,
      ...options.headers
    },
    ...isMethodWithBody && { body },
    signal
  };
}
function encodeBody(body, contentType) {
  if (contentType === "application/x-www-form-urlencoded") {
    return canBeFormUrlEncoded(body) ? encodeAsFormUrl(body) : "";
  }
  return JSON.stringify(body);
}

// src/app/case-assist-engine/case-assist-engine.ts
var import_bueno31 = require("@coveo/bueno");

// src/api/preprocess-request.ts
var NoopPreprocessRequest = (request) => request;

// src/utils/url-utils.ts
var URLPath = class {
  constructor(basePath) {
    __publicField(this, "_basePath");
    __publicField(this, "_params", {});
    this._basePath = basePath;
  }
  addParam(name, value) {
    this._params = {
      ...this.params,
      [name]: value
    };
  }
  get basePath() {
    return this._basePath;
  }
  get params() {
    return this._params;
  }
  get hasParams() {
    return Object.entries(this._params).length;
  }
  get href() {
    return this.hasParams ? `${this.basePath}?${Object.entries(this.params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&")}` : this.basePath;
  }
};

// src/api/api-client-utils.ts
function pickNonBaseParams(req) {
  const {
    url: _url,
    accessToken: _accessToken,
    organizationId: _organizationId,
    authentication: _authentication,
    ...nonBase
  } = req;
  return nonBase;
}
var unwrapError = (payload) => {
  const { response } = payload;
  if (response.body) {
    return unwrapSearchApiError(payload);
  }
  return unwrapClientError(response);
};
var unwrapSearchApiError = (payload) => {
  if (isSearchAPIException(payload)) {
    return unwrapErrorByException(payload);
  }
  if (isSearchAPIErrorWithStatusCode(payload)) {
    return payload.body;
  }
  return { message: "unknown", statusCode: 0, type: "unknown" };
};
var unwrapClientError = (response) => {
  const body = JSON.parse(
    JSON.stringify(response, Object.getOwnPropertyNames(response))
  );
  return {
    ...body,
    message: `Client side error: ${body.message || ""}`,
    statusCode: 400,
    type: "ClientError"
  };
};
function isSearchAPIErrorWithStatusCode(r) {
  return r.body.statusCode !== void 0;
}
function isSearchAPIException(r) {
  return r.body.exception !== void 0;
}
var unwrapErrorByException = (res) => ({
  message: res.body.exception.code,
  statusCode: res.response.status,
  type: res.body.exception.code
});

// src/api/search/encoding-finder.ts
function findEncoding(response) {
  const contentType = response.headers.get("content-type") || "";
  const charset = contentType.split(";").find((part) => part.indexOf("charset=") !== -1) || "";
  return charset.split("=")[1] || "UTF-8";
}

// src/api/search/search-api-params.ts
var baseSearchRequest = (req, method, contentType, path) => {
  const url = new URLPath(`${req.url}${path}`);
  url.addParam("organizationId", req.organizationId);
  if (req.authentication) {
    url.addParam("authentication", req.authentication);
  }
  return {
    accessToken: req.accessToken,
    method,
    contentType,
    url: url.href,
    origin: "searchApiFetch"
  };
};

// src/api/search/html/html-api-client.ts
var buildContentURL = (req, path) => {
  const url = new URLPath(`${req.url}${path}`);
  url.addParam("access_token", req.accessToken);
  url.addParam("organizationId", req.organizationId);
  url.addParam("uniqueId", req.uniqueId);
  if (req.authentication) {
    url.addParam("authentication", req.authentication);
  }
  if (req.q !== void 0) {
    url.addParam("q", req.q);
  }
  if (req.enableNavigation !== void 0) {
    url.addParam("enableNavigation", `${req.enableNavigation}`);
  }
  if (req.requestedOutputSize !== void 0) {
    url.addParam("requestedOutputSize", `${req.requestedOutputSize}`);
  }
  return url.href;
};
var getHtml = async (req, options) => {
  const response = await PlatformClient.call({
    ...baseSearchRequest(
      req,
      "POST",
      "application/x-www-form-urlencoded",
      "/html"
    ),
    requestParams: pickNonBaseParams(req),
    requestMetadata: { method: "html" },
    ...options
  });
  if (response instanceof Error) {
    throw response;
  }
  const encoding = findEncoding(response);
  const buffer = await response.arrayBuffer();
  const decoder = new TextDecoder(encoding);
  const body = decoder.decode(buffer);
  if (isSuccessHtmlResponse(body)) {
    return { success: body };
  }
  return { error: unwrapError({ response, body }) };
};
function isSuccessHtmlResponse(body) {
  return typeof body === "string";
}

// src/api/search/search-api-error-response.ts
function buildDisconnectedError(error) {
  return {
    statusCode: error.statusCode,
    type: error.name,
    message: error.message
  };
}
function buildIgnoredAbortedError(error) {
  return {
    statusCode: error.code,
    type: error.name,
    message: error.message,
    ignored: true
  };
}
function buildAPIResponseFromErrorOrThrow(error, disableAbortWarning) {
  if (disableAbortWarning && error.name === "AbortError") {
    return {
      error: buildIgnoredAbortedError(error)
    };
  }
  if (error instanceof DisconnectedError) {
    return { error: buildDisconnectedError(error) };
  }
  throw error;
}

// src/api/service/case-assist/case-assist-params.ts
var baseCaseAssistRequest = (req, method, contentType, path, queryStringArguments = {}) => {
  validateCaseAssistRequestParams(req);
  const baseUrl = `${req.url}/rest/organizations/${req.organizationId}/caseassists/${req.caseAssistId}${path}`;
  const queryString = buildQueryString(queryStringArguments);
  const effectiveUrl = queryString ? `${baseUrl}?${queryString}` : baseUrl;
  return {
    accessToken: req.accessToken,
    method,
    contentType,
    url: effectiveUrl,
    origin: "caseAssistApiFetch"
  };
};
var prepareSuggestionRequestFields = (fields) => Object.keys(fields).filter((fieldName) => fields[fieldName].value !== "").reduce((obj, fieldName) => {
  obj[fieldName] = fields[fieldName];
  return obj;
}, {});
var prepareContextFromFields = (fields) => Object.keys(fields).filter((fieldName) => fields[fieldName].value !== "").reduce(
  (obj, fieldName) => {
    obj[fieldName] = fields[fieldName].value;
    return obj;
  },
  {}
);
var validateCaseAssistRequestParams = (req) => {
  if (!req.url) {
    throw new Error("The 'url' attribute must contain a valid platform URL.");
  }
  if (!req.organizationId) {
    throw new Error(
      "The 'organizationId' attribute must contain a valid organization ID."
    );
  }
  if (!req.accessToken) {
    throw new Error(
      "The 'accessToken' attribute must contain a valid platform access token."
    );
  }
  if (!req.caseAssistId) {
    throw new Error(
      "The 'caseAssistId' attribute must contain a valid Case Assist configuration ID."
    );
  }
};
var buildQueryString = (args) => {
  return Object.keys(args).map((argName) => `${argName}=${encodeURIComponent(args[argName])}`).join("&");
};

// src/api/service/case-assist/get-case-classifications/get-case-classifications-request.ts
var buildGetCaseClassificationsRequest = (req) => {
  const queryStringArguments = req.debug ? { debug: "1" } : {};
  return {
    ...baseCaseAssistRequest(
      req,
      "POST",
      "application/json",
      "/classify",
      queryStringArguments
    ),
    requestParams: prepareRequestParams(req)
  };
};
var prepareRequestParams = (req) => ({
  clientId: req.clientId,
  locale: req.locale,
  fields: prepareSuggestionRequestFields(req.fields)
});

// src/api/service/case-assist/get-document-suggestions/get-document-suggestions-request.ts
var buildGetDocumentSuggestionsRequest = (req) => {
  const queryStringArguments = {};
  if (req.debug) {
    queryStringArguments.debug = "1";
  }
  if (req.numberOfResults) {
    queryStringArguments.numberOfResults = req.numberOfResults.toString();
  }
  return {
    ...baseCaseAssistRequest(
      req,
      "POST",
      "application/json",
      "/documents/suggest",
      queryStringArguments
    ),
    requestParams: prepareRequestParams2(req)
  };
};
var prepareRequestParams2 = (req) => ({
  clientId: req.clientId,
  locale: req.locale,
  fields: prepareSuggestionRequestFields(req.fields),
  context: req.context,
  analytics: req.analytics
});

// src/api/service/case-assist/case-assist-api-client.ts
var CaseAssistAPIClient = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Retrieves the case classifications from the API.
   *
   * See https://platform.cloud.coveo.com/docs?urls.primaryName=Customer%20Service#/Suggestions/postClassify
   *
   * @param req - The request parameters.
   * @returns The case classifications grouped by fields for the given case information.
   */
  async getCaseClassifications(req) {
    const response = await PlatformClient.call({
      ...buildGetCaseClassificationsRequest(req),
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    return response.ok ? { success: body } : { error: body };
  }
  /**
   * Retrieves the document suggestions from the API.
   *
   * See https://platform.cloud.coveo.com/docs?urls.primaryName=Customer%20Service#/Suggestions/getSuggestDocument
   *
   * @param req - The request parameters.
   * @returns The document suggestions for the given case information and context.
   */
  async getDocumentSuggestions(req) {
    const response = await PlatformClient.call({
      ...buildGetDocumentSuggestionsRequest(req),
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    return response.ok ? {
      success: body
    } : { error: body };
  }
  async html(req) {
    return getHtml(req, this.options);
  }
};

// src/features/case-assist-configuration/case-assist-configuration-actions.ts
var import_bueno2 = require("@coveo/bueno");
var import_toolkit = require("@reduxjs/toolkit");

// src/utils/validate-payload.ts
var import_bueno = require("@coveo/bueno");
var requiredNonEmptyString = new import_bueno.StringValue({
  required: true,
  emptyAllowed: false
});
var nonEmptyString = new import_bueno.StringValue({
  required: false,
  emptyAllowed: false
});
var requiredEmptyAllowedString = new import_bueno.StringValue({
  required: true,
  emptyAllowed: true
});
var nonRequiredEmptyAllowedString = new import_bueno.StringValue({
  required: false,
  emptyAllowed: true
});
var nonEmptyStringArray = new import_bueno.ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
var optionalNonEmptyVersionString = new import_bueno.StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^\d+\.\d+\.\d+$/
});
var optionalTrackingId = new import_bueno.StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var requiredTrackingId = new import_bueno.StringValue({
  required: true,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var serializeSchemaValidationError = ({
  message,
  name,
  stack
}) => ({ message, name, stack });
var validatePayloadAndThrow = (payload, definition) => {
  const isSchemaValue = "required" in definition;
  if (isSchemaValue) {
    return {
      payload: new import_bueno.Schema({
        value: definition
      }).validate({ value: payload }).value
    };
  }
  const asRecordValue = new import_bueno.RecordValue({
    options: { required: true },
    values: definition
  });
  const isInvalid = asRecordValue.validate(payload);
  if (isInvalid) {
    throw new import_bueno.SchemaValidationError(isInvalid);
  }
  return { payload };
};
var validatePayload = (payload, definition) => {
  try {
    return validatePayloadAndThrow(payload, definition);
  } catch (error) {
    return {
      payload,
      error: serializeSchemaValidationError(error)
    };
  }
};
var validateOptions = (engine, schema, obj, functionName) => {
  const message = `Check the options of ${functionName}`;
  return validateObject(
    engine,
    schema,
    obj,
    message,
    "Controller initialization error"
  );
};
var validateObject = (engine, schema, obj, validationMessage, errorMessage) => {
  try {
    return schema.validate(obj, validationMessage);
  } catch (error) {
    engine.logger.error(error, errorMessage);
    throw error;
  }
};

// src/features/case-assist-configuration/case-assist-configuration-actions.ts
var setCaseAssistConfiguration = (0, import_toolkit.createAction)(
  "caseAssistConfiguration/set",
  (payload) => validatePayload(payload, {
    caseAssistId: requiredNonEmptyString,
    locale: nonEmptyString,
    proxyBaseUrl: new import_bueno2.StringValue({ required: false, url: true })
  })
);

// src/features/case-assist-configuration/case-assist-configuration-slice.ts
var import_toolkit2 = require("@reduxjs/toolkit");

// src/features/case-assist-configuration/case-assist-configuration-state.ts
var getCaseAssistConfigurationInitialState = () => ({
  caseAssistId: "",
  locale: "en-US"
});

// src/features/case-assist-configuration/case-assist-configuration-slice.ts
var caseAssistConfigurationReducer = (0, import_toolkit2.createReducer)(
  getCaseAssistConfigurationInitialState(),
  (builder) => {
    builder.addCase(setCaseAssistConfiguration, (state, action) => {
      state.caseAssistId = action.payload.caseAssistId;
      state.locale = action.payload.locale;
      state.apiBaseUrl = action.payload.proxyBaseUrl;
    });
  }
);

// src/features/debug/debug-slice.ts
var import_toolkit5 = require("@reduxjs/toolkit");

// src/features/search-parameters/search-parameter-actions.ts
var import_toolkit3 = require("@reduxjs/toolkit");

// src/features/search-parameters/search-parameter-schema.ts
var import_bueno3 = require("@coveo/bueno");
var searchParametersDefinition = {
  q: new import_bueno3.StringValue(),
  enableQuerySyntax: new import_bueno3.BooleanValue(),
  aq: new import_bueno3.StringValue(),
  cq: new import_bueno3.StringValue(),
  firstResult: new import_bueno3.NumberValue({ min: 0 }),
  numberOfResults: new import_bueno3.NumberValue({ min: 0 }),
  sortCriteria: new import_bueno3.StringValue(),
  f: new import_bueno3.RecordValue(),
  fExcluded: new import_bueno3.RecordValue(),
  cf: new import_bueno3.RecordValue(),
  nf: new import_bueno3.RecordValue(),
  mnf: new import_bueno3.RecordValue(),
  df: new import_bueno3.RecordValue(),
  debug: new import_bueno3.BooleanValue(),
  sf: new import_bueno3.RecordValue(),
  tab: new import_bueno3.StringValue(),
  af: new import_bueno3.RecordValue()
};

// src/features/search-parameters/search-parameter-actions.ts
var restoreSearchParameters = (0, import_toolkit3.createAction)(
  "searchParameters/restore",
  (payload) => validatePayload(payload, searchParametersDefinition)
);
var restoreTab = (0, import_toolkit3.createAction)(
  "searchParameters/restoreTab",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);

// src/features/debug/debug-actions.ts
var import_toolkit4 = require("@reduxjs/toolkit");
var enableDebug = (0, import_toolkit4.createAction)("debug/enable");
var disableDebug = (0, import_toolkit4.createAction)("debug/disable");

// src/features/debug/debug-state.ts
var getDebugInitialState = () => false;

// src/features/debug/debug-slice.ts
var debugReducer = (0, import_toolkit5.createReducer)(getDebugInitialState(), (builder) => {
  builder.addCase(enableDebug, () => true).addCase(disableDebug, () => false).addCase(restoreSearchParameters, (state, action) => {
    return action.payload.debug ?? state;
  });
});

// src/features/search-hub/search-hub-actions.ts
var import_bueno4 = require("@coveo/bueno");
var import_toolkit6 = require("@reduxjs/toolkit");
var setSearchHub = (0, import_toolkit6.createAction)(
  "searchHub/set",
  (payload) => validatePayload(
    payload,
    new import_bueno4.StringValue({ required: true, emptyAllowed: true })
  )
);

// src/features/search-hub/search-hub-slice.ts
var import_toolkit9 = require("@reduxjs/toolkit");

// src/features/configuration/configuration-actions.ts
var import_bueno5 = require("@coveo/bueno");
var import_toolkit7 = require("@reduxjs/toolkit");

// src/utils/version.ts
var VERSION = "3.45.0";
var COVEO_FRAMEWORK = ["@coveo/atomic", "@coveo/quantic"];

// src/features/configuration/configuration-actions.ts
var originSchemaOnConfigUpdate = () => nonEmptyString;
var originSchemaOnUpdate = () => requiredNonEmptyString;
var updateBasicConfiguration = (0, import_toolkit7.createAction)(
  "configuration/updateBasicConfiguration",
  (payload) => validatePayload(payload, {
    accessToken: nonEmptyString,
    environment: new import_bueno5.StringValue({
      required: false,
      constrainTo: ["prod", "hipaa", "stg", "dev"]
    }),
    organizationId: nonEmptyString
  })
);
var updateSearchConfiguration = (0, import_toolkit7.createAction)(
  "configuration/updateSearchConfiguration",
  (payload) => {
    return validatePayload(payload, {
      proxyBaseUrl: new import_bueno5.StringValue({ required: false, url: true }),
      pipeline: new import_bueno5.StringValue({ required: false, emptyAllowed: true }),
      searchHub: nonEmptyString,
      timezone: nonEmptyString,
      locale: nonEmptyString,
      authenticationProviders: new import_bueno5.ArrayValue({
        required: false,
        each: requiredNonEmptyString
      })
    });
  }
);
var analyticsConfigurationSchema = {
  enabled: new import_bueno5.BooleanValue({ default: true }),
  originContext: originSchemaOnConfigUpdate(),
  originLevel2: originSchemaOnConfigUpdate(),
  originLevel3: originSchemaOnConfigUpdate(),
  proxyBaseUrl: new import_bueno5.StringValue({ required: false, url: true }),
  runtimeEnvironment: new import_bueno5.Value(),
  anonymous: new import_bueno5.BooleanValue({ default: false }),
  deviceId: nonEmptyString,
  userDisplayName: nonEmptyString,
  documentLocation: nonEmptyString,
  trackingId: optionalTrackingId,
  analyticsMode: new import_bueno5.StringValue({
    constrainTo: ["legacy", "next"],
    required: false,
    default: "next"
  }),
  source: new import_bueno5.RecordValue({
    options: { required: false },
    values: COVEO_FRAMEWORK.reduce(
      (acc, framework) => {
        acc[framework] = optionalNonEmptyVersionString;
        return acc;
      },
      {}
    )
  })
};
var updateAnalyticsConfiguration = (0, import_toolkit7.createAction)(
  "configuration/updateAnalyticsConfiguration",
  (payload) => {
    return validatePayload(payload, analyticsConfigurationSchema);
  }
);
var disableAnalytics = (0, import_toolkit7.createAction)("configuration/analytics/disable");
var enableAnalytics = (0, import_toolkit7.createAction)("configuration/analytics/enable");
var setOriginLevel2 = (0, import_toolkit7.createAction)(
  "configuration/analytics/originlevel2",
  (payload) => validatePayload(payload, { originLevel2: originSchemaOnUpdate() })
);
var setOriginLevel3 = (0, import_toolkit7.createAction)(
  "configuration/analytics/originlevel3",
  (payload) => validatePayload(payload, { originLevel3: originSchemaOnUpdate() })
);
var setAgentId = (0, import_toolkit7.createAction)(
  "knowledge/setAgentId",
  (payload) => validatePayload(payload, new import_bueno5.StringValue({ required: true }))
);

// src/features/history/history-actions.ts
var import_toolkit8 = require("@reduxjs/toolkit");
var undo = (0, import_toolkit8.createAction)("history/undo");
var redo = (0, import_toolkit8.createAction)("history/redo");
var snapshot = (0, import_toolkit8.createAction)("history/snapshot");
var back = (0, import_toolkit8.createAsyncThunk)("history/back", async (_, { dispatch }) => {
  dispatch(undo());
  await dispatch(change());
});
var forward = (0, import_toolkit8.createAsyncThunk)(
  "history/forward",
  async (_, { dispatch }) => {
    dispatch(redo());
    await dispatch(change());
  }
);
var change = (0, import_toolkit8.createAsyncThunk)(
  "history/change",
  async (_, { getState }) => {
    const s = getState();
    return s.history.present;
  }
);

// src/features/search-hub/search-hub-state.ts
var getSearchHubInitialState = () => "default";

// src/features/search-hub/search-hub-slice.ts
var searchHubReducer = (0, import_toolkit9.createReducer)(
  getSearchHubInitialState(),
  (builder) => {
    builder.addCase(setSearchHub, (_, action) => action.payload).addCase(
      change.fulfilled,
      (state, action) => action.payload?.searchHub ?? state
    ).addCase(
      updateSearchConfiguration,
      (state, action) => action.payload.searchHub || state
    );
  }
);

// src/api/analytics/analytics-relay-client.ts
var import_relay = require("@coveo/relay");
var import_toolkit11 = require("@reduxjs/toolkit");

// src/utils/runtime.ts
function isBrowser() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}

// src/api/analytics/analytics-selectors.ts
var import_toolkit10 = require("@reduxjs/toolkit");
var getAnalyticsSource = (0, import_toolkit10.createSelector)(
  (state) => state.source,
  (source) => Object.entries(source).map(
    ([frameworkName, frameworkVersion]) => `${frameworkName}@${frameworkVersion}`
  ).concat(`@coveo/headless@${VERSION}`)
);

// src/api/analytics/analytics-relay-client.ts
var getRelayInstanceFromState = (0, import_toolkit11.createSelector)(
  (state) => state.configuration.organizationId,
  (state) => state.configuration.environment,
  (state) => state.configuration.accessToken,
  (state) => state.configuration.analytics,
  (state) => getAnalyticsSource(state.configuration.analytics),
  (_state, navigatorContextProvider) => navigatorContextProvider,
  (organizationId, platformEnvironment, token, { trackingId, apiBaseUrl, enabled }, source, navigatorContextProvider) => {
    const environment = getEnvironment(navigatorContextProvider);
    return (0, import_relay.createRelay)({
      mode: enabled ? "emit" : "disabled",
      url: apiBaseUrl ?? getAnalyticsNextApiBaseUrl(organizationId, platformEnvironment),
      token,
      trackingId: trackingId ?? null,
      source,
      environment
    });
  }
);
var noopRelayEnvironment = {
  generateUUID: () => "",
  getLocation: () => null,
  getReferrer: () => null,
  getUserAgent: () => null,
  send: () => {
  },
  storage: {
    getItem: () => null,
    setItem: () => {
    },
    removeItem: () => {
    }
  }
};
var getEnvironment = (customProvider) => {
  if (!customProvider) {
    return void 0;
  }
  const customContext = customProvider();
  const baseEnvironment = isBrowser() ? (0, import_relay.buildBrowserEnvironment)() : noopRelayEnvironment;
  return {
    ...baseEnvironment,
    generateUUID: () => customContext.clientId,
    getLocation: () => customContext.location,
    getReferrer: () => customContext.referrer,
    getUserAgent: () => customContext.userAgent
  };
};

// src/api/knowledge/answer-generation/answer-generation-api.ts
var import_query2 = require("@reduxjs/toolkit/query");

// src/api/knowledge/answer-slice.ts
var import_query = require("@reduxjs/toolkit/query");
var dynamicBaseQuery = async (args, api, extraOptions) => {
  const state = api.getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const answerConfigurationId = state.generatedAnswer.answerConfigurationId;
  const updatedArgs = {
    ...args,
    headers: {
      ...args?.headers || {},
      Authorization: `Bearer ${accessToken}`
    }
  };
  try {
    const platformEndpoint = getOrganizationEndpoint(
      organizationId,
      environment
    );
    const data = (0, import_query.fetchBaseQuery)({
      baseUrl: `${platformEndpoint}/rest/organizations/${organizationId}/answer/v1/configs/${answerConfigurationId}`
    })(updatedArgs, api, extraOptions);
    return { data };
  } catch (error) {
    return { error };
  }
};
var answerSlice = (0, import_query.createApi)({
  reducerPath: "answer",
  baseQuery: (0, import_query.retry)(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// src/api/knowledge/answer-generation/answer-generation-api.ts
var answerGenerationApi = (0, import_query2.createApi)({
  reducerPath: "answerGenerationApi",
  refetchOnMountOrArgChange: true,
  baseQuery: (0, import_query2.retry)(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// src/api/knowledge/stream-answer-api.ts
var import_query3 = require("@reduxjs/toolkit/query");

// src/features/generated-answer/answer-api-selectors.ts
var import_toolkit12 = require("@reduxjs/toolkit");

// src/features/query/query-selectors.ts
var selectQuery = (state) => state.query;
var selectEnableQuerySyntax = (state) => state.query?.enableQuerySyntax;

// src/features/generated-answer/answer-api-selectors.ts
var selectAnswerTriggerParams = (0, import_toolkit12.createSelector)(
  (state) => selectQuery(state)?.q,
  (state) => state.search.requestId,
  (state) => state.generatedAnswer.cannotAnswer,
  (state) => state.configuration.analytics.analyticsMode,
  (state) => state.search.searchAction?.actionCause,
  (q, requestId, cannotAnswer, analyticsMode, actionCause) => ({
    q,
    requestId,
    cannotAnswer,
    analyticsMode,
    actionCause
  })
);
var selectAnswerApiQueryParams = (0, import_toolkit12.createSelector)(
  (state) => state.generatedAnswer?.answerApiQueryParams,
  (answerApiQueryParams) => answerApiQueryParams
);

// src/features/generated-answer/generated-answer-actions.ts
var import_bueno14 = require("@coveo/bueno");
var import_toolkit20 = require("@reduxjs/toolkit");

// src/api/knowledge/answer-generation/answer-generation-api-state.ts
var initialAnswerGenerationServerState = () => ({
  contentFormat: void 0,
  answer: void 0,
  citations: void 0,
  error: void 0,
  generated: false,
  isStreaming: false,
  isLoading: true
});

// src/utils/fetch-event-source/parse.ts
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10 /* NewLine */) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58 /* Colon */:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case 13 /* CarriageReturn */:
            discardTrailingNewline = true;
            lineEnd = position;
            break;
          case 10 /* NewLine */:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage?.(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field) {
        case "data":
          message.data = message.data ? `${message.data}
${value}` : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          retry3(value, message, onRetry);
          break;
      }
    }
  };
}
function retry3(value, message, onRetry) {
  const retry4 = parseInt(value, 10);
  if (!Number.isNaN(retry4)) {
    onRetry(message.retry = retry4);
  }
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}

// src/utils/fetch-event-source/fetch.ts
var EventStreamContentType = "text/event-stream";
var DefaultRetryInterval = 1e3;
var LastEventId = "last-event-id";
function isBrowser2() {
  return typeof window !== "undefined";
}
function fetchEventSource(input, {
  signal: inputSignal,
  headers: inputHeaders,
  onopen: inputOnOpen,
  onmessage,
  onclose,
  onerror,
  openWhenHidden,
  fetch: inputFetch,
  ...rest
}) {
  return new Promise((resolve, reject) => {
    const headers = { ...inputHeaders };
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController?.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden && isBrowser2()) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer;
    function dispose() {
      if (isBrowser2()) {
        document.removeEventListener("visibilitychange", onVisibilityChange);
      }
      clearTimeout(retryTimer);
      curRequestController?.abort();
    }
    inputSignal?.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const outputFetch = inputFetch ?? fetch;
    const onopen = inputOnOpen ?? defaultOnOpen;
    async function create() {
      curRequestController = AbortController ? new AbortController() : null;
      try {
        const response = await outputFetch(input, {
          ...rest,
          headers,
          signal: curRequestController?.signal
        });
        await onopen(response);
        await getBytes(
          response.body,
          getLines(
            getMessages(
              (id) => {
                if (id) {
                  headers[LastEventId] = id;
                } else {
                  delete headers[LastEventId];
                }
              },
              (retry4) => {
                retryInterval = retry4;
              },
              onmessage
            )
          )
        );
        onclose?.();
        dispose();
        resolve();
      } catch (err) {
        if (!curRequestController?.signal?.aborted) {
          try {
            const interval = onerror?.(err) ?? retryInterval;
            clearTimeout(retryTimer);
            retryTimer = setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType?.startsWith(EventStreamContentType)) {
    throw new Error(
      `Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`
    );
  }
}

// src/api/knowledge/answer-generation/streaming/answer-draft-reducer/answer-draft-reducer.ts
var setAnswerId = (draft, answerId) => {
  if (answerId) {
    draft.answerId = answerId;
  }
};
var initializeStreamingAnswer = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var setAnswer = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var setCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var endStreaming = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var setAnswerError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code ?? 500
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(
    `Generated answer error: ${errorMessage} (code: ${message.code})`
  );
};

// src/api/knowledge/answer-generation/streaming/server-state-event-handler/server-state-event-handler.ts
var serverStateEventHandler = {
  handleOpen: (response, updateCachedData) => {
    const answerId = response.headers.get("x-answer-id");
    if (answerId) {
      updateCachedData((draft) => {
        setAnswerId(draft, answerId);
      });
    }
  },
  handleMessage: {
    "agentInteraction.answerHeader": (_message, updateCachedData) => {
      updateCachedData((draft) => {
        initializeStreamingAnswer(draft, { contentFormat: "text/markdown" });
      });
    },
    "generativeengines.messageType": (message, updateCachedData) => {
      if (message?.payload?.textDelta) {
        updateCachedData((draft) => {
          setAnswer(draft, message.payload);
        });
      }
    },
    "agentInteraction.citations": (message, updateCachedData) => {
      if (message?.payload?.citations !== void 0) {
        updateCachedData((draft) => {
          setCitations(draft, message.payload);
        });
      }
    },
    "generativeengines.endOfStreamType": (message, updateCachedData) => {
      updateCachedData((draft) => {
        endStreaming(draft, message.payload);
      });
    },
    error: (message, updateCachedData) => {
      if (message.finishReason === "ERROR") {
        updateCachedData((draft) => {
          setAnswerError(draft, message);
        });
      }
    }
  }
};

// src/api/knowledge/answer-generation/streaming/answer-streaming-runner.ts
var streamAnswerWithStrategy = (endpointUrl, args, api, strategy) => {
  const { dispatch, updateCachedData, getState } = api;
  const {
    configuration: { accessToken }
  } = getState();
  return fetchEventSource(endpointUrl, {
    method: "POST",
    body: JSON.stringify(args),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "text/event-stream",
      "Content-Type": "application/json",
      "Accept-Encoding": "*"
    },
    fetch,
    onopen: async (response) => {
      serverStateEventHandler.handleOpen(response, updateCachedData);
      strategy.handleOpen(response, dispatch);
    },
    onclose: () => {
      strategy.handleClose?.(dispatch);
    },
    onerror: (error) => {
      strategy.handleError(error);
    },
    onmessage: (event) => {
      const message = parsePayload(event.data);
      if (!message) {
        return;
      }
      serverStateEventHandler.handleMessage.error?.(message, updateCachedData);
      strategy.handleMessage.error?.(message, dispatch);
      const messageType = message.payloadType;
      serverStateEventHandler.handleMessage[messageType]?.(
        message,
        updateCachedData
      );
      strategy.handleMessage[messageType]?.(message, dispatch);
    }
  });
};
function parsePayload(payload) {
  if (!payload?.length) {
    return null;
  }
  try {
    return JSON.parse(payload);
  } catch (err) {
    console.warn("Failed to parse message", {
      payload,
      error: err
    });
    return null;
  }
}

// src/features/follow-up-answers/follow-up-answers-actions.ts
var import_bueno6 = require("@coveo/bueno");
var import_toolkit13 = require("@reduxjs/toolkit");

// src/api/knowledge/answer-generation/endpoints/follow-up/url-builders/endpoint-url-builder.ts
var buildFollowUpEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const {
    organizationId,
    environment,
    knowledge: { agentId }
  } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId?.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for follow up endpoint");
  }
  const basePath = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath}/${trimmedAgentId}/follow-up`;
};

// src/api/knowledge/answer-generation/endpoints/follow-up/follow-up-endpoint.ts
var followUpEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateFollowUpAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        const { strategyKey, ...params } = args;
        const endpointUrl = buildFollowUpEndpointUrl(
          getState()
        );
        await streamAnswerWithStrategy(
          endpointUrl,
          params,
          {
            getState,
            updateCachedData,
            dispatch
          },
          streamingStrategyCreators[strategyKey]?.()
        );
      }
    })
  })
});
var initiateFollowUpEndpoint = (args) => {
  return followUpEndpoint.endpoints.generateFollowUpAnswer.initiate(args);
};

// src/features/configuration/configuration-selectors.ts
var selectLocale = (state) => state.configuration.search.locale;
var selectTimezone = (state) => state.configuration.search.timezone;
var selectAgentId = (state) => state.configuration?.knowledge?.agentId;

// src/features/follow-up-answers/follow-up-answer-request.ts
var constructGenerateFollowUpAnswerParams = (followUpQuestion, state) => {
  const conversationId = state.followUpAnswers?.conversationId ?? "";
  return {
    conversationId,
    q: followUpQuestion
  };
};

// src/features/follow-up-answers/follow-up-answers-actions.ts
var stringValue = new import_bueno6.StringValue({ required: true });
var setIsEnabled = (0, import_toolkit13.createAction)(
  "followUpAnswers/setIsEnabled",
  (payload) => validatePayload(payload, new import_bueno6.BooleanValue({ required: true }))
);
var setFollowUpAnswersConversationId = (0, import_toolkit13.createAction)(
  "followUpAnswers/setFollowUpAnswersConversationId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var createFollowUpAnswer = (0, import_toolkit13.createAction)(
  "followUpAnswers/createFollowUpAnswer",
  (payload) => validatePayload(payload, {
    question: requiredNonEmptyString
  })
);
var setActiveFollowUpAnswerId = (0, import_toolkit13.createAction)(
  "followUpAnswers/setActiveFollowUpAnswerId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setFollowUpAnswerContentFormat = (0, import_toolkit13.createAction)(
  "followUpAnswers/setFollowUpAnswerContentFormat",
  (payload) => validatePayload(payload, {
    contentFormat: answerContentFormatSchema,
    answerId: requiredNonEmptyString
  })
);
var setFollowUpIsLoading = (0, import_toolkit13.createAction)(
  "followUpAnswers/setFollowUpIsLoading",
  (payload) => validatePayload(payload, {
    isLoading: new import_bueno6.BooleanValue({ required: true }),
    answerId: requiredNonEmptyString
  })
);
var followUpMessageChunkReceived = (0, import_toolkit13.createAction)(
  "followUpAnswers/followUpMessageChunkReceived",
  (payload) => validatePayload(payload, {
    textDelta: stringValue,
    answerId: requiredNonEmptyString
  })
);
var followUpCitationsReceived = (0, import_toolkit13.createAction)(
  "followUpAnswers/followUpCitationsReceived",
  (payload) => validatePayload(payload, {
    citations: new import_bueno6.ArrayValue({
      required: true,
      each: new import_bueno6.RecordValue({
        values: citationSchema
      })
    }),
    answerId: requiredNonEmptyString
  })
);
var followUpCompleted = (0, import_toolkit13.createAction)(
  "followUpAnswers/followUpCompleted",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString,
    cannotAnswer: new import_bueno6.BooleanValue({ required: false })
  })
);
var followUpFailed = (0, import_toolkit13.createAction)(
  "followUpAnswers/followUpFailed",
  (payload) => validatePayload(payload, {
    message: new import_bueno6.StringValue(),
    code: new import_bueno6.NumberValue({ min: 0 }),
    answerId: requiredNonEmptyString
  })
);
var likeFollowUp = (0, import_toolkit13.createAction)(
  "followUpAnswers/likeFollowUp",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var dislikeFollowUp = (0, import_toolkit13.createAction)(
  "followUpAnswers/dislikeFollowUp",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var submitFollowUpFeedback = (0, import_toolkit13.createAction)(
  "followUpAnswers/submitFollowUpFeedback",
  (payload) => validatePayload(payload, {
    answerId: requiredNonEmptyString
  })
);
var resetFollowUpAnswers = (0, import_toolkit13.createAction)(
  "followUpAnswers/resetFollowUpAnswers"
);
var generateFollowUpAnswer = (0, import_toolkit13.createAsyncThunk)(
  "generatedAnswerWithFollowUps/generateFollowUpAnswer",
  async (question, { getState, dispatch, extra: { logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state)?.trim();
    const generateFollowUpAnswerParams = constructGenerateFollowUpAnswerParams(
      question,
      state
    );
    if (!agentId) {
      logger.warn(
        "Missing agentId in engine configuration. The generateFollowUpAnswer action requires an agent ID."
      );
      return;
    }
    if (!generateFollowUpAnswerParams.conversationId) {
      logger.warn(
        "Missing conversationId when generating a follow-up answer. The generateFollowUpAnswer action requires an existing conversation."
      );
      return;
    }
    dispatch(createFollowUpAnswer({ question }));
    await dispatch(
      initiateFollowUpEndpoint({
        strategyKey: "follow-up-answer",
        ...generateFollowUpAnswerParams
      })
    );
  }
);

// src/features/follow-up-answers/follow-up-answer-strategy.ts
var createFollowUpAnswerStrategy = () => {
  let answerId = null;
  return {
    handleOpen: (response, dispatch) => {
      answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setActiveFollowUpAnswerId(answerId));
        dispatch(setFollowUpIsLoading({ answerId, isLoading: true }));
        dispatch(
          setFollowUpAnswerContentFormat({
            contentFormat: "text/markdown",
            answerId
          })
        );
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "generativeengines.messageType": (message, dispatch) => {
        if (message?.payload?.textDelta) {
          dispatch(
            followUpMessageChunkReceived({
              textDelta: message.payload.textDelta,
              answerId
            })
          );
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        if (message?.payload?.citations !== void 0) {
          dispatch(
            followUpCitationsReceived({
              citations: message.payload.citations,
              answerId
            })
          );
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        const answerGenerated = message?.payload?.answerGenerated ?? false;
        dispatch(
          followUpCompleted({
            cannotAnswer: !answerGenerated,
            answerId
          })
        );
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(
            followUpFailed({
              answerId,
              message: message.errorMessage,
              code: message.code
            })
          );
        }
      }
    }
  };
};

// src/features/analytics/analytics-utils.ts
var import_bueno9 = require("@coveo/bueno");
var import_toolkit15 = require("@reduxjs/toolkit");

// ../../node_modules/.pnpm/coveo.analytics@2.30.52_encoding@0.1.13_react-native@0.83.1_@babel+core@7.28.6_@types+react@19.2.7_react@19.2.3_/node_modules/coveo.analytics/dist/browser.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var EventType;
(function(EventType2) {
  EventType2["search"] = "search";
  EventType2["click"] = "click";
  EventType2["custom"] = "custom";
  EventType2["view"] = "view";
  EventType2["collect"] = "collect";
})(EventType || (EventType = {}));
function hasWindow() {
  return typeof window !== "undefined";
}
function hasNavigator() {
  return typeof navigator !== "undefined";
}
function hasDocument() {
  return typeof document !== "undefined";
}
function hasLocalStorage() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage() {
  return hasNavigator() && navigator.cookieEnabled;
}
var eventTypesForDefaultValues = [EventType.click, EventType.custom, EventType.search, EventType.view];
var addDefaultValues = (eventType, payload) => {
  return eventTypesForDefaultValues.indexOf(eventType) !== -1 ? Object.assign({ language: hasDocument() ? document.documentElement.lang : "unknown", userAgent: hasNavigator() ? navigator.userAgent : "unknown" }, payload) : payload;
};
var Cookie = class _Cookie {
  static set(name, value, expire) {
    var domain, expirationDate, domainParts, host;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    host = window.location.hostname;
    if (host.indexOf(".") === -1) {
      writeCookie(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    var cookiePrefix = name + "=";
    var cookieArray = document.cookie.split(";");
    for (var i = 0; i < cookieArray.length; i++) {
      var cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}
function getAvailableStorage() {
  if (hasLocalStorage()) {
    return localStorage;
  }
  if (hasCookieStorage()) {
    return new CookieStorage();
  }
  if (hasSessionStorage()) {
    return sessionStorage;
  }
  return new NullStorage();
}
var CookieStorage = class _CookieStorage2 {
  getItem(key) {
    return Cookie.get(`${_CookieStorage2.prefix}${key}`);
  }
  removeItem(key) {
    Cookie.erase(`${_CookieStorage2.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie.set(`${_CookieStorage2.prefix}${key}`, data, expire);
  }
};
CookieStorage.prefix = "coveo_";
var CookieAndLocalStorage = class {
  constructor() {
    this.cookieStorage = new CookieStorage();
  }
  getItem(key) {
    return localStorage.getItem(key) || this.cookieStorage.getItem(key);
  }
  removeItem(key) {
    this.cookieStorage.removeItem(key);
    localStorage.removeItem(key);
  }
  setItem(key, data) {
    localStorage.setItem(key, data);
    this.cookieStorage.setItem(key, data, 31556926e3);
  }
};
var NullStorage = class {
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, data) {
  }
};
var STORE_KEY = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE = 1e3 * 60;
var MAX_VALUE_SIZE = 75;
var HistoryStore = class {
  constructor(store) {
    this.store = store || getAvailableStorage();
  }
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    let currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory != null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  addElementAsync(elem) {
    return __awaiter(this, void 0, void 0, function* () {
      elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
      elem = this.cropQueryElement(this.stripEmptyQuery(elem));
      let currentHistory = yield this.getHistoryWithInternalTimeAsync();
      if (currentHistory != null) {
        if (this.isValidEntry(elem)) {
          this.setHistory([elem].concat(currentHistory));
        }
      } else {
        this.setHistory([elem]);
      }
    });
  }
  getHistory() {
    const history = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history));
  }
  getHistoryAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      const history = yield this.getHistoryWithInternalTimeAsync();
      return this.stripEmptyQueries(this.stripInternalTime(history));
    });
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  getHistoryWithInternalTimeAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const elements = yield this.store.getItem(STORE_KEY);
        if (elements) {
          return JSON.parse(elements);
        } else {
          return [];
        }
      } catch (e) {
        return [];
      }
    });
  }
  setHistory(history) {
    try {
      this.store.setItem(STORE_KEY, JSON.stringify(history.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    let currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE);
    }
    return part;
  }
  isValidEntry(elem) {
    let lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value == elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE;
    }
    return true;
  }
  stripInternalTime(history) {
    if (Array.isArray(history)) {
      return history.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history) {
    return history.map((part) => this.stripEmptyQuery(part));
  }
};
var enhanceViewEvent = (eventType, payload) => __awaiter(void 0, void 0, void 0, function* () {
  if (eventType === EventType.view) {
    yield addPageViewToHistory(payload.contentIdValue);
    return Object.assign({ location: window.location.toString(), referrer: document.referrer, title: document.title }, payload);
  }
  return payload;
});
var addPageViewToHistory = (pageViewValue) => __awaiter(void 0, void 0, void 0, function* () {
  const store = new HistoryStore();
  const historyElement = {
    name: "PageView",
    value: pageViewValue,
    time: (/* @__PURE__ */ new Date()).toISOString()
  };
  yield store.addElementAsync(historyElement);
});
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var v5 = v35("v5", 80, sha1);
var uuidv5 = v5;
var libVersion = "2.30.52";
var getFormattedLocation = (location) => `${location.protocol}//${location.hostname}${location.pathname.indexOf("/") === 0 ? location.pathname : `/${location.pathname}`}${location.search}`;
var BasePluginEventTypes = {
  pageview: "pageview",
  event: "event"
};
var Plugin = class {
  constructor({ client, uuidGenerator = v4 }) {
    this.client = client;
    this.uuidGenerator = uuidGenerator;
  }
};
var BasePlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
    this.actionData = {};
    this.pageViewId = uuidGenerator();
    this.nextPageViewId = this.pageViewId;
    this.currentLocation = getFormattedLocation(window.location);
    this.lastReferrer = hasDocument() ? document.referrer : "";
    this.addHooks();
  }
  getApi(name) {
    switch (name) {
      case "setAction":
        return this.setAction;
      default:
        return null;
    }
  }
  setAction(action, options) {
    this.action = action;
    this.actionData = options;
  }
  clearData() {
    this.clearPluginData();
    this.action = void 0;
    this.actionData = {};
  }
  getLocationInformation(eventType, payload) {
    return Object.assign({ hitType: eventType }, this.getNextValues(eventType, payload));
  }
  updateLocationInformation(eventType, payload) {
    this.updateLocationForNextPageView(eventType, payload);
  }
  getDefaultContextInformation(eventType) {
    const documentContext = {
      title: hasDocument() ? document.title : "",
      encoding: hasDocument() ? document.characterSet : "UTF-8"
    };
    const screenContext = {
      screenResolution: `${screen.width}x${screen.height}`,
      screenColor: `${screen.colorDepth}-bit`
    };
    const navigatorContext = {
      language: navigator.language,
      userAgent: navigator.userAgent
    };
    const eventContext = {
      time: Date.now(),
      eventId: this.uuidGenerator()
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, eventContext), screenContext), navigatorContext), documentContext);
  }
  updateLocationForNextPageView(eventType, payload) {
    const { pageViewId, referrer, location } = this.getNextValues(eventType, payload);
    this.lastReferrer = referrer;
    this.pageViewId = pageViewId;
    this.currentLocation = location;
    if (eventType === BasePluginEventTypes.pageview) {
      this.nextPageViewId = this.uuidGenerator();
      this.hasSentFirstPageView = true;
    }
  }
  getNextValues(eventType, payload) {
    return {
      pageViewId: eventType === BasePluginEventTypes.pageview ? this.nextPageViewId : this.pageViewId,
      referrer: eventType === BasePluginEventTypes.pageview && this.hasSentFirstPageView ? this.currentLocation : this.lastReferrer,
      location: eventType === BasePluginEventTypes.pageview ? this.getCurrentLocationFromPayload(payload) : this.currentLocation
    };
  }
  getCurrentLocationFromPayload(payload) {
    if (!!payload.page) {
      const removeStartingSlash = (page) => page.replace(/^\/?(.*)$/, "/$1");
      const extractHostnamePart = (location) => location.split("/").slice(0, 3).join("/");
      return `${extractHostnamePart(this.currentLocation)}${removeStartingSlash(payload.page)}`;
    } else {
      return getFormattedLocation(window.location);
    }
  }
};
var CoveoLinkParam = class _CoveoLinkParam {
  constructor(clientId, timestamp) {
    if (!validate(clientId))
      throw Error("Not a valid uuid");
    this.clientId = clientId;
    this.creationDate = Math.floor(timestamp / 1e3);
  }
  toString() {
    return this.clientId.replace(/-/g, "") + "." + this.creationDate.toString();
  }
  get expired() {
    const age = Math.floor(Date.now() / 1e3) - this.creationDate;
    return age < 0 || age > _CoveoLinkParam.expirationTime;
  }
  validate(referrerString, referrerList) {
    return !this.expired && this.matchReferrer(referrerString, referrerList);
  }
  matchReferrer(referrerString, referrerList) {
    try {
      const url = new URL(referrerString);
      return referrerList.some((value) => {
        const hostRegExp = new RegExp(value.replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*") + "$");
        return hostRegExp.test(url.host);
      });
    } catch (error) {
      return false;
    }
  }
  static fromString(input) {
    const parts = input.split(".");
    if (parts.length !== 2) {
      return null;
    }
    const [clientIdPart, creationDate] = parts;
    if (clientIdPart.length !== 32 || isNaN(parseInt(creationDate))) {
      return null;
    }
    const clientId = clientIdPart.substring(0, 8) + "-" + clientIdPart.substring(8, 12) + "-" + clientIdPart.substring(12, 16) + "-" + clientIdPart.substring(16, 20) + "-" + clientIdPart.substring(20, 32);
    if (validate(clientId)) {
      return new _CoveoLinkParam(clientId, Number.parseInt(creationDate) * 1e3);
    } else {
      return null;
    }
  }
};
CoveoLinkParam.cvo_cid = "cvo_cid";
CoveoLinkParam.expirationTime = 120;
var LinkPlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
  }
  getApi(name) {
    switch (name) {
      case "decorate":
        return this.decorate;
      case "acceptFrom":
        return this.acceptFrom;
      default:
        return null;
    }
  }
  decorate(urlString) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.client.getCurrentVisitorId) {
        throw new Error("Could not retrieve current clientId");
      }
      try {
        const url = new URL(urlString);
        const clientId = yield this.client.getCurrentVisitorId();
        url.searchParams.set(CoveoLinkParam.cvo_cid, new CoveoLinkParam(clientId, Date.now()).toString());
        return url.toString();
      } catch (error) {
        throw new Error("Invalid URL provided");
      }
    });
  }
  acceptFrom(acceptedReferrers) {
    this.client.setAcceptedLinkReferrers(acceptedReferrers);
  }
};
LinkPlugin.Id = "link";
var keysOf = Object.keys;
function isObject(o) {
  return o !== null && typeof o === "object" && !Array.isArray(o);
}
var UTF8_HIGH_BIT = 128;
var UTF8_HEADER_2 = 192;
var UTF8_HEADER_3 = 224;
var UTF8_HEADER_4 = 240;
function utf8ByteCountFromFirstByte(firstByte) {
  if ((firstByte & 248) === UTF8_HEADER_4) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_4) === UTF8_HEADER_3) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_3) === UTF8_HEADER_2) {
    return 2;
  }
  return 1;
}
function truncateUrl(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT) != UTF8_HIGH_BIT) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_2) != UTF8_HIGH_BIT) {
      if (limit - end >= utf8ByteCountFromFirstByte(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
var ticketKeysMapping = {
  id: "svc_ticket_id",
  subject: "svc_ticket_subject",
  description: "svc_ticket_description",
  category: "svc_ticket_category",
  productId: "svc_ticket_product_id",
  custom: "svc_ticket_custom"
};
var ticketKeysMappingValues = keysOf(ticketKeysMapping).map((key) => ticketKeysMapping[key]);
var ticketSubKeysMatchGroup = [...ticketKeysMappingValues].join("|");
var ticketKeyRegex = new RegExp(`^(${ticketSubKeysMatchGroup}$)`);
var serviceActionsKeysMapping = {
  svcAction: "svc_action",
  svcActionData: "svc_action_data"
};
var convertTicketToMeasurementProtocol = (ticket) => {
  return keysOf(ticket).filter((key) => ticket[key] !== void 0).reduce((mappedTicket, key) => {
    const newKey = ticketKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedTicket), { [newKey]: ticket[key] });
  }, {});
};
var isTicketKey = (key) => ticketKeyRegex.test(key);
var isServiceKey = [isTicketKey];
var productKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  price: "pr",
  quantity: "qt",
  coupon: "cc",
  position: "ps",
  group: "group"
};
var impressionKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  position: "ps",
  price: "pr",
  group: "group"
};
var productActionsKeysMapping = {
  action: "pa",
  list: "pal",
  listSource: "pls"
};
var transactionActionsKeysMapping = {
  id: "ti",
  revenue: "tr",
  tax: "tt",
  shipping: "ts",
  coupon: "tcc",
  affiliation: "ta",
  step: "cos",
  option: "col"
};
var coveoCommerceExtensionKeys = [
  "loyaltyCardId",
  "loyaltyTier",
  "thirdPartyPersona",
  "companyName",
  "favoriteStore",
  "storeName",
  "userIndustry",
  "userRole",
  "userDepartment",
  "businessUnit"
];
var quoteActionsKeysMapping = {
  id: "quoteId",
  affiliation: "quoteAffiliation"
};
var reviewActionsKeysMapping = {
  id: "reviewId",
  rating: "reviewRating",
  comment: "reviewComment"
};
var commerceActionKeysMappingPerAction = {
  add: productActionsKeysMapping,
  bookmark_add: productActionsKeysMapping,
  bookmark_remove: productActionsKeysMapping,
  click: productActionsKeysMapping,
  checkout: productActionsKeysMapping,
  checkout_option: productActionsKeysMapping,
  detail: productActionsKeysMapping,
  impression: productActionsKeysMapping,
  remove: productActionsKeysMapping,
  refund: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  purchase: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  quickview: productActionsKeysMapping,
  quote: Object.assign(Object.assign({}, productActionsKeysMapping), quoteActionsKeysMapping),
  review: Object.assign(Object.assign({}, productActionsKeysMapping), reviewActionsKeysMapping)
};
var productKeysMappingValues = keysOf(productKeysMapping).map((key) => productKeysMapping[key]);
var impressionKeysMappingValues = keysOf(impressionKeysMapping).map((key) => impressionKeysMapping[key]);
var productActionsKeysMappingValues = keysOf(productActionsKeysMapping).map((key) => productActionsKeysMapping[key]);
var transactionActionsKeysMappingValues = keysOf(transactionActionsKeysMapping).map((key) => transactionActionsKeysMapping[key]);
var reviewKeysMappingValues = keysOf(reviewActionsKeysMapping).map((key) => reviewActionsKeysMapping[key]);
var quoteKeysMappingValues = keysOf(quoteActionsKeysMapping).map((key) => quoteActionsKeysMapping[key]);
var productSubKeysMatchGroup = [...productKeysMappingValues, "custom"].join("|");
var impressionSubKeysMatchGroup = [...impressionKeysMappingValues, "custom"].join("|");
var productPrefixMatchGroup = "(pr[0-9]+)";
var impressionPrefixMatchGroup = "(il[0-9]+pi[0-9]+)";
var productKeyRegex = new RegExp(`^${productPrefixMatchGroup}(${productSubKeysMatchGroup})$`);
var impressionKeyRegex = new RegExp(`^(${impressionPrefixMatchGroup}(${impressionSubKeysMatchGroup}))|(il[0-9]+nm)$`);
var productActionsKeyRegex = new RegExp(`^(${productActionsKeysMappingValues.join("|")})$`);
var transactionActionsKeyRegex = new RegExp(`^(${transactionActionsKeysMappingValues.join("|")})$`);
var customProductKeyRegex = new RegExp(`^${productPrefixMatchGroup}custom$`);
var customImpressionKeyRegex = new RegExp(`^${impressionPrefixMatchGroup}custom$`);
var coveoCommerceExtensionKeysRegex = new RegExp(`^(${[...coveoCommerceExtensionKeys, ...reviewKeysMappingValues, ...quoteKeysMappingValues].join("|")})$`);
var isProductKey = (key) => productKeyRegex.test(key);
var isImpressionKey = (key) => impressionKeyRegex.test(key);
var isProductActionsKey = (key) => productActionsKeyRegex.test(key);
var isTransactionActionsKeyRegex = (key) => transactionActionsKeyRegex.test(key);
var isCoveoCommerceExtensionKey = (key) => coveoCommerceExtensionKeysRegex.test(key);
var isCommerceKey = [
  isImpressionKey,
  isProductKey,
  isProductActionsKey,
  isTransactionActionsKeyRegex,
  isCoveoCommerceExtensionKey
];
var isCustomCommerceKey = [customProductKeyRegex, customImpressionKeyRegex];
var globalParamKeysMapping = {
  anonymizeIp: "aip"
};
var eventKeysMapping = {
  eventCategory: "ec",
  eventAction: "ea",
  eventLabel: "el",
  eventValue: "ev",
  page: "dp",
  visitorId: "cid",
  clientId: "cid",
  userId: "uid",
  currencyCode: "cu"
};
var contextInformationMapping = {
  hitType: "t",
  pageViewId: "pid",
  encoding: "de",
  location: "dl",
  referrer: "dr",
  screenColor: "sd",
  screenResolution: "sr",
  title: "dt",
  userAgent: "ua",
  language: "ul",
  eventId: "z",
  time: "tm"
};
var coveoExtensionsKeys = [
  "contentId",
  "contentIdKey",
  "contentType",
  "searchHub",
  "tab",
  "searchUid",
  "permanentId",
  "contentLocale",
  "trackingId"
];
var baseMeasurementProtocolKeysMapping = Object.assign(Object.assign(Object.assign(Object.assign({}, globalParamKeysMapping), eventKeysMapping), contextInformationMapping), coveoExtensionsKeys.reduce((all, key) => Object.assign(Object.assign({}, all), { [key]: key }), {}));
var measurementProtocolKeysMapping = Object.assign(Object.assign({}, baseMeasurementProtocolKeysMapping), serviceActionsKeysMapping);
var convertKeysToMeasurementProtocol = (params) => {
  const keysMappingForAction = !!params.action && commerceActionKeysMappingPerAction[params.action] || {};
  return keysOf(params).reduce((mappedKeys, key) => {
    const newKey = keysMappingForAction[key] || measurementProtocolKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedKeys), { [newKey]: params[key] });
  }, {});
};
var measurementProtocolKeysMappingValues = keysOf(measurementProtocolKeysMapping).map((key) => measurementProtocolKeysMapping[key]);
var isKnownMeasurementProtocolKey = (key) => measurementProtocolKeysMappingValues.indexOf(key) !== -1;
var isCustomKey = (key) => key === "custom";
var isMeasurementProtocolKey = (key) => {
  return [...isCommerceKey, ...isServiceKey, isKnownMeasurementProtocolKey, isCustomKey].some((test) => test(key));
};
var convertCustomMeasurementProtocolKeys = (data) => {
  return keysOf(data).reduce((all, current) => {
    const match = getFirstCustomMeasurementProtocolKeyMatch(current);
    if (match) {
      return Object.assign(Object.assign({}, all), convertCustomObject(match, data[current]));
    } else {
      return Object.assign(Object.assign({}, all), { [current]: data[current] });
    }
  }, {});
};
var getFirstCustomMeasurementProtocolKeyMatch = (key) => {
  let matchedKey = void 0;
  [...isCustomCommerceKey].every((regex) => {
    var _a;
    matchedKey = (_a = regex.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
    return !Boolean(matchedKey);
  });
  return matchedKey;
};
var convertCustomObject = (prefix, customData) => {
  return keysOf(customData).reduce((allCustom, currentCustomKey) => Object.assign(Object.assign({}, allCustom), { [`${prefix}${currentCustomKey}`]: customData[currentCustomKey] }), {});
};
var AnalyticsBeaconClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, originalPayload) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isAvailable()) {
        throw new Error(`navigator.sendBeacon is not supported in this browser. Consider adding a polyfill like "sendbeacon-polyfill".`);
      }
      const { baseUrl, preprocessRequest } = this.opts;
      const paramsFragments = yield this.getQueryParamsForEventType(eventType);
      const { url, payload } = yield this.preProcessRequestAsPotentialJSONString(`${baseUrl}/analytics/${eventType}?${paramsFragments}`, originalPayload, preprocessRequest);
      const parsedRequestData = this.encodeForEventType(eventType, payload);
      const body = new Blob([parsedRequestData], {
        type: "application/x-www-form-urlencoded"
      });
      navigator.sendBeacon(url, body);
      return;
    });
  }
  isAvailable() {
    return "sendBeacon" in navigator;
  }
  deleteHttpCookieVisitorId() {
    return Promise.resolve();
  }
  preProcessRequestAsPotentialJSONString(originalURL, originalPayload, preprocessRequest) {
    return __awaiter(this, void 0, void 0, function* () {
      let returnedUrl = originalURL;
      let returnedPayload = originalPayload;
      if (preprocessRequest) {
        const processedRequest = yield preprocessRequest({ url: originalURL, body: JSON.stringify(originalPayload) }, "analyticsBeacon");
        const { url: processedURL, body: processedBody } = processedRequest;
        returnedUrl = processedURL || originalURL;
        try {
          returnedPayload = JSON.parse(processedBody);
        } catch (e) {
          console.error("Unable to process the request body as a JSON string", e);
        }
      }
      return {
        payload: returnedPayload,
        url: returnedUrl
      };
    });
  }
  encodeForEventType(eventType, payload) {
    return this.isEventTypeLegacy(eventType) ? this.encodeEventToJson(eventType, payload) : this.encodeEventToJson(eventType, payload, this.opts.token);
  }
  getQueryParamsForEventType(eventType) {
    return __awaiter(this, void 0, void 0, function* () {
      const { token, visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return [
        token && this.isEventTypeLegacy(eventType) ? `access_token=${token}` : "",
        visitorId ? `visitorId=${visitorId}` : "",
        "discardVisitInfo=true"
      ].filter((p) => !!p).join("&");
    });
  }
  isEventTypeLegacy(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  encodeEventToJson(eventType, payload, access_token) {
    let encoded = `${eventType}Event=${encodeURIComponent(JSON.stringify(payload))}`;
    if (access_token) {
      encoded = `access_token=${encodeURIComponent(access_token)}&${encoded}`;
    }
    return encoded;
  }
};
var NoopAnalyticsClient = class {
  sendEvent(_, __) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
};
var fetch$1 = globalThis.fetch;
var AnalyticsFetchClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl, visitorIdProvider, preprocessRequest } = this.opts;
      const visitorIdParam = this.shouldAppendVisitorId(eventType) ? yield this.getVisitorIdParam() : "";
      const defaultOptions = {
        url: `${baseUrl}/analytics/${eventType}${visitorIdParam}`,
        credentials: "include",
        mode: "cors",
        headers: this.getHeaders(),
        method: "POST",
        body: JSON.stringify(payload)
      };
      const _a = Object.assign(Object.assign({}, defaultOptions), preprocessRequest ? yield preprocessRequest(defaultOptions, "analyticsFetch") : {}), { url } = _a, fetchData = __rest(_a, ["url"]);
      let response;
      try {
        response = yield fetch$1(url, fetchData);
      } catch (error) {
        console.error("An error has occured when sending the event.", error);
        return;
      }
      if (response.ok) {
        const visit = yield response.json();
        if (visit.visitorId) {
          visitorIdProvider.setCurrentVisitorId(visit.visitorId);
        }
        return visit;
      } else {
        try {
          response.json();
        } catch (_b) {
        }
        console.error(`An error has occured when sending the "${eventType}" event.`, response, payload);
        throw new Error(`An error has occurred when sending the "${eventType}" event. Check the console logs for more details.`);
      }
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl } = this.opts;
      const url = `${baseUrl}/analytics/visit`;
      yield fetch$1(url, { headers: this.getHeaders(), method: "DELETE" });
    });
  }
  shouldAppendVisitorId(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  getVisitorIdParam() {
    return __awaiter(this, void 0, void 0, function* () {
      const { visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return visitorId ? `?visitor=${visitorId}` : "";
    });
  }
  getHeaders() {
    const { token } = this.opts;
    return Object.assign(Object.assign({}, token ? { Authorization: `Bearer ${token}` } : {}), { "Content-Type": `application/json` });
  }
};
var BrowserRuntime = class {
  constructor(clientOptions, getUnprocessedRequests) {
    if (hasLocalStorage() && hasCookieStorage()) {
      this.storage = new CookieAndLocalStorage();
    } else if (hasLocalStorage()) {
      this.storage = localStorage;
    } else {
      console.warn("BrowserRuntime detected no valid storage available.", this);
      this.storage = new NullStorage();
    }
    this.client = new AnalyticsFetchClient(clientOptions);
    this.beaconClient = new AnalyticsBeaconClient(clientOptions);
    window.addEventListener("beforeunload", () => {
      const requests = getUnprocessedRequests();
      for (let { eventType, payload } of requests) {
        this.beaconClient.sendEvent(eventType, payload);
      }
    });
  }
  getClientDependingOnEventType(eventType) {
    return eventType === "click" && this.beaconClient.isAvailable() ? this.beaconClient : this.client;
  }
};
var NodeJSRuntime = class {
  constructor(clientOptions, storage) {
    this.storage = storage || new NullStorage();
    this.client = new AnalyticsFetchClient(clientOptions);
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var NoopRuntime = class {
  constructor() {
    this.storage = new NullStorage();
    this.client = new NoopAnalyticsClient();
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var API_KEY_PREFIX = "xx";
var isApiKey = (token) => (token === null || token === void 0 ? void 0 : token.startsWith(API_KEY_PREFIX)) || false;
var ReactNativeRuntimeWarning = `
        We've detected you're using React Native but have not provided the corresponding runtime, 
        for an optimal experience please use the "coveo.analytics/react-native" subpackage.
        Follow the Readme on how to set it up: https://github.com/coveo/coveo.analytics.js#using-react-native
    `;
function isReactNative() {
  return typeof navigator != "undefined" && navigator.product == "ReactNative";
}
var doNotTrackValues2 = ["1", 1, "yes", true];
function doNotTrack2() {
  const checks = [];
  if (hasWindow()) {
    checks.push(window.doNotTrack);
  }
  if (hasNavigator()) {
    checks.push(navigator.doNotTrack, navigator.msDoNotTrack, navigator.globalPrivacyControl);
  }
  return checks.some((value) => doNotTrackValues2.indexOf(value) !== -1);
}
var Version = "v15";
var Endpoints = {
  default: "https://analytics.cloud.coveo.com/rest/ua",
  production: "https://analytics.cloud.coveo.com/rest/ua",
  hipaa: "https://analyticshipaa.cloud.coveo.com/rest/ua"
};
function buildBaseUrl(endpoint = Endpoints.default, apiVersion = Version, isCustomEndpoint = false) {
  endpoint = endpoint.replace(/\/$/, "");
  if (isCustomEndpoint) {
    return `${endpoint}/${apiVersion}`;
  }
  const hasUARestEndpoint = endpoint.endsWith("/rest") || endpoint.endsWith("/rest/ua");
  return `${endpoint}${hasUARestEndpoint ? "" : "/rest"}/${apiVersion}`;
}
var COVEO_NAMESPACE = "38824e1f-37f5-42d3-8372-a4b8fa9df946";
var CoveoAnalyticsClient = class {
  get defaultOptions() {
    return {
      endpoint: Endpoints.default,
      isCustomEndpoint: false,
      token: "",
      version: Version,
      beforeSendHooks: [],
      afterSendHooks: []
    };
  }
  get version() {
    return libVersion;
  }
  constructor(opts) {
    this.acceptedLinkReferrers = [];
    if (!opts) {
      throw new Error("You have to pass options to this constructor");
    }
    this.options = Object.assign(Object.assign({}, this.defaultOptions), opts);
    this.visitorId = "";
    this.bufferedRequests = [];
    this.beforeSendHooks = [enhanceViewEvent, addDefaultValues].concat(this.options.beforeSendHooks);
    this.afterSendHooks = this.options.afterSendHooks;
    this.eventTypeMapping = {};
    const clientsOptions = {
      baseUrl: this.baseUrl,
      token: this.options.token,
      visitorIdProvider: this,
      preprocessRequest: this.options.preprocessRequest
    };
    if (doNotTrack2()) {
      this.runtime = new NoopRuntime();
    } else {
      this.runtime = this.options.runtimeEnvironment || this.initRuntime(clientsOptions);
    }
    this.addEventTypeMapping(EventType.view, { newEventType: EventType.view, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.click, { newEventType: EventType.click, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.custom, { newEventType: EventType.custom, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.search, { newEventType: EventType.search, addClientIdParameter: true });
  }
  initRuntime(clientsOptions) {
    if (hasWindow() && hasDocument()) {
      return new BrowserRuntime(clientsOptions, () => {
        const copy = [...this.bufferedRequests];
        this.bufferedRequests = [];
        return copy;
      });
    } else if (isReactNative()) {
      console.warn(ReactNativeRuntimeWarning);
    }
    return new NodeJSRuntime(clientsOptions);
  }
  get storage() {
    return this.runtime.storage;
  }
  determineVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return hasWindow() && this.extractClientIdFromLink(window.location.href) || (yield this.storage.getItem("visitorId")) || v4();
      } catch (err) {
        console.log("Could not get visitor ID from the current runtime environment storage. Using a random ID instead.", err);
        return v4();
      }
    });
  }
  getCurrentVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.visitorId) {
        const id = yield this.determineVisitorId();
        yield this.setCurrentVisitorId(id);
      }
      return this.visitorId;
    });
  }
  setCurrentVisitorId(visitorId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.visitorId = visitorId;
      yield this.storage.setItem("visitorId", visitorId);
    });
  }
  setClientId(value, namespace) {
    return __awaiter(this, void 0, void 0, function* () {
      if (validate(value)) {
        this.setCurrentVisitorId(value.toLowerCase());
      } else {
        if (!namespace) {
          throw Error("Cannot generate uuid client id without a specific namespace string.");
        }
        this.setCurrentVisitorId(uuidv5(value, uuidv5(namespace, COVEO_NAMESPACE)));
      }
    });
  }
  getParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.resolveParameters(eventType, ...payload);
    });
  }
  getPayload(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      return yield this.resolvePayloadForParameters(eventType, parametersToSend);
    });
  }
  get currentVisitorId() {
    const visitorId = this.visitorId || this.storage.getItem("visitorId");
    if (typeof visitorId !== "string") {
      this.setCurrentVisitorId(v4());
    }
    return this.visitorId;
  }
  set currentVisitorId(visitorId) {
    this.visitorId = visitorId;
    this.storage.setItem("visitorId", visitorId);
  }
  extractClientIdFromLink(urlString) {
    if (doNotTrack2()) {
      return null;
    }
    try {
      const linkParam = new URL(urlString).searchParams.get(CoveoLinkParam.cvo_cid);
      if (linkParam == null) {
        return null;
      }
      const linker = CoveoLinkParam.fromString(linkParam);
      if (!linker || !hasDocument() || !linker.validate(document.referrer, this.acceptedLinkReferrers)) {
        return null;
      }
      return linker.clientId;
    } catch (error) {
    }
    return null;
  }
  resolveParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { variableLengthArgumentsNames = [], addVisitorIdParameter = false, usesMeasurementProtocol = false, addClientIdParameter = false } = this.eventTypeMapping[eventType] || {};
      const processVariableArgumentNamesStep = (currentPayload) => variableLengthArgumentsNames.length > 0 ? this.parseVariableArgumentsPayload(variableLengthArgumentsNames, currentPayload) : currentPayload[0];
      const addVisitorIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, currentPayload), { visitorId: addVisitorIdParameter ? yield this.getCurrentVisitorId() : "" });
      });
      const addClientIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        if (addClientIdParameter) {
          return Object.assign(Object.assign({}, currentPayload), { clientId: yield this.getCurrentVisitorId() });
        }
        return currentPayload;
      });
      const setAnonymousUserStep = (currentPayload) => usesMeasurementProtocol ? this.ensureAnonymousUserWhenUsingApiKey(currentPayload) : currentPayload;
      const processBeforeSendHooksStep = (currentPayload) => this.beforeSendHooks.reduce((promisePayload, current) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield promisePayload;
        return yield current(eventType, payload2);
      }), currentPayload);
      const parametersToSend = yield [
        processVariableArgumentNamesStep,
        addVisitorIdStep,
        addClientIdStep,
        setAnonymousUserStep,
        processBeforeSendHooksStep
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield payloadPromise;
        return yield step(payload2);
      }), Promise.resolve(payload));
      return parametersToSend;
    });
  }
  resolvePayloadForParameters(eventType, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const { usesMeasurementProtocol = false } = this.eventTypeMapping[eventType] || {};
      const addTrackingIdStep = (currentPayload) => this.setTrackingIdIfTrackingIdNotPresent(currentPayload);
      const cleanPayloadStep = (currentPayload) => this.removeEmptyPayloadValues(currentPayload, eventType);
      const validateParams = (currentPayload) => this.validateParams(currentPayload, eventType);
      const processMeasurementProtocolConversionStep = (currentPayload) => usesMeasurementProtocol ? convertKeysToMeasurementProtocol(currentPayload) : currentPayload;
      const removeUnknownParameters = (currentPayload) => usesMeasurementProtocol ? this.removeUnknownParameters(currentPayload) : currentPayload;
      const processCustomParameters = (currentPayload) => usesMeasurementProtocol ? this.processCustomParameters(currentPayload) : this.mapCustomParametersToCustomData(currentPayload);
      const payloadToSend = yield [
        addTrackingIdStep,
        cleanPayloadStep,
        validateParams,
        processMeasurementProtocolConversionStep,
        removeUnknownParameters,
        processCustomParameters
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload = yield payloadPromise;
        return yield step(payload);
      }), Promise.resolve(parameters));
      return payloadToSend;
    });
  }
  makeEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { newEventType: eventTypeToSend = eventType } = this.eventTypeMapping[eventType] || {};
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      const payloadToSend = yield this.resolvePayloadForParameters(eventType, parametersToSend);
      return {
        eventType: eventTypeToSend,
        payload: payloadToSend,
        log: (remainingPayload) => __awaiter(this, void 0, void 0, function* () {
          this.bufferedRequests.push({
            eventType: eventTypeToSend,
            payload: Object.assign(Object.assign({}, payloadToSend), remainingPayload)
          });
          yield Promise.all(this.afterSendHooks.map((hook) => hook(eventType, Object.assign(Object.assign({}, parametersToSend), remainingPayload))));
          yield this.deferExecution();
          return yield this.sendFromBuffer();
        })
      };
    });
  }
  sendEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeEvent(eventType, ...payload)).log({});
    });
  }
  deferExecution() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  sendFromBuffer() {
    return __awaiter(this, void 0, void 0, function* () {
      const popped = this.bufferedRequests.shift();
      if (popped) {
        const { eventType, payload } = popped;
        return this.runtime.getClientDependingOnEventType(eventType).sendEvent(eventType, payload);
      }
    });
  }
  clear() {
    this.storage.removeItem("visitorId");
    const store = new HistoryStore();
    store.clear();
  }
  deleteHttpOnlyVisitorId() {
    this.runtime.client.deleteHttpCookieVisitorId();
  }
  makeSearchEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.search, request);
    });
  }
  sendSearchEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeSearchEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeClickEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.click, request);
    });
  }
  sendClickEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeClickEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeCustomEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.custom, request);
    });
  }
  sendCustomEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { lastSearchQueryUid } = _a, preparedRequest = __rest(_a, ["lastSearchQueryUid"]);
      return (yield this.makeCustomEvent(preparedRequest)).log({ lastSearchQueryUid });
    });
  }
  makeViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.view, request);
    });
  }
  sendViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeViewEvent(request)).log({});
    });
  }
  getVisit() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/visit`);
      const visit = yield response.json();
      this.visitorId = visit.visitorId;
      return visit;
    });
  }
  getHealth() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/monitoring/health`);
      return yield response.json();
    });
  }
  registerBeforeSendEventHook(hook) {
    this.beforeSendHooks.push(hook);
  }
  registerAfterSendEventHook(hook) {
    this.afterSendHooks.push(hook);
  }
  addEventTypeMapping(eventType, eventConfig) {
    this.eventTypeMapping[eventType] = eventConfig;
  }
  setAcceptedLinkReferrers(hosts) {
    if (Array.isArray(hosts) && hosts.every((host) => typeof host == "string"))
      this.acceptedLinkReferrers = hosts;
    else
      throw Error("Parameter should be an array of domain strings");
  }
  parseVariableArgumentsPayload(fieldsOrder, payload) {
    const parsedArguments = {};
    for (let i = 0, length = payload.length; i < length; i++) {
      const currentArgument = payload[i];
      if (typeof currentArgument === "string") {
        parsedArguments[fieldsOrder[i]] = currentArgument;
      } else if (typeof currentArgument === "object") {
        return Object.assign(Object.assign({}, parsedArguments), currentArgument);
      }
    }
    return parsedArguments;
  }
  isKeyAllowedEmpty(evtType, key) {
    const keysThatCanBeEmpty = {
      [EventType.search]: ["queryText"]
    };
    const match = keysThatCanBeEmpty[evtType] || [];
    return match.indexOf(key) !== -1;
  }
  removeEmptyPayloadValues(payload, eventType) {
    const isNotEmptyValue = (value) => typeof value !== "undefined" && value !== null && value !== "";
    return Object.keys(payload).filter((key) => this.isKeyAllowedEmpty(eventType, key) || isNotEmptyValue(payload[key])).reduce((newPayload, key) => Object.assign(Object.assign({}, newPayload), { [key]: payload[key] }), {});
  }
  removeUnknownParameters(payload) {
    const newPayload = Object.keys(payload).filter((key) => {
      if (isMeasurementProtocolKey(key)) {
        return true;
      } else {
        console.log(key, "is not processed by coveoua");
      }
    }).reduce((newPayload2, key) => Object.assign(Object.assign({}, newPayload2), { [key]: payload[key] }), {});
    return newPayload;
  }
  processCustomParameters(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    let lowercasedCustom = {};
    if (custom && isObject(custom)) {
      lowercasedCustom = this.lowercaseKeys(custom);
    }
    const newPayload = convertCustomMeasurementProtocolKeys(rest);
    return Object.assign(Object.assign({}, lowercasedCustom), newPayload);
  }
  mapCustomParametersToCustomData(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    if (custom && isObject(custom)) {
      const lowercasedCustom = this.lowercaseKeys(custom);
      return Object.assign(Object.assign({}, rest), { customData: Object.assign(Object.assign({}, lowercasedCustom), payload.customData) });
    } else {
      return payload;
    }
  }
  lowercaseKeys(custom) {
    const keys = Object.keys(custom);
    let result = {};
    keys.forEach((key) => {
      result[key.toLowerCase()] = custom[key];
    });
    return result;
  }
  validateParams(payload, eventType) {
    const { anonymizeIp } = payload, rest = __rest(payload, ["anonymizeIp"]);
    if (anonymizeIp !== void 0) {
      if (["0", "false", "undefined", "null", "{}", "[]", ""].indexOf(`${anonymizeIp}`.toLowerCase()) == -1) {
        rest.anonymizeIp = 1;
      }
    }
    if (eventType == EventType.view || eventType == EventType.click || eventType == EventType.search || eventType == EventType.custom) {
      rest.originLevel3 = this.limit(rest.originLevel3, 1024);
    }
    if (eventType == EventType.view) {
      rest.location = this.limit(rest.location, 1024);
    }
    if (eventType == "pageview" || eventType == "event") {
      rest.referrer = this.limit(rest.referrer, 2048);
      rest.location = this.limit(rest.location, 2048);
      rest.page = this.limit(rest.page, 2048);
    }
    return rest;
  }
  ensureAnonymousUserWhenUsingApiKey(payload) {
    const { userId } = payload, rest = __rest(payload, ["userId"]);
    if (isApiKey(this.options.token) && !userId) {
      rest["userId"] = "anonymous";
      return rest;
    } else {
      return payload;
    }
  }
  setTrackingIdIfTrackingIdNotPresent(payload) {
    const { trackingId } = payload, rest = __rest(payload, ["trackingId"]);
    if (trackingId) {
      return payload;
    }
    if (rest.hasOwnProperty("custom") && isObject(rest.custom)) {
      if (rest.custom.hasOwnProperty("context_website") || rest.custom.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.custom.context_website || rest.custom.siteName;
      }
    }
    if (rest.hasOwnProperty("customData") && isObject(rest.customData)) {
      if (rest.customData.hasOwnProperty("context_website") || rest.customData.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.customData.context_website || rest.customData.siteName;
      }
    }
    return rest;
  }
  limit(input, length) {
    return typeof input === "string" ? truncateUrl(input, length) : input;
  }
  get baseUrl() {
    return buildBaseUrl(this.options.endpoint, this.options.version, this.options.isCustomEndpoint);
  }
};
var InsightEvents;
(function(InsightEvents2) {
  InsightEvents2["contextChanged"] = "contextChanged";
  InsightEvents2["expandToFullUI"] = "expandToFullUI";
  InsightEvents2["openUserActions"] = "openUserActions";
  InsightEvents2["showPrecedingSessions"] = "showPrecedingSessions";
  InsightEvents2["showFollowingSessions"] = "showFollowingSessions";
  InsightEvents2["clickViewedDocument"] = "clickViewedDocument";
  InsightEvents2["clickPageView"] = "clickPageView";
  InsightEvents2["createArticle"] = "createArticle";
})(InsightEvents || (InsightEvents = {}));
var SearchPageEvents;
(function(SearchPageEvents3) {
  SearchPageEvents3["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents3["interfaceChange"] = "interfaceChange";
  SearchPageEvents3["didyoumeanAutomatic"] = "didyoumeanAutomatic";
  SearchPageEvents3["didyoumeanClick"] = "didyoumeanClick";
  SearchPageEvents3["resultsSort"] = "resultsSort";
  SearchPageEvents3["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents3["searchboxClear"] = "searchboxClear";
  SearchPageEvents3["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents3["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents3["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents3["documentQuickview"] = "documentQuickview";
  SearchPageEvents3["documentOpen"] = "documentOpen";
  SearchPageEvents3["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents3["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents3["searchFromLink"] = "searchFromLink";
  SearchPageEvents3["triggerNotify"] = "notify";
  SearchPageEvents3["triggerExecute"] = "execute";
  SearchPageEvents3["triggerQuery"] = "query";
  SearchPageEvents3["undoTriggerQuery"] = "undoQuery";
  SearchPageEvents3["triggerRedirect"] = "redirect";
  SearchPageEvents3["pagerResize"] = "pagerResize";
  SearchPageEvents3["pagerNumber"] = "pagerNumber";
  SearchPageEvents3["pagerNext"] = "pagerNext";
  SearchPageEvents3["pagerPrevious"] = "pagerPrevious";
  SearchPageEvents3["pagerScrolling"] = "pagerScrolling";
  SearchPageEvents3["staticFilterClearAll"] = "staticFilterClearAll";
  SearchPageEvents3["staticFilterSelect"] = "staticFilterSelect";
  SearchPageEvents3["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents3["facetClearAll"] = "facetClearAll";
  SearchPageEvents3["facetSearch"] = "facetSearch";
  SearchPageEvents3["facetSelect"] = "facetSelect";
  SearchPageEvents3["facetSelectAll"] = "facetSelectAll";
  SearchPageEvents3["facetDeselect"] = "facetDeselect";
  SearchPageEvents3["facetExclude"] = "facetExclude";
  SearchPageEvents3["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents3["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents3["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents3["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents3["queryError"] = "query";
  SearchPageEvents3["queryErrorBack"] = "errorBack";
  SearchPageEvents3["queryErrorClear"] = "errorClearQuery";
  SearchPageEvents3["queryErrorRetry"] = "errorRetry";
  SearchPageEvents3["recommendation"] = "recommendation";
  SearchPageEvents3["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents3["recommendationOpen"] = "recommendationOpen";
  SearchPageEvents3["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents3["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents3["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents3["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents3["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents3["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents3["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents3["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents3["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents3["showMoreSmartSnippetSuggestion"] = "showMoreSmartSnippetSuggestion";
  SearchPageEvents3["showLessSmartSnippetSuggestion"] = "showLessSmartSnippetSuggestion";
  SearchPageEvents3["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents3["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents3["openSmartSnippetInlineLink"] = "openSmartSnippetInlineLink";
  SearchPageEvents3["openSmartSnippetSuggestionInlineLink"] = "openSmartSnippetSuggestionInlineLink";
  SearchPageEvents3["recentQueryClick"] = "recentQueriesClick";
  SearchPageEvents3["clearRecentQueries"] = "clearRecentQueries";
  SearchPageEvents3["recentResultClick"] = "recentResultClick";
  SearchPageEvents3["clearRecentResults"] = "clearRecentResults";
  SearchPageEvents3["noResultsBack"] = "noResultsBack";
  SearchPageEvents3["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents3["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents3["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents3["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents3["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents3["caseAttach"] = "caseAttach";
  SearchPageEvents3["caseDetach"] = "caseDetach";
  SearchPageEvents3["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents3["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents3["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents3["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents3["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents3["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents3["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents3["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents3["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents3["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents3["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents3["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents3["rephraseGeneratedAnswer"] = "rephraseGeneratedAnswer";
  SearchPageEvents3["generatedAnswerFeedbackSubmitV2"] = "generatedAnswerFeedbackSubmitV2";
  SearchPageEvents3["generatedAnswerCitationClick"] = "generatedAnswerCitationClick";
  SearchPageEvents3["generatedAnswerCitationDocumentAttach"] = "generatedAnswerCitationDocumentAttach";
})(SearchPageEvents || (SearchPageEvents = {}));
var CustomEventsTypes = {
  [SearchPageEvents.triggerNotify]: "queryPipelineTriggers",
  [SearchPageEvents.triggerExecute]: "queryPipelineTriggers",
  [SearchPageEvents.triggerQuery]: "queryPipelineTriggers",
  [SearchPageEvents.triggerRedirect]: "queryPipelineTriggers",
  [SearchPageEvents.queryErrorBack]: "errors",
  [SearchPageEvents.queryErrorClear]: "errors",
  [SearchPageEvents.queryErrorRetry]: "errors",
  [SearchPageEvents.pagerNext]: "getMoreResults",
  [SearchPageEvents.pagerPrevious]: "getMoreResults",
  [SearchPageEvents.pagerNumber]: "getMoreResults",
  [SearchPageEvents.pagerResize]: "getMoreResults",
  [SearchPageEvents.pagerScrolling]: "getMoreResults",
  [SearchPageEvents.facetSearch]: "facet",
  [SearchPageEvents.facetShowLess]: "facet",
  [SearchPageEvents.facetShowMore]: "facet",
  [SearchPageEvents.recommendation]: "recommendation",
  [SearchPageEvents.likeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.dislikeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippet]: "smartSnippet",
  [SearchPageEvents.collapseSmartSnippet]: "smartSnippet",
  [SearchPageEvents.openSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.closeSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.sendSmartSnippetReason]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.collapseSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showMoreSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showLessSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.clearRecentQueries]: "recentQueries",
  [SearchPageEvents.recentResultClick]: "recentlyClickedDocuments",
  [SearchPageEvents.clearRecentResults]: "recentlyClickedDocuments",
  [SearchPageEvents.showLessFoldedResults]: "folding",
  [SearchPageEvents.caseDetach]: "case",
  [SearchPageEvents.likeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.dislikeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.openGeneratedAnswerSource]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerStreamEnd]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerSourceHover]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCopyToClipboard]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerHideAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerShowAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerExpand]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCollapse]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmit]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmitV2]: "generatedAnswer",
  [InsightEvents.expandToFullUI]: "interface",
  [InsightEvents.openUserActions]: "User Actions",
  [InsightEvents.showPrecedingSessions]: "User Actions",
  [InsightEvents.showFollowingSessions]: "User Actions",
  [InsightEvents.clickViewedDocument]: "User Actions",
  [InsightEvents.clickPageView]: "User Actions",
  [InsightEvents.createArticle]: "createArticle"
};
var NoopAnalytics = class {
  constructor() {
    this.runtime = new NoopRuntime();
    this.currentVisitorId = "";
  }
  getPayload() {
    return Promise.resolve();
  }
  getParameters() {
    return Promise.resolve();
  }
  makeEvent(eventType) {
    return Promise.resolve({ eventType, payload: null, log: () => Promise.resolve() });
  }
  sendEvent() {
    return Promise.resolve();
  }
  makeSearchEvent() {
    return this.makeEvent(EventType.search);
  }
  sendSearchEvent() {
    return Promise.resolve();
  }
  makeClickEvent() {
    return this.makeEvent(EventType.click);
  }
  sendClickEvent() {
    return Promise.resolve();
  }
  makeCustomEvent() {
    return this.makeEvent(EventType.custom);
  }
  sendCustomEvent() {
    return Promise.resolve();
  }
  makeViewEvent() {
    return this.makeEvent(EventType.view);
  }
  sendViewEvent() {
    return Promise.resolve();
  }
  getVisit() {
    return Promise.resolve({ id: "", visitorId: "" });
  }
  getHealth() {
    return Promise.resolve({ status: "" });
  }
  registerBeforeSendEventHook() {
  }
  registerAfterSendEventHook() {
  }
  addEventTypeMapping() {
  }
  get version() {
    return libVersion;
  }
};
function filterConsecutiveRepeatedValues(rawData) {
  let prev = "";
  return rawData.filter((value) => {
    const isDifferent = value !== prev;
    prev = value;
    return isDifferent;
  });
}
function removeSemicolons(rawData) {
  return rawData.map((value) => {
    return value.replace(/;/g, "");
  });
}
function getDataString(data) {
  const ANALYTICS_LENGTH_LIMIT = 256;
  const formattedData = data.join(";");
  if (formattedData.length <= ANALYTICS_LENGTH_LIMIT) {
    return formattedData;
  }
  return getDataString(data.slice(1));
}
var formatArrayForCoveoCustomData = (rawData) => {
  const dataWithoutSemicolons = removeSemicolons(rawData);
  const dataWithoutRepeatedValues = filterConsecutiveRepeatedValues(dataWithoutSemicolons);
  return getDataString(dataWithoutRepeatedValues);
};
function formatOmniboxMetadata(meta) {
  const partialQueries = typeof meta.partialQueries === "string" ? meta.partialQueries : formatArrayForCoveoCustomData(meta.partialQueries);
  const suggestions = typeof meta.suggestions === "string" ? meta.suggestions : formatArrayForCoveoCustomData(meta.suggestions);
  return Object.assign(Object.assign({}, meta), {
    partialQueries,
    suggestions
  });
}
var CoveoSearchPageClient = class {
  constructor(opts, provider) {
    this.opts = opts;
    this.provider = provider;
    const shouldDisableAnalytics = opts.enableAnalytics === false || doNotTrack2();
    this.coveoAnalyticsClient = shouldDisableAnalytics ? new NoopAnalytics() : new CoveoAnalyticsClient(opts);
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.opts);
  }
  makeInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.interfaceLoad);
  }
  logInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.recommendationInterfaceLoad);
  }
  logRecommendationInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendation() {
    return this.makeCustomEvent(SearchPageEvents.recommendation);
  }
  logRecommendation() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendation()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.recommendationOpen, info, identifier);
  }
  logRecommendationOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterClearAll, meta);
  }
  logStaticFilterClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterSelect, meta);
  }
  logStaticFilterSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterDeselect, meta);
  }
  logStaticFilterDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFetchMoreResults() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling, { type: "getMoreResults" });
  }
  logFetchMoreResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFetchMoreResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeInterfaceChange(metadata) {
    return this.makeSearchEvent(SearchPageEvents.interfaceChange, metadata);
  }
  logInterfaceChange(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceChange(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanAutomatic() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanAutomatic);
  }
  logDidYouMeanAutomatic() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanAutomatic()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanClick() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanClick);
  }
  logDidYouMeanClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeResultsSort(metadata) {
    return this.makeSearchEvent(SearchPageEvents.resultsSort, metadata);
  }
  logResultsSort(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeResultsSort(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxSubmit() {
    return this.makeSearchEvent(SearchPageEvents.searchboxSubmit);
  }
  logSearchboxSubmit() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxSubmit()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxClear() {
    return this.makeSearchEvent(SearchPageEvents.searchboxClear);
  }
  logSearchboxClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxAsYouType() {
    return this.makeSearchEvent(SearchPageEvents.searchboxAsYouType);
  }
  logSearchboxAsYouType() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxAsYouType()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbFacet(metadata) {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbFacet, metadata);
  }
  logBreadcrumbFacet(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbFacet(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbResetAll() {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbResetAll);
  }
  logBreadcrumbResetAll() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbResetAll()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentQuickview(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentQuickview, info, identifier);
  }
  logDocumentQuickview(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentQuickview(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentOpen, info, identifier);
  }
  logDocumentOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxAnalytics(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxAnalytics, formatOmniboxMetadata(meta));
  }
  logOmniboxAnalytics(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxAnalytics(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxFromLink(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxFromLink, formatOmniboxMetadata(meta));
  }
  logOmniboxFromLink(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxFromLink(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchFromLink() {
    return this.makeSearchEvent(SearchPageEvents.searchFromLink);
  }
  logSearchFromLink() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchFromLink()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerNotify(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerNotify, meta);
  }
  logTriggerNotify(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerNotify(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerExecute(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerExecute, meta);
  }
  logTriggerExecute(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerExecute(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerQuery() {
    return this.makeCustomEvent(SearchPageEvents.triggerQuery, { query: this.provider.getSearchEventRequestPayload().queryText }, "queryPipelineTriggers");
  }
  logTriggerQuery() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerQuery()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeUndoTriggerQuery(meta) {
    return this.makeSearchEvent(SearchPageEvents.undoTriggerQuery, meta);
  }
  logUndoTriggerQuery(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeUndoTriggerQuery(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerRedirect(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerRedirect, Object.assign(Object.assign({}, meta), { query: this.provider.getSearchEventRequestPayload().queryText }));
  }
  logTriggerRedirect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerRedirect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerResize(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerResize, meta);
  }
  logPagerResize(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerResize(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNumber(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNumber, meta);
  }
  logPagerNumber(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNumber(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNext(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNext, meta);
  }
  logPagerNext(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNext(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerPrevious(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerPrevious, meta);
  }
  logPagerPrevious(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerPrevious(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerScrolling() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling);
  }
  logPagerScrolling() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerScrolling()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetClearAll, meta);
  }
  logFacetClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSearch(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSearch, meta);
  }
  logFacetSearch(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSearch(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelect, meta);
  }
  logFacetSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetDeselect, meta);
  }
  logFacetDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetExclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetExclude, meta);
  }
  logFacetExclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetExclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUnexclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUnexclude, meta);
  }
  logFacetUnexclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUnexclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelectAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelectAll, meta);
  }
  logFacetSelectAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelectAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUpdateSort(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUpdateSort, meta);
  }
  logFacetUpdateSort(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUpdateSort(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowMore(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowMore, meta);
  }
  logFacetShowMore(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowMore(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowLess(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowLess, meta);
  }
  logFacetShowLess(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowLess(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryError(meta) {
    return this.makeCustomEvent(SearchPageEvents.queryError, meta);
  }
  logQueryError(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryError(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorBack);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorBack);
        })
      };
    });
  }
  logQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorRetry);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorRetry);
        })
      };
    });
  }
  logQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorRetry()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorClear);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorClear);
        })
      };
    });
  }
  logQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeLikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.likeSmartSnippet);
  }
  logLikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.dislikeSmartSnippet);
  }
  logDislikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeExpandSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippet);
  }
  logExpandSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippet);
  }
  logCollapseSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.openSmartSnippetFeedbackModal);
  }
  logOpenSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCloseSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.closeSmartSnippetFeedbackModal);
  }
  logCloseSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCloseSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSmartSnippetFeedbackReason(reason, details) {
    return this.makeCustomEvent(SearchPageEvents.sendSmartSnippetReason, { reason, details });
  }
  logSmartSnippetFeedbackReason(reason, details) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSmartSnippetFeedbackReason(reason, details)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeExpandSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logExpandSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logCollapseSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showMoreSmartSnippetSuggestion, snippet);
  }
  logShowMoreSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showLessSmartSnippetSuggestion, snippet);
  }
  logShowLessSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSource(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSource, info, identifier);
  }
  logOpenSmartSnippetSource(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSource(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSuggestionSource(info, snippet) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionSource, info, { contentIDKey: snippet.documentId.contentIdKey, contentIDValue: snippet.documentId.contentIdValue }, snippet);
  }
  makeCopyToClipboard(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.copyToClipboard, info, identifier);
  }
  logCopyToClipboard(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCopyToClipboard(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  logOpenSmartSnippetSuggestionSource(info, snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionSource(info, snippet)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetInlineLink, info, { contentIDKey: identifierAndLink.contentIDKey, contentIDValue: identifierAndLink.contentIDValue }, identifierAndLink);
  }
  logOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetInlineLink(info, identifierAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionInlineLink, info, {
      contentIDKey: snippetAndLink.documentId.contentIdKey,
      contentIDValue: snippetAndLink.documentId.contentIdValue
    }, snippetAndLink);
  }
  logOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRecentQueryClick() {
    return this.makeSearchEvent(SearchPageEvents.recentQueryClick);
  }
  logRecentQueryClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentQueryClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentQueries() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentQueries);
  }
  logClearRecentQueries() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentQueries()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecentResultClick(info, identifier) {
    return this.makeCustomEvent(SearchPageEvents.recentResultClick, { info, identifier });
  }
  logRecentResultClick(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentResultClick(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentResults() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentResults);
  }
  logClearRecentResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeNoResultsBack() {
    return this.makeSearchEvent(SearchPageEvents.noResultsBack);
  }
  logNoResultsBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeNoResultsBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreFoldedResults(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.showMoreFoldedResults, info, identifier);
  }
  logShowMoreFoldedResults(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreFoldedResults(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessFoldedResults() {
    return this.makeCustomEvent(SearchPageEvents.showLessFoldedResults);
  }
  logShowLessFoldedResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessFoldedResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeEventDescription(preparedEvent, actionCause) {
    var _a;
    return { actionCause, customData: (_a = preparedEvent.payload) === null || _a === void 0 ? void 0 : _a.customData };
  }
  makeCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      this.coveoAnalyticsClient.getParameters;
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const request = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), { eventType, eventValue: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      return (yield this.makeCustomEvent(event, metadata, eventType)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const payload = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), {
        eventType,
        eventValue
      });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(payload);
      return {
        description: this.makeEventDescription(preparedEvent, eventValue),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCustomEventWithType(eventValue, eventType, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  logSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchEvent(event, metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.getBaseSearchEventRequest(event, metadata);
      const preparedEvent = yield this.coveoAnalyticsClient.makeSearchEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  makeClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { queryPipeline: this.provider.getPipeline(), actionCause: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeClickEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClickEvent(event, info, identifier, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  getBaseSearchEventRequest(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      return Object.assign(Object.assign(Object.assign({}, yield this.getBaseEventRequest(Object.assign(Object.assign({}, metadata), (_b = (_a = this.provider).getGeneratedAnswerMetadata) === null || _b === void 0 ? void 0 : _b.call(_a)))), this.provider.getSearchEventRequestPayload()), { queryPipeline: this.provider.getPipeline(), actionCause: event });
    });
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      return Object.assign(Object.assign(Object.assign({}, this.getOrigins()), this.getSplitTestRun()), { customData, language: this.provider.getLanguage(), facetState: this.provider.getFacetState ? this.provider.getFacetState() : [], anonymous: this.provider.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getOrigins() {
    var _a, _b;
    return {
      originContext: (_b = (_a = this.provider).getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: this.provider.getOriginLevel1(),
      originLevel2: this.provider.getOriginLevel2(),
      originLevel3: this.provider.getOriginLevel3()
    };
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getSplitTestRun() {
    const splitTestRunName = this.provider.getSplitTestRunName ? this.provider.getSplitTestRunName() : "";
    const splitTestRunVersion = this.provider.getSplitTestRunVersion ? this.provider.getSplitTestRunVersion() : "";
    return Object.assign(Object.assign({}, splitTestRunName && { splitTestRunName }), splitTestRunVersion && { splitTestRunVersion });
  }
  makeLikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.likeGeneratedAnswer, metadata);
  }
  logLikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.dislikeGeneratedAnswer, metadata);
  }
  logDislikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenGeneratedAnswerSource(metadata) {
    return this.makeCustomEvent(SearchPageEvents.openGeneratedAnswerSource, metadata);
  }
  logOpenGeneratedAnswerSource(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenGeneratedAnswerSource(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCitationClick(info, citation) {
    return this.makeClickEvent(SearchPageEvents.generatedAnswerCitationClick, Object.assign(Object.assign({}, info), { documentPosition: 1 }), { contentIDKey: citation.documentId.contentIdKey, contentIDValue: citation.documentId.contentIdValue }, citation);
  }
  logGeneratedAnswerCitationClick(info, citation) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCitationClick(info, citation)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerSourceHover(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerSourceHover, metadata);
  }
  logGeneratedAnswerSourceHover(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerSourceHover(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCopyToClipboard(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCopyToClipboard, metadata);
  }
  logGeneratedAnswerCopyToClipboard(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCopyToClipboard(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerHideAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerHideAnswers, metadata);
  }
  logGeneratedAnswerHideAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerHideAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerShowAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerShowAnswers, metadata);
  }
  logGeneratedAnswerShowAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerShowAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerExpand(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerExpand, metadata);
  }
  logGeneratedAnswerExpand(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerExpand(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerCollapse(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCollapse, metadata);
  }
  logGeneratedAnswerCollapse(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCollapse(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerFeedbackSubmit(meta) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmit, meta);
  }
  logGeneratedAnswerFeedbackSubmit(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmit(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerFeedbackSubmitV2(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmitV2, metadata);
  }
  logGeneratedAnswerFeedbackSubmitV2(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmitV2(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRephraseGeneratedAnswer(meta) {
    return this.makeSearchEvent(SearchPageEvents.rephraseGeneratedAnswer, meta);
  }
  logRephraseGeneratedAnswer(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRephraseGeneratedAnswer(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRetryGeneratedAnswer() {
    return this.makeSearchEvent(SearchPageEvents.retryGeneratedAnswer);
  }
  logRetryGeneratedAnswer() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRetryGeneratedAnswer()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerStreamEnd(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerStreamEnd, metadata);
  }
  logGeneratedAnswerStreamEnd(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerStreamEnd(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
};
var SVCPluginEventTypes = Object.assign({}, BasePluginEventTypes);
var allSVCEventTypes = Object.keys(SVCPluginEventTypes).map((key) => SVCPluginEventTypes[key]);
var SVCPlugin = class extends BasePlugin {
  constructor({ client, uuidGenerator = v4 }) {
    super({ client, uuidGenerator });
    this.ticket = {};
  }
  getApi(name) {
    const superCall = super.getApi(name);
    if (superCall !== null)
      return superCall;
    switch (name) {
      case "setTicket":
        return this.setTicket;
      default:
        return null;
    }
  }
  addHooks() {
    this.addHooksForEvent();
    this.addHooksForPageView();
    this.addHooksForSVCEvents();
  }
  setTicket(ticket) {
    this.ticket = ticket;
  }
  clearPluginData() {
    this.ticket = {};
  }
  addHooksForSVCEvents() {
    this.client.registerBeforeSendEventHook((eventType, ...[payload]) => {
      return allSVCEventTypes.indexOf(eventType) !== -1 ? this.addSVCDataToPayload(eventType, payload) : payload;
    });
    this.client.registerAfterSendEventHook((eventType, ...[payload]) => {
      if (allSVCEventTypes.indexOf(eventType) !== -1) {
        this.updateLocationInformation(eventType, payload);
      }
      return payload;
    });
  }
  addHooksForPageView() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.pageview, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["page"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addHooksForEvent() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.event, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["eventCategory", "eventAction", "eventLabel", "eventValue"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addSVCDataToPayload(eventType, payload) {
    var _a;
    const svcPayload = Object.assign(Object.assign(Object.assign(Object.assign({}, this.getLocationInformation(eventType, payload)), this.getDefaultContextInformation(eventType)), this.action ? { svcAction: this.action } : {}), Object.keys((_a = this.actionData) !== null && _a !== void 0 ? _a : {}).length > 0 ? { svcActionData: this.actionData } : {});
    const ticketPayload = this.getTicketPayload();
    this.clearData();
    return Object.assign(Object.assign(Object.assign({}, ticketPayload), svcPayload), payload);
  }
  getTicketPayload() {
    return convertTicketToMeasurementProtocol(this.ticket);
  }
};
SVCPlugin.Id = "svc";
var CaseAssistEvents;
(function(CaseAssistEvents2) {
  CaseAssistEvents2["click"] = "click";
  CaseAssistEvents2["flowStart"] = "flowStart";
})(CaseAssistEvents || (CaseAssistEvents = {}));
var CaseAssistActions;
(function(CaseAssistActions2) {
  CaseAssistActions2["enterInterface"] = "ticket_create_start";
  CaseAssistActions2["fieldUpdate"] = "ticket_field_update";
  CaseAssistActions2["fieldSuggestionClick"] = "ticket_classification_click";
  CaseAssistActions2["documentSuggestionClick"] = "documentSuggestionClick";
  CaseAssistActions2["documentSuggestionQuickview"] = "documentSuggestionQuickview";
  CaseAssistActions2["suggestionRate"] = "suggestion_rate";
  CaseAssistActions2["nextCaseStep"] = "ticket_next_stage";
  CaseAssistActions2["caseCancelled"] = "ticket_cancel";
  CaseAssistActions2["caseSolved"] = "ticket_cancel";
  CaseAssistActions2["caseCreated"] = "ticket_create";
})(CaseAssistActions || (CaseAssistActions = {}));
var CaseCancelledReasons;
(function(CaseCancelledReasons2) {
  CaseCancelledReasons2["quit"] = "Quit";
  CaseCancelledReasons2["solved"] = "Solved";
})(CaseCancelledReasons || (CaseCancelledReasons = {}));
var CaseAssistClient = class {
  constructor(options, provider) {
    var _a;
    this.options = options;
    this.provider = provider;
    const analyticsEnabled = ((_a = options.enableAnalytics) !== null && _a !== void 0 ? _a : true) && !doNotTrack2();
    this.coveoAnalyticsClient = analyticsEnabled ? new CoveoAnalyticsClient(options) : new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.options);
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  logEnterInterface(meta) {
    this.svc.setAction(CaseAssistActions.enterInterface);
    this.svc.setTicket(meta.ticket);
    return this.sendFlowStartEvent();
  }
  logUpdateCaseField(meta) {
    this.svc.setAction(CaseAssistActions.fieldUpdate, {
      fieldName: meta.fieldName
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectFieldSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.fieldSuggestionClick, meta.suggestion);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionClick, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logQuickviewDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionQuickview, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logRateDocumentSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.suggestionRate, Object.assign({ rate: meta.rating }, meta.suggestion));
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logMoveToNextCaseStep(meta) {
    this.svc.setAction(CaseAssistActions.nextCaseStep, {
      stage: meta === null || meta === void 0 ? void 0 : meta.stage
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCancelled(meta) {
    this.svc.setAction(CaseAssistActions.caseCancelled, {
      reason: CaseCancelledReasons.quit
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseSolved(meta) {
    this.svc.setAction(CaseAssistActions.caseSolved, {
      reason: CaseCancelledReasons.solved
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCreated(meta) {
    this.svc.setAction(CaseAssistActions.caseCreated);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  sendFlowStartEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.flowStart, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  sendClickEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.click, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const customData = Object.assign({}, metadata);
      return Object.assign(Object.assign({}, this.getOrigins()), { customData, language: (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getLanguage(), anonymous: (_b = this.provider) === null || _b === void 0 ? void 0 : _b.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getOrigins() {
    var _a, _b, _c, _d, _e;
    return {
      originContext: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: (_c = this.provider) === null || _c === void 0 ? void 0 : _c.getOriginLevel1(),
      originLevel2: (_d = this.provider) === null || _d === void 0 ? void 0 : _d.getOriginLevel2(),
      originLevel3: (_e = this.provider) === null || _e === void 0 ? void 0 : _e.getOriginLevel3()
    };
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const payload = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { searchQueryUid: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getSearchUID()) !== null && _b !== void 0 ? _b : "", actionCause: event });
      return this.coveoAnalyticsClient.sendClickEvent(payload);
    });
  }
};

// src/api/analytics/base-analytics.ts
var getLanguage = (state) => {
  const langKey = state.configuration.search.locale.split("-")[0];
  if (!langKey || langKey.length !== 2) {
    return "en";
  }
  return langKey;
};
var BaseAnalyticsProvider = class {
  constructor(getState) {
    this.getState = getState;
    __publicField(this, "state");
    this.state = getState();
  }
  getLanguage() {
    return getLanguage(this.state);
  }
  getBaseMetadata() {
    const { context, configuration: configuration2 } = this.state;
    const contextValues = context?.contextValues || {};
    const formattedObject = {};
    for (const [key, value] of Object.entries(contextValues)) {
      const formattedKey = `context_${key}`;
      formattedObject[formattedKey] = value;
    }
    if (configuration2.analytics.analyticsMode === "legacy") {
      formattedObject.coveoHeadlessVersion = VERSION;
    }
    return formattedObject;
  }
  getOriginContext() {
    return this.state.configuration.analytics.originContext;
  }
  getOriginLevel1() {
    return this.state.searchHub || getSearchHubInitialState();
  }
  getOriginLevel2() {
    return this.state.configuration.analytics.originLevel2;
  }
  getOriginLevel3() {
    return this.state.configuration.analytics.originLevel3;
  }
  getIsAnonymous() {
    return this.state.configuration.analytics.anonymous;
  }
};

// src/api/analytics/coveo-analytics-utils.ts
var getVisitorID = (options) => new CoveoAnalyticsClient(options).getCurrentVisitorId();
var wrapPreprocessRequest = (logger, preprocessRequest) => {
  return typeof preprocessRequest === "function" ? (...args) => {
    const untaintedOutput = clone(args[0]);
    try {
      return preprocessRequest.apply(preprocessRequest, args);
    } catch (e) {
      logger.error(
        e,
        "Error in analytics preprocessRequest. Returning original request."
      );
      return untaintedOutput;
    }
  } : void 0;
};
var wrapAnalyticsClientSendEventHook = (logger, hook) => {
  return (...args) => {
    const untaintedOutput = clone(args[1]);
    try {
      return hook.apply(hook, args);
    } catch (e) {
      logger.error(
        e,
        "Error in analytics hook. Returning original request."
      );
      return untaintedOutput;
    }
  };
};

// src/api/analytics/case-assist-analytics.ts
var CaseAssistAnalyticsProvider = class extends BaseAnalyticsProvider {
  getSearchUID() {
    return this.state.documentSuggestion?.status.lastResponseId ?? "";
  }
};
var configureCaseAssistAnalytics = ({
  logger,
  getState,
  analyticsClientMiddleware = (_, p) => p,
  preprocessRequest,
  provider = new CaseAssistAnalyticsProvider(getState)
}) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment,
    "analytics"
  );
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CaseAssistClient(
    {
      enableAnalytics: enableAnalytics2,
      token,
      endpoint,
      runtimeEnvironment,
      preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
      beforeSendHooks: [
        wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
        (type, payload) => {
          logger.info(
            {
              ...payload,
              type,
              endpoint,
              token
            },
            "Analytics request"
          );
          return payload;
        }
      ]
    },
    provider
  );
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};

// src/features/facets/automatic-facet-set/automatic-facet-set-constants.ts
var DESIRED_COUNT_DEFAULT = 5;
var NUMBER_OF_VALUE_DEFAULT = 8;

// src/features/facets/automatic-facet-set/automatic-facet-set-state.ts
function getAutomaticFacetSetInitialState() {
  return {
    desiredCount: DESIRED_COUNT_DEFAULT,
    numberOfValues: NUMBER_OF_VALUE_DEFAULT,
    set: {}
  };
}

// src/features/facets/category-facet-set/category-facet-utils.ts
function findActiveValueAncestry(valuesAsTree) {
  const { activeValue, ancestryMap } = getActiveValueAndAncestryFromValueTree(valuesAsTree);
  return activeValue ? getActiveValueAncestry(activeValue, ancestryMap) : [];
}
function getActiveValueAndAncestryFromValueTree(valuesAsTrees) {
  const valueToVisit = [...valuesAsTrees];
  const ancestryMap = /* @__PURE__ */ new Map();
  while (valueToVisit.length > 0) {
    const currentValue = valueToVisit.shift();
    if (currentValue.state === "selected") {
      return { activeValue: currentValue, ancestryMap };
    }
    if (ancestryMap) {
      for (const childValue of currentValue.children) {
        ancestryMap.set(childValue, currentValue);
      }
    }
    valueToVisit.unshift(...currentValue.children);
  }
  return {};
}
function getActiveValueAncestry(activeValue, valueToParentMap) {
  const activeValueAncestry = [];
  if (!activeValue) {
    return [];
  }
  let lastParent = activeValue;
  do {
    activeValueAncestry.unshift(lastParent);
    lastParent = valueToParentMap.get(lastParent);
  } while (lastParent);
  return activeValueAncestry;
}

// src/features/facets/category-facet-set/category-facet-set-selectors.ts
var categoryFacetRequestSelector = (state, id) => {
  return state.categoryFacetSet[id]?.request;
};
var categoryFacetRequestSelectedValuesSelector = (state, facetId) => {
  const facetRequest = categoryFacetRequestSelector(state, facetId);
  return findActiveValueAncestry(facetRequest?.currentValues ?? []);
};

// src/features/facets/category-facet-set/category-facet-set-state.ts
function getCategoryFacetSetInitialState() {
  return {};
}

// src/features/facets/range-facets/date-facet-set/date-facet-set-state.ts
function getDateFacetSetInitialState() {
  return {};
}

// src/features/facets/range-facets/numeric-facet-set/numeric-facet-set-state.ts
function getNumericFacetSetInitialState() {
  return {};
}

// src/features/facets/facet-set/facet-set-state.ts
function getFacetSetInitialState() {
  return {};
}

// src/features/facets/facet-set/facet-set-analytics-actions-utils.ts
function getStateNeededForFacetMetadata(s) {
  return {
    facetSet: s.facetSet ?? getFacetSetInitialState(),
    categoryFacetSet: s.categoryFacetSet ?? getCategoryFacetSetInitialState(),
    dateFacetSet: s.dateFacetSet ?? getDateFacetSetInitialState(),
    numericFacetSet: s.numericFacetSet ?? getNumericFacetSetInitialState(),
    automaticFacetSet: s.automaticFacetSet ?? getAutomaticFacetSetInitialState()
  };
}
var buildFacetStateMetadata = (state) => {
  const facetState = [];
  getFacetRequests(state).forEach((facetRequest, facetIndex) => {
    const facetType = getFacetType(state, facetRequest.facetId);
    const facetRequestAnalytics = mapFacetRequestToAnalytics(
      facetRequest,
      facetIndex + 1
    );
    if (isCategoryFacetRequest(facetRequest)) {
      const hasSelectedValue = !!categoryFacetRequestSelectedValuesSelector(
        state,
        facetRequest.facetId
      ).length;
      if (!hasSelectedValue) {
        return;
      }
      facetState.push({
        ...facetRequestAnalytics,
        ...mapCategoryFacetValueToAnalytics(state, facetRequest.facetId),
        facetType,
        state: "selected"
      });
      return;
    }
    facetRequest.currentValues.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(
        facetValue,
        facetValueIndex + 1,
        facetType
      );
      const facetDisplayValueAnalytics = isSpecificFacetRequest(facetRequest) ? mapFacetDisplayValueToAnalytics(facetValue) : mapRangeDisplayFacetValueToAnalytics(
        facetValue
      );
      facetState.push({
        ...facetRequestAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  getAutomaticFacets(state).forEach((facet, facetIndex) => {
    const facetAnalytics = mapAutomaticFacetToAnalytics(facet, facetIndex + 1);
    facet.values.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(
        facetValue,
        facetValueIndex + 1,
        "specific"
      );
      const facetDisplayValueAnalytics = mapFacetDisplayValueToAnalytics(facetValue);
      facetState.push({
        ...facetAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  return facetState;
};
var isSpecificFacetRequest = (request) => request.type === "specific";
var isCategoryFacetRequest = (request) => request.type === "hierarchical";
var getFacetRequests = (state) => {
  return [
    ...Object.values(state.facetSet),
    ...Object.values(state.categoryFacetSet),
    ...Object.values(state.dateFacetSet),
    ...Object.values(state.numericFacetSet)
  ].map((facet) => facet.request);
};
var getAutomaticFacets = (state) => {
  return [...Object.values(state.automaticFacetSet.set)].map(
    (facet) => facet.response
  );
};
var mapFacetValueToAnalytics = (facetValue, valuePosition, facetType) => {
  return {
    state: facetValue.state,
    valuePosition,
    facetType
  };
};
var mapRangeDisplayFacetValueToAnalytics = (facetValue) => {
  return {
    displayValue: `${facetValue.start}..${facetValue.end}`,
    value: `${facetValue.start}..${facetValue.end}`,
    start: facetValue.start,
    end: facetValue.end,
    endInclusive: facetValue.endInclusive
  };
};
var mapFacetDisplayValueToAnalytics = (facetValue) => {
  return {
    displayValue: facetValue.value,
    value: facetValue.value
  };
};
var getCategoryFacetSelectedValue = (state, facetId) => {
  const selectedCategoryFacetValues = categoryFacetRequestSelectedValuesSelector(state, facetId);
  return selectedCategoryFacetValues.map((selectedCategoryFacetValue) => selectedCategoryFacetValue.value).join(";");
};
var mapCategoryFacetValueToAnalytics = (state, facetId) => {
  const valuePosition = 1;
  const value = getCategoryFacetSelectedValue(state, facetId);
  return {
    value,
    valuePosition,
    displayValue: value
  };
};
var mapAutomaticFacetToAnalytics = (facet, facetPosition) => {
  return {
    title: getFacetTitle(facet.field, facet.field),
    field: facet.field,
    id: facet.field,
    facetPosition
  };
};
var mapFacetRequestToAnalytics = (request, facetPosition) => {
  return {
    title: getFacetTitle(request.field, request.facetId),
    field: request.field,
    id: request.facetId,
    facetPosition
  };
};
var getFacetTitle = (field, facetId) => {
  return `${field}_${facetId}`;
};
var getFacetRequest = (state, facetId) => {
  return state.facetSet[facetId]?.request || state.categoryFacetSet[facetId]?.request || state.dateFacetSet[facetId]?.request || state.numericFacetSet[facetId]?.request || state.automaticFacetSet.set[facetId]?.response;
};
var getFacetType = (state, facetId) => {
  const facet = getFacetRequest(state, facetId);
  return facet ? facet.type : "specific";
};

// src/features/generated-answer/generated-answer-selectors.ts
var import_bueno7 = require("@coveo/bueno");
var import_toolkit14 = require("@reduxjs/toolkit");
var generativeQuestionAnsweringIdSelector = (state) => {
  if (isGeneratedAnswerFeatureEnabledWithAnswerAPI(state) || isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
    return state.generatedAnswer?.answerId;
  }
  if (isSearchSection(state)) {
    return state.search?.response?.extendedResults?.generativeQuestionAnsweringId;
  }
  return void 0;
};
var isGeneratedAnswerFeatureEnabledWithAnswerAPI = (state) => "answer" in state && "generatedAnswer" in state && !(0, import_bueno7.isNullOrUndefined)(state.generatedAnswer?.answerConfigurationId);
var isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI = (state) => {
  const agentId = selectAgentId(state);
  return "answerGenerationApi" in state && "generatedAnswer" in state && typeof agentId === "string" && agentId.trim().length > 0;
};
var isSearchSection = (state) => "search" in state && state.search !== void 0 && typeof state.search === "object";
var selectFieldsToIncludeInCitation = (state) => state.generatedAnswer?.fieldsToIncludeInCitations;
var citationSourceSelector = (0, import_toolkit14.createSelector)(
  (state) => state.generatedAnswer?.citations,
  (_state, citationId) => citationId,
  (citations, citationId) => citations?.find(
    (citation) => citation.id === citationId
  )
);

// src/features/query/query-state.ts
var getQueryInitialState = () => ({
  q: "",
  enableQuerySyntax: false
});

// src/features/search/search-state.ts
function emptyQuestionAnswer() {
  return {
    answerSnippet: "",
    documentId: {
      contentIdKey: "",
      contentIdValue: ""
    },
    question: "",
    relatedQuestions: [],
    score: 0
  };
}
function getSearchInitialState() {
  return {
    response: {
      results: [],
      searchUid: "",
      totalCountFiltered: 0,
      facets: [],
      generateAutomaticFacets: { facets: [] },
      queryCorrections: [],
      triggers: [],
      questionAnswer: emptyQuestionAnswer(),
      pipeline: "",
      splitTestRun: "",
      termsToHighlight: {},
      phrasesToHighlight: {},
      extendedResults: {}
    },
    duration: 0,
    queryExecuted: "",
    error: null,
    automaticallyCorrected: false,
    isLoading: false,
    results: [],
    searchResponseId: "",
    requestId: "",
    questionAnswer: emptyQuestionAnswer(),
    extendedResults: {},
    searchAction: void 0
  };
}

// src/features/sort-criteria/criteria.ts
var import_bueno8 = require("@coveo/bueno");
var SortOrder = /* @__PURE__ */ ((SortOrder2) => {
  SortOrder2["Ascending"] = "ascending";
  SortOrder2["Descending"] = "descending";
  return SortOrder2;
})(SortOrder || {});
var SortBy = /* @__PURE__ */ ((SortBy2) => {
  SortBy2["Relevancy"] = "relevancy";
  SortBy2["QRE"] = "qre";
  SortBy2["Date"] = "date";
  SortBy2["Field"] = "field";
  SortBy2["NoSort"] = "nosort";
  return SortBy2;
})(SortBy || {});
var buildCriterionExpression = (criterion) => {
  if ((0, import_bueno8.isArray)(criterion)) {
    return criterion.map((c) => buildCriterionExpression(c)).join(",");
  }
  switch (criterion.by) {
    case "relevancy" /* Relevancy */:
    case "qre" /* QRE */:
    case "nosort" /* NoSort */:
      return criterion.by;
    case "date" /* Date */:
      return `date ${criterion.order}`;
    case "field" /* Field */:
      return `@${criterion.field} ${criterion.order}`;
    default:
      return "";
  }
};
var buildRelevanceSortCriterion = () => ({
  by: "relevancy" /* Relevancy */
});
var criterionDefinition = new import_bueno8.RecordValue({
  values: {
    by: new import_bueno8.EnumValue({ enum: SortBy, required: true }),
    order: new import_bueno8.EnumValue({ enum: SortOrder }),
    field: new import_bueno8.StringValue()
  }
});

// src/features/sort-criteria/sort-criteria-state.ts
function getSortCriteriaInitialState() {
  return buildCriterionExpression(buildRelevanceSortCriterion());
}

// src/api/analytics/coveo.analytics/cookie.ts
var Cookie2 = class _Cookie {
  static set(name, value, expire) {
    let domain, expirationDate, domainParts;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    const host = window.location.hostname;
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
    if (ipv4Regex.test(host) || ipv6Regex.test(host)) {
      writeCookie2(name, value, expirationDate);
    } else if (host.indexOf(".") === -1) {
      writeCookie2(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie2(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    const cookiePrefix = name + "=";
    const cookieArray = document.cookie.split(";");
    for (let i = 0; i < cookieArray.length; i++) {
      let cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie2(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}

// src/api/analytics/coveo.analytics/detector.ts
function hasNavigator2() {
  return typeof navigator !== "undefined";
}
function hasLocalStorage2() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage2() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage2() {
  return Boolean(hasNavigator2() && navigator.cookieEnabled);
}

// src/api/analytics/coveo.analytics/storage.ts
var preferredStorage = null;
function getAvailableStorage2() {
  if (preferredStorage) {
    return preferredStorage;
  }
  if (hasLocalStorage2()) {
    return localStorage;
  }
  if (hasCookieStorage2()) {
    return new CookieStorage2();
  }
  if (hasSessionStorage2()) {
    return sessionStorage;
  }
  return new NullStorage2();
}
var _CookieStorage = class _CookieStorage {
  getItem(key) {
    return Cookie2.get(`${_CookieStorage.prefix}${key}`);
  }
  removeItem(key) {
    Cookie2.erase(`${_CookieStorage.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie2.set(`${_CookieStorage.prefix}${key}`, data, expire);
  }
};
__publicField(_CookieStorage, "prefix", "coveo_");
var CookieStorage2 = _CookieStorage;
var NullStorage2 = class {
  getItem(_key) {
    return null;
  }
  removeItem(_key) {
  }
  setItem(_key, _data) {
  }
};

// src/api/analytics/coveo.analytics/history-store.ts
var STORE_KEY2 = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS2 = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE2 = 1e3 * 60;
var MAX_VALUE_SIZE2 = 75;
var _HistoryStore = class _HistoryStore {
  constructor(store) {
    __publicField(this, "store");
    this.store = store || getAvailableStorage2();
  }
  static getInstance(store) {
    if (!_HistoryStore.instance) {
      _HistoryStore.instance = new _HistoryStore(store);
    }
    return _HistoryStore.instance;
  }
  /**
   * @deprecated Synchronous method is deprecated, use addElementAsync instead. This method will NOT work with react-native.
   */
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  async addElementAsync(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = await this.getHistoryWithInternalTimeAsync();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  /**
   * @deprecated Synchronous method is deprecated, use getHistoryAsync instead. This method will NOT work with react-native.
   */
  getHistory() {
    const history = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history));
  }
  async getHistoryAsync() {
    const history = await this.getHistoryWithInternalTimeAsync();
    return this.stripEmptyQueries(this.stripInternalTime(history));
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY2);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  async getHistoryWithInternalTimeAsync() {
    try {
      const elements = await this.store.getItem(STORE_KEY2);
      if (elements) {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  setHistory(history) {
    try {
      this.store.setItem(
        STORE_KEY2,
        JSON.stringify(history.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS2))
      );
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY2);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    const currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort(
        (first, second) => {
          return (second.internalTime || 0) - (first.internalTime || 0);
        }
      );
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE2);
    }
    return part;
  }
  isValidEntry(elem) {
    const lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value === elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE2;
    }
    return true;
  }
  stripInternalTime(history) {
    if (Array.isArray(history)) {
      return history.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history) {
    return history.map((part) => this.stripEmptyQuery(part));
  }
};
__publicField(_HistoryStore, "instance", null);
var HistoryStore2 = _HistoryStore;
var history_store_default = HistoryStore2;

// src/api/analytics/search-analytics.ts
var _SearchAnalyticsProvider = class _SearchAnalyticsProvider extends BaseAnalyticsProvider {
  constructor() {
    super(...arguments);
    __publicField(this, "getFacetRequest", (id) => {
      return this.state.facetSet?.[id]?.request || this.state.categoryFacetSet?.[id]?.request || this.state.dateFacetSet?.[id]?.request || this.state.numericFacetSet?.[id]?.request || this.state.automaticFacetSet?.set[id]?.response;
    });
  }
  getFacetState() {
    return buildFacetStateMetadata(
      getStateNeededForFacetMetadata(this.getState())
    );
  }
  getPipeline() {
    return this.state.pipeline || this.state.search?.response.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
  }
  getSearchEventRequestPayload() {
    return {
      queryText: this.queryText,
      responseTime: this.responseTime,
      results: this.resultURIs,
      numberOfResults: this.numberOfResults
    };
  }
  getSearchUID() {
    const newState = this.getState();
    return newState.search?.searchResponseId || newState.search?.response.searchUid || getSearchInitialState().response.searchUid;
  }
  getSplitTestRunName() {
    return this.state.search?.response.splitTestRun;
  }
  getSplitTestRunVersion() {
    const hasSplitTestRun = !!this.getSplitTestRunName();
    const effectivePipelineWithSplitTestRun = this.state.search?.response.pipeline || this.state.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
    return hasSplitTestRun ? effectivePipelineWithSplitTestRun : void 0;
  }
  getBaseMetadata() {
    const state = this.getState();
    const baseObject = super.getBaseMetadata();
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (generativeQuestionAnsweringId) {
      baseObject.generativeQuestionAnsweringId = generativeQuestionAnsweringId;
    }
    return baseObject;
  }
  getFacetMetadata(facetId, facetValue) {
    const facetRequest = this.getFacetRequest(facetId);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId,
      facetField,
      facetValue,
      facetTitle: `${facetField}_${facetId}`
    };
  }
  getFacetClearAllMetadata(facetId) {
    const facetRequest = this.getFacetRequest(facetId);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId,
      facetField,
      facetTitle: `${facetField}_${facetId}`
    };
  }
  getFacetUpdateSortMetadata(facetId, criteria) {
    const facetRequest = this.getFacetRequest(facetId);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId,
      facetField,
      criteria,
      facetTitle: `${facetField}_${facetId}`
    };
  }
  getRangeBreadcrumbFacetMetadata(facetId, facetValue) {
    const facetRequest = this.getFacetRequest(facetId);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId,
      facetField,
      facetRangeEnd: facetValue.end,
      facetRangeEndInclusive: facetValue.endInclusive,
      facetRangeStart: facetValue.start,
      facetTitle: `${facetField}_${facetId}`
    };
  }
  getResultSortMetadata() {
    return {
      ...this.getBaseMetadata(),
      resultsSortBy: this.state.sortCriteria ?? getSortCriteriaInitialState()
    };
  }
  getStaticFilterToggleMetadata(staticFilterId, staticFilterValue) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId,
      staticFilterValue
    };
  }
  getStaticFilterClearAllMetadata(staticFilterId) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId
    };
  }
  getUndoTriggerQueryMetadata(undoneQuery) {
    return {
      ...this.getBaseMetadata(),
      undoneQuery
    };
  }
  getCategoryBreadcrumbFacetMetadata(categoryFacetId, categoryFacetPath) {
    const facetRequest = this.getFacetRequest(categoryFacetId);
    const categoryFacetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      categoryFacetId,
      categoryFacetField,
      categoryFacetPath,
      categoryFacetTitle: `${categoryFacetField}_${categoryFacetId}`
    };
  }
  getOmniboxAnalyticsMetadata(id, suggestion) {
    const querySuggest = this.state.querySuggest?.[id];
    const suggestions = querySuggest.completions.map(
      (completion) => completion.expression
    );
    const lastIndex = querySuggest.partialQueries.length - 1;
    const partialQuery = querySuggest.partialQueries[lastIndex] || "";
    const querySuggestResponseId = querySuggest.responseId;
    return {
      ...this.getBaseMetadata(),
      suggestionRanking: suggestions.indexOf(suggestion),
      partialQuery,
      partialQueries: querySuggest.partialQueries.length > 0 ? querySuggest.partialQueries : "",
      suggestions: suggestions.length > 0 ? suggestions : "",
      querySuggestResponseId
    };
  }
  getInterfaceChangeMetadata() {
    return {
      ...this.getBaseMetadata(),
      interfaceChangeTo: this.state.configuration.analytics.originLevel2
    };
  }
  getOmniboxFromLinkMetadata(metadata) {
    return {
      ...this.getBaseMetadata(),
      ...metadata
    };
  }
  getGeneratedAnswerMetadata() {
    const state = this.getState();
    const formattedObject = {};
    if (state.generatedAnswer?.isVisible !== void 0) {
      formattedObject.showGeneratedAnswer = state.generatedAnswer.isVisible;
    }
    return formattedObject;
  }
  get resultURIs() {
    return this.results?.map((r) => ({
      documentUri: r.uri,
      documentUriHash: r.raw.urihash
    }));
  }
  get results() {
    return this.state.search?.response.results;
  }
  get queryText() {
    return this.state.query?.q || getQueryInitialState().q;
  }
  get responseTime() {
    return this.state.search?.duration || getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.state.search?.response.totalCountFiltered || getSearchInitialState().response.totalCountFiltered;
  }
};
__publicField(_SearchAnalyticsProvider, "fallbackPipelineName", "default");
var SearchAnalyticsProvider = _SearchAnalyticsProvider;
var configureLegacyAnalytics = ({
  logger,
  getState,
  analyticsClientMiddleware = (_, p) => p,
  preprocessRequest,
  provider
}) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment,
    "analytics"
  );
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CoveoSearchPageClient(
    {
      token,
      endpoint,
      runtimeEnvironment,
      preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
      beforeSendHooks: [
        wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
        (type, payload) => {
          logger.info(
            {
              ...payload,
              type,
              endpoint,
              token
            },
            "Analytics request"
          );
          return payload;
        }
      ]
    },
    provider
  );
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};
var getPageID = () => {
  const actions = history_store_default.getInstance().getHistory();
  const lastPageView = actions.reverse().find((action) => {
    return action.name === "PageView" && action.value;
  });
  if (!lastPageView) {
    return "";
  }
  return lastPageView.value;
};

// src/features/folding/folding-utils.ts
function getAllIncludedResultsFrom(relevantResult) {
  const foldedResults = getChildResultsRecursively(relevantResult);
  const parentResults = [relevantResult, ...foldedResults].filter((result) => result.parentResult).map((result) => result.parentResult);
  const resultsInCollection = removeDuplicates(
    [relevantResult, ...foldedResults, ...parentResults],
    (result) => result.uniqueId
  );
  return resultsInCollection;
}
function getChildResultsRecursively(result) {
  if (!result.childResults) {
    return [];
  }
  return result.childResults.flatMap((childResult) => [
    childResult,
    ...getChildResultsRecursively(childResult)
  ]);
}

// src/features/pipeline/pipeline-state.ts
var getPipelineInitialState = () => "";

// src/features/analytics/analytics-utils.ts
function makeBasicNewSearchAnalyticsAction(actionCause, getState) {
  return {
    ...new SearchAnalyticsProvider(getState).getBaseMetadata(),
    actionCause,
    type: actionCause
  };
}
function makeInstantlyCallable(action) {
  return Object.assign(action, { instantlyCallable: true });
}
function makePreparableAnalyticsAction(prefix, buildEvent) {
  const createAnalyticsAction = (body) => makeInstantlyCallable(
    (0, import_toolkit15.createAsyncThunk)(prefix, body)
  );
  const rootAction = createAnalyticsAction(async (_, { getState, extra }) => {
    const { analyticsClientMiddleware, preprocessRequest, logger } = extra;
    return await (await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    })).log({ state: getState(), extra });
  });
  const prepare = async ({
    getState,
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  }) => {
    const { description, log } = await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    });
    return {
      description,
      action: createAnalyticsAction(
        async (_, { getState: getNewState, extra: newExtra }) => {
          return await log({ state: getNewState(), extra: newExtra });
        }
      )
    };
  };
  Object.assign(rootAction, {
    prepare
  });
  return rootAction;
}
var makeAnalyticsActionFactory = (configurator, legacyGetBuilderConverter, providerClass) => {
  function makeAnalyticsAction2(...params) {
    const options = params.length === 1 ? {
      ...params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(
        params[0].__legacy__getBuilder
      ),
      analyticsConfigurator: configurator,
      providerClass
    } : {
      prefix: params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[1]),
      __legacy__provider: params[2],
      analyticsConfigurator: configurator,
      providerClass
    };
    return internalMakeAnalyticsAction(options);
  }
  return makeAnalyticsAction2;
};
var shouldSendLegacyEvent = (state) => state.configuration.analytics.analyticsMode === "legacy";
var shouldSendNextEvent = (state) => state.configuration.analytics.analyticsMode === "next";
var internalMakeAnalyticsAction = ({
  prefix,
  __legacy__getBuilder,
  __legacy__provider,
  analyticsPayloadBuilder,
  analyticsType,
  analyticsConfigurator,
  providerClass
}) => {
  __legacy__provider ?? (__legacy__provider = (getState) => new providerClass(getState));
  return makePreparableAnalyticsAction(
    prefix,
    async ({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    }) => {
      const loggers = [];
      const analyticsAction = {
        log: async ({ state: state2 }) => {
          for (const log of loggers) {
            await log(state2);
          }
        }
      };
      const state = getState();
      const client = analyticsConfigurator({
        getState,
        logger,
        analyticsClientMiddleware,
        preprocessRequest,
        provider: __legacy__provider(getState)
      });
      const builder = await __legacy__getBuilder(client, getState());
      analyticsAction.description = builder?.description;
      loggers.push(async (state2) => {
        if (shouldSendLegacyEvent(state2)) {
          await logLegacyEvent(
            builder,
            __legacy__provider,
            state2,
            logger,
            client.coveoAnalyticsClient
          );
        }
      });
      const { emit } = getRelayInstanceFromState(state);
      loggers.push(async (state2) => {
        if (shouldSendNextEvent(state2) && analyticsType && analyticsPayloadBuilder) {
          const payload = analyticsPayloadBuilder(state2);
          await logNextEvent(emit, analyticsType, payload);
        }
      });
      return analyticsAction;
    }
  );
};
async function logLegacyEvent(builder, __legacy__provider, state, logger, client) {
  __legacy__provider(() => state);
  const response = await builder?.log({
    searchUID: __legacy__provider(() => state).getSearchUID()
  });
  logger.info({ client, response }, "Analytics response");
}
var fromLogToLegacyBuilderFactory = (actionCause) => {
  const fromLogToLegacyBuilder = (log) => {
    return (client, state) => Promise.resolve({
      description: { actionCause },
      log: async (_metadata) => {
        log(client, state);
      }
    });
  };
  return fromLogToLegacyBuilder;
};
var makeAnalyticsAction = makeAnalyticsActionFactory(
  (options) => configureLegacyAnalytics({
    ...options,
    provider: options.provider || new SearchAnalyticsProvider(options.getState)
  }),
  (original) => original,
  SearchAnalyticsProvider
);
var makeCaseAssistAnalyticsAction = makeAnalyticsActionFactory(
  configureCaseAssistAnalytics,
  fromLogToLegacyBuilderFactory("caseAssist"),
  CaseAssistAnalyticsProvider
);
var partialDocumentInformation = (result, state) => {
  const paginationBasedIndex = (index) => index + (state.pagination?.firstResult ?? 0);
  let resultIndex = -1;
  const parentResults = state.search?.results;
  resultIndex = findPositionWithUniqueId(result, parentResults);
  if (resultIndex < 0) {
    resultIndex = findPositionInChildResults(result, parentResults);
  }
  if (resultIndex < 0) {
    resultIndex = 0;
  }
  return buildPartialDocumentInformation(
    result,
    paginationBasedIndex(resultIndex),
    state
  );
};
function buildPartialDocumentInformation(result, resultIndex, state) {
  const collection = result.raw.collection;
  const collectionName = typeof collection === "string" ? collection : "default";
  return {
    collectionName,
    documentAuthor: getDocumentAuthor(result),
    documentPosition: resultIndex + 1,
    documentTitle: result.title,
    documentUri: result.uri,
    documentUriHash: result.raw.urihash,
    documentUrl: result.clickUri,
    rankingModifier: result.rankingModifier || "",
    sourceName: getSourceName(result),
    queryPipeline: state.pipeline || getPipelineInitialState()
  };
}
var documentIdentifier = (result) => {
  if (!result.raw.permanentid) {
    console.warn(
      "Missing field permanentid on result. This might cause many issues with your Coveo deployment. See https://docs.coveo.com/en/1913 and https://docs.coveo.com/en/1640 for more information.",
      result
    );
  }
  return {
    contentIDKey: "permanentid",
    contentIDValue: result.raw.permanentid || ""
  };
};
var rawPartialDefinition = {
  urihash: new import_bueno9.StringValue(),
  sourcetype: new import_bueno9.StringValue(),
  permanentid: new import_bueno9.StringValue()
};
var resultPartialDefinition = {
  uniqueId: requiredNonEmptyString,
  raw: new import_bueno9.RecordValue({ values: rawPartialDefinition }),
  title: requiredNonEmptyString,
  uri: requiredNonEmptyString,
  clickUri: requiredNonEmptyString,
  rankingModifier: new import_bueno9.StringValue({ required: false, emptyAllowed: true })
};
function partialRawPayload(raw) {
  return Object.assign(
    {},
    ...Object.keys(rawPartialDefinition).map((key) => ({ [key]: raw[key] }))
  );
}
function partialResultPayload(result) {
  return Object.assign(
    {},
    ...Object.keys(resultPartialDefinition).map((key) => ({
      [key]: result[key]
    })),
    { raw: partialRawPayload(result.raw) }
  );
}
function getDocumentAuthor(result) {
  const author = result.raw.author;
  if ((0, import_bueno9.isNullOrUndefined)(author)) {
    return "unknown";
  }
  return Array.isArray(author) ? author.join(";") : `${author}`;
}
function getSourceName(result) {
  const source = result.raw.source;
  if ((0, import_bueno9.isNullOrUndefined)(source)) {
    return "unknown";
  }
  return source;
}
var validateResultPayload = (result) => new import_bueno9.Schema(resultPartialDefinition).validate(partialResultPayload(result));
function findPositionInChildResults(targetResult, parentResults) {
  for (const [i, parent] of parentResults.entries()) {
    const children = getAllIncludedResultsFrom(parent);
    const childIndex = findPositionWithUniqueId(targetResult, children);
    if (childIndex !== -1) {
      return i;
    }
  }
  return -1;
}
function findPositionWithUniqueId(targetResult, results = []) {
  return results.findIndex(({ uniqueId }) => uniqueId === targetResult.uniqueId);
}
async function logNextEvent(emitEvent, type, payload) {
  await emitEvent(type, payload);
  return;
}

// src/features/generated-answer/generated-answer-analytics-actions.ts
var logGeneratedAnswerStreamEnd = (answerGenerated) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/streamEnd",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const answerTextIsEmpty = answerGenerated ? !state.generatedAnswer?.answer || !state.generatedAnswer?.answer.length : void 0;
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerStreamEnd({
      generativeQuestionAnsweringId,
      answerGenerated,
      answerTextIsEmpty
    });
  },
  analyticsType: "Rga.AnswerReceived",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      answerGenerated: answerGenerated ?? false
    };
  }
});
var logGeneratedAnswerResponseLinked = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/responseLinked",
  __legacy__getBuilder: () => {
    return null;
  },
  analyticsType: "Rga.ResponseLinked",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      responseId: state.search?.searchResponseId || state.search?.response.searchUid || ""
    };
  }
});

// src/features/generated-answer/head-answer-strategy.ts
var createHeadAnswerStrategy = () => {
  return {
    handleOpen: (response, dispatch) => {
      const answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setAnswerId2(answerId));
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "agentInteraction.answerHeader": (message, dispatch) => {
        if (message?.payload?.conversationId) {
          dispatch(
            setFollowUpAnswersConversationId(message.payload.conversationId)
          );
        }
        if (message.payload.followUpEnabled) {
          dispatch(setIsEnabled(message.payload.followUpEnabled));
        }
        dispatch(setAnswerContentFormat("text/markdown"));
        dispatch(setIsStreaming(true));
        dispatch(setIsLoading(false));
      },
      "generativeengines.messageType": (message, dispatch) => {
        if (message?.payload?.textDelta) {
          dispatch(updateMessage({ textDelta: message.payload.textDelta }));
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        if (message?.payload?.citations !== void 0) {
          dispatch(updateCitations({ citations: message.payload.citations }));
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        const answerGenerated = message?.payload?.answerGenerated ?? false;
        dispatch(setIsAnswerGenerated(answerGenerated));
        dispatch(setCannotAnswer(!answerGenerated));
        dispatch(setIsStreaming(false));
        dispatch(setIsLoading(false));
        dispatch(logGeneratedAnswerStreamEnd(answerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(updateError(message));
        }
      }
    }
  };
};

// src/api/knowledge/answer-generation/streaming/strategies/streaming-strategy-creators.ts
var streamingStrategyCreators = {
  "head-answer": createHeadAnswerStrategy,
  "follow-up-answer": createFollowUpAnswerStrategy
};

// src/api/knowledge/answer-generation/endpoints/answer/url-builders/endpoint-url-builder.ts
var buildAnswerEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const {
    organizationId,
    environment,
    knowledge: { agentId }
  } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId?.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath}/${trimmedAgentId}/answer`;
};

// src/api/knowledge/answer-generation/endpoints/answer/answer-endpoint.ts
var answerEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        const { strategyKey, ...params } = args;
        const endpointUrl = buildAnswerEndpointUrl(
          getState()
        );
        await streamAnswerWithStrategy(
          endpointUrl,
          params,
          {
            getState,
            updateCachedData,
            dispatch
          },
          streamingStrategyCreators[strategyKey]?.()
        );
      }
    })
  })
});
var initiateAnswerEndpoint = (args) => {
  return answerEndpoint.endpoints.generateAnswer.initiate(args);
};

// src/features/advanced-search-queries/advanced-search-query-selectors.ts
var import_toolkit16 = require("@reduxjs/toolkit");
var selectAdvancedSearchQueries = (0, import_toolkit16.createSelector)(
  (state) => state.advancedSearchQueries,
  (advancedSearchQueries) => {
    if (!advancedSearchQueries) {
      return {};
    }
    const { aq, cq, dq, lq } = advancedSearchQueries;
    return {
      ...aq && { aq },
      ...cq && { cq },
      ...dq && { dq },
      ...lq && { lq }
    };
  }
);

// src/features/configuration/analytics-params.ts
var fromAnalyticsStateToAnalyticsParams = (s, navigatorContext, eventDescription) => {
  return {
    analytics: {
      clientId: navigatorContext.clientId,
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: navigatorContext.referrer,
      documentLocation: navigatorContext.location,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause
      },
      ...eventDescription && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.deviceId && { deviceId: s.deviceId },
      ...s.trackingId && { trackingId: s.trackingId },
      ...{
        capture: navigatorContext.capture ?? navigatorContext.clientId !== ""
      },
      ...{ source: getAnalyticsSource(s) }
    }
  };
};

// src/features/context/context-selector.ts
var selectContext = (state) => state.context;

// src/features/pipeline/select-pipeline.ts
var selectPipeline = (state) => state.pipeline;

// src/api/search/date/relative-date.ts
var import_bueno10 = require("@coveo/bueno");
var import_dayjs2 = __toESM(require("dayjs"), 1);
var import_quarterOfYear = __toESM(require("dayjs/plugin/quarterOfYear.js"), 1);

// src/api/search/date/date-format.ts
var import_dayjs = __toESM(require("dayjs"), 1);
var import_customParseFormat = __toESM(require("dayjs/plugin/customParseFormat.js"), 1);
import_dayjs.default.extend(import_customParseFormat.default);
var API_DATE_FORMAT = "YYYY/MM/DD@HH:mm:ss";
function formatDateForSearchApi(date) {
  return date.format(API_DATE_FORMAT);
}

// src/api/search/date/relative-date.ts
import_dayjs2.default.extend(import_quarterOfYear.default);
var validRelativeDatePeriods = ["past", "now", "next"];
var validRelativeDateUnits = [
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year"
];
function relativeToAbsoluteDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
      return (0, import_dayjs2.default)().subtract(amount, unit);
    case "next":
      return (0, import_dayjs2.default)().add(amount, unit);
    case "now":
      return (0, import_dayjs2.default)();
  }
}
function formatRelativeDateForSearchApi(relativeDate) {
  return formatDateForSearchApi(
    relativeToAbsoluteDate(parseRelativeDate(relativeDate))
  );
}
function splitDate(date) {
  return date.toLocaleLowerCase().split("-");
}
function isRelativeDateFormat(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return true;
  }
  if (!validRelativeDatePeriods.includes(period)) {
    return false;
  }
  if (!validRelativeDateUnits.includes(unit)) {
    return false;
  }
  const intAmount = parseInt(amount);
  if (Number.isNaN(intAmount) || intAmount <= 0) {
    return false;
  }
  return true;
}
function parseRelativeDate(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return {
      period: "now"
    };
  }
  return {
    period,
    amount: amount ? parseInt(amount) : void 0,
    unit: unit ? unit : void 0
  };
}

// src/features/facets/range-facets/date-facet-set/interfaces/request.ts
function isDateFacetRequest(request) {
  return request.type === "dateRange";
}

// src/features/search/search-mappings.ts
function formatStartFacetValue(value) {
  return `start${value}`;
}
function formatEndFacetValue(value) {
  return `end${value}`;
}
var initialSearchMappings = () => ({
  dateFacetValueMap: {}
});
function mapDateRangeRequest(value, facetId, mappings) {
  let start = value.start;
  let end = value.end;
  if (isRelativeDateFormat(start)) {
    start = formatRelativeDateForSearchApi(start);
    mappings.dateFacetValueMap[facetId][formatStartFacetValue(start)] = value.start;
  }
  if (isRelativeDateFormat(end)) {
    end = formatRelativeDateForSearchApi(end);
    mappings.dateFacetValueMap[facetId][formatEndFacetValue(end)] = value.end;
  }
  return { ...value, start, end };
}
function mapFacetRequest(facetRequest, mappings) {
  if (isDateFacetRequest(facetRequest)) {
    const { facetId, currentValues } = facetRequest;
    mappings.dateFacetValueMap[facetId] = {};
    return {
      ...facetRequest,
      currentValues: currentValues.map(
        (value) => mapDateRangeRequest(value, facetId, mappings)
      )
    };
  }
  return facetRequest;
}
function mapSearchRequest(searchRequest) {
  const mappings = initialSearchMappings();
  const request = {
    ...searchRequest,
    facets: searchRequest.facets?.map(
      (facetRequest) => mapFacetRequest(facetRequest, mappings)
    )
  };
  return { request, mappings };
}
function mapDateRangeResponse(value, facetId, mappings) {
  return {
    ...value,
    start: mappings.dateFacetValueMap[facetId][formatStartFacetValue(value.start)] || value.start,
    end: mappings.dateFacetValueMap[facetId][formatEndFacetValue(value.end)] || value.end
  };
}
function isDateFacetResponse(facetResponse, mappings) {
  return facetResponse.facetId in mappings.dateFacetValueMap;
}
function mapFacetResponse(facetResponse, mappings) {
  if (isDateFacetResponse(facetResponse, mappings)) {
    return {
      ...facetResponse,
      values: facetResponse.values.map(
        (value) => mapDateRangeResponse(value, facetResponse.facetId, mappings)
      )
    };
  }
  return facetResponse;
}
function mapSearchResponse(response, mappings) {
  if ("success" in response) {
    const success = {
      ...response.success,
      facets: response.success.facets?.map(
        (facetResponse) => mapFacetResponse(facetResponse, mappings)
      )
    };
    return { success };
  }
  return response;
}

// src/features/facets/generic/interfaces/generic-facet-request.ts
function getFacetRequests2(state) {
  return Object.values(state).map(
    (slice) => slice.request
  );
}

// src/utils/facet-utils.ts
function sortFacets(facets, sortOrder) {
  const payloadMap = {};
  facets.forEach((f2) => {
    payloadMap[f2.facetId] = f2;
  });
  const sortedFacets = [];
  sortOrder.forEach((facetId) => {
    if (facetId in payloadMap) {
      sortedFacets.push(payloadMap[facetId]);
      delete payloadMap[facetId];
    }
  });
  const remainingFacets = Object.values(payloadMap);
  return [...sortedFacets, ...remainingFacets];
}
function getRangeFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    if (request.generateAutomaticRanges && !hasActiveValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
var sortCriteriaMap = {
  alphanumericDescending: { type: "alphanumeric", order: "descending" },
  alphanumericNaturalDescending: {
    type: "alphanumericNatural",
    order: "descending"
  }
};
function getSpecificFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getAllFacets(state) {
  return [
    ...getSpecificFacetRequests(state.facetSet ?? {}),
    ...getRangeFacetRequests(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getAllEnabledFacets(state) {
  return getAllFacets(state).filter(
    ({ facetId }) => state.facetOptions?.facets[facetId]?.enabled ?? true
  );
}
function getFacets(state) {
  return sortFacets(getAllEnabledFacets(state), state.facetOrder ?? []);
}

// src/features/pagination/pagination-constants.ts
var maximumNumberOfResultsFromIndex = 5e3;

// src/features/search-and-folding/legacy/search-and-folding-request.ts
var import_bueno11 = require("@coveo/bueno");

// src/features/configuration/legacy-analytics-params.ts
var fromAnalyticsStateToAnalyticsParams2 = async (s, eventDescription) => {
  const isNextAnalytics = s.analyticsMode === "next";
  return {
    analytics: {
      clientId: await getVisitorID(s),
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: s.originLevel3,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause,
        customData: eventDescription.customData
      },
      ...eventDescription && !isNextAnalytics && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.documentLocation && { documentLocation: s.documentLocation },
      ...s.deviceId && { deviceId: s.deviceId },
      ...getPageID() && { pageId: getPageID() },
      ...isNextAnalytics && s.trackingId && { trackingId: s.trackingId },
      ...{ capture: isNextAnalytics },
      ...isNextAnalytics && { source: getAnalyticsSource(s) }
    }
  };
};

// src/features/search-and-folding/legacy/search-and-folding-request.ts
var buildSearchAndFoldingLoadCollectionRequest = async (state, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: state.configuration.analytics.originLevel3,
    timezone: state.configuration.search.timezone,
    ...state.configuration.analytics.enabled && {
      actionsHistory: history_store_default.getInstance().getHistory()
    },
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && await fromAnalyticsStateToAnalyticsParams2(
      state.configuration.analytics,
      eventDescription
    ),
    ...state.excerptLength && !(0, import_bueno11.isNullOrUndefined)(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/search-and-folding/search-and-folding-request.ts
var import_bueno12 = require("@coveo/bueno");
var buildSearchAndFoldingLoadCollectionRequest2 = (state, navigatorContext, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: navigatorContext.referrer,
    timezone: state.configuration.search.timezone,
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && fromAnalyticsStateToAnalyticsParams(
      state.configuration.analytics,
      navigatorContext,
      eventDescription
    ),
    ...state.excerptLength && !(0, import_bueno12.isNullOrUndefined)(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// src/features/static-filter-set/static-filter-set-selectors.ts
var import_toolkit17 = require("@reduxjs/toolkit");
var selectStaticFilterExpressions = (0, import_toolkit17.createSelector)(
  (state) => state.staticFilterSet,
  (staticFilterSet) => {
    const filters = Object.values(staticFilterSet || {});
    return filters.map((filter) => {
      const selected = filter.values.filter(
        (value) => value.state === "selected" && !!value.expression.trim()
      );
      const expression = selected.map((value) => value.expression).join(" OR ");
      return selected.length > 1 ? `(${expression})` : expression;
    });
  }
);

// src/features/search/search-request.ts
var buildSearchRequest = async (state, navigatorContext, eventDescription) => {
  const cq = buildConstantQuery(state);
  const facets = getFacets2(state);
  const automaticFacets = getAutomaticFacets2(state);
  const sharedWithFoldingRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest(
    state,
    eventDescription
  ) : buildSearchAndFoldingLoadCollectionRequest2(
    state,
    navigatorContext,
    eventDescription
  );
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getNumberOfResultsWithinIndexLimit(state) {
  if (!state.pagination) {
    return void 0;
  }
  const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
  if (isOverIndexLimit) {
    return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
  }
  return state.pagination.numberOfResults;
}
function getFacets2(state) {
  return sortFacets(getAllEnabledFacets2(state), state.facetOrder ?? []);
}
function getAutomaticFacets2(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest(response) {
  const { field, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field,
    label,
    currentValues: selectedValues
  };
}
function getAllEnabledFacets2(state) {
  return getAllFacets2(state).filter(
    ({ facetId }) => state.facetOptions?.facets[facetId]?.enabled ?? true
  );
}
function getAllFacets2(state) {
  return [
    ...getSpecificFacetRequests2(state.facetSet ?? {}),
    ...getRangeFacetRequests2(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests2(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getSpecificFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getRangeFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    const hasPreviousStateValues = currentValues.some(
      (value) => value.previousState
    );
    if (request.generateAutomaticRanges && !hasActiveValues && !hasPreviousStateValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
function buildConstantQuery(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find(
    (tab) => tab.isActive
  );
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = selectStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}

// src/features/search/search-selectors.ts
var import_toolkit18 = require("@reduxjs/toolkit");

// src/features/result-templates/result-templates-helpers.ts
var import_bueno13 = require("@coveo/bueno");
var getResultProperty = (result, property) => {
  const anyResult = result;
  if (!(0, import_bueno13.isNullOrUndefined)(anyResult[property])) {
    return anyResult[property];
  }
  if (!(0, import_bueno13.isNullOrUndefined)(result.raw[property])) {
    return result.raw[property];
  }
  return null;
};
var fieldsMustBeDefined = (fieldNames) => {
  return (result) => {
    return fieldNames.every(
      (fieldName) => !(0, import_bueno13.isNullOrUndefined)(getResultProperty(result, fieldName))
    );
  };
};
var fieldsMustNotBeDefined = (fieldNames) => {
  return (result) => {
    return fieldNames.every(
      (fieldName) => (0, import_bueno13.isNullOrUndefined)(getResultProperty(result, fieldName))
    );
  };
};
var fieldMustMatch = (fieldName, valuesToMatch) => {
  return (result) => {
    const fieldValues = getFieldValuesFromResult(fieldName, result);
    return valuesToMatch.some(
      (valueToMatch) => fieldValues.some(
        (fieldValue) => `${fieldValue}`.toLowerCase() === valueToMatch.toLowerCase()
      )
    );
  };
};
var fieldMustNotMatch = (fieldName, blacklistedValues) => {
  return (result) => {
    const fieldValues = getFieldValuesFromResult(fieldName, result);
    return blacklistedValues.every(
      (blacklistedValue) => fieldValues.every(
        (fieldValue) => `${fieldValue}`.toLowerCase() !== blacklistedValue.toLowerCase()
      )
    );
  };
};
var getFieldValuesFromResult = (fieldName, result) => {
  const rawValue = getResultProperty(result, fieldName);
  return isArray(rawValue) ? rawValue : [rawValue];
};
var ResultTemplatesHelpers = {
  getResultProperty,
  fieldsMustBeDefined,
  fieldsMustNotBeDefined,
  fieldMustMatch,
  fieldMustNotMatch
};

// src/features/search/search-selectors.ts
var selectSearchActionCause = (0, import_toolkit18.createSelector)(
  (state) => state.search,
  (state) => {
    return state?.searchAction?.actionCause || "";
  }
);

// src/features/search-hub/search-hub-selectors.ts
var selectSearchHub = (state) => state.searchHub;

// src/features/tab-set/tab-set-selectors.ts
var import_toolkit19 = require("@reduxjs/toolkit");
var selectActiveTab = (0, import_toolkit19.createSelector)(
  (state) => state,
  (tabSetState) => {
    if (!tabSetState) {
      return "";
    }
    for (const tabId in tabSetState) {
      if (tabSetState[tabId].isActive) {
        return tabSetState[tabId].id;
      }
    }
    return "";
  }
);
var selectActiveTabExpression = (0, import_toolkit19.createSelector)(
  (state) => state,
  (tabSetState) => {
    const activeTabId = selectActiveTab(tabSetState);
    return activeTabId && tabSetState ? tabSetState[activeTabId].expression : "";
  }
);

// src/features/dictionary-field-context/dictionary-field-context-selectors.ts
var selectDictionaryFieldContext = (state) => {
  if (!state.dictionaryFieldContext || !Object.keys(state.dictionaryFieldContext.contextValues).length) {
    return void 0;
  }
  return state.dictionaryFieldContext.contextValues;
};

// src/features/excerpt-length/excerpt-length-selectors.ts
var selectExcerptLength = (state) => state.excerptLength?.length;

// src/features/facet-options/facet-options-selectors.ts
var selectFacetOptions = (state) => {
  const { freezeFacetOrder } = state.facetOptions ?? {};
  return freezeFacetOrder !== void 0 ? { freezeFacetOrder } : void 0;
};

// src/features/folding/folding-selectors.ts
var selectFoldingQueryParams = (state) => {
  if (!state.folding) {
    return void 0;
  }
  return {
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: state.folding.filterFieldRange
  };
};

// src/features/sort-criteria/sort-criteria-selectors.ts
var selectSortCriteria = (state) => state.sortCriteria;

// src/features/generated-answer/generated-answer-request.ts
var buildStreamingRequest = async (state) => ({
  accessToken: state.configuration.accessToken,
  organizationId: state.configuration.organizationId,
  url: getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment
  ),
  streamId: state.search.extendedResults?.generativeQuestionAnsweringId
});
var constructAnswerAPIQueryParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const { aq, cq, dq, lq } = buildAdvancedSearchQueryParams(state);
  const context = selectContext(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    { actionCause: selectSearchActionCause(state) }
  );
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  const facetParams = getGeneratedFacetParams(state);
  const tab = selectActiveTab(state.tabSet) || "default";
  const locale = selectLocale(state);
  const timezone2 = selectTimezone(state);
  const referrer = navigatorContext.referrer || "";
  const facetOptions = selectFacetOptions(state);
  const sortCriteria = selectSortCriteria(state);
  const actionsHistory = getActionsHistory(state);
  const excerptLength = selectExcerptLength(state);
  const foldingParams = selectFoldingQueryParams(state);
  const dictionaryFieldContext = selectDictionaryFieldContext(state);
  return {
    q,
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq },
    ...state.query && { enableQuerySyntax: selectEnableQuerySyntax(state) },
    ...context?.contextValues && {
      context: context.contextValues
    },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...facetParams.length && { facets: facetParams },
    ...state.fields && { fieldsToInclude: state.fields.fieldsToInclude },
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    tab,
    locale,
    timezone: timezone2,
    ...state.debug !== void 0 && { debug: state.debug },
    referrer,
    ...actionsHistory,
    ...foldingParams ?? {},
    ...excerptLength && { excerptLength },
    ...dictionaryFieldContext && {
      dictionaryFieldContext
    },
    sortCriteria,
    ...facetOptions && { facetOptions },
    ...analyticsParams,
    ...state.insightCaseContext?.caseContext && {
      caseContext: state.insightCaseContext?.caseContext
    }
  };
};
var constructGenerateHeadAnswerParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const facetParams = getGeneratedFacetParams(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    { actionCause: selectSearchActionCause(state) }
  );
  const locale = selectLocale(state);
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  return {
    q: q || "",
    ...facetParams.length && { facets: facetParams },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...analyticsParams,
    locale
  };
};
var getGeneratedFacetParams = (state) => getFacets(state)?.map(
  (facetRequest) => mapFacetRequest(facetRequest, initialSearchMappings())
).sort(
  (a, b) => a.facetId > b.facetId ? 1 : b.facetId > a.facetId ? -1 : 0
);
var getActionsHistory = (state) => ({
  actionsHistory: state.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : []
});
var buildAdvancedSearchQueryParams = (state) => {
  const advancedSearchQueryParams = selectAdvancedSearchQueries(state);
  const mergedCq = buildConstantQuery(state);
  return {
    ...advancedSearchQueryParams,
    ...mergedCq && { cq: mergedCq }
  };
};

// src/features/generated-answer/generated-response-format.ts
var generatedContentFormat = ["text/plain", "text/markdown"];

// src/features/generated-answer/generated-answer-actions.ts
var stringValue2 = new import_bueno14.StringValue({ required: true });
var optionalStringValue = new import_bueno14.StringValue();
var booleanValue = new import_bueno14.BooleanValue({ required: true });
var citationSchema = {
  id: stringValue2,
  title: stringValue2,
  uri: stringValue2,
  permanentid: stringValue2,
  clickUri: optionalStringValue
};
var answerContentFormatSchema = new import_bueno14.StringValue({
  required: true,
  constrainTo: generatedContentFormat
});
var setIsVisible = (0, import_toolkit20.createAction)(
  "generatedAnswer/setIsVisible",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerId2 = (0, import_toolkit20.createAction)(
  "generatedAnswer/setAnswerId",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setAnswerGenerationMode = (0, import_toolkit20.createAction)(
  "generatedAnswer/setAnswerGenerationMode",
  (payload) => validatePayload(
    payload,
    new import_bueno14.StringValue({
      constrainTo: ["automatic", "manual"],
      required: false,
      default: "automatic"
    })
  )
);
var setIsEnabled2 = (0, import_toolkit20.createAction)(
  "generatedAnswer/setIsEnabled",
  (payload) => validatePayload(payload, booleanValue)
);
var updateMessage = (0, import_toolkit20.createAction)(
  "generatedAnswer/updateMessage",
  (payload) => validatePayload(payload, {
    textDelta: stringValue2
  })
);
var updateCitations = (0, import_toolkit20.createAction)(
  "generatedAnswer/updateCitations",
  (payload) => validatePayload(payload, {
    citations: new import_bueno14.ArrayValue({
      required: true,
      each: new import_bueno14.RecordValue({
        values: citationSchema
      })
    })
  })
);
var updateError = (0, import_toolkit20.createAction)(
  "generatedAnswer/updateError",
  (payload) => validatePayload(payload, {
    message: optionalStringValue,
    code: new import_bueno14.NumberValue({ min: 0 })
  })
);
var resetAnswer = (0, import_toolkit20.createAction)("generatedAnswer/resetAnswer");
var likeGeneratedAnswer = (0, import_toolkit20.createAction)("generatedAnswer/like");
var dislikeGeneratedAnswer = (0, import_toolkit20.createAction)("generatedAnswer/dislike");
var openGeneratedAnswerFeedbackModal = (0, import_toolkit20.createAction)(
  "generatedAnswer/feedbackModal/open"
);
var expandGeneratedAnswer = (0, import_toolkit20.createAction)("generatedAnswer/expand");
var collapseGeneratedAnswer = (0, import_toolkit20.createAction)("generatedAnswer/collapse");
var setId = (0, import_toolkit20.createAction)(
  "generatedAnswer/setId",
  (payload) => validatePayload(payload, {
    id: new import_bueno14.StringValue({
      required: true
    })
  })
);
var closeGeneratedAnswerFeedbackModal = (0, import_toolkit20.createAction)(
  "generatedAnswer/feedbackModal/close"
);
var sendGeneratedAnswerFeedback = (0, import_toolkit20.createAction)(
  "generatedAnswer/sendFeedback"
);
var setIsLoading = (0, import_toolkit20.createAction)(
  "generatedAnswer/setIsLoading",
  (payload) => validatePayload(payload, booleanValue)
);
var setIsStreaming = (0, import_toolkit20.createAction)(
  "generatedAnswer/setIsStreaming",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerContentFormat = (0, import_toolkit20.createAction)(
  "generatedAnswer/setAnswerContentFormat",
  (payload) => validatePayload(payload, answerContentFormatSchema)
);
var updateResponseFormat = (0, import_toolkit20.createAction)(
  "generatedAnswer/updateResponseFormat",
  (payload) => validatePayload(payload, {
    contentFormat: new import_bueno14.ArrayValue({
      each: answerContentFormatSchema,
      default: ["text/plain"]
    })
  })
);
var updateAnswerConfigurationId = (0, import_toolkit20.createAction)(
  "knowledge/updateAnswerConfigurationId",
  (payload) => validatePayload(payload, stringValue2)
);
var registerFieldsToIncludeInCitations = (0, import_toolkit20.createAction)(
  "generatedAnswer/registerFieldsToIncludeInCitations",
  (payload) => validatePayload(payload, nonEmptyStringArray)
);
var setIsAnswerGenerated = (0, import_toolkit20.createAction)(
  "generatedAnswer/setIsAnswerGenerated",
  (payload) => validatePayload(payload, booleanValue)
);
var setCannotAnswer = (0, import_toolkit20.createAction)(
  "generatedAnswer/setCannotAnswer",
  (payload) => validatePayload(payload, booleanValue)
);
var setAnswerApiQueryParams = (0, import_toolkit20.createAction)(
  "generatedAnswer/setAnswerApiQueryParams",
  (payload) => validatePayload(payload, new import_bueno14.RecordValue({}))
);
var streamAnswer = (0, import_toolkit20.createAsyncThunk)("generatedAnswer/streamAnswer", async (params, config) => {
  const state = config.getState();
  const { dispatch, extra, getState } = config;
  const { search } = getState();
  const { queryExecuted } = search;
  const { setAbortControllerRef } = params;
  const request = await buildStreamingRequest(state);
  const handleStreamPayload = (payloadType, payload) => {
    switch (payloadType) {
      case "genqa.headerMessageType": {
        const header = JSON.parse(
          payload
        );
        dispatch(setAnswerContentFormat(header.contentFormat));
        break;
      }
      case "genqa.messageType":
        dispatch(
          updateMessage(JSON.parse(payload))
        );
        break;
      case "genqa.citationsType":
        dispatch(
          updateCitations(
            JSON.parse(payload)
          )
        );
        break;
      case "genqa.endOfStreamType": {
        const isAnswerGenerated = JSON.parse(payload).answerGenerated;
        const cannotAnswer = queryExecuted.length !== 0 && !isAnswerGenerated;
        dispatch(setCannotAnswer(cannotAnswer));
        dispatch(setIsStreaming(false));
        dispatch(setIsAnswerGenerated(isAnswerGenerated));
        dispatch(logGeneratedAnswerStreamEnd(isAnswerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
        break;
      }
      default:
        if (state.debug) {
          extra.logger.warn(`Unknown payloadType: "${payloadType}"`);
        }
    }
  };
  dispatch(setIsLoading(true));
  const currentStreamRequestMatchesOriginalStreamRequest = (request2) => {
    return request2.streamId === config.getState().search.extendedResults.generativeQuestionAnsweringId;
  };
  const abortController = extra.streamingClient?.streamGeneratedAnswer(
    request,
    {
      write: (data) => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(setIsLoading(false));
          if (data.payload && data.payloadType) {
            handleStreamPayload(data.payloadType, data.payload);
          }
        }
      },
      abort: (error) => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(updateError(error));
        }
      },
      close: () => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(setIsStreaming(false));
        }
      },
      resetAnswer: () => {
        if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
          dispatch(resetAnswer());
        }
      }
    }
  );
  if (abortController) {
    setAbortControllerRef(abortController);
  } else {
    dispatch(setIsLoading(false));
  }
});
var generateAnswer = (0, import_toolkit20.createAsyncThunk)(
  "generatedAnswer/generateAnswer",
  async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
    dispatch(resetAnswer());
    const state = getState();
    if (state.generatedAnswer.answerConfigurationId) {
      const answerApiQueryParams = constructAnswerAPIQueryParams(
        state,
        navigatorContext
      );
      dispatch(setAnswerApiQueryParams(answerApiQueryParams));
      await dispatch(fetchAnswer(answerApiQueryParams));
    } else {
      logger.warn(
        "[WARNING] Missing answerConfigurationId in engine configuration. The generateAnswer action requires an answer configuration ID to use CRGA with the Answer API."
      );
    }
  }
);
var generateHeadAnswer = (0, import_toolkit20.createAsyncThunk)(
  "generatedAnswerWithFollowUps/generateHeadAnswer",
  async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
    const state = getState();
    const agentId = selectAgentId(state);
    if (!agentId) {
      logger.warn(
        "Missing agentId in engine configuration. The generateHeadAnswer action requires an agent ID."
      );
      return;
    }
    dispatch(resetAnswer());
    const generateHeadAnswerParams = constructGenerateHeadAnswerParams(
      state,
      navigatorContext
    );
    const headAnswerEndpointArgs = {
      ...generateHeadAnswerParams,
      strategyKey: "head-answer"
    };
    dispatch(setAnswerApiQueryParams(generateHeadAnswerParams));
    await dispatch(initiateAnswerEndpoint(headAnswerEndpointArgs));
  }
);

// src/api/knowledge/stream-answer-api.ts
var handleHeaderMessage = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var handleMessage = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var handleCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var handleEndOfStream = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var handleError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(
    `Generated answer error: ${errorMessage} (code: ${message.code})`
  );
};
var updateCacheWithEvent = (event, draft, dispatch) => {
  const message = JSON.parse(event.data);
  if (message.finishReason === "ERROR" && message.errorMessage) {
    handleError(draft, message);
  }
  const parsedPayload = message.payload.length ? JSON.parse(message.payload) : {};
  switch (message.payloadType) {
    case "genqa.headerMessageType":
      if (parsedPayload.contentFormat) {
        handleHeaderMessage(draft, parsedPayload);
        dispatch(setAnswerContentFormat(parsedPayload.contentFormat));
      }
      break;
    case "genqa.messageType":
      if (parsedPayload.textDelta) {
        handleMessage(draft, parsedPayload);
        dispatch(updateMessage({ textDelta: parsedPayload.textDelta }));
      }
      break;
    case "genqa.citationsType":
      if (parsedPayload.citations) {
        handleCitations(draft, parsedPayload);
        dispatch(updateCitations({ citations: parsedPayload.citations }));
      }
      break;
    case "genqa.endOfStreamType":
      handleEndOfStream(draft, parsedPayload);
      dispatch(
        logGeneratedAnswerStreamEnd(parsedPayload.answerGenerated ?? false)
      );
      dispatch(logGeneratedAnswerResponseLinked());
      break;
  }
};
var buildAnswerEndpoint = (platformEndpoint, organizationId, answerConfigurationId, insightId) => {
  if (!platformEndpoint || !organizationId || !answerConfigurationId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath = `/rest/organizations/${organizationId}`;
  const prefix = insightId ? `insight/v1/configs/${insightId}/answer` : `answer/v1/configs`;
  return `${platformEndpoint}${basePath}/${prefix}/${answerConfigurationId}/generate`;
};
var answerApi = answerSlice.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    getAnswer: builder.query({
      queryFn: () => ({
        data: {
          contentFormat: void 0,
          answer: void 0,
          citations: void 0,
          error: void 0,
          generated: false,
          isStreaming: true,
          isLoading: true
        }
      }),
      serializeQueryArgs: ({ endpointName, queryArgs }) => {
        const { analytics: _analytics, ...queryArgsWithoutAnalytics } = queryArgs;
        return `${endpointName}(${JSON.stringify(queryArgsWithoutAnalytics)})`;
      },
      async onCacheEntryAdded(args, { getState, cacheDataLoaded, updateCachedData, dispatch }) {
        await cacheDataLoaded;
        const { configuration: configuration2, generatedAnswer, insightConfiguration } = getState();
        const { organizationId, environment, accessToken } = configuration2;
        const platformEndpoint = getOrganizationEndpoint(
          organizationId,
          environment
        );
        const answerEndpoint2 = buildAnswerEndpoint(
          platformEndpoint,
          organizationId,
          generatedAnswer.answerConfigurationId,
          insightConfiguration?.insightId
        );
        await fetchEventSource(answerEndpoint2, {
          method: "POST",
          body: JSON.stringify(args),
          headers: {
            Authorization: `Bearer ${accessToken}`,
            Accept: "application/json",
            "Content-Type": "application/json",
            "Accept-Encoding": "*"
          },
          fetch,
          onopen: async (res) => {
            const answerId = res.headers.get("x-answer-id");
            if (answerId) {
              updateCachedData((draft) => {
                draft.answerId = answerId;
                dispatch(setAnswerId2(answerId));
              });
            }
          },
          onmessage: (event) => {
            updateCachedData((draft) => {
              updateCacheWithEvent(event, draft, dispatch);
            });
          },
          onerror: (error) => {
            throw error;
          },
          onclose: () => {
            updateCachedData((draft) => {
              dispatch(setCannotAnswer(!draft.generated));
            });
          }
        });
      }
    })
  })
});
var fetchAnswer = (fetchAnswerParams) => {
  return answerApi.endpoints.getAnswer.initiate(fetchAnswerParams);
};

// src/features/debug/version-slice.ts
var import_toolkit21 = require("@reduxjs/toolkit");
var versionReducer = (0, import_toolkit21.createReducer)(VERSION, (builder) => builder);

// src/app/analytics-middleware.ts
var import_bueno15 = require("@coveo/bueno");
function isAnalyticsAction(action) {
  const analytics = action.payload?.analyticsAction;
  return isActionWithType(action) && !(0, import_bueno15.isNullOrUndefined)(analytics);
}
function isActionWithType(action) {
  return "type" in action;
}
var analyticsMiddleware = (api) => (next) => (action) => {
  let analytics;
  if (isAnalyticsAction(action)) {
    analytics = action.payload.analyticsAction;
    delete action.payload.analyticsAction;
  }
  const ret = next(action);
  if (isActionWithType(action)) {
    if (action.type === "search/executeSearch/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with search:", action);
    }
    if (action.type === "recommendation/get/fullfilled" && analytics === void 0) {
      console.error(
        "No analytics action associated with recommendation:",
        action
      );
    }
    if (action.type === "productRecommendations/get/fullfilled" && analytics === void 0) {
      console.error(
        "No analytics action associated with product recommendation:",
        action
      );
    }
  }
  if (analytics !== void 0) {
    api.dispatch(analytics);
  }
  return ret;
};

// src/features/configuration/configuration-slice.ts
var import_bueno17 = require("@coveo/bueno");
var import_toolkit23 = require("@reduxjs/toolkit");

// src/features/tab-set/tab-set-actions.ts
var import_bueno16 = require("@coveo/bueno");
var import_toolkit22 = require("@reduxjs/toolkit");
var registerTab = (0, import_toolkit22.createAction)(
  "tab/register",
  (payload) => {
    const schema = new import_bueno16.RecordValue({
      values: {
        id: requiredNonEmptyString,
        expression: requiredEmptyAllowedString
      }
    });
    return validatePayload(payload, schema);
  }
);
var updateActiveTab = (0, import_toolkit22.createAction)(
  "tab/updateActiveTab",
  (id) => {
    return validatePayload(id, requiredNonEmptyString);
  }
);

// src/features/configuration/configuration-state.ts
var import_dayjs3 = __toESM(require("dayjs"), 1);
var import_timezone = __toESM(require("dayjs/plugin/timezone.js"), 1);
var import_utc = __toESM(require("dayjs/plugin/utc.js"), 1);
import_dayjs3.default.extend(import_utc.default);
import_dayjs3.default.extend(import_timezone.default);
var getConfigurationInitialState = () => ({
  organizationId: "",
  accessToken: "",
  search: {
    locale: "en-US",
    timezone: import_dayjs3.default.tz.guess(),
    authenticationProviders: []
  },
  analytics: {
    enabled: true,
    originContext: "Search",
    originLevel2: "default",
    originLevel3: "default",
    anonymous: false,
    deviceId: "",
    userDisplayName: "",
    documentLocation: "",
    analyticsMode: "next",
    source: {}
  },
  knowledge: {
    answerConfigurationId: "",
    agentId: void 0
  },
  environment: "prod"
});

// src/features/configuration/magic-cookie.ts
var pendragonCookieValueMatcher = /(^|; )Coveo-Pendragon=([^;]*)/;
function getMagicCookie() {
  if (typeof window === "undefined") {
    return false;
  } else {
    return pendragonCookieValueMatcher.exec(document.cookie)?.pop() || null;
  }
}

// src/features/configuration/configuration-slice.ts
var configurationReducer = (0, import_toolkit23.createReducer)(
  getConfigurationInitialState(),
  (builder) => builder.addCase(updateBasicConfiguration, (state, action) => {
    handleUpdateBasicConfiguration(state, action.payload);
  }).addCase(updateSearchConfiguration, (state, action) => {
    handleUpdateSearchConfiguration(state, action.payload);
  }).addCase(updateAnalyticsConfiguration, (state, action) => {
    handleUpdateAnalyticsConfiguration(state, action.payload);
  }).addCase(disableAnalytics, (state) => {
    state.analytics.enabled = false;
  }).addCase(enableAnalytics, (state) => {
    state.analytics.enabled = true;
  }).addCase(setOriginLevel2, (state, action) => {
    state.analytics.originLevel2 = action.payload.originLevel2;
  }).addCase(setOriginLevel3, (state, action) => {
    state.analytics.originLevel3 = action.payload.originLevel3;
  }).addCase(updateActiveTab, (state, action) => {
    state.analytics.originLevel2 = action.payload;
  }).addCase(restoreTab, (state, action) => {
    state.analytics.originLevel2 = action.payload;
  }).addCase(restoreSearchParameters, (state, action) => {
    if (!(0, import_bueno17.isNullOrUndefined)(action.payload.tab)) {
      state.analytics.originLevel2 = action.payload.tab;
    }
  }).addCase(setAgentId, (state, { payload }) => {
    state.knowledge.agentId = payload;
  })
);
function handleUpdateBasicConfiguration(state, payload) {
  if (!(0, import_bueno17.isNullOrUndefined)(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!(0, import_bueno17.isNullOrUndefined)(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateSearchConfiguration(state, payload) {
  if (!(0, import_bueno17.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.search.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.locale)) {
    state.search.locale = payload.locale;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.timezone)) {
    state.search.timezone = payload.timezone;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.authenticationProviders)) {
    state.search.authenticationProviders = payload.authenticationProviders;
  }
}
function handleUpdateAnalyticsConfiguration(state, payload) {
  if (!(0, import_bueno17.isNullOrUndefined)(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.originContext)) {
    state.analytics.originContext = payload.originContext;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.originLevel2)) {
    state.analytics.originLevel2 = payload.originLevel2;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.originLevel3)) {
    state.analytics.originLevel3 = payload.originLevel3;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.analyticsMode)) {
    state.analytics.analyticsMode = payload.analyticsMode;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.source)) {
    state.analytics.source = payload.source;
  }
  try {
    const magicCookie = getMagicCookie();
    if (magicCookie) {
      state.analytics.analyticsMode = "next";
      state.analytics.trackingId = magicCookie;
    }
  } catch (_) {
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.runtimeEnvironment)) {
    state.analytics.runtimeEnvironment = payload.runtimeEnvironment;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.anonymous)) {
    state.analytics.anonymous = payload.anonymous;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.deviceId)) {
    state.analytics.deviceId = payload.deviceId;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.userDisplayName)) {
    state.analytics.userDisplayName = payload.userDisplayName;
  }
  if (!(0, import_bueno17.isNullOrUndefined)(payload.documentLocation)) {
    state.analytics.documentLocation = payload.documentLocation;
  }
}

// src/app/common-reducers.ts
var configuration = configurationReducer;

// src/app/instantly-callable-middleware.ts
function isInstantlyCallableThunkAction(action) {
  return action.instantlyCallable;
}
var instantlyCallableThunkActionMiddleware = () => (next) => (action) => next(isInstantlyCallableThunkAction(action) ? action() : action);

// src/app/listener-middleware/generate-answer-listener-middleware.ts
var import_toolkit33 = require("@reduxjs/toolkit");

// src/features/search/search-actions.ts
var import_bueno28 = require("@coveo/bueno");
var import_toolkit32 = require("@reduxjs/toolkit");

// src/features/breadcrumb/breadcrumb-actions.ts
var import_toolkit24 = require("@reduxjs/toolkit");
var deselectAllBreadcrumbs = (0, import_toolkit24.createAction)("breadcrumb/deselectAll");
var deselectAllNonBreadcrumbs = (0, import_toolkit24.createAction)(
  "breadcrumb/deselectAllNonBreadcrumbs"
);

// src/features/facets/generic/facet-actions.ts
var import_bueno18 = require("@coveo/bueno");
var import_toolkit25 = require("@reduxjs/toolkit");
var updateFacetAutoSelection = (0, import_toolkit25.createAction)(
  "facet/updateFacetAutoSelection",
  (payload) => validatePayload(payload, {
    allow: new import_bueno18.BooleanValue({ required: true })
  })
);

// src/api/analytics/instant-result-analytics.ts
var InstantResultsAnalyticsProvider = class extends SearchAnalyticsProvider {
  constructor(getState) {
    super(getState);
    this.getState = getState;
  }
  get activeInstantResultQuery() {
    const state = this.getState().instantResults;
    for (const id in state) {
      for (const query in state[id].cache) {
        if (state[id].cache[query].isActive) {
          return state[id].q;
        }
      }
    }
    return null;
  }
  get activeInstantResultCache() {
    const state = this.getState().instantResults;
    for (const id in state) {
      for (const query in state[id].cache) {
        if (state[id].cache[query].isActive) {
          return state[id].cache[query];
        }
      }
    }
    return null;
  }
  get results() {
    return this.activeInstantResultCache?.results;
  }
  get queryText() {
    return this.activeInstantResultQuery ?? getQueryInitialState().q;
  }
  get responseTime() {
    return this.activeInstantResultCache?.duration ?? getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.activeInstantResultCache?.totalCountFiltered ?? getSearchInitialState().response.totalCountFiltered;
  }
  getSearchUID() {
    const searchUid = this.activeInstantResultCache?.searchUid;
    return searchUid || super.getSearchUID();
  }
};

// src/features/instant-results/instant-result-analytics-actions.ts
var logInstantResultsSearch = () => makeAnalyticsAction(
  "analytics/instantResult/searchboxAsYouType",
  (client) => client.makeSearchboxAsYouType(),
  (getState) => new InstantResultsAnalyticsProvider(getState)
);
var searchboxAsYouType = () => ({
  actionCause: "searchboxAsYouType" /* searchboxAsYouType */
});

// src/features/instant-results/instant-results-actions.ts
var import_toolkit26 = require("@reduxjs/toolkit");
var instantResultsRegisterDefinition = {
  id: requiredNonEmptyString
};
var instantResultsQueryDefinition = {
  ...instantResultsRegisterDefinition,
  q: requiredEmptyAllowedString
};
var registerInstantResults = (0, import_toolkit26.createAction)(
  "instantResults/register",
  (payload) => validatePayload(payload, instantResultsRegisterDefinition)
);
var updateInstantResultsQuery = (0, import_toolkit26.createAction)(
  "instantResults/updateQuery",
  (payload) => validatePayload(payload, instantResultsQueryDefinition)
);
var clearExpiredResults = (0, import_toolkit26.createAction)(
  "instantResults/clearExpired",
  (payload) => validatePayload(payload, instantResultsRegisterDefinition)
);

// src/features/pagination/pagination-actions.ts
var import_bueno19 = require("@coveo/bueno");
var import_toolkit27 = require("@reduxjs/toolkit");
var numberValue = new import_bueno19.NumberValue({ required: true, min: 0 });
var registerNumberOfResults = (0, import_toolkit27.createAction)(
  "pagination/registerNumberOfResults",
  (payload) => validatePayload(payload, numberValue)
);
var updateNumberOfResults = (0, import_toolkit27.createAction)(
  "pagination/updateNumberOfResults",
  (payload) => validatePayload(payload, numberValue)
);
var registerPage = (0, import_toolkit27.createAction)(
  "pagination/registerPage",
  (payload) => validatePayload(payload, numberValue)
);
var updatePage = (0, import_toolkit27.createAction)(
  "pagination/updatePage",
  (payload) => validatePayload(payload, numberValue)
);
var nextPage = (0, import_toolkit27.createAction)("pagination/nextPage");
var previousPage = (0, import_toolkit27.createAction)("pagination/previousPage");

// src/features/query/query-actions.ts
var import_bueno20 = require("@coveo/bueno");
var import_toolkit28 = require("@reduxjs/toolkit");
var updateQuery = (0, import_toolkit28.createAction)(
  "query/updateQuery",
  (payload) => validatePayload(payload, {
    q: new import_bueno20.StringValue(),
    enableQuerySyntax: new import_bueno20.BooleanValue()
  })
);

// src/features/search/legacy/search-actions.ts
var import_bueno26 = require("@coveo/bueno");
var import_toolkit31 = require("@reduxjs/toolkit");

// src/features/advanced-search-queries/advanced-search-queries-state.ts
var getAdvancedSearchQueriesInitialState = () => ({
  cq: "",
  cqWasSet: false,
  aq: "",
  aqWasSet: false,
  lq: "",
  lqWasSet: false,
  dq: "",
  dqWasSet: false,
  defaultFilters: {
    cq: "",
    aq: "",
    lq: "",
    dq: ""
  }
});

// src/features/search/search-analytics-actions.ts
var logFetchMoreResults = () => makeAnalyticsAction(
  "search/logFetchMoreResults",
  (client) => client.makeFetchMoreResults()
);
var logQueryError = (error) => makeAnalyticsAction(
  "search/queryError",
  (client, state) => client.makeQueryError({
    query: state.query?.q || getQueryInitialState().q,
    aq: state.advancedSearchQueries?.aq || getAdvancedSearchQueriesInitialState().aq,
    cq: state.advancedSearchQueries?.cq || getAdvancedSearchQueriesInitialState().cq,
    dq: state.advancedSearchQueries?.dq || getAdvancedSearchQueriesInitialState().dq,
    errorType: error.type,
    errorMessage: error.message
  })
);

// src/features/search/legacy/search-actions-thunk-processor.ts
var import_bueno25 = require("@coveo/bueno");

// src/api/search/search-api-client.ts
var import_bueno21 = require("@coveo/bueno");
var isSuccessResponse = (r) => {
  return r.success !== void 0;
};
var isErrorResponse = (r) => {
  return r.error !== void 0;
};

// src/features/did-you-mean/did-you-mean-actions.ts
var import_bueno22 = require("@coveo/bueno");
var import_toolkit29 = require("@reduxjs/toolkit");
var enableDidYouMean = (0, import_toolkit29.createAction)("didYouMean/enable");
var disableDidYouMean = (0, import_toolkit29.createAction)("didYouMean/disable");
var disableAutomaticQueryCorrection = (0, import_toolkit29.createAction)(
  "didYouMean/automaticCorrections/disable"
);
var enableAutomaticQueryCorrection = (0, import_toolkit29.createAction)(
  "didYouMean/automaticCorrections/enable"
);
var applyDidYouMeanCorrection = (0, import_toolkit29.createAction)(
  "didYouMean/correction",
  (payload) => validatePayload(payload, requiredNonEmptyString)
);
var setCorrectionMode = (0, import_toolkit29.createAction)(
  "didYouMean/automaticCorrections/mode",
  (payload) => validatePayload(
    payload,
    new import_bueno22.StringValue({
      constrainTo: ["next", "legacy"],
      emptyAllowed: false,
      required: true
    })
  )
);

// src/features/did-you-mean/did-you-mean-analytics-actions.ts
var logDidYouMeanAutomatic = () => makeAnalyticsAction(
  "analytics/didyoumean/automatic",
  (client) => client.makeDidYouMeanAutomatic()
);
var didYouMeanAutomatic = () => ({
  actionCause: "didYouMeanAutomatic" /* didYouMeanAutomatic */
});

// src/features/context/context-state.ts
function getContextInitialState() {
  return {
    contextValues: {}
  };
}

// src/features/dictionary-field-context/dictionary-field-context-state.ts
function getDictionaryFieldContextInitialState() {
  return {
    contextValues: {}
  };
}

// src/features/facet-options/facet-options-state.ts
function getFacetOptionsInitialState() {
  return {
    freezeFacetOrder: false,
    facets: {}
  };
}

// src/features/facets/facet-order/facet-order-state.ts
function getFacetOrderInitialState() {
  return [];
}

// src/features/pagination/pagination-state.ts
function getPaginationInitialState() {
  return {
    firstResult: 0,
    defaultNumberOfResults: 10,
    numberOfResults: 10,
    totalCountFiltered: 0
  };
}

// src/features/query-set/query-set-state.ts
function getQuerySetInitialState() {
  return {};
}

// src/features/static-filter-set/static-filter-set-state.ts
function getStaticFilterSetInitialState() {
  return {};
}

// src/features/tab-set/tab-set-state.ts
function getTabSetInitialState() {
  return {};
}

// src/features/history/history-state.ts
function extractHistory(state) {
  return {
    context: state.context || getContextInitialState(),
    dictionaryFieldContext: state.dictionaryFieldContext || getDictionaryFieldContextInitialState(),
    facetSet: state.facetSet || getFacetSetInitialState(),
    numericFacetSet: state.numericFacetSet || getNumericFacetSetInitialState(),
    dateFacetSet: state.dateFacetSet || getDateFacetSetInitialState(),
    categoryFacetSet: state.categoryFacetSet || getCategoryFacetSetInitialState(),
    automaticFacetSet: state.automaticFacetSet ?? getAutomaticFacetSetInitialState(),
    pagination: state.pagination || getPaginationInitialState(),
    query: state.query || getQueryInitialState(),
    tabSet: state.tabSet || getTabSetInitialState(),
    advancedSearchQueries: state.advancedSearchQueries || getAdvancedSearchQueriesInitialState(),
    staticFilterSet: state.staticFilterSet || getStaticFilterSetInitialState(),
    querySet: state.querySet || getQuerySetInitialState(),
    sortCriteria: state.sortCriteria || getSortCriteriaInitialState(),
    pipeline: state.pipeline || getPipelineInitialState(),
    searchHub: state.searchHub || getSearchHubInitialState(),
    facetOptions: state.facetOptions || getFacetOptionsInitialState(),
    facetOrder: state.facetOrder ?? getFacetOrderInitialState(),
    debug: state.debug ?? getDebugInitialState()
  };
}

// src/features/triggers/trigger-analytics-actions.ts
var import_bueno23 = require("@coveo/bueno");
var logUndoTriggerQueryPayloadDefinition = new import_bueno23.RecordValue({
  values: {
    undoneQuery: requiredEmptyAllowedString
  },
  options: { required: true }
});
var logTriggerQuery = () => makeAnalyticsAction("analytics/trigger/query", (client, state) => {
  if (state.triggers?.queryModification.newQuery) {
    return client.makeTriggerQuery();
  }
  return null;
});

// src/features/triggers/triggers-actions.ts
var import_bueno24 = require("@coveo/bueno");
var import_toolkit30 = require("@reduxjs/toolkit");
var updateIgnoreQueryTrigger = (0, import_toolkit30.createAction)(
  "trigger/query/ignore",
  (q) => validatePayload(q, new import_bueno24.StringValue({ emptyAllowed: true, required: true }))
);
var applyQueryTriggerModification = (0, import_toolkit30.createAction)(
  "trigger/query/modification",
  (payload) => validatePayload(
    payload,
    new import_bueno24.RecordValue({
      values: { originalQuery: nonEmptyString, modification: nonEmptyString }
    })
  )
);

// src/features/search/legacy/search-request.ts
var buildSearchRequest2 = async (state, eventDescription) => {
  const cq = buildConstantQuery2(state);
  const facets = getFacets(state);
  const automaticFacets = getAutomaticFacets3(state);
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest(state, eventDescription);
  const getNumberOfResultsWithinIndexLimit2 = () => {
    if (!state.pagination) {
      return void 0;
    }
    const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
    if (isOverIndexLimit) {
      return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
    }
    return state.pagination.numberOfResults;
  };
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit2(),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getAutomaticFacets3(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest2).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest2(response) {
  const { field, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field,
    label,
    currentValues: selectedValues
  };
}
function buildConstantQuery2(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find(
    (tab) => tab.isActive
  );
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = getStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}
function getStaticFilterExpressions(state) {
  const filters = Object.values(state.staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter(
      (value) => value.state === "selected" && !!value.expression.trim()
    );
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
}

// src/features/search/legacy/search-actions-thunk-processor.ts
var AsyncSearchThunkProcessor = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    const startedAt = Date.now();
    const response = mapSearchResponse(
      await this.extra.apiClient.search(request, options),
      mappings
    );
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !(0, import_bueno25.isNullOrUndefined)(queryCorrection) && !(0, import_bueno25.isNullOrUndefined)(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(
      originalFetchedResponse
    );
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    this.analyticsAction?.()(
      this.dispatch,
      () => this.getStateAfterResponse(
        originalFetchedResponse.queryExecuted,
        originalFetchedResponse.duration,
        state,
        successResponse
      ),
      this.extra
    );
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    if (this.analyticsAction) {
      await this.dispatch(this.analyticsAction);
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery,
      analyticsAction: logTriggerQuery()
    };
  }
  getStateAfterResponse(query, duration, previousState, response) {
    return {
      ...previousState,
      query: {
        q: query,
        enableQuerySyntax: previousState.query?.enableQuerySyntax ?? getQueryInitialState().enableQuerySyntax
      },
      search: {
        ...getSearchInitialState(),
        duration,
        response,
        results: response.results
      }
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery(),
      analyticsAction: this.analyticsAction
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest2(this.getState()),
      { origin: "mainSearch" }
    );
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(
      applyQueryTriggerModification({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest2(this.getState()),
      { origin: "mainSearch" }
    );
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get analyticsAction() {
    return this.config.analyticsAction;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// src/features/search/legacy/search-actions.ts
var executeSearch = (0, import_toolkit31.createAsyncThunk)("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  return await legacyExecuteSearch(state, config, searchAction);
});
var fetchPage = (0, import_toolkit31.createAsyncThunk)("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchPage(state, config, searchAction);
});
var fetchMoreResults = (0, import_toolkit31.createAsyncThunk)("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  return await legacyFetchMoreResults(config, state);
});
var fetchFacetValues = (0, import_toolkit31.createAsyncThunk)(
  "search/fetchFacetValues",
  async (searchAction, config) => {
    const state = config.getState();
    return await legacyFetchFacetValues(config, searchAction, state);
  }
);
var fetchInstantResults = (0, import_toolkit31.createAsyncThunk)(
  "search/fetchInstantResults",
  async (payload, config) => {
    return legacyFetchInstantResults(payload, config);
  }
);
var buildFetchMoreRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(state, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest = async (state, q, numberOfResults) => {
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest(state);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(state, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory = (state) => {
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
async function legacyFetchInstantResults(payload, config) {
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new import_bueno26.NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new import_bueno26.NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const state = config.getState();
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: logInstantResultsSearch() }, (modification) => {
    config.dispatch(
      updateInstantResultsQuery({ q: modification, id: payload.id })
    );
  });
  const request = await buildInstantResultSearchRequest(
    state,
    q,
    maxResultsPerQuery
  );
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      analyticsAction: processed.analyticsAction,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
}
async function legacyFetchPage(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: searchAction
  });
  const request = await buildSearchRequest2(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchMoreResults(config, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await logFetchMoreResults().prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: logFetchMoreResults()
  });
  const request = await buildFetchMoreRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchFacetValues(config, searchAction, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const request = await buildFetchFacetValuesRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
}
async function legacyExecuteSearch(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const request = await buildSearchRequest2(state, eventDescription);
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}

// src/features/search/search-actions-thunk-processor.ts
var import_bueno27 = require("@coveo/bueno");
var AsyncSearchThunkProcessor2 = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    const startedAt = Date.now();
    const response = mapSearchResponse(
      await this.extra.apiClient.search(request, options),
      mappings
    );
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !(0, import_bueno27.isNullOrUndefined)(queryCorrection) && !(0, import_bueno27.isNullOrUndefined)(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(
      originalFetchedResponse
    );
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery()
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const state = this.getState();
    const { actionCause } = didYouMeanAutomatic();
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest(state, this.extra.navigatorContext, {
        actionCause
      }),
      { origin: "mainSearch" }
    );
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(
      applyQueryTriggerModification({
        newQuery: modified,
        originalQuery: this.getCurrentQuery()
      })
    );
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(
      await buildSearchRequest(this.getState(), this.extra.navigatorContext),
      { origin: "mainSearch" }
    );
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// src/features/search/search-actions.ts
var prepareForSearchWithQuery = (0, import_toolkit32.createAsyncThunk)("search/prepareForSearchWithQuery", (payload, thunk) => {
  const { dispatch } = thunk;
  validatePayload(payload, {
    q: new import_bueno28.StringValue(),
    enableQuerySyntax: new import_bueno28.BooleanValue(),
    clearFilters: new import_bueno28.BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deselectAllBreadcrumbs());
    dispatch(deselectAllNonBreadcrumbs());
  }
  dispatch(updateFacetAutoSelection({ allow: true }));
  dispatch(
    updateQuery({ q: payload.q, enableQuerySyntax: payload.enableQuerySyntax })
  );
  dispatch(updatePage(1));
});
var updateSearchAction = (0, import_toolkit32.createAction)(
  "search/updateSearchAction"
);
var executeSearch2 = (0, import_toolkit32.createAsyncThunk)(
  "search/executeSearch",
  async (searchAction, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyExecuteSearch(state, config, searchAction.legacy);
    }
    addEntryInActionsHistory2(state);
    const analyticsAction = searchAction.next ? buildSearchReduxAction(searchAction.next) : void 0;
    const request = await buildSearchRequest(
      state,
      config.extra.navigatorContext,
      analyticsAction
    );
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: analyticsAction ?? {} });
    const fetched = await processor.fetchFromAPI(request, {
      origin: "mainSearch"
    });
    return await processor.process(fetched);
  }
);
var fetchPage2 = (0, import_toolkit32.createAsyncThunk)("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  addEntryInActionsHistory2(state);
  if (state.configuration.analytics.analyticsMode === "legacy" || !searchAction.next) {
    return legacyFetchPage(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction: searchAction.next
  });
  const request = await buildSearchRequest(
    state,
    config.extra.navigatorContext,
    searchAction.next
  );
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchMoreResults2 = (0, import_toolkit32.createAsyncThunk)("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchMoreResults(config, state);
  }
  const analyticsAction = makeBasicNewSearchAnalyticsAction(
    "browseResults" /* browseResults */,
    config.getState
  );
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction
  });
  const request = await buildFetchMoreRequest2(
    state,
    config.extra.navigatorContext,
    analyticsAction
  );
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchFacetValues2 = (0, import_toolkit32.createAsyncThunk)(
  "search/fetchFacetValues",
  async (searchAction, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyExecuteSearch(state, config, searchAction.legacy);
    }
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: {} });
    const request = await buildFetchFacetValuesRequest2(
      state,
      config.extra.navigatorContext
    );
    const fetched = await processor.fetchFromAPI(request, {
      origin: "facetValues"
    });
    return await processor.process(fetched);
  }
);
var fetchInstantResults2 = (0, import_toolkit32.createAsyncThunk)(
  "search/fetchInstantResults",
  async (payload, config) => {
    const state = config.getState();
    if (state.configuration.analytics.analyticsMode === "legacy") {
      return legacyFetchInstantResults(payload, config);
    }
    validatePayload(payload, {
      id: requiredNonEmptyString,
      q: requiredNonEmptyString,
      maxResultsPerQuery: new import_bueno28.NumberValue({
        required: true,
        min: 1
      }),
      cacheTimeout: new import_bueno28.NumberValue()
    });
    const { q, maxResultsPerQuery } = payload;
    const analyticsAction = buildSearchReduxAction(searchboxAsYouType());
    const request = await buildInstantResultSearchRequest2(
      state,
      config.extra.navigatorContext,
      q,
      maxResultsPerQuery,
      analyticsAction
    );
    const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction }, (modification) => {
      config.dispatch(
        updateInstantResultsQuery({ q: modification, id: payload.id })
      );
    });
    const fetched = await processor.fetchFromAPI(request, {
      origin: "instantResults",
      disableAbortWarning: true
    });
    const processed = await processor.process(fetched);
    if ("response" in processed) {
      return {
        results: processed.response.results,
        searchUid: processed.response.searchUid,
        totalCountFiltered: processed.response.totalCountFiltered,
        duration: processed.duration
      };
    }
    return processed;
  }
);
var buildFetchMoreRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest(
    state,
    navigatorContext,
    eventDescription
  );
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest2 = async (state, navigatorContext, q, numberOfResults, eventDescription) => {
  const sharedWithFoldingRequest = buildSearchAndFoldingLoadCollectionRequest2(
    state,
    navigatorContext,
    eventDescription
  );
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest(
    state,
    navigatorContext,
    eventDescription
  );
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory2 = (state) => {
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
var buildSearchReduxAction = (action) => ({
  actionCause: action.actionCause,
  type: action.actionCause
});

// src/app/listener-middleware/generate-answer-listener-middleware.ts
var generateAnswerListener = (0, import_toolkit33.createListenerMiddleware)();
generateAnswerListener.startListening({
  actionCreator: executeSearch2.pending,
  effect: async (_action, listenerApi) => {
    const state = listenerApi.getState();
    const q = selectQuery(state)?.q;
    const queryIsEmpty = !q || q.trim() === "";
    if (!isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
      return;
    }
    listenerApi.dispatch(resetAnswer());
    listenerApi.dispatch(resetFollowUpAnswers());
    if (queryIsEmpty) {
      return;
    }
    listenerApi.dispatch(generateHeadAnswer());
  }
});

// src/app/logger-middlewares.ts
var logActionErrorMiddleware = (logger) => () => (next) => (action) => {
  const unknownAction = action;
  if (!unknownAction.error) {
    return next(action);
  }
  const error = unknownAction.error;
  if (!unknownAction.payload?.ignored) {
    logger.error(
      { error, action },
      `Action dispatch error ${unknownAction.type}`
    );
  }
  if (unknownAction.error.name === "SchemaValidationError") {
    return;
  }
  return next(action);
};
var logActionMiddleware = (logger) => (api) => (next) => (action) => {
  logger.debug(
    {
      action,
      nextState: api.getState()
    },
    `Action dispatched: ${action.type}`
  );
  return next(action);
};

// src/app/navigator-context-provider.ts
var getNavigatorContext = (relay, customProvider) => {
  const { referrer, userAgent, location, clientId } = relay.getMeta("");
  const customContext = customProvider ? customProvider() : {};
  return { ...customContext, referrer, userAgent, location, clientId };
};

// src/app/reducer-manager.ts
var import_toolkit34 = require("@reduxjs/toolkit");
function createReducerManager(initialReducers, preloadedState) {
  const reducers = { ...initialReducers };
  let crossReducer;
  const rootReducer = (combined) => {
    return (state, action) => {
      const intermediate = combined(state, action);
      const final = crossReducer ? crossReducer(intermediate, action) : intermediate;
      return final;
    };
  };
  return {
    get combinedReducer() {
      const placeholderReducers = fromEntries(
        Object.entries(preloadedState).filter(([key]) => !(key in reducers)).map(([key, value]) => [key, () => value])
      );
      return rootReducer(
        (0, import_toolkit34.combineReducers)({ ...placeholderReducers, ...reducers })
      );
    },
    containsAll(newReducers) {
      const keys = Object.keys(newReducers);
      return keys.every((key) => key in reducers);
    },
    add(newReducers) {
      Object.keys(newReducers).filter((key) => !(key in reducers)).forEach((key) => {
        reducers[key] = newReducers[key];
      });
    },
    addCrossReducer(reducer) {
      crossReducer = reducer;
    }
  };
}

// src/features/error/error-actions.ts
var import_toolkit35 = require("@reduxjs/toolkit");
var setError = (0, import_toolkit35.createAction)("app/setError");

// src/utils/jwt-utils.ts
function parseJWT(token) {
  if (!token || !isJWTToken(token)) {
    return null;
  }
  try {
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const base64decoded = atob(base64);
    const jsonPayload = decodeURIComponent(
      base64decoded.split("").map((character) => {
        return `%${`00${character.charCodeAt(0).toString(16)}`.slice(-2)}`;
      }).join("")
    );
    return JSON.parse(jsonPayload);
  } catch (_) {
    return null;
  }
}
function shouldRenewJWT(token, bufferSeconds = 60) {
  if (!token) {
    return false;
  }
  const parsedToken = parseJWT(token);
  if (!parsedToken || typeof parsedToken.exp !== "number") {
    return false;
  }
  const nowSeconds = Math.floor(Date.now() / 1e3);
  return parsedToken.exp <= nowSeconds + bufferSeconds;
}
function isJWTToken(token) {
  if (!token) {
    return false;
  }
  return /^[A-Za-z0-9_-]{2,}(?:\.[A-Za-z0-9_-]{2,}){2}$/.test(token);
}

// src/app/renew-access-token-middleware.ts
function createRenewAccessTokenMiddleware(logger, renewToken) {
  let accessTokenRenewalsAttempts = 0;
  let pendingTokenRenewal = null;
  const resetRenewalTriesAfterDelay = debounce(() => {
    accessTokenRenewalsAttempts = 0;
  }, 500);
  const handleTokenRenewal = async (store, handleErrors = false) => {
    const isTokenRenewalPending = !pendingTokenRenewal;
    if (isTokenRenewalPending && renewToken) {
      pendingTokenRenewal = (async () => {
        if (handleErrors) {
          attempt(renewToken);
        }
        return await renewToken();
      })().finally(() => {
        pendingTokenRenewal = null;
      });
    }
    const accessToken = await pendingTokenRenewal;
    if (isTokenRenewalPending && accessToken) {
      store.dispatch(updateBasicConfiguration({ accessToken }));
    }
    return accessToken;
  };
  const handleProactiveTokenRenewal = async (store) => {
    const state = store.getState();
    const accessToken = getAccessTokenFromState(state);
    if (!accessToken || !shouldRenewJWT(accessToken)) {
      return;
    }
    logger.debug(
      "Access token is expired or about to expire, attempting renewal."
    );
    try {
      const newAccessToken = await handleTokenRenewal(store);
      if (newAccessToken) {
        logger.debug("Access token was renewed.");
      } else {
        logger.warn(
          "Access token renewal returned an empty token. Please check the #renewAccessToken function."
        );
      }
    } catch (error) {
      logger.warn(
        error,
        "Access token renewal failed. A retry will occur if necessary."
      );
    }
  };
  const handleExpiredToken = async (store, payload, action) => {
    if (accessTokenRenewalsAttempts >= 5) {
      logger.warn(
        "Attempted to renew the token but was not successful. Please check the #renewAccessToken function."
      );
      dispatchError(store, payload.error);
      return payload;
    }
    accessTokenRenewalsAttempts++;
    resetRenewalTriesAfterDelay();
    await handleTokenRenewal(store, true);
    store.dispatch(action);
    return;
  };
  return (store) => (next) => async (action) => {
    const isThunk = typeof action === "function";
    const hasRenewFunction = typeof renewToken === "function";
    if (!isThunk) {
      return next(action);
    }
    if (hasRenewFunction) {
      await handleProactiveTokenRenewal(store);
    }
    const payload = await next(action);
    if (!isExpiredTokenError(payload)) {
      return payload;
    }
    if (!hasRenewFunction) {
      logger.warn(
        "Unable to renew the expired token because a renew function was not provided. Please specify the #renewAccessToken option when initializing the engine."
      );
      dispatchError(store, payload.error);
      return payload;
    }
    return await handleExpiredToken(store, payload, action);
  };
}
function isExpiredTokenError(action) {
  return typeof action === "object" && action !== null && "error" in action && // biome-ignore lint/suspicious/noExplicitAny: any action is possible here.
  action.error?.name === new UnauthorizedTokenError().name;
}
function dispatchError(store, error) {
  store.dispatch(
    setError({
      status: 401,
      statusCode: 401,
      message: error.message,
      type: error.name
    })
  );
}
async function attempt(fn) {
  try {
    return await fn();
  } catch (_) {
    return "";
  }
}
function getAccessTokenFromState(state) {
  return state.configuration.accessToken;
}

// src/app/store.ts
var import_toolkit36 = require("@reduxjs/toolkit");
function configureStore({
  reducer,
  preloadedState,
  middlewares = [],
  thunkExtraArguments,
  name
}) {
  return (0, import_toolkit36.configureStore)({
    reducer,
    preloadedState,
    devTools: {
      stateSanitizer: (state) => state.history ? { ...state, history: "<<OMIT>>" } : state,
      name,
      shouldHotReload: false
      // KIT-961 -> Redux dev tool + hot reloading interacts badly with replaceReducers mechanism.
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ thunk: { extraArgument: thunkExtraArguments } }).prepend(...middlewares).concat(logActionMiddleware(thunkExtraArguments.logger))
  });
}

// src/app/engine.ts
function getUpdateAnalyticsConfigurationPayload(configuration2, logger) {
  const { analytics } = configuration2;
  const { analyticsClientMiddleware: _, ...payload } = analytics ?? {};
  const payloadWithURL = {
    ...payload,
    ...analytics?.proxyBaseUrl && {
      apiBaseUrl: analytics.proxyBaseUrl,
      nexApiBaseUrl: analytics.proxyBaseUrl
    }
  };
  if (payloadWithURL.analyticsMode !== "next" && doNotTrack()) {
    logger.info("Analytics disabled since doNotTrack is active.");
    return {
      ...payloadWithURL,
      enabled: false
    };
  }
  return payloadWithURL;
}
function buildEngine(options, thunkExtraArguments) {
  const reducers = {
    ...options.reducers,
    configuration,
    version: versionReducer
  };
  const engine = buildCoreEngine(
    { ...options, reducers },
    thunkExtraArguments,
    configuration
  );
  const { accessToken, environment, organizationId } = options.configuration;
  engine.dispatch(
    updateBasicConfiguration({
      accessToken,
      environment,
      organizationId
    })
  );
  const analyticsPayload = getUpdateAnalyticsConfigurationPayload(
    options.configuration,
    engine.logger
  );
  if (analyticsPayload) {
    engine.dispatch(updateAnalyticsConfiguration(analyticsPayload));
  }
  return engine;
}
function buildCoreEngine(options, thunkExtraArguments, configurationReducer2) {
  const { reducers, navigatorContextProvider } = options;
  const reducerManager = createReducerManager(
    { ...reducers, configurationReducer: configurationReducer2 },
    options.preloadedState ?? {}
  );
  if (options.crossReducer) {
    reducerManager.addCrossReducer(options.crossReducer);
  }
  const logger = thunkExtraArguments.logger;
  const thunkExtraArgumentsWithRelay = {
    ...thunkExtraArguments,
    get relay() {
      return getRelayInstanceFromState(engine.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    }
  };
  const store = createStore(
    options,
    thunkExtraArgumentsWithRelay,
    reducerManager
  );
  const engine = {
    addReducers(reducers2) {
      if (reducerManager.containsAll(reducers2)) {
        return;
      }
      reducerManager.add(reducers2);
      store.replaceReducer(reducerManager.combinedReducer);
    },
    dispatch: store.dispatch,
    subscribe: store.subscribe,
    enableAnalytics() {
      store.dispatch(enableAnalytics());
    },
    disableAnalytics() {
      store.dispatch(disableAnalytics());
    },
    get state() {
      return store.getState();
    },
    get relay() {
      return getRelayInstanceFromState(this.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    },
    logger,
    store
  };
  return engine;
}
function createStore(options, thunkExtraArguments, reducerManager) {
  const { preloadedState, configuration: configuration2 } = options;
  const name = configuration2.name || "coveo-headless";
  const middlewares = createMiddleware(options, thunkExtraArguments.logger);
  return configureStore({
    preloadedState,
    reducer: reducerManager.combinedReducer,
    middlewares,
    thunkExtraArguments,
    name
  });
}
function createMiddleware(options, logger) {
  const { renewAccessToken } = options.configuration;
  const renewTokenMiddleware = createRenewAccessTokenMiddleware(
    logger,
    renewAccessToken
  );
  return [
    instantlyCallableThunkActionMiddleware,
    renewTokenMiddleware,
    logActionErrorMiddleware(logger),
    analyticsMiddleware
  ].concat(
    answerApi.middleware,
    answerGenerationApi.middleware,
    generateAnswerListener.middleware,
    options.middlewares || []
  );
}
var nextAnalyticsUsageWithServiceFeatureWarning = '[Warning] A component from the Coveo Headless library has been instantiated with the Analytics Mode: "Next".\nHowever, this mode is not available for Coveo for Service features, and this configuration may not work as expected.\nPlease switch back to the "legacy" analytics mode to ensure proper functionality.\nFor more information, refer to the documentation: https://docs.coveo.com/en/o3r90189/build-a-search-ui/event-protocol';
function warnIfUsingNextAnalyticsModeForServiceFeature(analyticsMode) {
  if (analyticsMode === "next") {
    console.warn(nextAnalyticsUsageWithServiceFeatureWarning);
  }
}

// src/app/logger.ts
var import_pino = require("pino");
function buildLogger(options) {
  return (0, import_pino.pino)({
    name: "@coveo/headless",
    level: options?.level || "warn",
    formatters: {
      log: options?.logFormatter
    }
  });
}

// src/app/thunk-extra-arguments.ts
function buildThunkExtraArguments(configuration2, logger) {
  const analyticsClientMiddleware = getAnalyticsClientMiddleware(configuration2);
  const validatePayload2 = validatePayloadAndThrow;
  const preprocessRequest = getPreprocessRequest(configuration2);
  return {
    analyticsClientMiddleware,
    validatePayload: validatePayload2,
    preprocessRequest,
    logger
  };
}
function getAnalyticsClientMiddleware(configuration2) {
  const { analytics } = configuration2;
  const NoopAnalyticsMiddleware = (_, p) => p;
  return analytics?.analyticsClientMiddleware || NoopAnalyticsMiddleware;
}
function getPreprocessRequest(configuration2) {
  return configuration2.preprocessRequest || NoopPreprocessRequest;
}

// src/app/case-assist-engine/case-assist-engine-configuration.ts
var import_bueno30 = require("@coveo/bueno");

// src/app/engine-configuration.ts
var import_bueno29 = require("@coveo/bueno");
var engineConfigurationDefinitions = {
  organizationId: requiredNonEmptyString,
  accessToken: requiredNonEmptyString,
  name: new import_bueno29.StringValue({
    required: false,
    emptyAllowed: false
  }),
  analytics: new import_bueno29.RecordValue({
    options: {
      required: false
    },
    values: {
      enabled: new import_bueno29.BooleanValue({
        required: false
      }),
      originContext: new import_bueno29.StringValue({
        required: false
      }),
      originLevel2: new import_bueno29.StringValue({
        required: false
      }),
      originLevel3: new import_bueno29.StringValue({
        required: false
      }),
      analyticsMode: new import_bueno29.StringValue({
        constrainTo: ["legacy", "next"],
        required: false,
        default: "next"
      }),
      proxyBaseUrl: new import_bueno29.StringValue({
        required: false,
        url: true
      }),
      trackingId: new import_bueno29.StringValue({
        required: false,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  environment: new import_bueno29.StringValue({
    required: false,
    default: "prod",
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  })
};

// src/app/case-assist-engine/case-assist-engine-configuration.ts
var caseAssistEngineConfigurationSchema = new import_bueno30.Schema({
  ...engineConfigurationDefinitions,
  caseAssistId: requiredNonEmptyString,
  locale: nonEmptyString
});

// src/app/case-assist-engine/case-assist-engine.ts
var caseassistEngineReducers = {
  debug: debugReducer,
  caseAssistConfiguration: caseAssistConfigurationReducer,
  searchHub: searchHubReducer
};
function buildCaseAssistEngine(options) {
  const logger = buildLogger(options.loggerOptions);
  validateConfiguration(options.configuration, logger);
  const caseAssistAPIClient = createCaseAssistAPIClient(
    options.configuration,
    logger
  );
  const thunkArguments = {
    ...buildThunkExtraArguments(options.configuration, logger),
    apiClient: caseAssistAPIClient
  };
  const augmentedOptions = {
    ...options,
    reducers: caseassistEngineReducers
  };
  const engine = buildEngine(augmentedOptions, thunkArguments);
  warnIfUsingNextAnalyticsModeForServiceFeature(
    engine.state.configuration.analytics.analyticsMode
  );
  const { caseAssistId, locale, searchHub, proxyBaseUrl } = options.configuration;
  engine.dispatch(
    setCaseAssistConfiguration({
      caseAssistId,
      locale,
      proxyBaseUrl
    })
  );
  if (!(0, import_bueno31.isNullOrUndefined)(searchHub)) {
    engine.dispatch(setSearchHub(searchHub));
  }
  return {
    ...engine,
    get state() {
      return engine.state;
    }
  };
}
function validateConfiguration(configuration2, logger) {
  try {
    caseAssistEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error(error, "Case Assist engine configuration error");
    throw error;
  }
}
function createCaseAssistAPIClient(configuration2, logger) {
  return new CaseAssistAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest
  });
}

// src/controllers/case-field/headless-case-field.ts
var import_bueno32 = require("@coveo/bueno");

// src/features/case-assist/case-assist-analytics-selectors.ts
var KnownCaseFields = /* @__PURE__ */ ((KnownCaseFields2) => {
  KnownCaseFields2["id"] = "id";
  KnownCaseFields2["subject"] = "subject";
  KnownCaseFields2["description"] = "description";
  KnownCaseFields2["category"] = "category";
  KnownCaseFields2["productId"] = "productId";
  return KnownCaseFields2;
})(KnownCaseFields || {});
var isCustomFieldName = (fieldName) => !Object.values(KnownCaseFields).includes(fieldName);
var caseAssistCaseSelector = (state) => {
  const selectFieldValue = (fieldName) => caseAssistCaseInputValueSelector(state, fieldName) ?? caseAssistCaseFieldValueSelector(state, fieldName);
  return {
    id: selectFieldValue("id" /* id */),
    subject: selectFieldValue("subject" /* subject */),
    description: selectFieldValue("description" /* description */),
    category: selectFieldValue("category" /* category */),
    productId: selectFieldValue("productId" /* productId */),
    custom: {
      ...caseAssistCustomCaseInputValuesSelector(state),
      ...caseAssistCustomCaseFieldValuesSelector(state)
    }
  };
};
var caseAssistCaseInputValueSelector = (state, fieldName) => state?.caseInput?.[fieldName]?.value;
var caseAssistCustomCaseInputValuesSelector = (state) => Object.keys(state?.caseInput ?? []).reduce((customFields, fieldName) => {
  if (isCustomFieldName(fieldName)) {
    const value = state?.caseInput?.[fieldName]?.value;
    if (value) {
      return { ...customFields, [fieldName]: value };
    }
  }
  return customFields;
}, {});
var caseAssistCaseFieldValueSelector = (state, fieldName) => state?.caseField?.fields[fieldName]?.value;
var caseAssistCustomCaseFieldValuesSelector = (state) => Object.keys(state?.caseField?.fields ?? []).reduce(
  (customFields, fieldName) => {
    if (isCustomFieldName(fieldName)) {
      const value = state?.caseField?.fields?.[fieldName]?.value;
      if (value) {
        return { ...customFields, [fieldName]: value };
      }
    }
    return customFields;
  },
  {}
);
var caseAssistCaseClassificationSelector = (state, classificationId, autoSelection = false) => {
  const classificationFieldName = Object.keys(
    state?.caseField?.fields ?? {}
  ).find(
    (fieldName) => state?.caseField?.fields[fieldName].suggestions.some(
      (suggestion) => suggestion.id === classificationId
    )
  );
  if (!classificationFieldName) {
    throw new Error(
      `Classification with ID '${classificationId}' could not be found.`
    );
  }
  const classificationField = state?.caseField?.fields[classificationFieldName];
  const classification = classificationField?.suggestions.find(
    (suggestion) => suggestion.id === classificationId
  );
  const result = {
    classificationId: classification?.id ?? "",
    responseId: state.caseField?.status.lastResponseId ?? "",
    fieldName: classificationFieldName,
    classification: {
      value: classification?.value ?? "",
      confidence: classification?.confidence ?? 0
    }
  };
  if (autoSelection) {
    return { ...result, autoSelection };
  }
  return result;
};
var caseAssistDocumentSuggestionSelector = (state, suggestionId, fromQuickview = false, openDocument = false) => {
  let suggestionIdx;
  const suggestion = state.documentSuggestion?.documents.find((s, idx) => {
    const isFound = s.uniqueId === suggestionId;
    if (isFound) {
      suggestionIdx = idx + 1;
    }
    return isFound;
  });
  if (!suggestion) {
    throw new Error(
      `Document Suggestion with ID '${suggestionId}' could not be found.`
    );
  }
  const result = {
    suggestionId: suggestion.uniqueId,
    permanentId: suggestion.fields.permanentid,
    responseId: state.documentSuggestion?.status.lastResponseId ?? "",
    suggestion: {
      documentUri: suggestion.fields.uri,
      documentUriHash: suggestion.fields.urihash,
      documentTitle: suggestion.title,
      documentUrl: suggestion.clickUri,
      documentPosition: suggestionIdx ?? 0,
      sourceName: suggestion.fields.source
    }
  };
  if (fromQuickview) {
    return { ...result, fromQuickview };
  }
  if (openDocument) {
    return { ...result, openDocument };
  }
  return result;
};

// src/features/case-assist/case-assist-analytics-actions.ts
var logCaseStart = () => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/case/start",
  __legacy__getBuilder: (client, state) => {
    return client.logEnterInterface({
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.Start",
  analyticsPayloadBuilder: () => ({})
});
var logCaseNextStage = (options) => makeCaseAssistAnalyticsAction(
  "analytics/caseAssist/case/nextStage",
  (client, state) => client.logMoveToNextCaseStep({
    ticket: caseAssistCaseSelector(state),
    stage: options?.stageName
  })
);
var logCreateCase = () => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/case/create",
  __legacy__getBuilder: (client, state) => {
    return client.logCaseCreated({
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.CreateTicket",
  analyticsPayloadBuilder: (state) => {
    const { id, category, subject, description, productId } = caseAssistCaseSelector(state);
    return {
      ticket: {
        id,
        category,
        subject,
        description,
        system: productId
      }
    };
  }
});
var logSolveCase = () => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/case/solve",
  __legacy__getBuilder: (client, state) => {
    return client.logCaseSolved({
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.Cancel",
  analyticsPayloadBuilder: () => ({
    reason: "solved"
  })
});
var logAbandonCase = () => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/case/abandon",
  __legacy__getBuilder: (client, state) => {
    return client.logCaseCancelled({
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.Cancel",
  analyticsPayloadBuilder: () => ({
    reason: "quit"
  })
});
var logUpdateCaseField = (fieldName) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/case/field/update",
  __legacy__getBuilder: (client, state) => {
    return client.logUpdateCaseField({
      fieldName,
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.UpdateField",
  analyticsPayloadBuilder: (state) => {
    const fieldValue = state.caseField?.fields?.[fieldName]?.value || state.caseInput?.[fieldName]?.value || "";
    return {
      fieldName,
      fieldValue
    };
  }
});
var logAutoSelectCaseField = (classificationId) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/classification/click",
  __legacy__getBuilder: (client, state) => {
    return client.logSelectFieldSuggestion({
      suggestion: caseAssistCaseClassificationSelector(
        state,
        classificationId,
        true
      ),
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.SelectFieldClassification",
  analyticsPayloadBuilder: (state) => {
    const responseId = state.caseField?.status?.lastResponseId;
    if (responseId) {
      return {
        autoselected: true,
        classificationId,
        responseId
      };
    }
  }
});
var logClassificationClick = (classificationId) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/classification/click",
  __legacy__getBuilder: (client, state) => {
    return client.logSelectFieldSuggestion({
      suggestion: caseAssistCaseClassificationSelector(
        state,
        classificationId
      ),
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.SelectFieldClassification",
  analyticsPayloadBuilder: (state) => {
    const responseId = state.caseField?.status?.lastResponseId;
    if (responseId) {
      return {
        autoselected: false,
        classificationId,
        responseId
      };
    }
  }
});
var logDocumentSuggestionClick = (suggestionId) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/documentSuggestion/click",
  __legacy__getBuilder: (client, state) => {
    return client.logSelectDocumentSuggestion({
      suggestion: caseAssistDocumentSuggestionSelector(state, suggestionId),
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.DocumentSuggestionClick",
  analyticsPayloadBuilder: (state) => {
    const responseId = state.documentSuggestion?.status?.lastResponseId;
    const documentSuggestion = caseAssistDocumentSuggestionSelector(
      state,
      suggestionId
    );
    if (responseId) {
      return {
        responseId,
        position: documentSuggestion.suggestion.documentPosition,
        itemMetadata: {
          uniqueFieldName: "uniqueId",
          uniqueFieldValue: documentSuggestion.suggestionId,
          url: documentSuggestion.suggestion.documentUri,
          title: documentSuggestion.suggestion.documentTitle
        }
      };
    }
  }
});
var logQuickviewDocumentSuggestionClick = (suggestionId) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/documentSuggestion/click",
  __legacy__getBuilder: (client, state) => {
    return client.logQuickviewDocumentSuggestion({
      suggestion: caseAssistDocumentSuggestionSelector(state, suggestionId),
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.DocumentSuggestionClick",
  analyticsPayloadBuilder: (state) => {
    const responseId = state.documentSuggestion?.status?.lastResponseId;
    const documentSuggestion = caseAssistDocumentSuggestionSelector(
      state,
      suggestionId
    );
    if (responseId) {
      return {
        responseId,
        position: documentSuggestion.suggestion.documentPosition,
        itemMetadata: {
          uniqueFieldName: "uniqueId",
          uniqueFieldValue: documentSuggestion.suggestionId,
          url: documentSuggestion.suggestion.documentUri,
          title: documentSuggestion.suggestion.documentTitle
        }
      };
    }
  }
});
var logDocumentSuggestionOpen = (suggestionId) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/documentSuggestion/click",
  __legacy__getBuilder: (client, state) => {
    return client.logSelectDocumentSuggestion({
      suggestion: caseAssistDocumentSuggestionSelector(
        state,
        suggestionId,
        false,
        true
      ),
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.DocumentSuggestionClick",
  analyticsPayloadBuilder: (state) => {
    const responseId = state.documentSuggestion?.status?.lastResponseId;
    const documentSuggestion = caseAssistDocumentSuggestionSelector(
      state,
      suggestionId
    );
    if (responseId) {
      return {
        responseId,
        position: documentSuggestion.suggestion.documentPosition,
        itemMetadata: {
          uniqueFieldName: "uniqueId",
          uniqueFieldValue: documentSuggestion.suggestionId,
          url: documentSuggestion.suggestion.documentUri,
          title: documentSuggestion.suggestion.documentTitle
        }
      };
    }
  }
});
var logDocumentSuggestionRating = (suggestionId, rating) => makeCaseAssistAnalyticsAction({
  prefix: "analytics/caseAssist/documentSuggestion/rate",
  __legacy__getBuilder: (client, state) => {
    return client.logRateDocumentSuggestion({
      rating,
      suggestion: caseAssistDocumentSuggestionSelector(state, suggestionId),
      ticket: caseAssistCaseSelector(state)
    });
  },
  analyticsType: "CaseAssist.DocumentSuggestionFeedback",
  analyticsPayloadBuilder: (state) => {
    const responseId = state.documentSuggestion?.status?.lastResponseId;
    const documentSuggestion = caseAssistDocumentSuggestionSelector(
      state,
      suggestionId
    );
    if (responseId) {
      return {
        responseId,
        itemMetadata: {
          uniqueFieldName: "uniqueId",
          uniqueFieldValue: documentSuggestion.suggestionId,
          url: documentSuggestion.suggestion.documentUri,
          title: documentSuggestion.suggestion.documentTitle
        },
        liked: !!rating
      };
    }
  }
});

// src/features/case-field/case-field-actions.ts
var import_toolkit37 = require("@reduxjs/toolkit");
var registerCaseField = (0, import_toolkit37.createAction)(
  "caseAssist/caseField/register",
  (payload) => validatePayload(payload, {
    fieldName: requiredNonEmptyString,
    fieldValue: requiredEmptyAllowedString
  })
);
var updateCaseField = (0, import_toolkit37.createAction)(
  "caseAssist/caseField/update",
  (payload) => validatePayload(payload, {
    fieldName: requiredNonEmptyString,
    fieldValue: requiredEmptyAllowedString
  })
);
var fetchCaseClassifications = (0, import_toolkit37.createAsyncThunk)(
  "caseAssist/classifications/fetch",
  async (_, { getState, rejectWithValue, extra: { apiClient } }) => {
    const state = getState();
    const fetched = await apiClient.getCaseClassifications(
      await buildFetchClassificationRequest(state)
    );
    if (isErrorResponse(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var buildFetchClassificationRequest = async (state) => ({
  accessToken: state.configuration.accessToken,
  organizationId: state.configuration.organizationId,
  url: state.caseAssistConfiguration.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment
  ),
  caseAssistId: state.caseAssistConfiguration.caseAssistId,
  ...state.configuration.analytics.enabled && {
    clientId: await getVisitorID(state.configuration.analytics)
  },
  fields: state.caseInput,
  context: state.caseField ? prepareContextFromFields(state.caseField.fields) : void 0,
  locale: state.caseAssistConfiguration.locale,
  debug: state.debug
});

// src/features/case-field/case-field-slice.ts
var import_toolkit38 = require("@reduxjs/toolkit");

// src/features/case-field/case-field-state.ts
var getCaseFieldInitialState = () => ({
  status: {
    loading: false,
    error: null,
    lastResponseId: ""
  },
  fields: {}
});

// src/features/case-field/case-field-slice.ts
var caseFieldReducer = (0, import_toolkit38.createReducer)(
  getCaseFieldInitialState(),
  (builder) => {
    builder.addCase(registerCaseField, (state, action) => {
      const { fieldName, fieldValue } = action.payload;
      state.fields[fieldName] = {
        value: fieldValue,
        suggestions: []
      };
    }).addCase(updateCaseField, (state, action) => {
      const { fieldName, fieldValue } = action.payload;
      state.fields[fieldName].value = fieldValue;
    }).addCase(fetchCaseClassifications.rejected, (state, action) => {
      state.status.error = action.payload ?? null;
      state.status.loading = false;
    }).addCase(fetchCaseClassifications.fulfilled, (state, action) => {
      const defaultField = { value: "", suggestions: [] };
      Object.entries(action.payload.response.fields).forEach(
        ([fieldName, content]) => {
          if (!state.fields[fieldName]) {
            state.fields[fieldName] = { ...defaultField };
          }
          state.fields[fieldName].suggestions = content.predictions;
        }
      );
      state.status.lastResponseId = action.payload.response.responseId;
      state.status.error = null;
      state.status.loading = false;
    }).addCase(fetchCaseClassifications.pending, (state) => {
      state.status.loading = true;
    }).addCase(setError, (state, action) => {
      state.status.error = action.payload;
      state.status.loading = false;
    });
  }
);

// src/features/case-input/case-input-slice.ts
var import_toolkit40 = require("@reduxjs/toolkit");

// src/features/case-input/case-input-actions.ts
var import_toolkit39 = require("@reduxjs/toolkit");
var updateCaseInput = (0, import_toolkit39.createAction)(
  "caseAssist/caseInput/update",
  (payload) => validatePayload(payload, {
    fieldName: requiredNonEmptyString,
    fieldValue: requiredEmptyAllowedString
  })
);

// src/features/case-input/case-input-state.ts
var getCaseInputInitialState = () => ({});

// src/features/case-input/case-input-slice.ts
var caseInputReducer = (0, import_toolkit40.createReducer)(
  getCaseInputInitialState(),
  (builder) => {
    builder.addCase(updateCaseInput, (state, action) => {
      state[action.payload.fieldName] = {
        value: action.payload.fieldValue
      };
    });
  }
);

// src/features/document-suggestion/document-suggestion-actions.ts
var import_toolkit41 = require("@reduxjs/toolkit");
var fetchDocumentSuggestions = (0, import_toolkit41.createAsyncThunk)(
  "caseAssist/documentSuggestions/fetch",
  async (_, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
    const state = getState();
    const fetched = await apiClient.getDocumentSuggestions(
      await buildFetchDocumentSuggestionsRequest(state, navigatorContext)
    );
    if (isErrorResponse(fetched)) {
      return rejectWithValue(fetched.error);
    }
    return {
      response: fetched.success
    };
  }
);
var buildFetchDocumentSuggestionsRequest = async (state, navigatorContext) => ({
  accessToken: state.configuration.accessToken,
  organizationId: state.configuration.organizationId,
  url: state.caseAssistConfiguration.apiBaseUrl ?? getOrganizationEndpoint(
    state.configuration.organizationId,
    state.configuration.environment
  ),
  caseAssistId: state.caseAssistConfiguration.caseAssistId,
  ...state.configuration.analytics.enabled && {
    clientId: await getVisitorID(state.configuration.analytics)
  },
  ...state.configuration.analytics.enabled && fromAnalyticsStateToAnalyticsParams(
    state.configuration.analytics,
    navigatorContext,
    {
      actionCause: "documentSuggestion" /* documentSuggestion */
    }
  ),
  fields: state.caseInput,
  context: state.caseField ? prepareContextFromFields(state.caseField.fields) : void 0,
  locale: state.caseAssistConfiguration.locale,
  debug: state.debug
});

// src/features/document-suggestion/document-suggestion-slice.ts
var import_toolkit42 = require("@reduxjs/toolkit");

// src/features/document-suggestion/document-suggestion-state.ts
var getDocumentSuggestionInitialState = () => ({
  status: {
    loading: false,
    error: null,
    lastResponseId: ""
  },
  documents: []
});

// src/features/document-suggestion/document-suggestion-slice.ts
var documentSuggestionReducer = (0, import_toolkit42.createReducer)(
  getDocumentSuggestionInitialState(),
  (builder) => {
    builder.addCase(fetchDocumentSuggestions.rejected, (state, action) => {
      state.status.error = action.payload ?? null;
      state.status.loading = false;
    }).addCase(fetchDocumentSuggestions.fulfilled, (state, action) => {
      state.documents = action.payload.response.documents;
      state.status.lastResponseId = action.payload.response.responseId;
      state.status.error = null;
      state.status.loading = false;
    }).addCase(fetchDocumentSuggestions.pending, (state) => {
      state.status.loading = true;
    }).addCase(setError, (state, action) => {
      state.status.error = action.payload;
      state.status.loading = false;
    });
  }
);

// src/controllers/controller/headless-controller.ts
function buildController(engine) {
  let prevState;
  const listeners = /* @__PURE__ */ new Map();
  const hasNoListeners = () => listeners.size === 0;
  const hasStateChanged = (currentState) => {
    try {
      const stringifiedState = JSON.stringify(currentState);
      const hasChanged = prevState !== stringifiedState;
      prevState = stringifiedState;
      return hasChanged;
    } catch (e) {
      console.warn(
        'Could not detect if state has changed, check the controller "get state method"',
        e
      );
      return true;
    }
  };
  return {
    subscribe(listener) {
      listener();
      const symbol = Symbol();
      let unsubscribe;
      if (hasNoListeners()) {
        prevState = JSON.stringify(this.state);
        unsubscribe = engine.subscribe(() => {
          if (hasStateChanged(this.state)) {
            listeners.forEach((listener2) => listener2());
          }
        });
      }
      listeners.set(symbol, listener);
      return () => {
        listeners.delete(symbol);
        if (hasNoListeners()) {
          unsubscribe?.();
        }
      };
    },
    get state() {
      return {};
    }
  };
}

// src/controllers/case-field/headless-case-field.ts
var optionsSchema = new import_bueno32.Schema({
  field: requiredNonEmptyString
});
function buildCaseField(engine, props = {}) {
  if (!loadCaseFieldReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const options = validateOptions(
    engine,
    optionsSchema,
    props.options,
    "buildCaseField"
  );
  const getState = () => {
    return engine.state;
  };
  const isRegistered = getState().caseField?.fields?.[options.field];
  if (!isRegistered) {
    dispatch(
      registerCaseField({
        fieldName: options.field,
        fieldValue: ""
      })
    );
  }
  return {
    ...controller,
    get state() {
      const loading = getState().caseField?.status?.loading ?? false;
      const error = getState().caseField?.status?.error ?? null;
      const field = getState().caseField?.fields?.[options.field];
      const value = field?.value ?? "";
      const suggestions = field?.suggestions ?? [];
      return {
        loading,
        error,
        value,
        suggestions
      };
    },
    update(value, updatesToFetch, autoSelection) {
      const suggestionId = getState().caseField?.fields?.[options.field]?.suggestions?.find((s) => s.value === value)?.id;
      if (suggestionId) {
        autoSelection ? dispatch(logAutoSelectCaseField(suggestionId)) : dispatch(logClassificationClick(suggestionId));
      }
      dispatch(
        updateCaseField({
          fieldName: options.field,
          fieldValue: value
        })
      );
      !autoSelection && dispatch(logUpdateCaseField(options.field));
      updatesToFetch?.caseClassifications && dispatch(fetchCaseClassifications());
      updatesToFetch?.documentSuggestions && dispatch(fetchDocumentSuggestions());
    }
  };
}
function loadCaseFieldReducers(engine) {
  engine.addReducers({
    configuration,
    caseAssistConfiguration: caseAssistConfigurationReducer,
    caseInput: caseInputReducer,
    caseField: caseFieldReducer,
    documentSuggestion: documentSuggestionReducer
  });
  return true;
}

// src/controllers/case-input/headless-case-input.ts
var import_bueno33 = require("@coveo/bueno");
function validateCaseInputOptions(engine, options) {
  const schema = new import_bueno33.Schema({
    field: requiredNonEmptyString
  });
  validateOptions(engine, schema, options, "buildCaseInput");
}
function buildCaseInput(engine, props) {
  if (!loadCaseInputReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  validateCaseInputOptions(engine, props.options);
  const fieldName = props.options.field;
  const isRegistered = getState().caseInput?.[fieldName];
  if (!isRegistered) {
    dispatch(
      updateCaseInput({
        fieldName,
        fieldValue: ""
      })
    );
  }
  return {
    ...controller,
    update(value, updatesToFetch) {
      dispatch(
        updateCaseInput({
          fieldName,
          fieldValue: value
        })
      );
      dispatch(logUpdateCaseField(fieldName));
      updatesToFetch?.caseClassifications && dispatch(fetchCaseClassifications());
      updatesToFetch?.documentSuggestions && dispatch(fetchDocumentSuggestions());
    },
    get state() {
      return getState().caseInput[fieldName];
    }
  };
}
function loadCaseInputReducers(engine) {
  engine.addReducers({
    configuration,
    caseAssistConfiguration: caseAssistConfigurationReducer,
    caseInput: caseInputReducer,
    caseField: caseFieldReducer,
    documentSuggestion: documentSuggestionReducer
  });
  return true;
}

// src/controllers/core/interactive-result/headless-core-interactive-result.ts
function buildInteractiveResultCore(engine, props, action) {
  if (!loadInteractiveResultCoreReducers(engine)) {
    throw loadReducerError;
  }
  const defaultDelay = 1e3;
  const options = {
    selectionDelay: defaultDelay,
    debounceWait: defaultDelay,
    ...props.options
  };
  let longPressTimer;
  return {
    select: debounce(action, options.debounceWait, { isImmediate: true }),
    beginDelayedSelect() {
      longPressTimer = setTimeout(action, options.selectionDelay);
    },
    cancelPendingSelect() {
      longPressTimer && clearTimeout(longPressTimer);
    }
  };
}
function loadInteractiveResultCoreReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}

// src/controllers/document-suggestion-list/case-assist-headless-interactive-result.ts
function buildCaseAssistInteractiveResult(engine, props) {
  let wasOpened = false;
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(logDocumentSuggestionOpen(props.options.result.uniqueId));
  };
  return buildInteractiveResultCore(engine, props, logAnalyticsIfNeverOpened);
}

// src/controllers/document-suggestion-list/headless-document-suggestion-list.ts
function buildDocumentSuggestionList(engine) {
  if (!loadDocumentSuggestionListReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  return {
    ...controller,
    fetch() {
      dispatch(fetchDocumentSuggestions());
    },
    get state() {
      const state = getState().documentSuggestion;
      return {
        loading: state.status.loading,
        error: state.status.error,
        documents: state.documents
      };
    }
  };
}
function loadDocumentSuggestionListReducers(engine) {
  engine.addReducers({
    configuration,
    caseAssistConfiguration: caseAssistConfigurationReducer,
    caseInput: caseInputReducer,
    caseField: caseFieldReducer,
    documentSuggestion: documentSuggestionReducer
  });
  return true;
}

// src/features/result-preview/result-preview-actions.ts
var import_bueno34 = require("@coveo/bueno");
var import_toolkit43 = require("@reduxjs/toolkit");

// src/features/result-preview/result-preview-request-builder.ts
async function buildResultPreviewRequest(state, options) {
  const { search, accessToken, organizationId } = state.configuration;
  const q = state.query?.q || "";
  return {
    url: search.apiBaseUrl ?? getSearchApiBaseUrl(
      state.configuration.organizationId,
      state.configuration.environment
    ),
    accessToken,
    organizationId,
    enableNavigation: false,
    q,
    ...options,
    requestedOutputSize: options.requestedOutputSize || 0,
    ...search.authenticationProviders.length && {
      authentication: search.authenticationProviders.join(",")
    }
  };
}

// src/features/result-preview/result-preview-actions.ts
var fetchResultContent = (0, import_toolkit43.createAsyncThunk)(
  "resultPreview/fetchResultContent",
  async (options, { extra, getState, rejectWithValue }) => {
    const state = getState();
    const req = await buildResultPreviewRequest(state, options);
    const res = await extra.apiClient.html(req);
    if (isErrorResponse(res)) {
      return rejectWithValue(res.error);
    }
    return {
      content: res.success,
      uniqueId: options.uniqueId
    };
  }
);
var nextPreview = (0, import_toolkit43.createAction)("resultPreview/next");
var previousPreview = (0, import_toolkit43.createAction)("resultPreview/previous");
var preparePreviewPagination = (0, import_toolkit43.createAction)(
  "resultPreview/prepare",
  (payload) => validatePayload(payload, { results: new import_bueno34.ArrayValue({ required: true }) })
);
var MAX_GET_LENGTH = 2048;
var updateContentURL = (0, import_toolkit43.createAsyncThunk)(
  "resultPreview/updateContentURL",
  async (options, { getState, extra }) => {
    const state = getState();
    const contentURL = buildContentURL(
      await options.buildResultPreviewRequest(state, {
        uniqueId: options.uniqueId,
        requestedOutputSize: options.requestedOutputSize
      }),
      options.path
    );
    if (contentURL?.length > MAX_GET_LENGTH) {
      extra.logger.error(
        `The content URL was truncated as it exceeds the maximum allowed length of ${MAX_GET_LENGTH} characters.`
      );
    }
    return {
      contentURL
    };
  }
);

// src/features/result-preview/result-preview-slice.ts
var import_toolkit44 = require("@reduxjs/toolkit");

// src/features/result-preview/result-preview-state.ts
function getResultPreviewInitialState() {
  return {
    uniqueId: "",
    content: "",
    isLoading: false,
    position: -1,
    resultsWithPreview: []
  };
}

// src/features/result-preview/result-preview-slice.ts
var resetPreviewContentState = (state) => {
  const { content, isLoading, uniqueId, contentURL } = getResultPreviewInitialState();
  state.content = content;
  state.isLoading = isLoading;
  state.uniqueId = uniqueId;
  state.contentURL = contentURL;
};
var getUniqueIdsOfResultsWithHTMLVersion = (results) => results.filter((r) => r.hasHtmlVersion).map((r) => r.uniqueId);
var resultPreviewReducer = (0, import_toolkit44.createReducer)(
  getResultPreviewInitialState(),
  (builder) => {
    builder.addCase(fetchResultContent.pending, (state) => {
      state.isLoading = true;
    }).addCase(fetchResultContent.fulfilled, (state, action) => {
      const { content, uniqueId } = action.payload;
      state.position = state.resultsWithPreview.indexOf(uniqueId);
      state.content = content;
      state.uniqueId = uniqueId;
      state.isLoading = false;
    }).addCase(executeSearch2.fulfilled, (state, action) => {
      resetPreviewContentState(state);
      state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(
        action.payload.response.results
      );
    }).addCase(fetchMoreResults2.fulfilled, (state, action) => {
      resetPreviewContentState(state);
      state.resultsWithPreview = state.resultsWithPreview.concat(
        getUniqueIdsOfResultsWithHTMLVersion(action.payload.response.results)
      );
    }).addCase(fetchPage2.fulfilled, resetPreviewContentState).addCase(preparePreviewPagination, (state, action) => {
      state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(
        action.payload.results
      );
    }).addCase(nextPreview, (state) => {
      if (state.isLoading) {
        return;
      }
      let newPos = state.position + 1;
      if (newPos > state.resultsWithPreview.length - 1) {
        newPos = 0;
      }
      state.position = newPos;
    }).addCase(previousPreview, (state) => {
      if (state.isLoading) {
        return;
      }
      let newPos = state.position - 1;
      if (newPos < 0) {
        newPos = state.resultsWithPreview.length - 1;
      }
      state.position = newPos;
    }).addCase(updateContentURL.fulfilled, (state, action) => {
      state.contentURL = action.payload.contentURL;
    });
  }
);

// src/controllers/core/quickview/headless-core-quickview.ts
function buildCoreQuickview(engine, props, buildResultPreviewRequest2, path, fetchResultContentCallback) {
  if (!loadQuickviewReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const controller = buildController(engine);
  const { result, maximumPreviewSize } = props.options;
  const getUniqueIdFromPosition = () => {
    const { resultsWithPreview, position } = getState().resultPreview;
    return resultsWithPreview[position];
  };
  const onFetchContent = (uniqueId) => {
    dispatch(
      updateContentURL({
        uniqueId,
        requestedOutputSize: maximumPreviewSize,
        buildResultPreviewRequest: buildResultPreviewRequest2,
        path
      })
    );
    if (!props.options.onlyContentURL) {
      dispatch(
        fetchResultContent({
          uniqueId,
          requestedOutputSize: maximumPreviewSize
        })
      );
    }
    if (fetchResultContentCallback) {
      fetchResultContentCallback();
    }
  };
  return {
    ...controller,
    fetchResultContent() {
      onFetchContent(result.uniqueId);
    },
    next() {
      dispatch(nextPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    previous() {
      dispatch(previousPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    get state() {
      const state = getState();
      const resultHasPreview = result.hasHtmlVersion;
      const preview = state.resultPreview;
      const content = result.uniqueId === preview.uniqueId ? preview.content : "";
      const isLoading = preview.isLoading;
      const contentURL = preview.contentURL;
      const currentResultUniqueId = getUniqueIdFromPosition();
      return {
        content,
        resultHasPreview,
        isLoading,
        contentURL,
        currentResultUniqueId
      };
    }
  };
}
function loadQuickviewReducers(engine) {
  engine.addReducers({ configuration, resultPreview: resultPreviewReducer });
  return true;
}

// src/controllers/quickview/case-assist-headless-quickview.ts
function buildCaseAssistQuickview(engine, props) {
  if (!loadSearchQuickviewReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getDocuments = () => getState().documentSuggestion.documents;
  const fetchResultContentCallback = () => {
    engine.dispatch(
      logQuickviewDocumentSuggestionClick(props.options.result.uniqueId)
    );
  };
  const path = "/html";
  const core = buildCoreQuickview(
    engine,
    props,
    buildResultPreviewRequest,
    path,
    fetchResultContentCallback
  );
  dispatch(
    preparePreviewPagination({
      results: getDocuments()
    })
  );
  return {
    ...core,
    get state() {
      return {
        ...core.state,
        currentDocument: getDocuments().findIndex(
          (r) => r.uniqueId === core.state.currentResultUniqueId
        ) + 1,
        totalDocuments: getDocuments().length
      };
    }
  };
}
function loadSearchQuickviewReducers(engine) {
  engine.addReducers({ documentSuggestion: documentSuggestionReducer });
  return true;
}

// src/features/analytics/analytics-actions.ts
var validateEvent = (p) => validatePayload(p, {
  evt: requiredNonEmptyString,
  type: nonEmptyString
});
var logSearchEvent = (p) => makeAnalyticsAction("analytics/generic/search", (client) => {
  validateEvent(p);
  const { evt, meta } = p;
  return client.makeSearchEvent(evt, meta);
});
var logClickEvent = (p) => makeAnalyticsAction("analytics/generic/click", (client, state) => {
  validateResultPayload(p.result);
  validateEvent(p);
  return client.makeClickEvent(
    p.evt,
    partialDocumentInformation(p.result, state),
    documentIdentifier(p.result),
    p.meta
  );
});
var logCustomEvent = (p) => makeAnalyticsAction("analytics/generic/custom", (client) => {
  validateEvent(p);
  return client.makeCustomEventWithType(p.evt, p.type, p.meta);
});

// src/features/analytics/generic-analytics-actions-loader.ts
function loadGenericAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logSearchEvent,
    logClickEvent,
    logCustomEvent
  };
}

// src/features/case-assist/case-assist-analytics-actions-loader.ts
function loadCaseAssistAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logCaseStart,
    logCaseNextStage,
    logCreateCase,
    logSolveCase,
    logAbandonCase,
    logUpdateCaseField,
    logClassificationClick,
    logDocumentSuggestionClick,
    logDocumentSuggestionRating,
    logQuickviewDocumentSuggestionClick
  };
}

// src/features/case-field/case-field-actions-loader.ts
function loadCaseFieldActions(engine) {
  engine.addReducers({ caseField: caseFieldReducer });
  return {
    registerCaseField,
    updateCaseField,
    fetchCaseClassifications
  };
}

// src/features/case-input/case-input-actions-loader.ts
function loadCaseInputActions(engine) {
  engine.addReducers({ caseInput: caseInputReducer });
  return {
    updateCaseInput
  };
}

// src/features/document-suggestion/document-suggestion-actions-loader.ts
function loadDocumentSuggestionActions(engine) {
  engine.addReducers({ documentSuggestion: documentSuggestionReducer });
  return {
    fetchDocumentSuggestions
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ResultTemplatesHelpers,
  buildCaseAssistEngine,
  buildCaseField,
  buildCaseInput,
  buildController,
  buildDocumentSuggestion,
  buildDocumentSuggestionList,
  buildInteractiveResult,
  buildQuickview,
  getAnalyticsNextApiBaseUrl,
  getOrganizationEndpoint,
  loadCaseAssistAnalyticsActions,
  loadCaseFieldActions,
  loadCaseInputActions,
  loadDocumentSuggestionActions,
  loadGenericAnalyticsActions
});
