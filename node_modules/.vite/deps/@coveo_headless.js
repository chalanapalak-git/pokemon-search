import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/exponential-backoff/dist/options.js
var require_options = __commonJS({
  "node_modules/exponential-backoff/dist/options.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultOptions = {
      delayFirstAttempt: false,
      jitter: "none",
      maxDelay: Infinity,
      numOfAttempts: 10,
      retry: function() {
        return true;
      },
      startingDelay: 100,
      timeMultiple: 2
    };
    function getSanitizedOptions(options) {
      var sanitized = __assign(__assign({}, defaultOptions), options);
      if (sanitized.numOfAttempts < 1) {
        sanitized.numOfAttempts = 1;
      }
      return sanitized;
    }
    exports.getSanitizedOptions = getSanitizedOptions;
  }
});

// node_modules/exponential-backoff/dist/jitter/full/full.jitter.js
var require_full_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/full/full.jitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fullJitter(delay) {
      var jitteredDelay = Math.random() * delay;
      return Math.round(jitteredDelay);
    }
    exports.fullJitter = fullJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/no/no.jitter.js
var require_no_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/no/no.jitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noJitter(delay) {
      return delay;
    }
    exports.noJitter = noJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/jitter.factory.js
var require_jitter_factory = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/jitter.factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var full_jitter_1 = require_full_jitter();
    var no_jitter_1 = require_no_jitter();
    function JitterFactory(options) {
      switch (options.jitter) {
        case "full":
          return full_jitter_1.fullJitter;
        case "none":
        default:
          return no_jitter_1.noJitter;
      }
    }
    exports.JitterFactory = JitterFactory;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.base.js
var require_delay_base = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jitter_factory_1 = require_jitter_factory();
    var Delay = (
      /** @class */
      function() {
        function Delay2(options) {
          this.options = options;
          this.attempt = 0;
        }
        Delay2.prototype.apply = function() {
          var _this = this;
          return new Promise(function(resolve) {
            return setTimeout(resolve, _this.jitteredDelay);
          });
        };
        Delay2.prototype.setAttemptNumber = function(attempt2) {
          this.attempt = attempt2;
        };
        Object.defineProperty(Delay2.prototype, "jitteredDelay", {
          get: function() {
            var jitter = jitter_factory_1.JitterFactory(this.options);
            return jitter(this.delay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "delay", {
          get: function() {
            var constant = this.options.startingDelay;
            var base = this.options.timeMultiple;
            var power = this.numOfDelayedAttempts;
            var delay = constant * Math.pow(base, power);
            return Math.min(delay, this.options.maxDelay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt;
          },
          enumerable: true,
          configurable: true
        });
        return Delay2;
      }()
    );
    exports.Delay = Delay;
  }
});

// node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js
var require_skip_first_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var SkipFirstDelay = (
      /** @class */
      function(_super) {
        __extends(SkipFirstDelay2, _super);
        function SkipFirstDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        SkipFirstDelay2.prototype.apply = function() {
          return __awaiter2(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
            });
          });
        };
        Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
          get: function() {
            return this.attempt === 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt - 1;
          },
          enumerable: true,
          configurable: true
        });
        return SkipFirstDelay2;
      }(delay_base_1.Delay)
    );
    exports.SkipFirstDelay = SkipFirstDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/always/always.delay.js
var require_always_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/always/always.delay.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var AlwaysDelay = (
      /** @class */
      function(_super) {
        __extends(AlwaysDelay2, _super);
        function AlwaysDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return AlwaysDelay2;
      }(delay_base_1.Delay)
    );
    exports.AlwaysDelay = AlwaysDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.factory.js
var require_delay_factory = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var skip_first_delay_1 = require_skip_first_delay();
    var always_delay_1 = require_always_delay();
    function DelayFactory(options, attempt2) {
      var delay = initDelayClass(options);
      delay.setAttemptNumber(attempt2);
      return delay;
    }
    exports.DelayFactory = DelayFactory;
    function initDelayClass(options) {
      if (!options.delayFirstAttempt) {
        return new skip_first_delay_1.SkipFirstDelay(options);
      }
      return new always_delay_1.AlwaysDelay(options);
    }
  }
});

// node_modules/exponential-backoff/dist/backoff.js
var require_backoff = __commonJS({
  "node_modules/exponential-backoff/dist/backoff.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var options_1 = require_options();
    var delay_factory_1 = require_delay_factory();
    function backOff2(request, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var sanitizedOptions, backOff3;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              sanitizedOptions = options_1.getSanitizedOptions(options);
              backOff3 = new BackOff(request, sanitizedOptions);
              return [4, backOff3.execute()];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    exports.backOff = backOff2;
    var BackOff = (
      /** @class */
      function() {
        function BackOff2(request, options) {
          this.request = request;
          this.options = options;
          this.attemptNumber = 0;
        }
        BackOff2.prototype.execute = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var e_1, shouldRetry;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.attemptLimitReached)
                    return [3, 7];
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 6]);
                  return [4, this.applyDelay()];
                case 2:
                  _a.sent();
                  return [4, this.request()];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  e_1 = _a.sent();
                  this.attemptNumber++;
                  return [4, this.options.retry(e_1, this.attemptNumber)];
                case 5:
                  shouldRetry = _a.sent();
                  if (!shouldRetry || this.attemptLimitReached) {
                    throw e_1;
                  }
                  return [3, 6];
                case 6:
                  return [3, 0];
                case 7:
                  throw new Error("Something went wrong.");
              }
            });
          });
        };
        Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
          get: function() {
            return this.attemptNumber >= this.options.numOfAttempts;
          },
          enumerable: true,
          configurable: true
        });
        BackOff2.prototype.applyDelay = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var delay;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                  return [4, delay.apply()];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return BackOff2;
      }()
    );
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f3 = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f3 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f4 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f4) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f4 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f4 + "Date", n2[d] = f4 + "Date", n2[c] = f4 + "Month", n2[h] = f4 + "FullYear", n2[u] = f4 + "Hours", n2[s] = f4 + "Minutes", n2[i] = f4 + "Seconds", n2[r] = f4 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f4) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f4), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f4 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f4 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f3:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f3 = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3)
            return 0;
          if ("Z" === e3)
            return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e2.indexOf(r2(i2, 0, t2)) > -1) {
              n2 = i2 > 12;
              break;
            }
        } else
          n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f3("seconds")], ss: [i, f3("seconds")], m: [i, f3("minutes")], mm: [i, f3("minutes")], H: [i, f3("hours")], h: [i, f3("hours")], HH: [i, f3("hours")], hh: [i, f3("hours")], D: [i, f3("day")], DD: [r, f3("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2)
          for (var r2 = 1; r2 <= 31; r2 += 1)
            t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f3("week")], ww: [r, f3("week")], M: [i, f3("month")], MM: [r, f3("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1)
          throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1)
          throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f3("year")], YY: [r, function(e2) {
        this.year = a(e2);
      }], YYYY: [/\d{4}/, f3("year")], Z: h, ZZ: h };
      function l(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = o2.length, f4 = 0; f4 < a2; f4 += 1) {
          var h2 = o2[f4], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
          o2[f4] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3)
              r3 += i3.length;
            else {
              var s2 = i3.regex, f5 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f5.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f4 = true === o2[2], h2 = true === o2[3], u2 = f4 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f4 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1)
                  return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f5 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f5 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array)
            for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
              o2[1] = a2[m - 1];
              var M = n2.apply(this, o2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e3);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS({
  "node_modules/dayjs/plugin/timezone.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_timezone = e();
    }(exports, function() {
      "use strict";
      var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
      return function(n, i, o) {
        var r, a = function(t2, n2, i2) {
          void 0 === i2 && (i2 = {});
          var o2 = new Date(t2), r2 = function(t3, n3) {
            void 0 === n3 && (n3 = {});
            var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
            return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
          }(n2, i2);
          return r2.formatToParts(o2);
        }, u = function(e2, n2) {
          for (var i2 = a(e2, n2), r2 = [], u2 = 0; u2 < i2.length; u2 += 1) {
            var f4 = i2[u2], s2 = f4.type, m = f4.value, c = t[s2];
            c >= 0 && (r2[c] = parseInt(m, 10));
          }
          var d = r2[3], l = 24 === d ? 0 : d, h = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", v = +e2;
          return (o.utc(h).valueOf() - (v -= v % 1e3)) / 6e4;
        }, f3 = i.prototype;
        f3.tz = function(t2, e2) {
          void 0 === t2 && (t2 = r);
          var n2, i2 = this.utcOffset(), a2 = this.toDate(), u2 = a2.toLocaleString("en-US", { timeZone: t2 }), f4 = Math.round((a2 - new Date(u2)) / 1e3 / 60), s2 = 15 * -Math.round(a2.getTimezoneOffset() / 15) - f4;
          if (!Number(s2))
            n2 = this.utcOffset(0, e2);
          else if (n2 = o(u2, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(s2, true), e2) {
            var m = n2.utcOffset();
            n2 = n2.add(i2 - m, "minute");
          }
          return n2.$x.$timezone = t2, n2;
        }, f3.offsetName = function(t2) {
          var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, { timeZoneName: t2 }).find(function(t3) {
            return "timezonename" === t3.type.toLowerCase();
          });
          return n2 && n2.value;
        };
        var s = f3.startOf;
        f3.startOf = function(t2, e2) {
          if (!this.$x || !this.$x.$timezone)
            return s.call(this, t2, e2);
          var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
          return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
        }, o.tz = function(t2, e2, n2) {
          var i2 = n2 && e2, a2 = n2 || e2 || r, f4 = u(+o(), a2);
          if ("string" != typeof t2)
            return o(t2).tz(a2);
          var s2 = function(t3, e3, n3) {
            var i3 = t3 - 60 * e3 * 1e3, o2 = u(i3, n3);
            if (e3 === o2)
              return [i3, e3];
            var r2 = u(i3 -= 60 * (o2 - e3) * 1e3, n3);
            return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1e3, Math.max(o2, r2)];
          }(o.utc(t2, i2).valueOf(), f4, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
          return d.$x.$timezone = a2, d;
        }, o.tz.guess = function() {
          return Intl.DateTimeFormat().resolvedOptions().timeZone;
        }, o.tz.setDefault = function(t2) {
          r = t2;
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "node_modules/dayjs/plugin/utc.js"(exports, module) {
    !function(t, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_utc = i();
    }(exports, function() {
      "use strict";
      var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
      return function(s, f3, n) {
        var u = f3.prototype;
        n.utc = function(t2) {
          var i2 = { date: t2, utc: true, args: arguments };
          return new f3(i2);
        }, u.utc = function(i2) {
          var e2 = n(this.toDate(), { locale: this.$L, utc: true });
          return i2 ? e2.add(this.utcOffset(), t) : e2;
        }, u.local = function() {
          return n(this.toDate(), { locale: this.$L, utc: false });
        };
        var o = u.parse;
        u.parse = function(t2) {
          t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
        };
        var r = u.init;
        u.init = function() {
          if (this.$u) {
            var t2 = this.$d;
            this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
          } else
            r.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function(s2, f4) {
          var n2 = this.$utils().u;
          if (n2(s2))
            return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
          if ("string" == typeof s2 && (s2 = function(t2) {
            void 0 === t2 && (t2 = "");
            var s3 = t2.match(i);
            if (!s3)
              return null;
            var f5 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f5[0], u3 = 60 * +f5[1] + +f5[2];
            return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
          }(s2), null === s2))
            return this;
          var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
          if (f4)
            return o2.$offset = u2, o2.$u = 0 === s2, o2;
          if (0 !== s2) {
            var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
          } else
            o2 = this.utc();
          return o2;
        };
        var h = u.format;
        u.format = function(t2) {
          var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h.call(this, i2);
        }, u.valueOf = function() {
          var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t2;
        }, u.isUTC = function() {
          return !!this.$u;
        }, u.toISOString = function() {
          return this.toDate().toISOString();
        }, u.toString = function() {
          return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function(t2) {
          return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function(t2, i2, e2) {
          if (t2 && this.$u === t2.$u)
            return c.call(this, t2, i2, e2);
          var s2 = this.local(), f4 = n(t2).local();
          return c.call(s2, f4, i2, e2);
        };
      };
    });
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f3, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f3;
        var objects = new Array(len);
        objects[0] = ss(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f3;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i = 0; i < flen; ) {
        if (f3.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f3.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino2;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function levelToValue(level, logger) {
      return level === "silent" ? Infinity : logger.levels.values[level];
    }
    var baseLogFunctionSymbol = Symbol("pino.logFuncs");
    var hierarchySymbol = Symbol("pino.hierarchy");
    var logFallbackMap = {
      error: "log",
      fatal: "error",
      warn: "error",
      info: "log",
      debug: "log",
      trace: "log"
    };
    function appendChildLogger(parentLogger, childLogger) {
      const newEntry = {
        logger: childLogger,
        parent: parentLogger[hierarchySymbol]
      };
      childLogger[hierarchySymbol] = newEntry;
    }
    function setupBaseLogFunctions(logger, levels, proto2) {
      const logFunctions = {};
      levels.forEach((level) => {
        logFunctions[level] = proto2[level] ? proto2[level] : _console[level] || _console[logFallbackMap[level] || "log"] || noop3;
      });
      logger[baseLogFunctionSymbol] = logFunctions;
    }
    function shouldSerialize(serialize2, serializers) {
      if (Array.isArray(serialize2)) {
        const hasToFilter = serialize2.filter(function(k) {
          return k !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize2 === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino2(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto2 = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize2 = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto2 === "function") {
        levels.forEach(function(level2) {
          proto2[level2] = proto2;
        });
      }
      if (opts.enabled === false || opts.browser.disabled)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto2);
      if (!logger.log)
        logger.log = noop3;
      setupBaseLogFunctions(logger, levels, proto2);
      appendChildLogger({}, logger);
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize: serialize2,
        asObject: opts.browser.asObject,
        asObjectBindingsOnly: opts.browser.asObjectBindingsOnly,
        formatters: opts.browser.formatters,
        levels,
        timestamp: getTimeFunction(opts),
        messageKey: opts.messageKey || "msg",
        onChild: opts.onChild || noop3
      };
      logger.levels = getLevels(opts);
      logger.level = level;
      logger.isLevelEnabled = function(level2) {
        if (!this.levels.values[level2]) {
          return false;
        }
        return this.levels.values[level2] >= this.levels.values[this.level];
      };
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop3;
      logger.serializers = serializers;
      logger._serialize = serialize2;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = function(...args) {
        return child.call(this, setOpts, ...args);
      };
      if (transmit2)
        logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return levelToValue(this.level, this);
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(this, setOpts, logger, "error");
        set2(this, setOpts, logger, "fatal");
        set2(this, setOpts, logger, "warn");
        set2(this, setOpts, logger, "info");
        set2(this, setOpts, logger, "debug");
        set2(this, setOpts, logger, "trace");
        customLevels.forEach((level3) => {
          set2(this, setOpts, logger, level3);
        });
      }
      function child(setOpts2, bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize2 && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize2 && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize2;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.bindings = bindings;
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        const newLogger = new Child(this);
        appendChildLogger(this, newLogger);
        newLogger.child = function(...args) {
          return child.call(this, setOpts2, ...args);
        };
        newLogger.level = childOptions.level || this.level;
        setOpts2.onChild(newLogger);
        return newLogger;
      }
      return logger;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino2.levels.values, customLevels);
      const labels = Object.assign({}, pino2.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino2.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino2.stdSerializers = stdSerializers;
    pino2.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function getBindingChain(logger) {
      const bindings = [];
      if (logger.bindings) {
        bindings.push(logger.bindings);
      }
      let hierarchy = logger[hierarchySymbol];
      while (hierarchy.parent) {
        hierarchy = hierarchy.parent;
        if (hierarchy.logger.bindings) {
          bindings.push(hierarchy.logger.bindings);
        }
      }
      return bindings.reverse();
    }
    function set2(self2, opts, rootLogger, level) {
      Object.defineProperty(self2, level, {
        value: levelToValue(self2.level, rootLogger) > levelToValue(level, rootLogger) ? noop3 : rootLogger[baseLogFunctionSymbol][level],
        writable: true,
        enumerable: true,
        configurable: true
      });
      if (self2[level] === noop3) {
        if (!opts.transmit)
          return;
        const transmitLevel = opts.transmit.level || self2.level;
        const transmitValue = levelToValue(transmitLevel, rootLogger);
        const methodValue = levelToValue(level, rootLogger);
        if (methodValue < transmitValue)
          return;
      }
      self2[level] = createWrap(self2, opts, rootLogger, level);
      const bindings = getBindingChain(self2);
      if (bindings.length === 0) {
        return;
      }
      self2[level] = prependBindingsInArguments(bindings, self2[level]);
    }
    function prependBindingsInArguments(bindings, logFunc) {
      return function() {
        return logFunc.apply(this, [...bindings, ...arguments]);
      };
    }
    function createWrap(self2, opts, rootLogger, level) {
      return function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto2 = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i = 0; i < args.length; i++)
            args[i] = arguments[i];
          var argsIsSerialized = false;
          if (opts.serialize) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
            argsIsSerialized = true;
          }
          if (opts.asObject || opts.formatters) {
            write.call(proto2, ...asObject(this, level, args, ts, opts));
          } else
            write.apply(proto2, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || self2._level;
            const transmitValue = levelToValue(transmitLevel, rootLogger);
            const methodValue = levelToValue(level, rootLogger);
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: rootLogger.levels.values[opts.transmit.level || self2._level],
              send: opts.transmit.send,
              val: levelToValue(self2._level, rootLogger)
            }, args, argsIsSerialized);
          }
        };
      }(self2[baseLogFunctionSymbol][level]);
    }
    function asObject(logger, level, args, ts, opts) {
      const {
        level: levelFormatter,
        log: logObjectFormatter = (obj) => obj
      } = opts.formatters || {};
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const logObject = {};
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (ts) {
        logObject.time = ts;
      }
      if (levelFormatter) {
        const formattedLevel = levelFormatter(level, logger.levels.values[level]);
        Object.assign(logObject, formattedLevel);
      } else {
        logObject.level = logger.levels.values[level];
      }
      if (opts.asObjectBindingsOnly) {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
        }
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject, ...argsCloned];
      } else {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
          msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
        } else if (typeof msg === "string")
          msg = format(argsCloned.shift(), argsCloned);
        if (msg !== void 0)
          logObject[opts.messageKey] = msg;
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject];
      }
    }
    function applySerializers(args, serialize2, serializers, stdErrSerialize) {
      for (const i in args) {
        if (stdErrSerialize && args[i] instanceof Error) {
          args[i] = pino2.stdSerializers.err(args[i]);
        } else if (typeof args[i] === "object" && !Array.isArray(args[i]) && serialize2) {
          for (const k in args[i]) {
            if (serialize2.indexOf(k) > -1 && k in serializers) {
              args[i][k] = serializers[k](args[i][k]);
            }
          }
        }
      }
    }
    function transmit(logger, opts, args, argsIsSerialized = false) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      if (!argsIsSerialized) {
        applySerializers(
          args,
          logger._serialize || Object.keys(logger.serializers),
          logger.serializers,
          logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
        );
      }
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a) {
      return a;
    }
    function noop3() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o) {
        return typeof o !== "undefined" && o;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
    module.exports.default = pino2;
    module.exports.pino = pino2;
  }
});

// node_modules/@coveo/headless/dist/esm/utils/highlight.js
var highlight_exports = {};
__export(highlight_exports, {
  escapeHtml: () => escapeHtml,
  getHighlightedSuggestion: () => getHighlightedSuggestion,
  highlightString: () => highlightString
});

// node_modules/@coveo/bueno/dist/bueno.esm.js
function buildSchemaValidationError(errors2, context) {
  const message = `
  The following properties are invalid:

    ${errors2.join("\n	")}
  
  ${context}
  `;
  return new SchemaValidationError(message);
}
var SchemaValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SchemaValidationError";
  }
};
var Schema = class {
  constructor(definition4) {
    this.definition = definition4;
  }
  validate(values = {}, message = "") {
    const mergedValues = {
      ...this.default,
      ...values
    };
    const errors2 = [];
    for (const property in this.definition) {
      const error = this.definition[property].validate(mergedValues[property]);
      error && errors2.push(`${property}: ${error}`);
    }
    if (errors2.length) {
      throw buildSchemaValidationError(errors2, message);
    }
    return mergedValues;
  }
  get default() {
    const defaultValues = {};
    for (const property in this.definition) {
      const defaultValue = this.definition[property].default;
      if (defaultValue !== void 0) {
        defaultValues[property] = defaultValue;
      }
    }
    return defaultValues;
  }
};
var Value = class {
  constructor(baseConfig = {}) {
    this.baseConfig = baseConfig;
  }
  validate(value) {
    if (this.baseConfig.required && isNullOrUndefined(value)) {
      return "value is required.";
    }
    return null;
  }
  get default() {
    return this.baseConfig.default instanceof Function ? this.baseConfig.default() : this.baseConfig.default;
  }
  get required() {
    return this.baseConfig.required === true;
  }
};
function isUndefined(value) {
  return value === void 0;
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return isUndefined(value) || isNull(value);
}
var BooleanValue = class {
  constructor(config = {}) {
    __publicField(this, "value");
    this.value = new Value(config);
  }
  validate(value) {
    const valueValidation = this.value.validate(value);
    if (valueValidation) {
      return valueValidation;
    }
    if (!isBooleanOrUndefined(value)) {
      return "value is not a boolean.";
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
function isBooleanOrUndefined(value) {
  return isUndefined(value) || isBoolean(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
var NumberValue = class {
  constructor(config = {}) {
    __publicField(this, "value");
    this.config = config;
    this.value = new Value(config);
  }
  validate(value) {
    const valueValidation = this.value.validate(value);
    if (valueValidation) {
      return valueValidation;
    }
    if (!isNumberOrUndefined(value)) {
      return "value is not a number.";
    }
    if (value < this.config.min) {
      return `minimum value of ${this.config.min} not respected.`;
    }
    if (value > this.config.max) {
      return `maximum value of ${this.config.max} not respected.`;
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
function isNumberOrUndefined(value) {
  return isUndefined(value) || isNumber(value);
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
var ISODateStringRegex = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i;
var StringValue = class {
  constructor(config = {}) {
    __publicField(this, "value");
    __publicField(this, "config");
    this.config = {
      emptyAllowed: true,
      url: false,
      ...config
    };
    this.value = new Value(this.config);
  }
  validate(value) {
    const { emptyAllowed, url, regex, constrainTo, ISODate } = this.config;
    const valueValidation = this.value.validate(value);
    if (valueValidation) {
      return valueValidation;
    }
    if (isUndefined(value)) {
      return null;
    }
    if (!isString(value)) {
      return "value is not a string.";
    }
    if (!emptyAllowed && !value.length) {
      return "value is an empty string.";
    }
    if (url) {
      try {
        new URL(value);
      } catch (_) {
        return "value is not a valid URL.";
      }
    }
    if (regex && !regex.test(value)) {
      return `value did not match provided regex ${regex}`;
    }
    if (constrainTo && !constrainTo.includes(value)) {
      const values = constrainTo.join(", ");
      return `value should be one of: ${values}.`;
    }
    if (ISODate && !(ISODateStringRegex.test(value) && new Date(value).toString() !== "Invalid Date")) {
      return "value is not a valid ISO8601 date string";
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
var RecordValue = class {
  constructor(config = {}) {
    __publicField(this, "config");
    this.config = {
      options: { required: false },
      values: {},
      ...config
    };
  }
  validate(input) {
    if (isUndefined(input)) {
      return this.config.options.required ? "value is required and is currently undefined" : null;
    }
    if (!isRecord(input)) {
      return "value is not an object";
    }
    for (const [k, v] of Object.entries(this.config.values)) {
      if (v.required && isNullOrUndefined(input[k])) {
        return `value does not contain ${k}`;
      }
    }
    let out = "";
    for (const [key, validator] of Object.entries(this.config.values)) {
      const value = input[key];
      const invalidValue = validator.validate(value);
      if (invalidValue !== null) {
        out += ` ${invalidValue}`;
      }
    }
    return out === "" ? null : out;
  }
  get default() {
    return void 0;
  }
  get required() {
    return !!this.config.options.required;
  }
};
function isRecord(value) {
  return value !== void 0 && typeof value === "object";
}
var ArrayValue = class {
  constructor(config = {}) {
    __publicField(this, "value");
    this.config = config;
    this.value = new Value(this.config);
  }
  validate(input) {
    if (!isNullOrUndefined(input) && !Array.isArray(input)) {
      return "value is not an array";
    }
    const invalid = this.value.validate(input);
    if (invalid !== null) {
      return invalid;
    }
    if (isNullOrUndefined(input)) {
      return null;
    }
    if (this.config.max !== void 0 && input.length > this.config.max) {
      return `value contains more than ${this.config.max}`;
    }
    if (this.config.min !== void 0 && input.length < this.config.min) {
      return `value contains less than ${this.config.min}`;
    }
    if (this.config.each !== void 0) {
      let out = "";
      input.forEach((el) => {
        if (this.config.each.required && isNullOrUndefined(el)) {
          out = `value is null or undefined: ${input.join(",")}`;
        }
        const isInvalid = this.validatePrimitiveValue(el, this.config.each);
        if (isInvalid !== null) {
          out += ` ${isInvalid}`;
        }
      });
      return out === "" ? null : out;
    }
    return null;
  }
  validatePrimitiveValue(v, validator) {
    if (isBoolean(v)) {
      return validator.validate(v);
    } else if (isString(v)) {
      return validator.validate(v);
    } else if (isNumber(v)) {
      return validator.validate(v);
    } else if (isRecord(v)) {
      return validator.validate(v);
    }
    return "value is not a primitive value";
  }
  get default() {
    return void 0;
  }
  get required() {
    return this.value.required;
  }
};
function isArray(value) {
  return Array.isArray(value);
}
var EnumValue = class {
  constructor(config) {
    __publicField(this, "value");
    this.config = config;
    this.value = new Value(config);
  }
  validate(value) {
    const invalid = this.value.validate(value);
    if (invalid !== null) {
      return invalid;
    }
    if (isUndefined(value)) {
      return null;
    }
    const valueInEnum = Object.values(this.config.enum).find(
      (enumValue) => enumValue === value
    );
    if (!valueInEnum) {
      return "value is not in enum.";
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};

// node_modules/@coveo/headless/dist/esm/utils/utils.js
var randomID = (prepend, length = 5) => prepend + Math.random().toString(36).substring(2, 2 + length);
function isArray2(value) {
  return Array.isArray(value);
}
function isEmptyString(str) {
  return str.trim() === "";
}
function removeDuplicates(arr, predicate) {
  return [
    ...arr.reduce((map, item) => {
      const key = predicate(item);
      map.has(key) || map.set(key, item);
      return map;
    }, /* @__PURE__ */ new Map()).values()
  ];
}
function encodedBtoa(stringToEncode) {
  return btoa(encodeURI(stringToEncode));
}
function omit(key, obj) {
  const { [key]: _omitted, ...rest } = obj;
  return rest;
}
function getObjectHash(obj) {
  return encodedBtoa(JSON.stringify(obj));
}
var doNotTrackValues = /* @__PURE__ */ new Set(["1", 1, "yes", true]);
function doNotTrack() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  const nav = navigator;
  const win = window;
  return [
    nav.globalPrivacyControl,
    nav.doNotTrack,
    nav.msDoNotTrack,
    win.doNotTrack
  ].some((value) => doNotTrackValues.has(value));
}
function fromEntries(values) {
  const newObject = {};
  for (const [key, value] of values) {
    newObject[key] = value;
  }
  return newObject;
}
function resetTimeout(callback, timeoutId, ms) {
  clearTimeout(timeoutId);
  return setTimeout(callback, ms);
}
function clone(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (!value) {
    return value;
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (_) {
    return value;
  }
}
function debounce(func, wait, options = {}) {
  let timeoutId;
  return (...args) => {
    const shouldCallImmediately = options.isImmediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = void 0;
      if (!options.isImmediate) {
        func.apply(void 0, args);
      }
    }, wait);
    if (shouldCallImmediately) {
      return func.apply(void 0, args);
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/highlight.js
function highlightString(params) {
  if (isEmptyString(params.openingDelimiter) || isEmptyString(params.closingDelimiter)) {
    throw Error("delimiters should be a non-empty string");
  }
  if (isNullOrUndefined(params.content) || isEmptyString(params.content)) {
    return params.content;
  }
  if (params.highlights.length === 0) {
    return escapeHtml(params.content);
  }
  const maxIndex = params.content.length;
  let highlighted = "";
  let last = 0;
  for (let i = 0; i < params.highlights.length; i++) {
    const highlight = params.highlights[i];
    const start = highlight.offset;
    const end = start + highlight.length;
    if (end > maxIndex) {
      break;
    }
    highlighted += escapeHtml(params.content.slice(last, start));
    highlighted += params.openingDelimiter;
    highlighted += escapeHtml(params.content.slice(start, end));
    highlighted += params.closingDelimiter;
    last = end;
  }
  if (last !== maxIndex) {
    highlighted += escapeHtml(params.content.slice(last));
  }
  return highlighted;
}
function getHighlightedSuggestion(suggestion, options) {
  suggestion = escapeHtml(suggestion);
  return suggestion.replace(/\[(.*?)\]|\{(.*?)\}|\((.*?)\)/g, (part, notMatched, matched, corrected) => {
    if (notMatched) {
      return suggestionWithDelimiters(notMatched, options.notMatchDelimiters);
    }
    if (matched) {
      return suggestionWithDelimiters(matched, options.exactMatchDelimiters);
    }
    if (corrected) {
      return suggestionWithDelimiters(corrected, options.correctionDelimiters);
    }
    return part;
  });
}
function suggestionWithDelimiters(suggestion, delimiters) {
  if (delimiters) {
    return delimiters.open + suggestion + delimiters.close;
  }
  return suggestion;
}
function escapeHtml(str) {
  const mapOfCharToEscape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };
  const source = `(?:${Object.keys(mapOfCharToEscape).join("|")})`;
  const testRegexp = RegExp(source);
  const replaceRegexp = RegExp(source, "g");
  return testRegexp.test(str) ? str.replace(replaceRegexp, (substring) => mapOfCharToEscape[substring]) : str;
}

// node_modules/@coveo/headless/dist/esm/utils/fetch-event-source/parse.js
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
var ControlChars;
(function(ControlChars2) {
  ControlChars2[ControlChars2["NewLine"] = 10] = "NewLine";
  ControlChars2[ControlChars2["CarriageReturn"] = 13] = "CarriageReturn";
  ControlChars2[ControlChars2["Space"] = 32] = "Space";
  ControlChars2[ControlChars2["Colon"] = 58] = "Colon";
})(ControlChars || (ControlChars = {}));
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === ControlChars.NewLine) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case ControlChars.Colon:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case ControlChars.CarriageReturn:
            discardTrailingNewline = true;
            lineEnd = position;
            break;
          case ControlChars.NewLine:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage == null ? void 0 : onMessage(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field2 = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field2) {
        case "data":
          message.data = message.data ? `${message.data}
${value}` : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          retry(value, message, onRetry);
          break;
      }
    }
  };
}
function retry(value, message, onRetry) {
  const retry3 = parseInt(value, 10);
  if (!Number.isNaN(retry3)) {
    onRetry(message.retry = retry3);
  }
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}

// node_modules/@coveo/headless/dist/esm/utils/fetch-event-source/fetch.js
var EventStreamContentType = "text/event-stream";
var DefaultRetryInterval = 1e3;
var LastEventId = "last-event-id";
function isBrowser() {
  return typeof window !== "undefined";
}
function fetchEventSource(input, { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch, ...rest }) {
  return new Promise((resolve, reject) => {
    const headers = { ...inputHeaders };
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController == null ? void 0 : curRequestController.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden && isBrowser()) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer;
    function dispose() {
      if (isBrowser()) {
        document.removeEventListener("visibilitychange", onVisibilityChange);
      }
      clearTimeout(retryTimer);
      curRequestController == null ? void 0 : curRequestController.abort();
    }
    inputSignal == null ? void 0 : inputSignal.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const outputFetch = inputFetch ?? fetch;
    const onopen = inputOnOpen ?? defaultOnOpen;
    async function create() {
      var _a;
      curRequestController = AbortController ? new AbortController() : null;
      try {
        const response = await outputFetch(input, {
          ...rest,
          headers,
          signal: curRequestController == null ? void 0 : curRequestController.signal
        });
        await onopen(response);
        await getBytes(response.body, getLines(getMessages((id) => {
          if (id) {
            headers[LastEventId] = id;
          } else {
            delete headers[LastEventId];
          }
        }, (retry3) => {
          retryInterval = retry3;
        }, onmessage)));
        onclose == null ? void 0 : onclose();
        dispose();
        resolve();
      } catch (err) {
        if (!((_a = curRequestController == null ? void 0 : curRequestController.signal) == null ? void 0 : _a.aborted)) {
          try {
            const interval = (onerror == null ? void 0 : onerror(err)) ?? retryInterval;
            clearTimeout(retryTimer);
            retryTimer = setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!(contentType == null ? void 0 : contentType.startsWith(EventStreamContentType))) {
    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
  }
}

// node_modules/@coveo/headless/dist/esm/utils/url-utils.js
var URLPath = class {
  constructor(basePath2) {
    __publicField(this, "_basePath");
    __publicField(this, "_params", {});
    this._basePath = basePath2;
  }
  addParam(name, value) {
    this._params = {
      ...this.params,
      [name]: value
    };
  }
  get basePath() {
    return this._basePath;
  }
  get params() {
    return this._params;
  }
  get hasParams() {
    return Object.entries(this._params).length;
  }
  get href() {
    return this.hasParams ? `${this.basePath}?${Object.entries(this.params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&")}` : this.basePath;
  }
};

// node_modules/@coveo/headless/dist/esm/api/generated-answer/generated-answer-client.js
var buildStreamingUrl = (url, orgId, streamId) => new URLPath(`${url}/rest/organizations/${orgId}/machinelearning/streaming/${streamId}`).href;
var MAX_RETRIES = 3;
var MAX_TIMEOUT = 5e3;
var EVENT_STREAM_CONTENT_TYPE = "text/event-stream";
var RETRYABLE_STREAM_ERROR_CODE = 1;
var RetryableError = class extends Error {
};
var FatalError = class extends Error {
  constructor(payload) {
    super(payload.message);
    __publicField(this, "payload");
    this.payload = payload;
  }
};
var TimeoutStateManager = class {
  constructor() {
    __publicField(this, "timeouts", /* @__PURE__ */ new Set());
  }
  add(timeout) {
    this.timeouts.add(timeout);
  }
  remove(timeout) {
    clearTimeout(timeout);
    this.timeouts.delete(timeout);
  }
  isActive(timeout) {
    return this.timeouts.has(timeout);
  }
};
var GeneratedAnswerAPIClient = class {
  constructor(options) {
    __publicField(this, "logger");
    this.logger = options.logger;
  }
  streamGeneratedAnswer(params, callbacks) {
    const { url, organizationId, streamId, accessToken } = params;
    const { write, abort, close, resetAnswer: resetAnswer2 } = callbacks;
    const timeoutStateManager = new TimeoutStateManager();
    if (!streamId) {
      this.logger.error("No stream ID found");
      return;
    }
    let retryCount = 0;
    let timeout;
    const retryStream = () => {
      if (timeout && !timeoutStateManager.isActive(timeout)) {
        abortController == null ? void 0 : abortController.abort();
        resetAnswer2();
        stream();
      }
    };
    const refreshTimeout = () => {
      timeoutStateManager.remove(timeout);
      timeout = resetTimeout(retryStream, timeout, MAX_TIMEOUT);
      timeoutStateManager.add(timeout);
    };
    const abortController = new AbortController();
    const stream = () => fetchEventSource(buildStreamingUrl(url, organizationId, streamId), {
      method: "GET",
      fetch,
      headers: {
        Authorization: `Bearer ${accessToken}`,
        accept: "*/*"
      },
      openWhenHidden: true,
      signal: abortController == null ? void 0 : abortController.signal,
      async onopen(response) {
        if (response.ok && response.headers.get("content-type") === EVENT_STREAM_CONTENT_TYPE) {
          return;
        }
        const isClientSideError = response.status >= 400 && response.status < 500 && response.status !== 429;
        if (isClientSideError) {
          throw new FatalError({
            message: "Error opening stream",
            code: response.status
          });
        } else {
          throw new RetryableError();
        }
      },
      onmessage: (event) => {
        if (abortController == null ? void 0 : abortController.signal.aborted) {
          return;
        }
        const data = JSON.parse(event.data);
        if (data.finishReason === "ERROR") {
          timeoutStateManager.remove(timeout);
          abortController == null ? void 0 : abortController.abort();
          abort({
            message: data.errorMessage,
            code: data.statusCode
          });
          return;
        }
        write(data);
        retryCount = 0;
        if (data.finishReason === "COMPLETED") {
          timeoutStateManager.remove(timeout);
          close();
        } else {
          refreshTimeout();
        }
      },
      onerror: (err) => {
        if (abortController == null ? void 0 : abortController.signal.aborted) {
          return;
        }
        timeoutStateManager.remove(timeout);
        if (err instanceof FatalError) {
          abortController == null ? void 0 : abortController.abort();
          abort(err);
          throw err;
        }
        if (++retryCount > MAX_RETRIES) {
          this.logger.info("Maximum retry exceeded.");
          const error = {
            message: "Failed to complete stream.",
            code: RETRYABLE_STREAM_ERROR_CODE
          };
          abortController == null ? void 0 : abortController.abort();
          abort(error);
          throw new FatalError(error);
        }
        this.logger.info(`Retrying...(${retryCount}/${MAX_RETRIES})`);
        resetAnswer2();
      }
    });
    stream();
    return abortController;
  }
};

// node_modules/@coveo/headless/dist/esm/api/platform-client.js
var import_exponential_backoff = __toESM(require_backoff(), 1);

// node_modules/@coveo/headless/dist/esm/utils/errors.js
var loadReducerError = new Error("Failed to load reducers.");
var UnauthorizedTokenError = class extends Error {
  constructor() {
    super();
    this.name = "UnauthorizedTokenError";
    this.message = "The token being used to perform the request is unauthorized. It may be expired or invalid.";
  }
};
var DisconnectedError = class extends Error {
  constructor(url, statusCode) {
    super();
    __publicField(this, "statusCode");
    this.name = "Disconnected";
    this.message = `Client could not connect to the following URL: ${url}`;
    this.statusCode = statusCode ?? 0;
  }
};

// node_modules/@coveo/headless/dist/esm/api/form-url-encoder.js
function encodeAsFormUrl(obj) {
  const body = [];
  for (const property in obj) {
    const key = encodeURIComponent(property);
    const value = encodeURIComponent(obj[property]);
    body.push(`${key}=${value}`);
  }
  return body.join("&");
}
function canBeFormUrlEncoded(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (!obj) {
    return false;
  }
  return Object.values(obj).every(isPrimitive);
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}

// node_modules/@coveo/headless/dist/esm/api/platform-client.js
function isThrottled(status) {
  return status === 429;
}
var PlatformClient = class _PlatformClient {
  static async call(options) {
    const defaultRequestOptions = buildDefaultRequestOptions(options);
    const { logger } = options;
    const requestInfo = await _PlatformClient.preprocessRequest(defaultRequestOptions, options);
    logger.info(requestInfo, "Platform request");
    const { url, ...requestData } = requestInfo;
    const request = async () => {
      const response = await fetch(url, requestData);
      if (isThrottled(response.status)) {
        throw response;
      }
      return response;
    };
    try {
      const response = await (0, import_exponential_backoff.backOff)(request, {
        startingDelay: 100,
        timeMultiple: 2,
        maxDelay: 800,
        numOfAttempts: 4,
        jitter: "full",
        retry: async (e) => {
          const shouldRetry = e && isThrottled(e.status);
          if (shouldRetry) {
            logger.info("Platform retrying request");
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
          return shouldRetry;
        }
      });
      switch (response.status) {
        case 419:
        case 401:
          logger.info("Platform renewing token");
          throw new UnauthorizedTokenError();
        case 404:
          throw new DisconnectedError(url, response.status);
        default:
          logger.info({ response, requestInfo }, "Platform response");
          return response;
      }
    } catch (error) {
      if (error.message === "Failed to fetch") {
        return new DisconnectedError(url);
      }
      return error;
    }
  }
  static async preprocessRequest(defaultRequestOptions, options) {
    const { origin, preprocessRequest, logger, requestMetadata } = options;
    const { signal: _signal, ...withoutSignal } = defaultRequestOptions;
    const untaintedOutput = clone(withoutSignal);
    try {
      const processedRequest = await preprocessRequest(defaultRequestOptions, origin, requestMetadata);
      return {
        ...defaultRequestOptions,
        ...processedRequest
      };
    } catch (e) {
      logger.error(e, "Platform request preprocessing failed. Returning default request options.");
    }
    return untaintedOutput;
  }
};
function getOrganizationEndpoint(organizationId, environment = "prod", endpointType = "platform") {
  const environmentSuffix = environment === "prod" ? "" : environment;
  const endpointTypePart = endpointType === "platform" ? "" : `.${endpointType}`;
  return `https://${organizationId}${endpointTypePart}.org${environmentSuffix}.coveo.com`;
}
function getSearchApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(organizationId, environment);
  return `${organizationEndpoint}/rest/search/v2`;
}
function getAnalyticsNextApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(organizationId, environment, "analytics");
  return `${organizationEndpoint}/rest/organizations/${organizationId}/events/v1`;
}
function buildDefaultRequestOptions(options) {
  const { url, method, requestParams, contentType, accessToken, signal } = options;
  const isMethodWithBody = options.method === "POST" || options.method === "PUT";
  const body = encodeBody(requestParams, contentType);
  return {
    url,
    method,
    headers: {
      "Content-Type": contentType,
      Authorization: `Bearer ${accessToken}`,
      ...options.headers
    },
    ...isMethodWithBody && { body },
    signal
  };
}
function encodeBody(body, contentType) {
  if (contentType === "application/x-www-form-urlencoded") {
    return canBeFormUrlEncoded(body) ? encodeAsFormUrl(body) : "";
  }
  return JSON.stringify(body);
}

// node_modules/@coveo/headless/dist/esm/api/preprocess-request.js
var NoopPreprocessRequest = (request) => request;

// node_modules/@coveo/headless/dist/esm/features/search/search-state.js
function emptyQuestionAnswer() {
  return {
    answerSnippet: "",
    documentId: {
      contentIdKey: "",
      contentIdValue: ""
    },
    question: "",
    relatedQuestions: [],
    score: 0
  };
}
function getSearchInitialState() {
  return {
    response: {
      results: [],
      searchUid: "",
      totalCountFiltered: 0,
      facets: [],
      generateAutomaticFacets: { facets: [] },
      queryCorrections: [],
      triggers: [],
      questionAnswer: emptyQuestionAnswer(),
      pipeline: "",
      splitTestRun: "",
      termsToHighlight: {},
      phrasesToHighlight: {},
      extendedResults: {}
    },
    duration: 0,
    queryExecuted: "",
    error: null,
    automaticallyCorrected: false,
    isLoading: false,
    results: [],
    searchResponseId: "",
    requestId: "",
    questionAnswer: emptyQuestionAnswer(),
    extendedResults: {},
    searchAction: void 0
  };
}

// node_modules/@coveo/headless/dist/esm/api/api-client-utils.js
function pickNonBaseParams(req) {
  const { url: _url, accessToken: _accessToken, organizationId: _organizationId, authentication: _authentication, ...nonBase } = req;
  return nonBase;
}
var unwrapError = (payload) => {
  const { response } = payload;
  if (response.body) {
    return unwrapSearchApiError(payload);
  }
  return unwrapClientError(response);
};
var unwrapSearchApiError = (payload) => {
  if (isSearchAPIException(payload)) {
    return unwrapErrorByException(payload);
  }
  if (isSearchAPIErrorWithStatusCode(payload)) {
    return payload.body;
  }
  return { message: "unknown", statusCode: 0, type: "unknown" };
};
var unwrapClientError = (response) => {
  const body = JSON.parse(JSON.stringify(response, Object.getOwnPropertyNames(response)));
  return {
    ...body,
    message: `Client side error: ${body.message || ""}`,
    statusCode: 400,
    type: "ClientError"
  };
};
function isSearchAPIErrorWithStatusCode(r) {
  return r.body.statusCode !== void 0;
}
function isSearchAPIException(r) {
  return r.body.exception !== void 0;
}
var unwrapErrorByException = (res) => ({
  message: res.body.exception.code,
  statusCode: res.response.status,
  type: res.body.exception.code
});

// node_modules/@coveo/headless/dist/esm/api/search/api-calls-queue.js
var APICallsQueue = class {
  constructor() {
    __publicField(this, "currentAbortController", null);
  }
  /**
   * Enqueue an API call so that it can get cancelled if another call is enqueued before it finishes.
   */
  async enqueue(call, options) {
    const lastAbortController = this.currentAbortController;
    this.currentAbortController = new AbortController();
    const abortController = this.currentAbortController;
    if (lastAbortController) {
      if (options.warnOnAbort) {
        options.logger.warn("Cancelling current pending search query");
      }
      lastAbortController.abort();
    }
    try {
      return await call((abortController == null ? void 0 : abortController.signal) ?? null);
    } finally {
      if (this.currentAbortController === abortController) {
        this.currentAbortController = null;
      }
    }
  }
};

// node_modules/@coveo/headless/dist/esm/api/search/encoding-finder.js
function findEncoding(response) {
  const contentType = response.headers.get("content-type") || "";
  const charset = contentType.split(";").find((part) => part.indexOf("charset=") !== -1) || "";
  return charset.split("=")[1] || "UTF-8";
}

// node_modules/@coveo/headless/dist/esm/api/search/search-api-params.js
var baseSearchRequest = (req, method, contentType, path) => {
  const url = new URLPath(`${req.url}${path}`);
  url.addParam("organizationId", req.organizationId);
  if (req.authentication) {
    url.addParam("authentication", req.authentication);
  }
  return {
    accessToken: req.accessToken,
    method,
    contentType,
    url: url.href,
    origin: "searchApiFetch"
  };
};

// node_modules/@coveo/headless/dist/esm/api/search/html/html-api-client.js
var buildContentURL = (req, path) => {
  const url = new URLPath(`${req.url}${path}`);
  url.addParam("access_token", req.accessToken);
  url.addParam("organizationId", req.organizationId);
  url.addParam("uniqueId", req.uniqueId);
  if (req.authentication) {
    url.addParam("authentication", req.authentication);
  }
  if (req.q !== void 0) {
    url.addParam("q", req.q);
  }
  if (req.enableNavigation !== void 0) {
    url.addParam("enableNavigation", `${req.enableNavigation}`);
  }
  if (req.requestedOutputSize !== void 0) {
    url.addParam("requestedOutputSize", `${req.requestedOutputSize}`);
  }
  return url.href;
};
var getHtml = async (req, options) => {
  const response = await PlatformClient.call({
    ...baseSearchRequest(req, "POST", "application/x-www-form-urlencoded", "/html"),
    requestParams: pickNonBaseParams(req),
    requestMetadata: { method: "html" },
    ...options
  });
  if (response instanceof Error) {
    throw response;
  }
  const encoding = findEncoding(response);
  const buffer = await response.arrayBuffer();
  const decoder = new TextDecoder(encoding);
  const body = decoder.decode(buffer);
  if (isSuccessHtmlResponse(body)) {
    return { success: body };
  }
  return { error: unwrapError({ response, body }) };
};
function isSuccessHtmlResponse(body) {
  return typeof body === "string";
}

// node_modules/@coveo/headless/dist/esm/api/search/search-api-error-response.js
function buildDisconnectedError(error) {
  return {
    statusCode: error.statusCode,
    type: error.name,
    message: error.message
  };
}
function buildIgnoredAbortedError(error) {
  return {
    statusCode: error.code,
    type: error.name,
    message: error.message,
    ignored: true
  };
}
function buildAPIResponseFromErrorOrThrow(error, disableAbortWarning) {
  if (disableAbortWarning && error.name === "AbortError") {
    return {
      error: buildIgnoredAbortedError(error)
    };
  }
  if (error instanceof DisconnectedError) {
    return { error: buildDisconnectedError(error) };
  }
  throw error;
}

// node_modules/@coveo/headless/dist/esm/api/search/search-api-client.js
var SearchAPIClient = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "apiCallsQueues", {
      unknown: new APICallsQueue(),
      mainSearch: new APICallsQueue(),
      facetValues: new APICallsQueue(),
      foldingCollection: new APICallsQueue(),
      instantResults: new APICallsQueue()
    });
    this.options = options;
  }
  async plan(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", "/plan"),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "plan" },
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    if (isSuccessPlanResponse(body)) {
      return { success: body };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
  async querySuggest(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", "/querySuggest"),
      requestMetadata: { method: "querySuggest" },
      requestParams: pickNonBaseParams(req),
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    const payload = { response, body };
    if (isSuccessQuerySuggestionsResponse(body)) {
      const processedResponse = await this.options.postprocessQuerySuggestResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError(payload)
    };
  }
  async search(req, options) {
    const origin = (options == null ? void 0 : options.origin) ?? "unknown";
    const response = await this.apiCallsQueues[origin].enqueue((signal) => PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", ""),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "search", origin: options == null ? void 0 : options.origin },
      ...this.options,
      signal: signal ?? void 0
    }), { logger: this.options.logger, warnOnAbort: !(options == null ? void 0 : options.disableAbortWarning) });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response, options == null ? void 0 : options.disableAbortWarning);
    }
    const body = await response.json();
    const payload = { response, body };
    if (isSuccessSearchResponse(body)) {
      payload.body = shimResponse(body);
      const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError(payload)
    };
  }
  async facetSearch(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", "/facet"),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "facetSearch" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    const payload = { response, body };
    const processedResponse = await this.options.postprocessFacetSearchResponseMiddleware(payload);
    return processedResponse.body;
  }
  async recommendations(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "POST", "application/json", ""),
      requestParams: pickNonBaseParams(req),
      requestMetadata: { method: "recommendations" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    if (isSuccessSearchResponse(body)) {
      const payload = { response, body };
      payload.body = shimResponse(body);
      const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
  async html(req) {
    return getHtml(req, { ...this.options });
  }
  async fieldDescriptions(req) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req, "GET", "application/json", "/fields"),
      requestParams: {},
      requestMetadata: { method: "fieldDescriptions" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    if (isSuccessFieldsDescriptionResponse(body)) {
      return { success: body };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
};
var isSuccessResponse = (r) => {
  return r.success !== void 0;
};
var isErrorResponse = (r) => {
  return r.error !== void 0;
};
function isSuccessSearchResponse(body) {
  return body.results !== void 0;
}
function shimResponse(response) {
  const empty = emptyQuestionAnswer();
  if (isNullOrUndefined(response.questionAnswer)) {
    response.questionAnswer = empty;
    return response;
  }
  response.questionAnswer = { ...empty, ...response.questionAnswer };
  return response;
}
function isSuccessQuerySuggestionsResponse(body) {
  return body.completions !== void 0;
}
function isSuccessPlanResponse(body) {
  return body.preprocessingOutput !== void 0;
}
function isSuccessFieldsDescriptionResponse(body) {
  return body.fields !== void 0;
}

// node_modules/@coveo/headless/dist/esm/api/search/search-api-client-middleware.js
var NoopPostprocessSearchResponseMiddleware = (response) => response;
var NoopPostprocessFacetSearchResponseMiddleware = (response) => response;
var NoopPostprocessQuerySuggestResponseMiddleware = (response) => response;

// node_modules/@coveo/headless/dist/esm/utils/validate-payload.js
var requiredNonEmptyString = new StringValue({
  required: true,
  emptyAllowed: false
});
var nonEmptyString = new StringValue({
  required: false,
  emptyAllowed: false
});
var requiredEmptyAllowedString = new StringValue({
  required: true,
  emptyAllowed: true
});
var nonRequiredEmptyAllowedString = new StringValue({
  required: false,
  emptyAllowed: true
});
var nonEmptyStringArray = new ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
var optionalNonEmptyVersionString = new StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^\d+\.\d+\.\d+$/
});
var optionalTrackingId = new StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var requiredTrackingId = new StringValue({
  required: true,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
var serializeSchemaValidationError = ({ message, name, stack }) => ({ message, name, stack });
var validatePayloadAndThrow = (payload, definition4) => {
  const isSchemaValue = "required" in definition4;
  if (isSchemaValue) {
    return {
      payload: new Schema({
        value: definition4
      }).validate({ value: payload }).value
    };
  }
  const asRecordValue = new RecordValue({
    options: { required: true },
    values: definition4
  });
  const isInvalid = asRecordValue.validate(payload);
  if (isInvalid) {
    throw new SchemaValidationError(isInvalid);
  }
  return { payload };
};
var validatePayload = (payload, definition4) => {
  try {
    return validatePayloadAndThrow(payload, definition4);
  } catch (error) {
    return {
      payload,
      error: serializeSchemaValidationError(error)
    };
  }
};
var validateInitialState = (engine, schema, obj, functionName) => {
  const message = `Check the initialState of ${functionName}`;
  return validateObject(engine, schema, obj, message, "Controller initialization error");
};
var validateOptions = (engine, schema, obj, functionName) => {
  const message = `Check the options of ${functionName}`;
  return validateObject(engine, schema, obj, message, "Controller initialization error");
};
var validateObject = (engine, schema, obj, validationMessage, errorMessage) => {
  try {
    return schema.validate(obj, validationMessage);
  } catch (error) {
    engine.logger.error(error, errorMessage);
    throw error;
  }
};

// node_modules/redux/dist/redux.mjs
var $$observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener2, key) => {
        nextListeners.set(key, listener2);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener2) {
    if (typeof listener2 !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener2)}'`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener2);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener2) => {
      listener2();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach((key) => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE)
    return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState2 = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(false ? formatProdErrorMessage(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(false ? formatProdErrorMessage(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (true) {
      if (typeof reducers[key] === "undefined") {
        warning(`No reducer provided for key "${key}"`);
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (true) {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (true) {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(false ? formatProdErrorMessage(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore22) => (reducer, preloadedState) => {
    const store = createStore22(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject(action) && "type" in action && typeof action.type === "string";
}

// node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = true ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (true) {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  if (!value)
    return false;
  return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto2 = Object.getPrototypeOf(value);
  if (proto2 === null || proto2 === Object.prototype)
    return true;
  const Ctor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  if (Ctor === Object)
    return true;
  if (typeof Ctor !== "function")
    return false;
  let ctorString = cachedCtorStrings.get(Ctor);
  if (ctorString === void 0) {
    ctorString = Function.toString.call(Ctor);
    cachedCtorStrings.set(Ctor, ctorString);
  }
  return ctorString === objectCtorString;
}
function original(value) {
  if (!isDraft(value))
    die(15, value);
  return value[DRAFT_STATE].base_;
}
function each(obj, iter, strict = true) {
  if (getArchtype(obj) === 0) {
    const keys2 = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
    keys2.forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain2 = isPlainObject2(base);
  if (strict === true || strict === "class_only" && !isPlain2) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto2 = getPrototypeOf(base);
    if (proto2 !== null && isPlain2) {
      return { ...base };
    }
    const obj = Object.create(proto2);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: dontMutateMethodOverride,
      add: dontMutateMethodOverride,
      clear: dontMutateMethodOverride,
      delete: dontMutateMethodOverride
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  value: dontMutateFrozenCollections
};
function isFrozen(obj) {
  if (obj === null || typeof obj !== "object")
    return true;
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey])
    plugins[pluginKey] = implementation;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path),
      useStrictIteration
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(
        rootScope,
        state,
        result,
        key,
        childValue,
        path,
        isSet2
      ),
      useStrictIteration
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue == null) {
    return;
  }
  if (typeof childValue !== "object" && !targetIsSet) {
    return;
  }
  const childIsFrozen = isFrozen(childValue);
  if (childIsFrozen && !targetIsSet) {
    return;
  }
  if (childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !childIsFrozen) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray4 = Array.isArray(base);
  const state = {
    type_: isArray4 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray4) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto2 = getPrototypeOf(source);
  while (proto2) {
    const desc = Object.getOwnPropertyDescriptor(proto2, prop);
    if (desc)
      return desc;
    proto2 = getPrototypeOf(proto2);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.useStrictIteration_ = true;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
    if (typeof (config == null ? void 0 : config.useStrictIteration) === "boolean")
      this.setUseStrictIteration(config.useStrictIteration);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  let strict = true;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    strict = state.scope_.immer_.shouldUseStrictIteration();
  } else {
    copy = shallowCopy(value, true);
  }
  each(
    copy,
    (key, childValue) => {
      set(copy, key, currentImpl(childValue));
    },
    strict
  );
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
function enablePatches() {
  const errorOffset = 16;
  if (true) {
    errors.push(
      'Sets cannot have "replace" patches.',
      function(op) {
        return "Unsupported patch operation: " + op;
      },
      function(path) {
        return "Cannot apply patch, path doesn't resolve: " + path;
      },
      "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    );
  }
  const REPLACE = "replace";
  const ADD = "add";
  const REMOVE = "remove";
  function generatePatches_(state, basePath2, patches, inversePatches) {
    switch (state.type_) {
      case 0:
      case 2:
        return generatePatchesFromAssigned(
          state,
          basePath2,
          patches,
          inversePatches
        );
      case 1:
        return generateArrayPatches(state, basePath2, patches, inversePatches);
      case 3:
        return generateSetPatches(
          state,
          basePath2,
          patches,
          inversePatches
        );
    }
  }
  function generateArrayPatches(state, basePath2, patches, inversePatches) {
    let { base_, assigned_ } = state;
    let copy_ = state.copy_;
    if (copy_.length < base_.length) {
      ;
      [base_, copy_] = [copy_, base_];
      [patches, inversePatches] = [inversePatches, patches];
    }
    for (let i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        const path = basePath2.concat([i]);
        patches.push({
          op: REPLACE,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    }
    for (let i = base_.length; i < copy_.length; i++) {
      const path = basePath2.concat([i]);
      patches.push({
        op: ADD,
        path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i])
      });
    }
    for (let i = copy_.length - 1; base_.length <= i; --i) {
      const path = basePath2.concat([i]);
      inversePatches.push({
        op: REMOVE,
        path
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath2, patches, inversePatches) {
    const { base_, copy_ } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get(base_, key);
      const value = get(copy_, key);
      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE)
        return;
      const path = basePath2.concat(key);
      patches.push(op === REMOVE ? { op, path } : { op, path, value });
      inversePatches.push(
        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
      );
    });
  }
  function generateSetPatches(state, basePath2, patches, inversePatches) {
    let { base_, copy_ } = state;
    let i = 0;
    base_.forEach((value) => {
      if (!copy_.has(value)) {
        const path = basePath2.concat([i]);
        patches.push({
          op: REMOVE,
          path,
          value
        });
        inversePatches.unshift({
          op: ADD,
          path,
          value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach((value) => {
      if (!base_.has(value)) {
        const path = basePath2.concat([i]);
        patches.push({
          op: ADD,
          path,
          value
        });
        inversePatches.unshift({
          op: REMOVE,
          path,
          value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach((patch) => {
      const { path, op } = patch;
      let base = draft;
      for (let i = 0; i < path.length - 1; i++) {
        const parentType = getArchtype(base);
        let p = path[i];
        if (typeof p !== "string" && typeof p !== "number") {
          p = "" + p;
        }
        if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
          die(errorOffset + 3);
        if (typeof base === "function" && p === "prototype")
          die(errorOffset + 3);
        base = get(base, p);
        if (typeof base !== "object")
          die(errorOffset + 2, path.join("/"));
      }
      const type = getArchtype(base);
      const value = deepClonePatchValue(patch.value);
      const key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2:
              return base.set(key, value);
            case 3:
              die(errorOffset);
            default:
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2:
              return base.set(key, value);
            case 3:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1:
              return base.splice(key, 1);
            case 2:
              return base.delete(key);
            case 3:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(errorOffset + 1, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj))
      return obj;
    if (Array.isArray(obj))
      return obj.map(deepClonePatchValue);
    if (isMap(obj))
      return new Map(
        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
      );
    if (isSet(obj))
      return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj)
      cloned[key] = deepClonePatchValue(obj[key]);
    if (has(obj, DRAFTABLE))
      cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else
      return obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(
  immer
);
var setUseStrictIteration = immer.setUseStrictIteration.bind(
  immer
);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);

// node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ;
        ({ stack } = e);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
  const { memoize, memoizeOptions } = options;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e) {
      ;
      ({ stack } = e);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var NOT_FOUND = Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var REDUX_PROXY_LABEL = Symbol();
var proto = Object.getPrototypeOf({});
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a;
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// node_modules/redux-thunk/dist/redux-thunk.mjs
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs
var createDraftSafeSelectorCreator = (...args) => {
  const createSelector2 = createSelectorCreator(...args);
  const createDraftSafeSelector2 = Object.assign((...args2) => {
    const selector = createSelector2(...args2);
    const wrappedSelector = (value, ...rest) => selector(isDraft(value) ? current(value) : value, ...rest);
    Object.assign(wrappedSelector, selector);
    return wrappedSelector;
  }, {
    withTypes: () => createDraftSafeSelector2
  });
  return createDraftSafeSelector2;
};
var createDraftSafeSelector = createDraftSafeSelectorCreator(weakMapMemoize);
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop3) {
    return noop3;
  };
};
var hasMatchFunction = (v) => {
  return v && typeof v.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(false ? formatProdErrorMessage(0) : "prepareAction did not return an object");
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options;
  return () => (next) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next(action);
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn) {
      const started = Date.now();
      try {
        return fn();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map, key, compute) {
  if (map.has(key))
    return map.get(key);
  return map.set(key, compute(key)).get(key);
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (let key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (let key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key in keysToDetect) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware(options = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  } else {
    let stringify2 = function(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
    }, getSerialize2 = function(serializer, decycler) {
      let stack = [], keys2 = [];
      if (!decycler)
        decycler = function(_, value) {
          if (stack[0] === value)
            return "[Circular ~]";
          return "[Circular ~." + keys2.slice(0, stack.indexOf(value)).join(".") + "]";
        };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys2.splice(thisPos, Infinity, key) : keys2.push(key);
          if (~stack.indexOf(value))
            value = decycler.call(this, key, value);
        } else
          stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
      };
    };
    var stringify = stringify2, getSerialize = getSerialize2;
    let {
      isImmutable = isImmutableDefault,
      ignoredPaths,
      warnAfter = 32
    } = options;
    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return ({
      getState
    }) => {
      let state = getState();
      let tracker = track(state);
      let result;
      return (next) => (action) => {
        const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        const dispatchedAction = next(action);
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  }
}
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache2) {
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache2 == null ? void 0 : cache2.has(value))
    return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache2);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache2 && isNestedFrozen(value))
    cache2.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value))
    return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null)
      continue;
    if (!isNestedFrozen(nestedValue))
      return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  } else {
    const {
      isSerializable = isPlain,
      getEntries,
      ignoredActions = [],
      ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths = [],
      warnAfter = 32,
      ignoreState = false,
      ignoreActions = false,
      disableCache = false
    } = options;
    const cache2 = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (storeAPI) => (next) => (action) => {
      if (!isAction(action)) {
        return next(action);
      }
      const result = next(action);
      const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
        measureUtils.measureTime(() => {
          const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache2);
          if (foundActionNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundActionNonSerializableValue;
            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
          }
        });
      }
      if (!ignoreState) {
        measureUtils.measureTime(() => {
          const state = storeAPI.getState();
          const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache2);
          if (foundStateNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundStateNonSerializableValue;
            console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        });
        measureUtils.warnIfExceeded();
      }
      return result;
    };
  }
}
function isBoolean2(x) {
  return typeof x === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk: thunk2 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options ?? {};
  let middlewareArray = new Tuple();
  if (thunk2) {
    if (isBoolean2(thunk2)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk2.extraArgument));
    }
  }
  if (true) {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean2(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean2(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean2(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = () => (payload) => ({
  payload,
  meta: {
    [SHOULD_AUTOBATCH]: true
  }
});
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options = {
  type: "raf"
}) => (next) => (...args) => {
  const store = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l) => l());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      var _a;
      try {
        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error(false ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  }
  if (middleware && typeof middleware !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
    if (!Array.isArray(finalMiddleware)) {
      throw new Error(false ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: true,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (enhancers && typeof enhancers !== "function") {
    throw new Error(false ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
  }
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (!Array.isArray(storeEnhancers)) {
    throw new Error(false ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
  }
  if (storeEnhancers.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
  }
  if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (true) {
        if (actionMatchers.length > 0) {
          throw new Error(false ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(false ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error(false ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState2, mapOrBuilderCallback) {
  if (true) {
    if (typeof mapOrBuilderCallback === "object") {
      throw new Error(false ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    }
  }
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = () => freezeDraftable(initialState2());
  } else {
    const frozenInitialState = freezeDraftable(initialState2);
    getInitialState = () => frozenInitialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer2
    }) => reducer2)];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers) {
  return (action) => {
    return matchers.some((matcher) => matches(matcher, action));
  };
}
function isAllOf(...matchers) {
  return (action) => {
    return matchers.every((matcher) => matches(matcher, action));
  };
}
function hasExpectedRequestMetadata(action, validStatus) {
  if (!action || !action.meta)
    return false;
  const hasValidRequestId = typeof action.meta.requestId === "string";
  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
  return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a) {
  return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
}
function isPending(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["pending"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isPending()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));
}
function isRejected(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejected()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));
}
function isRejectedWithValue(...asyncThunks) {
  const hasFlag = (action) => {
    return action && action.meta && action.meta.rejectedWithValue;
  };
  if (asyncThunks.length === 0) {
    return isAllOf(isRejected(...asyncThunks), hasFlag);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejectedWithValue()(asyncThunks[0]);
  }
  return isAllOf(isRejected(...asyncThunks), hasFlag);
}
function isFulfilled(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["fulfilled"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isFulfilled()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));
}
function isAsyncThunkAction(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isAsyncThunkAction()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var FulfillWithMeta = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var miniSerializeError = (value) => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
var createAsyncThunk = (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
      payload,
      error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...meta || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: (error == null ? void 0 : error.name) === "AbortError",
        condition: (error == null ? void 0 : error.name) === "ConditionError"
      }
    }));
    function actionCreator(arg) {
      return (dispatch, getState, extra) => {
        const requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        const promise = async function() {
          var _a, _b;
          let finalAction;
          try {
            let conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta) => {
                return new RejectWithValue(value, meta);
              },
              fulfillWithValue: (value, meta) => {
                return new FulfillWithMeta(value, meta);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err) {
            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        }();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var asyncThunkSymbol = Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = {
  [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = ((ReducerType2) => {
  ReducerType2["reducer"] = "reducer";
  ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
  ReducerType2["asyncThunk"] = "asyncThunk";
  return ReducerType2;
})(ReducerType || {});
function getType(slice, actionKey) {
  return `${slice}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  var _a;
  const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
  return function createSlice2(options) {
    const {
      name,
      reducerPath = name
    } = options;
    if (!name) {
      throw new Error(false ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
    }
    if (typeof process !== "undefined" && true) {
      if (options.initialState === void 0) {
        console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
      }
    }
    const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(false ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(false ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer2) {
        context.sliceCaseReducersByName[name2] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (true) {
        if (typeof options.extraReducers === "object") {
          throw new Error(false ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m of actionMatchers) {
          builder.addMatcher(m.matcher, m.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          } else if (true) {
            throw new Error(false ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map = {};
          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {
            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);
          }
          return map;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice = {
      name,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config);
        return {
          ...slice,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (true) {
        throw new Error(false ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(false ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(false ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop,
    pending: pending || noop,
    rejected: rejected || noop,
    settled: settled || noop
  });
}
function noop() {
}
var task = "task";
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = `task-${cancelled}`;
var taskCompleted = `task-${completed}`;
var listenerCancelled = `${listener}-${cancelled}`;
var listenerCompleted = `${listener}-${completed}`;
var TaskAbortError = class {
  constructor(code) {
    __publicField(this, "name", "TaskAbortError");
    __publicField(this, "message");
    this.code = code;
    this.message = `${task} ${cancelled} (reason: ${code})`;
  }
};
var assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new TypeError(false ? formatProdErrorMessage(32) : `${expected} is not a function`);
  }
};
var noop2 = () => {
};
var catchRejection = (promise, onError = noop2) => {
  promise.catch(onError);
  return promise;
};
var addAbortSignalListener = (abortSignal, callback) => {
  abortSignal.addEventListener("abort", callback, {
    once: true
  });
  return () => abortSignal.removeEventListener("abort", callback);
};
var abortControllerWithReason = (abortController, reason) => {
  const signal = abortController.signal;
  if (signal.aborted) {
    return;
  }
  if (!("reason" in signal)) {
    Object.defineProperty(signal, "reason", {
      enumerable: true,
      value: reason,
      configurable: true,
      writable: true
    });
  }
  ;
  abortController.abort(reason);
};
var validateActive = (signal) => {
  if (signal.aborted) {
    const {
      reason
    } = signal;
    throw new TaskAbortError(reason);
  }
};
function raceWithSignal(signal, promise) {
  let cleanup = noop2;
  return new Promise((resolve, reject) => {
    const notifyRejection = () => reject(new TaskAbortError(signal.reason));
    if (signal.aborted) {
      notifyRejection();
      return;
    }
    cleanup = addAbortSignalListener(signal, notifyRejection);
    promise.finally(() => cleanup()).then(resolve, reject);
  }).finally(() => {
    cleanup = noop2;
  });
}
var runTask = async (task2, cleanUp) => {
  try {
    await Promise.resolve();
    const value = await task2();
    return {
      status: "ok",
      value
    };
  } catch (error) {
    return {
      status: error instanceof TaskAbortError ? "cancelled" : "rejected",
      error
    };
  } finally {
    cleanUp == null ? void 0 : cleanUp();
  }
};
var createPause = (signal) => {
  return (promise) => {
    return catchRejection(raceWithSignal(signal, promise).then((output) => {
      validateActive(signal);
      return output;
    }));
  };
};
var createDelay = (signal) => {
  const pause = createPause(signal);
  return (timeoutMs) => {
    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
  };
};
var {
  assign
} = Object;
var INTERNAL_NIL_TOKEN = {};
var alm = "listenerMiddleware";
var createFork = (parentAbortSignal, parentBlockingPromises) => {
  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));
  return (taskExecutor, opts) => {
    assertFunction(taskExecutor, "taskExecutor");
    const childAbortController = new AbortController();
    linkControllers(childAbortController);
    const result = runTask(async () => {
      validateActive(parentAbortSignal);
      validateActive(childAbortController.signal);
      const result2 = await taskExecutor({
        pause: createPause(childAbortController.signal),
        delay: createDelay(childAbortController.signal),
        signal: childAbortController.signal
      });
      validateActive(childAbortController.signal);
      return result2;
    }, () => abortControllerWithReason(childAbortController, taskCompleted));
    if (opts == null ? void 0 : opts.autoJoin) {
      parentBlockingPromises.push(result.catch(noop2));
    }
    return {
      result: createPause(parentAbortSignal)(result),
      cancel() {
        abortControllerWithReason(childAbortController, taskCancelled);
      }
    };
  };
};
var createTakePattern = (startListening, signal) => {
  const take = async (predicate, timeout) => {
    validateActive(signal);
    let unsubscribe = () => {
    };
    const tuplePromise = new Promise((resolve, reject) => {
      let stopListening = startListening({
        predicate,
        effect: (action, listenerApi) => {
          listenerApi.unsubscribe();
          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);
        }
      });
      unsubscribe = () => {
        stopListening();
        reject();
      };
    });
    const promises = [tuplePromise];
    if (timeout != null) {
      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));
    }
    try {
      const output = await raceWithSignal(signal, Promise.race(promises));
      validateActive(signal);
      return output;
    } finally {
      unsubscribe();
    }
  };
  return (predicate, timeout) => catchRejection(take(predicate, timeout));
};
var getListenerEntryPropsFrom = (options) => {
  let {
    type,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options;
  if (type) {
    predicate = createAction(type).match;
  } else if (actionCreator) {
    type = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) {
  } else {
    throw new Error(false ? formatProdErrorMessage(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  }
  assertFunction(effect, "options.listener");
  return {
    predicate,
    type,
    effect
  };
};
var createListenerEntry = assign((options) => {
  const {
    type,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options);
  const entry = {
    id: nanoid(),
    effect,
    type,
    predicate,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(false ? formatProdErrorMessage(22) : "Unsubscribe not initialized");
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
var findListenerEntry = (listenerMap, options) => {
  const {
    type,
    effect,
    predicate
  } = getListenerEntryPropsFrom(options);
  return Array.from(listenerMap.values()).find((entry) => {
    const matchPredicateOrType = typeof type === "string" ? entry.type === type : entry.predicate === predicate;
    return matchPredicateOrType && entry.effect === effect;
  });
};
var cancelActiveListeners = (entry) => {
  entry.pending.forEach((controller) => {
    abortControllerWithReason(controller, listenerCancelled);
  });
};
var createClearListenerMiddleware = (listenerMap) => {
  return () => {
    listenerMap.forEach(cancelActiveListeners);
    listenerMap.clear();
  };
};
var safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
  try {
    errorHandler(errorToNotify, errorInfo);
  } catch (errorHandlerError) {
    setTimeout(() => {
      throw errorHandlerError;
    }, 0);
  }
};
var addListener = assign(createAction(`${alm}/add`), {
  withTypes: () => addListener
});
var clearAllListeners = createAction(`${alm}/removeAll`);
var removeListener = assign(createAction(`${alm}/remove`), {
  withTypes: () => removeListener
});
var defaultErrorHandler = (...args) => {
  console.error(`${alm}/error`, ...args);
};
var createListenerMiddleware = (middlewareOptions = {}) => {
  const listenerMap = /* @__PURE__ */ new Map();
  const {
    extra,
    onError = defaultErrorHandler
  } = middlewareOptions;
  assertFunction(onError, "onError");
  const insertEntry = (entry) => {
    entry.unsubscribe = () => listenerMap.delete(entry.id);
    listenerMap.set(entry.id, entry);
    return (cancelOptions) => {
      entry.unsubscribe();
      if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {
        cancelActiveListeners(entry);
      }
    };
  };
  const startListening = (options) => {
    const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);
    return insertEntry(entry);
  };
  assign(startListening, {
    withTypes: () => startListening
  });
  const stopListening = (options) => {
    const entry = findListenerEntry(listenerMap, options);
    if (entry) {
      entry.unsubscribe();
      if (options.cancelActive) {
        cancelActiveListeners(entry);
      }
    }
    return !!entry;
  };
  assign(stopListening, {
    withTypes: () => stopListening
  });
  const notifyListener = async (entry, action, api, getOriginalState) => {
    const internalTaskController = new AbortController();
    const take = createTakePattern(startListening, internalTaskController.signal);
    const autoJoinPromises = [];
    try {
      entry.pending.add(internalTaskController);
      await Promise.resolve(entry.effect(
        action,
        // Use assign() rather than ... to avoid extra helper functions added to bundle
        assign({}, api, {
          getOriginalState,
          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),
          take,
          delay: createDelay(internalTaskController.signal),
          pause: createPause(internalTaskController.signal),
          extra,
          signal: internalTaskController.signal,
          fork: createFork(internalTaskController.signal, autoJoinPromises),
          unsubscribe: entry.unsubscribe,
          subscribe: () => {
            listenerMap.set(entry.id, entry);
          },
          cancelActiveListeners: () => {
            entry.pending.forEach((controller, _, set2) => {
              if (controller !== internalTaskController) {
                abortControllerWithReason(controller, listenerCancelled);
                set2.delete(controller);
              }
            });
          },
          cancel: () => {
            abortControllerWithReason(internalTaskController, listenerCancelled);
            entry.pending.delete(internalTaskController);
          },
          throwIfCancelled: () => {
            validateActive(internalTaskController.signal);
          }
        })
      ));
    } catch (listenerError) {
      if (!(listenerError instanceof TaskAbortError)) {
        safelyNotifyError(onError, listenerError, {
          raisedBy: "effect"
        });
      }
    } finally {
      await Promise.all(autoJoinPromises);
      abortControllerWithReason(internalTaskController, listenerCompleted);
      entry.pending.delete(internalTaskController);
    }
  };
  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
  const middleware = (api) => (next) => (action) => {
    if (!isAction(action)) {
      return next(action);
    }
    if (addListener.match(action)) {
      return startListening(action.payload);
    }
    if (clearAllListeners.match(action)) {
      clearListenerMiddleware();
      return;
    }
    if (removeListener.match(action)) {
      return stopListening(action.payload);
    }
    let originalState = api.getState();
    const getOriginalState = () => {
      if (originalState === INTERNAL_NIL_TOKEN) {
        throw new Error(false ? formatProdErrorMessage(23) : `${alm}: getOriginalState can only be called synchronously`);
      }
      return originalState;
    };
    let result;
    try {
      result = next(action);
      if (listenerMap.size > 0) {
        const currentState = api.getState();
        const listenerEntries = Array.from(listenerMap.values());
        for (const entry of listenerEntries) {
          let runListener = false;
          try {
            runListener = entry.predicate(action, currentState, originalState);
          } catch (predicateError) {
            runListener = false;
            safelyNotifyError(onError, predicateError, {
              raisedBy: "predicate"
            });
          }
          if (!runListener) {
            continue;
          }
          notifyListener(entry, action, api, getOriginalState);
        }
      }
    } finally {
      originalState = INTERNAL_NIL_TOKEN;
    }
    return result;
  };
  return {
    middleware,
    startListening,
    stopListening,
    clearListeners: clearListenerMiddleware
  };
};
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");

// node_modules/uuid/dist/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version2, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version2;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL2;

// node_modules/uuid/dist/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/v4.js
function _v4(options, buf, offset) {
  var _a;
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default = v4;

// node_modules/uuid/dist/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/@coveo/explorer-messenger/dist/messenger.js
function createExplorerMessenger() {
  const isBrowser4 = typeof window !== "undefined";
  return {
    sendMessage(message) {
      isBrowser4 && window.postMessage(message, "*");
    }
  };
}

// node_modules/@coveo/relay/lib/npm/relay.mjs
function emit({ config, environment, event, listenerManager }) {
  const { url, token, mode } = config;
  const isEnabled = mode !== "disabled";
  if (isEnabled) {
    listenerManager.call(event);
    environment.send(url, token, event);
  }
}
var clientIdKey = "visitorId";
function createClientIdManager(environmentManager) {
  return {
    getClientId: () => {
      const environment = environmentManager.get();
      const storage = environment.storage;
      const existingClientId = storage.getItem(clientIdKey);
      const clientId = existingClientId && validate_default(existingClientId) ? existingClientId : environment.generateUUID();
      storage.setItem(clientIdKey, clientId);
      return clientId;
    }
  };
}
var version = "1.2.15";
var UTF8_HIGH_BIT = 128;
var UTF8_HEADER_2 = 192;
var UTF8_HEADER_3 = 224;
var UTF8_HEADER_4 = 240;
var UTF8_HEADER_4_MASK = 248;
function utf8ByteCountFromFirstByte(firstByte) {
  if ((firstByte & UTF8_HEADER_4_MASK) === UTF8_HEADER_4) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_4) === UTF8_HEADER_3) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_3) === UTF8_HEADER_2) {
    return 2;
  }
  return 1;
}
function truncateUrl(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT) != UTF8_HIGH_BIT) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_2) != UTF8_HIGH_BIT) {
      if (limit - end >= utf8ByteCountFromFirstByte(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
function getEventConfig(config) {
  const { trackingId } = config;
  return { trackingId };
}
function getSource(config) {
  return (config.source || []).concat([`relay@${version}`]);
}
function createMeta(type, config, environment, clientIdManager) {
  const { getReferrer: getReferrer2, getLocation, getUserAgent } = environment;
  const eventConfig = getEventConfig(config);
  const clientId = clientIdManager.getClientId();
  return Object.freeze({
    type,
    config: eventConfig,
    ts: Date.now(),
    source: getSource(config),
    clientId,
    userAgent: getUserAgent(),
    referrer: truncate(getReferrer2()),
    location: truncate(getLocation())
  });
}
function truncate(url) {
  const limit = 1024;
  return url !== null ? truncateUrl(url, limit) : null;
}
function createRelayEvent(type, payload, config, environment, clientIdManager) {
  return {
    ...payload,
    meta: createMeta(type, config, environment, clientIdManager)
  };
}
var ANY_EVENT_TYPE = "*";
function createListenerManager() {
  const listeners = [];
  function getListenerIndex({ type, callback }) {
    return listeners.findIndex((listener2) => listener2.type === type && listener2.callback === callback);
  }
  function isMatchesType(listener2, type) {
    return listener2.type === "*" || type === listener2.type;
  }
  function add(listener2) {
    if (getListenerIndex(listener2) < 0) {
      listeners.push(listener2);
    }
    return () => remove(listener2.type, listener2.callback);
  }
  function call(event) {
    listeners.forEach((listener2) => {
      if (isMatchesType(listener2, event.meta.type)) {
        try {
          listener2.callback(event);
        } catch (e) {
          console.error(e);
        }
      }
    });
  }
  function removeMultiple(type) {
    if (type === ANY_EVENT_TYPE) {
      listeners.length = 0;
    } else {
      for (let i = listeners.length - 1; i >= 0; i--) {
        if (listeners[i].type === type) {
          listeners.splice(i, 1);
        }
      }
    }
  }
  function removeOne(listener2) {
    const index = getListenerIndex(listener2);
    if (index >= 0) {
      listeners.splice(index, 1);
    }
  }
  function remove(type, callback) {
    if (callback) {
      removeOne({ type, callback });
    } else {
      removeMultiple(type);
    }
  }
  return {
    add,
    call,
    remove
  };
}
function pick({ url, token, trackingId, ...rest }) {
  return Object.freeze({
    url,
    token,
    trackingId,
    ...!!rest.mode && { mode: rest.mode },
    ...!!rest.source && { source: rest.source },
    ...!!rest.environment && { environment: rest.environment }
  });
}
function createConfigManager(initialConfig) {
  let _config = pick(initialConfig);
  return {
    get: () => _config,
    update: (updatedConfig) => {
      _config = pick({ ..._config, ...updatedConfig });
    }
  };
}
var cookieManager = createCookieManager();
function createCookieManager() {
  const prefix = "coveo_";
  const getDomain = (host) => {
    const parts = host.split(".").slice(-2);
    return parts.length == 2 ? parts.join(".") : "";
  };
  return {
    getItem(key) {
      const cookiePrefix = `${prefix}${key}=`;
      const cookieArray = document.cookie.split(";");
      for (const cookie of cookieArray) {
        const prettifyCookie = cookie.replace(/^\s+/, "");
        if (prettifyCookie.lastIndexOf(cookiePrefix, 0) === 0) {
          return prettifyCookie.substring(cookiePrefix.length, prettifyCookie.length);
        }
      }
      return null;
    },
    setItem(key, data, expire) {
      const domain = getDomain(window.location.hostname);
      const expireSection = `;expires=${new Date((/* @__PURE__ */ new Date()).getTime() + expire).toUTCString()}`;
      const domainSection = domain ? `;domain=${domain}` : "";
      document.cookie = `${prefix}${key}=${data}${expireSection}${domainSection};path=/;SameSite=Lax`;
    },
    removeItem(key) {
      this.setItem(key, "", -1);
    }
  };
}
function createBrowserStorage() {
  return {
    getItem(key) {
      return cookieManager.getItem(key) || localStorage.getItem(key);
    },
    removeItem(key) {
      cookieManager.removeItem(key);
      localStorage.removeItem(key);
    },
    setItem(key, data) {
      const oneYear = 31556952e3;
      localStorage.setItem(key, data);
      cookieManager.setItem(key, data, oneYear);
    }
  };
}
function getReferrer() {
  const referrer = document.referrer;
  return referrer === "" ? null : referrer;
}
function buildBrowserEnvironment() {
  return {
    runtime: "browser",
    send: (url, token, event) => {
      const response = navigator.sendBeacon(`${url}?access_token=${token}`, new Blob([JSON.stringify([event])], {
        type: "application/json"
      }));
      const messenger = createExplorerMessenger();
      messenger.sendMessage({ kind: "EVENT_PROTOCOL", event, url, token });
      if (!response) {
        throw new Error(`Failed to send the event(s) because the payload size exceeded the maximum allowed size (32 KB). Please contact support if the problem persists.`);
      }
    },
    getReferrer: () => getReferrer(),
    getLocation: () => window.location.href,
    getUserAgent: () => navigator.userAgent,
    generateUUID: () => v4_default(),
    storage: createBrowserStorage()
  };
}
function localStorageAvailable() {
  try {
    const x = "__storage_test__";
    localStorage.setItem(x, x);
    localStorage.removeItem(x);
    return true;
  } catch (e) {
    return e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    localStorage && localStorage.length !== 0;
  }
}
function createNullStorage() {
  return {
    getItem() {
      return null;
    },
    removeItem() {
      return;
    },
    setItem() {
      return;
    }
  };
}
function buildNullEnvironment() {
  return {
    runtime: "null",
    send: () => void 0,
    getReferrer: () => null,
    getLocation: () => null,
    getUserAgent: () => null,
    generateUUID: () => "",
    storage: createNullStorage()
  };
}
function buildEnvironment(configManager) {
  const active = configManager.get().mode !== "disabled";
  const environmentFromConfig = configManager.get().environment;
  const nullEnvironment = buildNullEnvironment();
  if (active && environmentFromConfig) {
    return {
      storage: nullEnvironment.storage,
      ...environmentFromConfig,
      runtime: "custom"
    };
  }
  if (active && isBrowser2() && localStorageAvailable()) {
    return buildBrowserEnvironment();
  }
  return nullEnvironment;
}
function isBrowser2() {
  try {
    return typeof window === "object";
  } catch {
    return false;
  }
}
function createEnvironmentManager(configManager) {
  return {
    get: () => Object.freeze(buildEnvironment(configManager))
  };
}
function createRelay(initialConfig) {
  const configManager = createConfigManager(initialConfig);
  const listenerManager = createListenerManager();
  const environmentManager = createEnvironmentManager(configManager);
  const clientIdManager = createClientIdManager(environmentManager);
  return {
    emit: (type, payload) => {
      const config = configManager.get();
      const environment = environmentManager.get();
      const event = createRelayEvent(type, payload, config, environment, clientIdManager);
      return emit({
        config,
        environment,
        event,
        listenerManager
      });
    },
    getMeta: (type) => createMeta(type, configManager.get(), environmentManager.get(), clientIdManager),
    on: (type, callback) => listenerManager.add({ type, callback }),
    off: (type, callback) => listenerManager.remove(type, callback),
    updateConfig: (config) => configManager.update(config),
    version
  };
}

// node_modules/@coveo/headless/dist/esm/utils/runtime.js
function isBrowser3() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}

// node_modules/@coveo/headless/dist/esm/utils/version.js
var VERSION = "3.45.0";
var COVEO_FRAMEWORK = ["@coveo/atomic", "@coveo/quantic"];

// node_modules/@coveo/headless/dist/esm/api/analytics/analytics-selectors.js
var getAnalyticsSource = createSelector((state) => state.source, (source) => Object.entries(source).map(([frameworkName, frameworkVersion]) => `${frameworkName}@${frameworkVersion}`).concat(`@coveo/headless@${VERSION}`));

// node_modules/@coveo/headless/dist/esm/api/analytics/analytics-relay-client.js
var getRelayInstanceFromState = createSelector((state) => state.configuration.organizationId, (state) => state.configuration.environment, (state) => state.configuration.accessToken, (state) => state.configuration.analytics, (state) => getAnalyticsSource(state.configuration.analytics), (_state, navigatorContextProvider) => navigatorContextProvider, (organizationId, platformEnvironment, token, { trackingId, apiBaseUrl, enabled }, source, navigatorContextProvider) => {
  const environment = getEnvironment(navigatorContextProvider);
  return createRelay({
    mode: enabled ? "emit" : "disabled",
    url: apiBaseUrl ?? getAnalyticsNextApiBaseUrl(organizationId, platformEnvironment),
    token,
    trackingId: trackingId ?? null,
    source,
    environment
  });
});
var noopRelayEnvironment = {
  generateUUID: () => "",
  getLocation: () => null,
  getReferrer: () => null,
  getUserAgent: () => null,
  send: () => {
  },
  storage: {
    getItem: () => null,
    setItem: () => {
    },
    removeItem: () => {
    }
  }
};
var getEnvironment = (customProvider) => {
  if (!customProvider) {
    return void 0;
  }
  const customContext = customProvider();
  const baseEnvironment = isBrowser3() ? buildBrowserEnvironment() : noopRelayEnvironment;
  return {
    ...baseEnvironment,
    generateUUID: () => customContext.clientId,
    getLocation: () => customContext.location,
    getReferrer: () => customContext.referrer,
    getUserAgent: () => customContext.userAgent
  };
};

// node_modules/coveo.analytics/dist/browser.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var EventType;
(function(EventType2) {
  EventType2["search"] = "search";
  EventType2["click"] = "click";
  EventType2["custom"] = "custom";
  EventType2["view"] = "view";
  EventType2["collect"] = "collect";
})(EventType || (EventType = {}));
function hasWindow() {
  return typeof window !== "undefined";
}
function hasNavigator() {
  return typeof navigator !== "undefined";
}
function hasDocument() {
  return typeof document !== "undefined";
}
function hasLocalStorage() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage() {
  return hasNavigator() && navigator.cookieEnabled;
}
var eventTypesForDefaultValues = [EventType.click, EventType.custom, EventType.search, EventType.view];
var addDefaultValues = (eventType, payload) => {
  return eventTypesForDefaultValues.indexOf(eventType) !== -1 ? Object.assign({ language: hasDocument() ? document.documentElement.lang : "unknown", userAgent: hasNavigator() ? navigator.userAgent : "unknown" }, payload) : payload;
};
var Cookie = class _Cookie {
  static set(name, value, expire) {
    var domain, expirationDate, domainParts, host;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    host = window.location.hostname;
    if (host.indexOf(".") === -1) {
      writeCookie(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    var cookiePrefix = name + "=";
    var cookieArray = document.cookie.split(";");
    for (var i = 0; i < cookieArray.length; i++) {
      var cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}
function getAvailableStorage() {
  if (hasLocalStorage()) {
    return localStorage;
  }
  if (hasCookieStorage()) {
    return new CookieStorage();
  }
  if (hasSessionStorage()) {
    return sessionStorage;
  }
  return new NullStorage();
}
var CookieStorage = class _CookieStorage2 {
  getItem(key) {
    return Cookie.get(`${_CookieStorage2.prefix}${key}`);
  }
  removeItem(key) {
    Cookie.erase(`${_CookieStorage2.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie.set(`${_CookieStorage2.prefix}${key}`, data, expire);
  }
};
CookieStorage.prefix = "coveo_";
var CookieAndLocalStorage = class {
  constructor() {
    this.cookieStorage = new CookieStorage();
  }
  getItem(key) {
    return localStorage.getItem(key) || this.cookieStorage.getItem(key);
  }
  removeItem(key) {
    this.cookieStorage.removeItem(key);
    localStorage.removeItem(key);
  }
  setItem(key, data) {
    localStorage.setItem(key, data);
    this.cookieStorage.setItem(key, data, 31556926e3);
  }
};
var NullStorage = class {
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, data) {
  }
};
var STORE_KEY = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE = 1e3 * 60;
var MAX_VALUE_SIZE = 75;
var HistoryStore = class {
  constructor(store) {
    this.store = store || getAvailableStorage();
  }
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    let currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory != null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  addElementAsync(elem) {
    return __awaiter(this, void 0, void 0, function* () {
      elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
      elem = this.cropQueryElement(this.stripEmptyQuery(elem));
      let currentHistory = yield this.getHistoryWithInternalTimeAsync();
      if (currentHistory != null) {
        if (this.isValidEntry(elem)) {
          this.setHistory([elem].concat(currentHistory));
        }
      } else {
        this.setHistory([elem]);
      }
    });
  }
  getHistory() {
    const history3 = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history3));
  }
  getHistoryAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      const history3 = yield this.getHistoryWithInternalTimeAsync();
      return this.stripEmptyQueries(this.stripInternalTime(history3));
    });
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  getHistoryWithInternalTimeAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const elements = yield this.store.getItem(STORE_KEY);
        if (elements) {
          return JSON.parse(elements);
        } else {
          return [];
        }
      } catch (e) {
        return [];
      }
    });
  }
  setHistory(history3) {
    try {
      this.store.setItem(STORE_KEY, JSON.stringify(history3.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    let currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE);
    }
    return part;
  }
  isValidEntry(elem) {
    let lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value == elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE;
    }
    return true;
  }
  stripInternalTime(history3) {
    if (Array.isArray(history3)) {
      return history3.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history3) {
    return history3.map((part) => this.stripEmptyQuery(part));
  }
};
var history = Object.freeze({
  __proto__: null,
  HistoryStore,
  MAX_NUMBER_OF_HISTORY_ELEMENTS,
  MAX_VALUE_SIZE,
  MIN_THRESHOLD_FOR_DUPLICATE_VALUE,
  STORE_KEY,
  default: HistoryStore
});
var enhanceViewEvent = (eventType, payload) => __awaiter(void 0, void 0, void 0, function* () {
  if (eventType === EventType.view) {
    yield addPageViewToHistory(payload.contentIdValue);
    return Object.assign({ location: window.location.toString(), referrer: document.referrer, title: document.title }, payload);
  }
  return payload;
});
var addPageViewToHistory = (pageViewValue) => __awaiter(void 0, void 0, void 0, function* () {
  const store = new HistoryStore();
  const historyElement = {
    name: "PageView",
    value: pageViewValue,
    time: (/* @__PURE__ */ new Date()).toISOString()
  };
  yield store.addElementAsync(historyElement);
});
var getRandomValues2;
var rnds82 = new Uint8Array(16);
function rng2() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds82);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate2(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex2 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex2.push((i + 256).toString(16).slice(1));
}
function unsafeStringify2(arr, offset = 0) {
  return byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + "-" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + "-" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + "-" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + "-" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]];
}
function parse2(uuid) {
  if (!validate2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v352(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes2(value);
    }
    if (typeof namespace === "string") {
      namespace = parse2(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify2(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS2;
  generateUUID.URL = URL$1;
  return generateUUID;
}
var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID: randomUUID2
};
function v42(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify2(rnds);
}
function f2(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL2(x, n) {
  return x << n | x >>> 32 - n;
}
function sha12(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL2(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL2(a, 5) + f2(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL2(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var v52 = v352("v5", 80, sha12);
var uuidv5 = v52;
var libVersion = "2.30.52";
var getFormattedLocation = (location) => `${location.protocol}//${location.hostname}${location.pathname.indexOf("/") === 0 ? location.pathname : `/${location.pathname}`}${location.search}`;
var BasePluginEventTypes = {
  pageview: "pageview",
  event: "event"
};
var Plugin = class {
  constructor({ client, uuidGenerator = v42 }) {
    this.client = client;
    this.uuidGenerator = uuidGenerator;
  }
};
var BasePlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v42 }) {
    super({ client, uuidGenerator });
    this.actionData = {};
    this.pageViewId = uuidGenerator();
    this.nextPageViewId = this.pageViewId;
    this.currentLocation = getFormattedLocation(window.location);
    this.lastReferrer = hasDocument() ? document.referrer : "";
    this.addHooks();
  }
  getApi(name) {
    switch (name) {
      case "setAction":
        return this.setAction;
      default:
        return null;
    }
  }
  setAction(action, options) {
    this.action = action;
    this.actionData = options;
  }
  clearData() {
    this.clearPluginData();
    this.action = void 0;
    this.actionData = {};
  }
  getLocationInformation(eventType, payload) {
    return Object.assign({ hitType: eventType }, this.getNextValues(eventType, payload));
  }
  updateLocationInformation(eventType, payload) {
    this.updateLocationForNextPageView(eventType, payload);
  }
  getDefaultContextInformation(eventType) {
    const documentContext = {
      title: hasDocument() ? document.title : "",
      encoding: hasDocument() ? document.characterSet : "UTF-8"
    };
    const screenContext = {
      screenResolution: `${screen.width}x${screen.height}`,
      screenColor: `${screen.colorDepth}-bit`
    };
    const navigatorContext = {
      language: navigator.language,
      userAgent: navigator.userAgent
    };
    const eventContext = {
      time: Date.now(),
      eventId: this.uuidGenerator()
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, eventContext), screenContext), navigatorContext), documentContext);
  }
  updateLocationForNextPageView(eventType, payload) {
    const { pageViewId, referrer, location } = this.getNextValues(eventType, payload);
    this.lastReferrer = referrer;
    this.pageViewId = pageViewId;
    this.currentLocation = location;
    if (eventType === BasePluginEventTypes.pageview) {
      this.nextPageViewId = this.uuidGenerator();
      this.hasSentFirstPageView = true;
    }
  }
  getNextValues(eventType, payload) {
    return {
      pageViewId: eventType === BasePluginEventTypes.pageview ? this.nextPageViewId : this.pageViewId,
      referrer: eventType === BasePluginEventTypes.pageview && this.hasSentFirstPageView ? this.currentLocation : this.lastReferrer,
      location: eventType === BasePluginEventTypes.pageview ? this.getCurrentLocationFromPayload(payload) : this.currentLocation
    };
  }
  getCurrentLocationFromPayload(payload) {
    if (!!payload.page) {
      const removeStartingSlash = (page) => page.replace(/^\/?(.*)$/, "/$1");
      const extractHostnamePart = (location) => location.split("/").slice(0, 3).join("/");
      return `${extractHostnamePart(this.currentLocation)}${removeStartingSlash(payload.page)}`;
    } else {
      return getFormattedLocation(window.location);
    }
  }
};
var CoveoLinkParam = class _CoveoLinkParam {
  constructor(clientId, timestamp) {
    if (!validate2(clientId))
      throw Error("Not a valid uuid");
    this.clientId = clientId;
    this.creationDate = Math.floor(timestamp / 1e3);
  }
  toString() {
    return this.clientId.replace(/-/g, "") + "." + this.creationDate.toString();
  }
  get expired() {
    const age = Math.floor(Date.now() / 1e3) - this.creationDate;
    return age < 0 || age > _CoveoLinkParam.expirationTime;
  }
  validate(referrerString, referrerList) {
    return !this.expired && this.matchReferrer(referrerString, referrerList);
  }
  matchReferrer(referrerString, referrerList) {
    try {
      const url = new URL(referrerString);
      return referrerList.some((value) => {
        const hostRegExp = new RegExp(value.replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*") + "$");
        return hostRegExp.test(url.host);
      });
    } catch (error) {
      return false;
    }
  }
  static fromString(input) {
    const parts = input.split(".");
    if (parts.length !== 2) {
      return null;
    }
    const [clientIdPart, creationDate] = parts;
    if (clientIdPart.length !== 32 || isNaN(parseInt(creationDate))) {
      return null;
    }
    const clientId = clientIdPart.substring(0, 8) + "-" + clientIdPart.substring(8, 12) + "-" + clientIdPart.substring(12, 16) + "-" + clientIdPart.substring(16, 20) + "-" + clientIdPart.substring(20, 32);
    if (validate2(clientId)) {
      return new _CoveoLinkParam(clientId, Number.parseInt(creationDate) * 1e3);
    } else {
      return null;
    }
  }
};
CoveoLinkParam.cvo_cid = "cvo_cid";
CoveoLinkParam.expirationTime = 120;
var LinkPlugin = class extends Plugin {
  constructor({ client, uuidGenerator = v42 }) {
    super({ client, uuidGenerator });
  }
  getApi(name) {
    switch (name) {
      case "decorate":
        return this.decorate;
      case "acceptFrom":
        return this.acceptFrom;
      default:
        return null;
    }
  }
  decorate(urlString) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.client.getCurrentVisitorId) {
        throw new Error("Could not retrieve current clientId");
      }
      try {
        const url = new URL(urlString);
        const clientId = yield this.client.getCurrentVisitorId();
        url.searchParams.set(CoveoLinkParam.cvo_cid, new CoveoLinkParam(clientId, Date.now()).toString());
        return url.toString();
      } catch (error) {
        throw new Error("Invalid URL provided");
      }
    });
  }
  acceptFrom(acceptedReferrers) {
    this.client.setAcceptedLinkReferrers(acceptedReferrers);
  }
};
LinkPlugin.Id = "link";
var keysOf = Object.keys;
function isObject(o) {
  return o !== null && typeof o === "object" && !Array.isArray(o);
}
var UTF8_HIGH_BIT2 = 128;
var UTF8_HEADER_22 = 192;
var UTF8_HEADER_32 = 224;
var UTF8_HEADER_42 = 240;
function utf8ByteCountFromFirstByte2(firstByte) {
  if ((firstByte & 248) === UTF8_HEADER_42) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_42) === UTF8_HEADER_32) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_32) === UTF8_HEADER_22) {
    return 2;
  }
  return 1;
}
function truncateUrl2(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT2) != UTF8_HIGH_BIT2) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_22) != UTF8_HIGH_BIT2) {
      if (limit - end >= utf8ByteCountFromFirstByte2(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
var ticketKeysMapping = {
  id: "svc_ticket_id",
  subject: "svc_ticket_subject",
  description: "svc_ticket_description",
  category: "svc_ticket_category",
  productId: "svc_ticket_product_id",
  custom: "svc_ticket_custom"
};
var ticketKeysMappingValues = keysOf(ticketKeysMapping).map((key) => ticketKeysMapping[key]);
var ticketSubKeysMatchGroup = [...ticketKeysMappingValues].join("|");
var ticketKeyRegex = new RegExp(`^(${ticketSubKeysMatchGroup}$)`);
var serviceActionsKeysMapping = {
  svcAction: "svc_action",
  svcActionData: "svc_action_data"
};
var convertTicketToMeasurementProtocol = (ticket) => {
  return keysOf(ticket).filter((key) => ticket[key] !== void 0).reduce((mappedTicket, key) => {
    const newKey = ticketKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedTicket), { [newKey]: ticket[key] });
  }, {});
};
var isTicketKey = (key) => ticketKeyRegex.test(key);
var isServiceKey = [isTicketKey];
var productKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  price: "pr",
  quantity: "qt",
  coupon: "cc",
  position: "ps",
  group: "group"
};
var impressionKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  position: "ps",
  price: "pr",
  group: "group"
};
var productActionsKeysMapping = {
  action: "pa",
  list: "pal",
  listSource: "pls"
};
var transactionActionsKeysMapping = {
  id: "ti",
  revenue: "tr",
  tax: "tt",
  shipping: "ts",
  coupon: "tcc",
  affiliation: "ta",
  step: "cos",
  option: "col"
};
var coveoCommerceExtensionKeys = [
  "loyaltyCardId",
  "loyaltyTier",
  "thirdPartyPersona",
  "companyName",
  "favoriteStore",
  "storeName",
  "userIndustry",
  "userRole",
  "userDepartment",
  "businessUnit"
];
var quoteActionsKeysMapping = {
  id: "quoteId",
  affiliation: "quoteAffiliation"
};
var reviewActionsKeysMapping = {
  id: "reviewId",
  rating: "reviewRating",
  comment: "reviewComment"
};
var commerceActionKeysMappingPerAction = {
  add: productActionsKeysMapping,
  bookmark_add: productActionsKeysMapping,
  bookmark_remove: productActionsKeysMapping,
  click: productActionsKeysMapping,
  checkout: productActionsKeysMapping,
  checkout_option: productActionsKeysMapping,
  detail: productActionsKeysMapping,
  impression: productActionsKeysMapping,
  remove: productActionsKeysMapping,
  refund: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  purchase: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  quickview: productActionsKeysMapping,
  quote: Object.assign(Object.assign({}, productActionsKeysMapping), quoteActionsKeysMapping),
  review: Object.assign(Object.assign({}, productActionsKeysMapping), reviewActionsKeysMapping)
};
var productKeysMappingValues = keysOf(productKeysMapping).map((key) => productKeysMapping[key]);
var impressionKeysMappingValues = keysOf(impressionKeysMapping).map((key) => impressionKeysMapping[key]);
var productActionsKeysMappingValues = keysOf(productActionsKeysMapping).map((key) => productActionsKeysMapping[key]);
var transactionActionsKeysMappingValues = keysOf(transactionActionsKeysMapping).map((key) => transactionActionsKeysMapping[key]);
var reviewKeysMappingValues = keysOf(reviewActionsKeysMapping).map((key) => reviewActionsKeysMapping[key]);
var quoteKeysMappingValues = keysOf(quoteActionsKeysMapping).map((key) => quoteActionsKeysMapping[key]);
var productSubKeysMatchGroup = [...productKeysMappingValues, "custom"].join("|");
var impressionSubKeysMatchGroup = [...impressionKeysMappingValues, "custom"].join("|");
var productPrefixMatchGroup = "(pr[0-9]+)";
var impressionPrefixMatchGroup = "(il[0-9]+pi[0-9]+)";
var productKeyRegex = new RegExp(`^${productPrefixMatchGroup}(${productSubKeysMatchGroup})$`);
var impressionKeyRegex = new RegExp(`^(${impressionPrefixMatchGroup}(${impressionSubKeysMatchGroup}))|(il[0-9]+nm)$`);
var productActionsKeyRegex = new RegExp(`^(${productActionsKeysMappingValues.join("|")})$`);
var transactionActionsKeyRegex = new RegExp(`^(${transactionActionsKeysMappingValues.join("|")})$`);
var customProductKeyRegex = new RegExp(`^${productPrefixMatchGroup}custom$`);
var customImpressionKeyRegex = new RegExp(`^${impressionPrefixMatchGroup}custom$`);
var coveoCommerceExtensionKeysRegex = new RegExp(`^(${[...coveoCommerceExtensionKeys, ...reviewKeysMappingValues, ...quoteKeysMappingValues].join("|")})$`);
var isProductKey = (key) => productKeyRegex.test(key);
var isImpressionKey = (key) => impressionKeyRegex.test(key);
var isProductActionsKey = (key) => productActionsKeyRegex.test(key);
var isTransactionActionsKeyRegex = (key) => transactionActionsKeyRegex.test(key);
var isCoveoCommerceExtensionKey = (key) => coveoCommerceExtensionKeysRegex.test(key);
var isCommerceKey = [
  isImpressionKey,
  isProductKey,
  isProductActionsKey,
  isTransactionActionsKeyRegex,
  isCoveoCommerceExtensionKey
];
var isCustomCommerceKey = [customProductKeyRegex, customImpressionKeyRegex];
var globalParamKeysMapping = {
  anonymizeIp: "aip"
};
var eventKeysMapping = {
  eventCategory: "ec",
  eventAction: "ea",
  eventLabel: "el",
  eventValue: "ev",
  page: "dp",
  visitorId: "cid",
  clientId: "cid",
  userId: "uid",
  currencyCode: "cu"
};
var contextInformationMapping = {
  hitType: "t",
  pageViewId: "pid",
  encoding: "de",
  location: "dl",
  referrer: "dr",
  screenColor: "sd",
  screenResolution: "sr",
  title: "dt",
  userAgent: "ua",
  language: "ul",
  eventId: "z",
  time: "tm"
};
var coveoExtensionsKeys = [
  "contentId",
  "contentIdKey",
  "contentType",
  "searchHub",
  "tab",
  "searchUid",
  "permanentId",
  "contentLocale",
  "trackingId"
];
var baseMeasurementProtocolKeysMapping = Object.assign(Object.assign(Object.assign(Object.assign({}, globalParamKeysMapping), eventKeysMapping), contextInformationMapping), coveoExtensionsKeys.reduce((all, key) => Object.assign(Object.assign({}, all), { [key]: key }), {}));
var measurementProtocolKeysMapping = Object.assign(Object.assign({}, baseMeasurementProtocolKeysMapping), serviceActionsKeysMapping);
var convertKeysToMeasurementProtocol = (params) => {
  const keysMappingForAction = !!params.action && commerceActionKeysMappingPerAction[params.action] || {};
  return keysOf(params).reduce((mappedKeys, key) => {
    const newKey = keysMappingForAction[key] || measurementProtocolKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedKeys), { [newKey]: params[key] });
  }, {});
};
var measurementProtocolKeysMappingValues = keysOf(measurementProtocolKeysMapping).map((key) => measurementProtocolKeysMapping[key]);
var isKnownMeasurementProtocolKey = (key) => measurementProtocolKeysMappingValues.indexOf(key) !== -1;
var isCustomKey = (key) => key === "custom";
var isMeasurementProtocolKey = (key) => {
  return [...isCommerceKey, ...isServiceKey, isKnownMeasurementProtocolKey, isCustomKey].some((test) => test(key));
};
var convertCustomMeasurementProtocolKeys = (data) => {
  return keysOf(data).reduce((all, current2) => {
    const match = getFirstCustomMeasurementProtocolKeyMatch(current2);
    if (match) {
      return Object.assign(Object.assign({}, all), convertCustomObject(match, data[current2]));
    } else {
      return Object.assign(Object.assign({}, all), { [current2]: data[current2] });
    }
  }, {});
};
var getFirstCustomMeasurementProtocolKeyMatch = (key) => {
  let matchedKey = void 0;
  [...isCustomCommerceKey].every((regex) => {
    var _a;
    matchedKey = (_a = regex.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
    return !Boolean(matchedKey);
  });
  return matchedKey;
};
var convertCustomObject = (prefix, customData) => {
  return keysOf(customData).reduce((allCustom, currentCustomKey) => Object.assign(Object.assign({}, allCustom), { [`${prefix}${currentCustomKey}`]: customData[currentCustomKey] }), {});
};
var AnalyticsBeaconClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, originalPayload) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isAvailable()) {
        throw new Error(`navigator.sendBeacon is not supported in this browser. Consider adding a polyfill like "sendbeacon-polyfill".`);
      }
      const { baseUrl, preprocessRequest } = this.opts;
      const paramsFragments = yield this.getQueryParamsForEventType(eventType);
      const { url, payload } = yield this.preProcessRequestAsPotentialJSONString(`${baseUrl}/analytics/${eventType}?${paramsFragments}`, originalPayload, preprocessRequest);
      const parsedRequestData = this.encodeForEventType(eventType, payload);
      const body = new Blob([parsedRequestData], {
        type: "application/x-www-form-urlencoded"
      });
      navigator.sendBeacon(url, body);
      return;
    });
  }
  isAvailable() {
    return "sendBeacon" in navigator;
  }
  deleteHttpCookieVisitorId() {
    return Promise.resolve();
  }
  preProcessRequestAsPotentialJSONString(originalURL, originalPayload, preprocessRequest) {
    return __awaiter(this, void 0, void 0, function* () {
      let returnedUrl = originalURL;
      let returnedPayload = originalPayload;
      if (preprocessRequest) {
        const processedRequest = yield preprocessRequest({ url: originalURL, body: JSON.stringify(originalPayload) }, "analyticsBeacon");
        const { url: processedURL, body: processedBody } = processedRequest;
        returnedUrl = processedURL || originalURL;
        try {
          returnedPayload = JSON.parse(processedBody);
        } catch (e) {
          console.error("Unable to process the request body as a JSON string", e);
        }
      }
      return {
        payload: returnedPayload,
        url: returnedUrl
      };
    });
  }
  encodeForEventType(eventType, payload) {
    return this.isEventTypeLegacy(eventType) ? this.encodeEventToJson(eventType, payload) : this.encodeEventToJson(eventType, payload, this.opts.token);
  }
  getQueryParamsForEventType(eventType) {
    return __awaiter(this, void 0, void 0, function* () {
      const { token, visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return [
        token && this.isEventTypeLegacy(eventType) ? `access_token=${token}` : "",
        visitorId ? `visitorId=${visitorId}` : "",
        "discardVisitInfo=true"
      ].filter((p) => !!p).join("&");
    });
  }
  isEventTypeLegacy(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  encodeEventToJson(eventType, payload, access_token) {
    let encoded = `${eventType}Event=${encodeURIComponent(JSON.stringify(payload))}`;
    if (access_token) {
      encoded = `access_token=${encodeURIComponent(access_token)}&${encoded}`;
    }
    return encoded;
  }
};
var NoopAnalyticsClient = class {
  sendEvent(_, __) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
};
var fetch$1 = globalThis.fetch;
var AnalyticsFetchClient = class {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl, visitorIdProvider, preprocessRequest } = this.opts;
      const visitorIdParam = this.shouldAppendVisitorId(eventType) ? yield this.getVisitorIdParam() : "";
      const defaultOptions = {
        url: `${baseUrl}/analytics/${eventType}${visitorIdParam}`,
        credentials: "include",
        mode: "cors",
        headers: this.getHeaders(),
        method: "POST",
        body: JSON.stringify(payload)
      };
      const _a = Object.assign(Object.assign({}, defaultOptions), preprocessRequest ? yield preprocessRequest(defaultOptions, "analyticsFetch") : {}), { url } = _a, fetchData = __rest(_a, ["url"]);
      let response;
      try {
        response = yield fetch$1(url, fetchData);
      } catch (error) {
        console.error("An error has occured when sending the event.", error);
        return;
      }
      if (response.ok) {
        const visit = yield response.json();
        if (visit.visitorId) {
          visitorIdProvider.setCurrentVisitorId(visit.visitorId);
        }
        return visit;
      } else {
        try {
          response.json();
        } catch (_b) {
        }
        console.error(`An error has occured when sending the "${eventType}" event.`, response, payload);
        throw new Error(`An error has occurred when sending the "${eventType}" event. Check the console logs for more details.`);
      }
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl } = this.opts;
      const url = `${baseUrl}/analytics/visit`;
      yield fetch$1(url, { headers: this.getHeaders(), method: "DELETE" });
    });
  }
  shouldAppendVisitorId(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  getVisitorIdParam() {
    return __awaiter(this, void 0, void 0, function* () {
      const { visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return visitorId ? `?visitor=${visitorId}` : "";
    });
  }
  getHeaders() {
    const { token } = this.opts;
    return Object.assign(Object.assign({}, token ? { Authorization: `Bearer ${token}` } : {}), { "Content-Type": `application/json` });
  }
};
var BrowserRuntime = class {
  constructor(clientOptions, getUnprocessedRequests) {
    if (hasLocalStorage() && hasCookieStorage()) {
      this.storage = new CookieAndLocalStorage();
    } else if (hasLocalStorage()) {
      this.storage = localStorage;
    } else {
      console.warn("BrowserRuntime detected no valid storage available.", this);
      this.storage = new NullStorage();
    }
    this.client = new AnalyticsFetchClient(clientOptions);
    this.beaconClient = new AnalyticsBeaconClient(clientOptions);
    window.addEventListener("beforeunload", () => {
      const requests = getUnprocessedRequests();
      for (let { eventType, payload } of requests) {
        this.beaconClient.sendEvent(eventType, payload);
      }
    });
  }
  getClientDependingOnEventType(eventType) {
    return eventType === "click" && this.beaconClient.isAvailable() ? this.beaconClient : this.client;
  }
};
var NodeJSRuntime = class {
  constructor(clientOptions, storage) {
    this.storage = storage || new NullStorage();
    this.client = new AnalyticsFetchClient(clientOptions);
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var NoopRuntime = class {
  constructor() {
    this.storage = new NullStorage();
    this.client = new NoopAnalyticsClient();
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
};
var API_KEY_PREFIX = "xx";
var isApiKey = (token) => (token === null || token === void 0 ? void 0 : token.startsWith(API_KEY_PREFIX)) || false;
var ReactNativeRuntimeWarning = `
        We've detected you're using React Native but have not provided the corresponding runtime, 
        for an optimal experience please use the "coveo.analytics/react-native" subpackage.
        Follow the Readme on how to set it up: https://github.com/coveo/coveo.analytics.js#using-react-native
    `;
function isReactNative() {
  return typeof navigator != "undefined" && navigator.product == "ReactNative";
}
var doNotTrackValues2 = ["1", 1, "yes", true];
function doNotTrack2() {
  const checks = [];
  if (hasWindow()) {
    checks.push(window.doNotTrack);
  }
  if (hasNavigator()) {
    checks.push(navigator.doNotTrack, navigator.msDoNotTrack, navigator.globalPrivacyControl);
  }
  return checks.some((value) => doNotTrackValues2.indexOf(value) !== -1);
}
var Version = "v15";
var Endpoints = {
  default: "https://analytics.cloud.coveo.com/rest/ua",
  production: "https://analytics.cloud.coveo.com/rest/ua",
  hipaa: "https://analyticshipaa.cloud.coveo.com/rest/ua"
};
function buildBaseUrl(endpoint = Endpoints.default, apiVersion = Version, isCustomEndpoint = false) {
  endpoint = endpoint.replace(/\/$/, "");
  if (isCustomEndpoint) {
    return `${endpoint}/${apiVersion}`;
  }
  const hasUARestEndpoint = endpoint.endsWith("/rest") || endpoint.endsWith("/rest/ua");
  return `${endpoint}${hasUARestEndpoint ? "" : "/rest"}/${apiVersion}`;
}
var COVEO_NAMESPACE = "38824e1f-37f5-42d3-8372-a4b8fa9df946";
var CoveoAnalyticsClient = class {
  get defaultOptions() {
    return {
      endpoint: Endpoints.default,
      isCustomEndpoint: false,
      token: "",
      version: Version,
      beforeSendHooks: [],
      afterSendHooks: []
    };
  }
  get version() {
    return libVersion;
  }
  constructor(opts) {
    this.acceptedLinkReferrers = [];
    if (!opts) {
      throw new Error("You have to pass options to this constructor");
    }
    this.options = Object.assign(Object.assign({}, this.defaultOptions), opts);
    this.visitorId = "";
    this.bufferedRequests = [];
    this.beforeSendHooks = [enhanceViewEvent, addDefaultValues].concat(this.options.beforeSendHooks);
    this.afterSendHooks = this.options.afterSendHooks;
    this.eventTypeMapping = {};
    const clientsOptions = {
      baseUrl: this.baseUrl,
      token: this.options.token,
      visitorIdProvider: this,
      preprocessRequest: this.options.preprocessRequest
    };
    if (doNotTrack2()) {
      this.runtime = new NoopRuntime();
    } else {
      this.runtime = this.options.runtimeEnvironment || this.initRuntime(clientsOptions);
    }
    this.addEventTypeMapping(EventType.view, { newEventType: EventType.view, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.click, { newEventType: EventType.click, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.custom, { newEventType: EventType.custom, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.search, { newEventType: EventType.search, addClientIdParameter: true });
  }
  initRuntime(clientsOptions) {
    if (hasWindow() && hasDocument()) {
      return new BrowserRuntime(clientsOptions, () => {
        const copy = [...this.bufferedRequests];
        this.bufferedRequests = [];
        return copy;
      });
    } else if (isReactNative()) {
      console.warn(ReactNativeRuntimeWarning);
    }
    return new NodeJSRuntime(clientsOptions);
  }
  get storage() {
    return this.runtime.storage;
  }
  determineVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return hasWindow() && this.extractClientIdFromLink(window.location.href) || (yield this.storage.getItem("visitorId")) || v42();
      } catch (err) {
        console.log("Could not get visitor ID from the current runtime environment storage. Using a random ID instead.", err);
        return v42();
      }
    });
  }
  getCurrentVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.visitorId) {
        const id = yield this.determineVisitorId();
        yield this.setCurrentVisitorId(id);
      }
      return this.visitorId;
    });
  }
  setCurrentVisitorId(visitorId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.visitorId = visitorId;
      yield this.storage.setItem("visitorId", visitorId);
    });
  }
  setClientId(value, namespace) {
    return __awaiter(this, void 0, void 0, function* () {
      if (validate2(value)) {
        this.setCurrentVisitorId(value.toLowerCase());
      } else {
        if (!namespace) {
          throw Error("Cannot generate uuid client id without a specific namespace string.");
        }
        this.setCurrentVisitorId(uuidv5(value, uuidv5(namespace, COVEO_NAMESPACE)));
      }
    });
  }
  getParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.resolveParameters(eventType, ...payload);
    });
  }
  getPayload(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      return yield this.resolvePayloadForParameters(eventType, parametersToSend);
    });
  }
  get currentVisitorId() {
    const visitorId = this.visitorId || this.storage.getItem("visitorId");
    if (typeof visitorId !== "string") {
      this.setCurrentVisitorId(v42());
    }
    return this.visitorId;
  }
  set currentVisitorId(visitorId) {
    this.visitorId = visitorId;
    this.storage.setItem("visitorId", visitorId);
  }
  extractClientIdFromLink(urlString) {
    if (doNotTrack2()) {
      return null;
    }
    try {
      const linkParam = new URL(urlString).searchParams.get(CoveoLinkParam.cvo_cid);
      if (linkParam == null) {
        return null;
      }
      const linker = CoveoLinkParam.fromString(linkParam);
      if (!linker || !hasDocument() || !linker.validate(document.referrer, this.acceptedLinkReferrers)) {
        return null;
      }
      return linker.clientId;
    } catch (error) {
    }
    return null;
  }
  resolveParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { variableLengthArgumentsNames = [], addVisitorIdParameter = false, usesMeasurementProtocol = false, addClientIdParameter = false } = this.eventTypeMapping[eventType] || {};
      const processVariableArgumentNamesStep = (currentPayload) => variableLengthArgumentsNames.length > 0 ? this.parseVariableArgumentsPayload(variableLengthArgumentsNames, currentPayload) : currentPayload[0];
      const addVisitorIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, currentPayload), { visitorId: addVisitorIdParameter ? yield this.getCurrentVisitorId() : "" });
      });
      const addClientIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        if (addClientIdParameter) {
          return Object.assign(Object.assign({}, currentPayload), { clientId: yield this.getCurrentVisitorId() });
        }
        return currentPayload;
      });
      const setAnonymousUserStep = (currentPayload) => usesMeasurementProtocol ? this.ensureAnonymousUserWhenUsingApiKey(currentPayload) : currentPayload;
      const processBeforeSendHooksStep = (currentPayload) => this.beforeSendHooks.reduce((promisePayload, current2) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield promisePayload;
        return yield current2(eventType, payload2);
      }), currentPayload);
      const parametersToSend = yield [
        processVariableArgumentNamesStep,
        addVisitorIdStep,
        addClientIdStep,
        setAnonymousUserStep,
        processBeforeSendHooksStep
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield payloadPromise;
        return yield step(payload2);
      }), Promise.resolve(payload));
      return parametersToSend;
    });
  }
  resolvePayloadForParameters(eventType, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const { usesMeasurementProtocol = false } = this.eventTypeMapping[eventType] || {};
      const addTrackingIdStep = (currentPayload) => this.setTrackingIdIfTrackingIdNotPresent(currentPayload);
      const cleanPayloadStep = (currentPayload) => this.removeEmptyPayloadValues(currentPayload, eventType);
      const validateParams = (currentPayload) => this.validateParams(currentPayload, eventType);
      const processMeasurementProtocolConversionStep = (currentPayload) => usesMeasurementProtocol ? convertKeysToMeasurementProtocol(currentPayload) : currentPayload;
      const removeUnknownParameters = (currentPayload) => usesMeasurementProtocol ? this.removeUnknownParameters(currentPayload) : currentPayload;
      const processCustomParameters = (currentPayload) => usesMeasurementProtocol ? this.processCustomParameters(currentPayload) : this.mapCustomParametersToCustomData(currentPayload);
      const payloadToSend = yield [
        addTrackingIdStep,
        cleanPayloadStep,
        validateParams,
        processMeasurementProtocolConversionStep,
        removeUnknownParameters,
        processCustomParameters
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload = yield payloadPromise;
        return yield step(payload);
      }), Promise.resolve(parameters));
      return payloadToSend;
    });
  }
  makeEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { newEventType: eventTypeToSend = eventType } = this.eventTypeMapping[eventType] || {};
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      const payloadToSend = yield this.resolvePayloadForParameters(eventType, parametersToSend);
      return {
        eventType: eventTypeToSend,
        payload: payloadToSend,
        log: (remainingPayload) => __awaiter(this, void 0, void 0, function* () {
          this.bufferedRequests.push({
            eventType: eventTypeToSend,
            payload: Object.assign(Object.assign({}, payloadToSend), remainingPayload)
          });
          yield Promise.all(this.afterSendHooks.map((hook) => hook(eventType, Object.assign(Object.assign({}, parametersToSend), remainingPayload))));
          yield this.deferExecution();
          return yield this.sendFromBuffer();
        })
      };
    });
  }
  sendEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeEvent(eventType, ...payload)).log({});
    });
  }
  deferExecution() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  sendFromBuffer() {
    return __awaiter(this, void 0, void 0, function* () {
      const popped = this.bufferedRequests.shift();
      if (popped) {
        const { eventType, payload } = popped;
        return this.runtime.getClientDependingOnEventType(eventType).sendEvent(eventType, payload);
      }
    });
  }
  clear() {
    this.storage.removeItem("visitorId");
    const store = new HistoryStore();
    store.clear();
  }
  deleteHttpOnlyVisitorId() {
    this.runtime.client.deleteHttpCookieVisitorId();
  }
  makeSearchEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.search, request);
    });
  }
  sendSearchEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeSearchEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeClickEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.click, request);
    });
  }
  sendClickEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeClickEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeCustomEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.custom, request);
    });
  }
  sendCustomEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { lastSearchQueryUid } = _a, preparedRequest = __rest(_a, ["lastSearchQueryUid"]);
      return (yield this.makeCustomEvent(preparedRequest)).log({ lastSearchQueryUid });
    });
  }
  makeViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.view, request);
    });
  }
  sendViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeViewEvent(request)).log({});
    });
  }
  getVisit() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/visit`);
      const visit = yield response.json();
      this.visitorId = visit.visitorId;
      return visit;
    });
  }
  getHealth() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/monitoring/health`);
      return yield response.json();
    });
  }
  registerBeforeSendEventHook(hook) {
    this.beforeSendHooks.push(hook);
  }
  registerAfterSendEventHook(hook) {
    this.afterSendHooks.push(hook);
  }
  addEventTypeMapping(eventType, eventConfig) {
    this.eventTypeMapping[eventType] = eventConfig;
  }
  setAcceptedLinkReferrers(hosts) {
    if (Array.isArray(hosts) && hosts.every((host) => typeof host == "string"))
      this.acceptedLinkReferrers = hosts;
    else
      throw Error("Parameter should be an array of domain strings");
  }
  parseVariableArgumentsPayload(fieldsOrder, payload) {
    const parsedArguments = {};
    for (let i = 0, length = payload.length; i < length; i++) {
      const currentArgument = payload[i];
      if (typeof currentArgument === "string") {
        parsedArguments[fieldsOrder[i]] = currentArgument;
      } else if (typeof currentArgument === "object") {
        return Object.assign(Object.assign({}, parsedArguments), currentArgument);
      }
    }
    return parsedArguments;
  }
  isKeyAllowedEmpty(evtType, key) {
    const keysThatCanBeEmpty = {
      [EventType.search]: ["queryText"]
    };
    const match = keysThatCanBeEmpty[evtType] || [];
    return match.indexOf(key) !== -1;
  }
  removeEmptyPayloadValues(payload, eventType) {
    const isNotEmptyValue = (value) => typeof value !== "undefined" && value !== null && value !== "";
    return Object.keys(payload).filter((key) => this.isKeyAllowedEmpty(eventType, key) || isNotEmptyValue(payload[key])).reduce((newPayload, key) => Object.assign(Object.assign({}, newPayload), { [key]: payload[key] }), {});
  }
  removeUnknownParameters(payload) {
    const newPayload = Object.keys(payload).filter((key) => {
      if (isMeasurementProtocolKey(key)) {
        return true;
      } else {
        console.log(key, "is not processed by coveoua");
      }
    }).reduce((newPayload2, key) => Object.assign(Object.assign({}, newPayload2), { [key]: payload[key] }), {});
    return newPayload;
  }
  processCustomParameters(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    let lowercasedCustom = {};
    if (custom && isObject(custom)) {
      lowercasedCustom = this.lowercaseKeys(custom);
    }
    const newPayload = convertCustomMeasurementProtocolKeys(rest);
    return Object.assign(Object.assign({}, lowercasedCustom), newPayload);
  }
  mapCustomParametersToCustomData(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    if (custom && isObject(custom)) {
      const lowercasedCustom = this.lowercaseKeys(custom);
      return Object.assign(Object.assign({}, rest), { customData: Object.assign(Object.assign({}, lowercasedCustom), payload.customData) });
    } else {
      return payload;
    }
  }
  lowercaseKeys(custom) {
    const keys2 = Object.keys(custom);
    let result = {};
    keys2.forEach((key) => {
      result[key.toLowerCase()] = custom[key];
    });
    return result;
  }
  validateParams(payload, eventType) {
    const { anonymizeIp } = payload, rest = __rest(payload, ["anonymizeIp"]);
    if (anonymizeIp !== void 0) {
      if (["0", "false", "undefined", "null", "{}", "[]", ""].indexOf(`${anonymizeIp}`.toLowerCase()) == -1) {
        rest.anonymizeIp = 1;
      }
    }
    if (eventType == EventType.view || eventType == EventType.click || eventType == EventType.search || eventType == EventType.custom) {
      rest.originLevel3 = this.limit(rest.originLevel3, 1024);
    }
    if (eventType == EventType.view) {
      rest.location = this.limit(rest.location, 1024);
    }
    if (eventType == "pageview" || eventType == "event") {
      rest.referrer = this.limit(rest.referrer, 2048);
      rest.location = this.limit(rest.location, 2048);
      rest.page = this.limit(rest.page, 2048);
    }
    return rest;
  }
  ensureAnonymousUserWhenUsingApiKey(payload) {
    const { userId } = payload, rest = __rest(payload, ["userId"]);
    if (isApiKey(this.options.token) && !userId) {
      rest["userId"] = "anonymous";
      return rest;
    } else {
      return payload;
    }
  }
  setTrackingIdIfTrackingIdNotPresent(payload) {
    const { trackingId } = payload, rest = __rest(payload, ["trackingId"]);
    if (trackingId) {
      return payload;
    }
    if (rest.hasOwnProperty("custom") && isObject(rest.custom)) {
      if (rest.custom.hasOwnProperty("context_website") || rest.custom.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.custom.context_website || rest.custom.siteName;
      }
    }
    if (rest.hasOwnProperty("customData") && isObject(rest.customData)) {
      if (rest.customData.hasOwnProperty("context_website") || rest.customData.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.customData.context_website || rest.customData.siteName;
      }
    }
    return rest;
  }
  limit(input, length) {
    return typeof input === "string" ? truncateUrl2(input, length) : input;
  }
  get baseUrl() {
    return buildBaseUrl(this.options.endpoint, this.options.version, this.options.isCustomEndpoint);
  }
};
var InsightEvents;
(function(InsightEvents2) {
  InsightEvents2["contextChanged"] = "contextChanged";
  InsightEvents2["expandToFullUI"] = "expandToFullUI";
  InsightEvents2["openUserActions"] = "openUserActions";
  InsightEvents2["showPrecedingSessions"] = "showPrecedingSessions";
  InsightEvents2["showFollowingSessions"] = "showFollowingSessions";
  InsightEvents2["clickViewedDocument"] = "clickViewedDocument";
  InsightEvents2["clickPageView"] = "clickPageView";
  InsightEvents2["createArticle"] = "createArticle";
})(InsightEvents || (InsightEvents = {}));
var SearchPageEvents;
(function(SearchPageEvents3) {
  SearchPageEvents3["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents3["interfaceChange"] = "interfaceChange";
  SearchPageEvents3["didyoumeanAutomatic"] = "didyoumeanAutomatic";
  SearchPageEvents3["didyoumeanClick"] = "didyoumeanClick";
  SearchPageEvents3["resultsSort"] = "resultsSort";
  SearchPageEvents3["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents3["searchboxClear"] = "searchboxClear";
  SearchPageEvents3["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents3["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents3["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents3["documentQuickview"] = "documentQuickview";
  SearchPageEvents3["documentOpen"] = "documentOpen";
  SearchPageEvents3["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents3["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents3["searchFromLink"] = "searchFromLink";
  SearchPageEvents3["triggerNotify"] = "notify";
  SearchPageEvents3["triggerExecute"] = "execute";
  SearchPageEvents3["triggerQuery"] = "query";
  SearchPageEvents3["undoTriggerQuery"] = "undoQuery";
  SearchPageEvents3["triggerRedirect"] = "redirect";
  SearchPageEvents3["pagerResize"] = "pagerResize";
  SearchPageEvents3["pagerNumber"] = "pagerNumber";
  SearchPageEvents3["pagerNext"] = "pagerNext";
  SearchPageEvents3["pagerPrevious"] = "pagerPrevious";
  SearchPageEvents3["pagerScrolling"] = "pagerScrolling";
  SearchPageEvents3["staticFilterClearAll"] = "staticFilterClearAll";
  SearchPageEvents3["staticFilterSelect"] = "staticFilterSelect";
  SearchPageEvents3["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents3["facetClearAll"] = "facetClearAll";
  SearchPageEvents3["facetSearch"] = "facetSearch";
  SearchPageEvents3["facetSelect"] = "facetSelect";
  SearchPageEvents3["facetSelectAll"] = "facetSelectAll";
  SearchPageEvents3["facetDeselect"] = "facetDeselect";
  SearchPageEvents3["facetExclude"] = "facetExclude";
  SearchPageEvents3["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents3["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents3["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents3["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents3["queryError"] = "query";
  SearchPageEvents3["queryErrorBack"] = "errorBack";
  SearchPageEvents3["queryErrorClear"] = "errorClearQuery";
  SearchPageEvents3["queryErrorRetry"] = "errorRetry";
  SearchPageEvents3["recommendation"] = "recommendation";
  SearchPageEvents3["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents3["recommendationOpen"] = "recommendationOpen";
  SearchPageEvents3["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents3["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents3["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents3["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents3["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents3["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents3["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents3["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents3["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents3["showMoreSmartSnippetSuggestion"] = "showMoreSmartSnippetSuggestion";
  SearchPageEvents3["showLessSmartSnippetSuggestion"] = "showLessSmartSnippetSuggestion";
  SearchPageEvents3["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents3["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents3["openSmartSnippetInlineLink"] = "openSmartSnippetInlineLink";
  SearchPageEvents3["openSmartSnippetSuggestionInlineLink"] = "openSmartSnippetSuggestionInlineLink";
  SearchPageEvents3["recentQueryClick"] = "recentQueriesClick";
  SearchPageEvents3["clearRecentQueries"] = "clearRecentQueries";
  SearchPageEvents3["recentResultClick"] = "recentResultClick";
  SearchPageEvents3["clearRecentResults"] = "clearRecentResults";
  SearchPageEvents3["noResultsBack"] = "noResultsBack";
  SearchPageEvents3["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents3["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents3["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents3["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents3["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents3["caseAttach"] = "caseAttach";
  SearchPageEvents3["caseDetach"] = "caseDetach";
  SearchPageEvents3["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents3["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents3["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents3["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents3["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents3["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents3["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents3["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents3["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents3["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents3["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents3["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents3["rephraseGeneratedAnswer"] = "rephraseGeneratedAnswer";
  SearchPageEvents3["generatedAnswerFeedbackSubmitV2"] = "generatedAnswerFeedbackSubmitV2";
  SearchPageEvents3["generatedAnswerCitationClick"] = "generatedAnswerCitationClick";
  SearchPageEvents3["generatedAnswerCitationDocumentAttach"] = "generatedAnswerCitationDocumentAttach";
})(SearchPageEvents || (SearchPageEvents = {}));
var CustomEventsTypes = {
  [SearchPageEvents.triggerNotify]: "queryPipelineTriggers",
  [SearchPageEvents.triggerExecute]: "queryPipelineTriggers",
  [SearchPageEvents.triggerQuery]: "queryPipelineTriggers",
  [SearchPageEvents.triggerRedirect]: "queryPipelineTriggers",
  [SearchPageEvents.queryErrorBack]: "errors",
  [SearchPageEvents.queryErrorClear]: "errors",
  [SearchPageEvents.queryErrorRetry]: "errors",
  [SearchPageEvents.pagerNext]: "getMoreResults",
  [SearchPageEvents.pagerPrevious]: "getMoreResults",
  [SearchPageEvents.pagerNumber]: "getMoreResults",
  [SearchPageEvents.pagerResize]: "getMoreResults",
  [SearchPageEvents.pagerScrolling]: "getMoreResults",
  [SearchPageEvents.facetSearch]: "facet",
  [SearchPageEvents.facetShowLess]: "facet",
  [SearchPageEvents.facetShowMore]: "facet",
  [SearchPageEvents.recommendation]: "recommendation",
  [SearchPageEvents.likeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.dislikeSmartSnippet]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippet]: "smartSnippet",
  [SearchPageEvents.collapseSmartSnippet]: "smartSnippet",
  [SearchPageEvents.openSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.closeSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents.sendSmartSnippetReason]: "smartSnippet",
  [SearchPageEvents.expandSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.collapseSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showMoreSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.showLessSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents.clearRecentQueries]: "recentQueries",
  [SearchPageEvents.recentResultClick]: "recentlyClickedDocuments",
  [SearchPageEvents.clearRecentResults]: "recentlyClickedDocuments",
  [SearchPageEvents.showLessFoldedResults]: "folding",
  [SearchPageEvents.caseDetach]: "case",
  [SearchPageEvents.likeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.dislikeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents.openGeneratedAnswerSource]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerStreamEnd]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerSourceHover]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCopyToClipboard]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerHideAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerShowAnswers]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerExpand]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerCollapse]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmit]: "generatedAnswer",
  [SearchPageEvents.generatedAnswerFeedbackSubmitV2]: "generatedAnswer",
  [InsightEvents.expandToFullUI]: "interface",
  [InsightEvents.openUserActions]: "User Actions",
  [InsightEvents.showPrecedingSessions]: "User Actions",
  [InsightEvents.showFollowingSessions]: "User Actions",
  [InsightEvents.clickViewedDocument]: "User Actions",
  [InsightEvents.clickPageView]: "User Actions",
  [InsightEvents.createArticle]: "createArticle"
};
var NoopAnalytics = class {
  constructor() {
    this.runtime = new NoopRuntime();
    this.currentVisitorId = "";
  }
  getPayload() {
    return Promise.resolve();
  }
  getParameters() {
    return Promise.resolve();
  }
  makeEvent(eventType) {
    return Promise.resolve({ eventType, payload: null, log: () => Promise.resolve() });
  }
  sendEvent() {
    return Promise.resolve();
  }
  makeSearchEvent() {
    return this.makeEvent(EventType.search);
  }
  sendSearchEvent() {
    return Promise.resolve();
  }
  makeClickEvent() {
    return this.makeEvent(EventType.click);
  }
  sendClickEvent() {
    return Promise.resolve();
  }
  makeCustomEvent() {
    return this.makeEvent(EventType.custom);
  }
  sendCustomEvent() {
    return Promise.resolve();
  }
  makeViewEvent() {
    return this.makeEvent(EventType.view);
  }
  sendViewEvent() {
    return Promise.resolve();
  }
  getVisit() {
    return Promise.resolve({ id: "", visitorId: "" });
  }
  getHealth() {
    return Promise.resolve({ status: "" });
  }
  registerBeforeSendEventHook() {
  }
  registerAfterSendEventHook() {
  }
  addEventTypeMapping() {
  }
  get version() {
    return libVersion;
  }
};
function filterConsecutiveRepeatedValues(rawData) {
  let prev = "";
  return rawData.filter((value) => {
    const isDifferent = value !== prev;
    prev = value;
    return isDifferent;
  });
}
function removeSemicolons(rawData) {
  return rawData.map((value) => {
    return value.replace(/;/g, "");
  });
}
function getDataString(data) {
  const ANALYTICS_LENGTH_LIMIT = 256;
  const formattedData = data.join(";");
  if (formattedData.length <= ANALYTICS_LENGTH_LIMIT) {
    return formattedData;
  }
  return getDataString(data.slice(1));
}
var formatArrayForCoveoCustomData = (rawData) => {
  const dataWithoutSemicolons = removeSemicolons(rawData);
  const dataWithoutRepeatedValues = filterConsecutiveRepeatedValues(dataWithoutSemicolons);
  return getDataString(dataWithoutRepeatedValues);
};
function formatOmniboxMetadata(meta) {
  const partialQueries = typeof meta.partialQueries === "string" ? meta.partialQueries : formatArrayForCoveoCustomData(meta.partialQueries);
  const suggestions = typeof meta.suggestions === "string" ? meta.suggestions : formatArrayForCoveoCustomData(meta.suggestions);
  return Object.assign(Object.assign({}, meta), {
    partialQueries,
    suggestions
  });
}
var CoveoSearchPageClient = class {
  constructor(opts, provider) {
    this.opts = opts;
    this.provider = provider;
    const shouldDisableAnalytics = opts.enableAnalytics === false || doNotTrack2();
    this.coveoAnalyticsClient = shouldDisableAnalytics ? new NoopAnalytics() : new CoveoAnalyticsClient(opts);
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.opts);
  }
  makeInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.interfaceLoad);
  }
  logInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents.recommendationInterfaceLoad);
  }
  logRecommendationInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendation() {
    return this.makeCustomEvent(SearchPageEvents.recommendation);
  }
  logRecommendation() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendation()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.recommendationOpen, info, identifier);
  }
  logRecommendationOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterClearAll, meta);
  }
  logStaticFilterClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterSelect, meta);
  }
  logStaticFilterSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.staticFilterDeselect, meta);
  }
  logStaticFilterDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFetchMoreResults() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling, { type: "getMoreResults" });
  }
  logFetchMoreResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFetchMoreResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeInterfaceChange(metadata) {
    return this.makeSearchEvent(SearchPageEvents.interfaceChange, metadata);
  }
  logInterfaceChange(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceChange(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanAutomatic() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanAutomatic);
  }
  logDidYouMeanAutomatic() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanAutomatic()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanClick() {
    return this.makeSearchEvent(SearchPageEvents.didyoumeanClick);
  }
  logDidYouMeanClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeResultsSort(metadata) {
    return this.makeSearchEvent(SearchPageEvents.resultsSort, metadata);
  }
  logResultsSort(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeResultsSort(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxSubmit() {
    return this.makeSearchEvent(SearchPageEvents.searchboxSubmit);
  }
  logSearchboxSubmit() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxSubmit()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxClear() {
    return this.makeSearchEvent(SearchPageEvents.searchboxClear);
  }
  logSearchboxClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxAsYouType() {
    return this.makeSearchEvent(SearchPageEvents.searchboxAsYouType);
  }
  logSearchboxAsYouType() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxAsYouType()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbFacet(metadata) {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbFacet, metadata);
  }
  logBreadcrumbFacet(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbFacet(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbResetAll() {
    return this.makeSearchEvent(SearchPageEvents.breadcrumbResetAll);
  }
  logBreadcrumbResetAll() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbResetAll()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentQuickview(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentQuickview, info, identifier);
  }
  logDocumentQuickview(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentQuickview(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.documentOpen, info, identifier);
  }
  logDocumentOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxAnalytics(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxAnalytics, formatOmniboxMetadata(meta));
  }
  logOmniboxAnalytics(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxAnalytics(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxFromLink(meta) {
    return this.makeSearchEvent(SearchPageEvents.omniboxFromLink, formatOmniboxMetadata(meta));
  }
  logOmniboxFromLink(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxFromLink(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchFromLink() {
    return this.makeSearchEvent(SearchPageEvents.searchFromLink);
  }
  logSearchFromLink() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchFromLink()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerNotify(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerNotify, meta);
  }
  logTriggerNotify(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerNotify(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerExecute(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerExecute, meta);
  }
  logTriggerExecute(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerExecute(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerQuery() {
    return this.makeCustomEvent(SearchPageEvents.triggerQuery, { query: this.provider.getSearchEventRequestPayload().queryText }, "queryPipelineTriggers");
  }
  logTriggerQuery() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerQuery()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeUndoTriggerQuery(meta) {
    return this.makeSearchEvent(SearchPageEvents.undoTriggerQuery, meta);
  }
  logUndoTriggerQuery(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeUndoTriggerQuery(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerRedirect(meta) {
    return this.makeCustomEvent(SearchPageEvents.triggerRedirect, Object.assign(Object.assign({}, meta), { query: this.provider.getSearchEventRequestPayload().queryText }));
  }
  logTriggerRedirect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerRedirect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerResize(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerResize, meta);
  }
  logPagerResize(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerResize(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNumber(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNumber, meta);
  }
  logPagerNumber(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNumber(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNext(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerNext, meta);
  }
  logPagerNext(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNext(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerPrevious(meta) {
    return this.makeCustomEvent(SearchPageEvents.pagerPrevious, meta);
  }
  logPagerPrevious(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerPrevious(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerScrolling() {
    return this.makeCustomEvent(SearchPageEvents.pagerScrolling);
  }
  logPagerScrolling() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerScrolling()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetClearAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetClearAll, meta);
  }
  logFacetClearAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetClearAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSearch(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSearch, meta);
  }
  logFacetSearch(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSearch(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelect, meta);
  }
  logFacetSelect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetDeselect(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetDeselect, meta);
  }
  logFacetDeselect(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetDeselect(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetExclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetExclude, meta);
  }
  logFacetExclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetExclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUnexclude(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUnexclude, meta);
  }
  logFacetUnexclude(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUnexclude(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelectAll(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetSelectAll, meta);
  }
  logFacetSelectAll(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelectAll(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUpdateSort(meta) {
    return this.makeSearchEvent(SearchPageEvents.facetUpdateSort, meta);
  }
  logFacetUpdateSort(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUpdateSort(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowMore(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowMore, meta);
  }
  logFacetShowMore(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowMore(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowLess(meta) {
    return this.makeCustomEvent(SearchPageEvents.facetShowLess, meta);
  }
  logFacetShowLess(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowLess(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryError(meta) {
    return this.makeCustomEvent(SearchPageEvents.queryError, meta);
  }
  logQueryError(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryError(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorBack);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorBack);
        })
      };
    });
  }
  logQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorRetry);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorRetry);
        })
      };
    });
  }
  logQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorRetry()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents.queryErrorClear);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents.queryErrorClear);
        })
      };
    });
  }
  logQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeLikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.likeSmartSnippet);
  }
  logLikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.dislikeSmartSnippet);
  }
  logDislikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeExpandSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippet);
  }
  logExpandSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippet);
  }
  logCollapseSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.openSmartSnippetFeedbackModal);
  }
  logOpenSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCloseSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents.closeSmartSnippetFeedbackModal);
  }
  logCloseSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCloseSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSmartSnippetFeedbackReason(reason, details) {
    return this.makeCustomEvent(SearchPageEvents.sendSmartSnippetReason, { reason, details });
  }
  logSmartSnippetFeedbackReason(reason, details) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSmartSnippetFeedbackReason(reason, details)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeExpandSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.expandSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logExpandSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.collapseSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logCollapseSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showMoreSmartSnippetSuggestion, snippet);
  }
  logShowMoreSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents.showLessSmartSnippetSuggestion, snippet);
  }
  logShowLessSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSource(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSource, info, identifier);
  }
  logOpenSmartSnippetSource(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSource(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSuggestionSource(info, snippet) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionSource, info, { contentIDKey: snippet.documentId.contentIdKey, contentIDValue: snippet.documentId.contentIdValue }, snippet);
  }
  makeCopyToClipboard(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.copyToClipboard, info, identifier);
  }
  logCopyToClipboard(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCopyToClipboard(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  logOpenSmartSnippetSuggestionSource(info, snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionSource(info, snippet)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetInlineLink, info, { contentIDKey: identifierAndLink.contentIDKey, contentIDValue: identifierAndLink.contentIDValue }, identifierAndLink);
  }
  logOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetInlineLink(info, identifierAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return this.makeClickEvent(SearchPageEvents.openSmartSnippetSuggestionInlineLink, info, {
      contentIDKey: snippetAndLink.documentId.contentIdKey,
      contentIDValue: snippetAndLink.documentId.contentIdValue
    }, snippetAndLink);
  }
  logOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRecentQueryClick() {
    return this.makeSearchEvent(SearchPageEvents.recentQueryClick);
  }
  logRecentQueryClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentQueryClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentQueries() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentQueries);
  }
  logClearRecentQueries() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentQueries()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecentResultClick(info, identifier) {
    return this.makeCustomEvent(SearchPageEvents.recentResultClick, { info, identifier });
  }
  logRecentResultClick(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentResultClick(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentResults() {
    return this.makeCustomEvent(SearchPageEvents.clearRecentResults);
  }
  logClearRecentResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeNoResultsBack() {
    return this.makeSearchEvent(SearchPageEvents.noResultsBack);
  }
  logNoResultsBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeNoResultsBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreFoldedResults(info, identifier) {
    return this.makeClickEvent(SearchPageEvents.showMoreFoldedResults, info, identifier);
  }
  logShowMoreFoldedResults(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreFoldedResults(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessFoldedResults() {
    return this.makeCustomEvent(SearchPageEvents.showLessFoldedResults);
  }
  logShowLessFoldedResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessFoldedResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeEventDescription(preparedEvent, actionCause) {
    var _a;
    return { actionCause, customData: (_a = preparedEvent.payload) === null || _a === void 0 ? void 0 : _a.customData };
  }
  makeCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      this.coveoAnalyticsClient.getParameters;
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const request = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), { eventType, eventValue: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      return (yield this.makeCustomEvent(event, metadata, eventType)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const payload = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), {
        eventType,
        eventValue
      });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(payload);
      return {
        description: this.makeEventDescription(preparedEvent, eventValue),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCustomEventWithType(eventValue, eventType, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  logSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchEvent(event, metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.getBaseSearchEventRequest(event, metadata);
      const preparedEvent = yield this.coveoAnalyticsClient.makeSearchEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  makeClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { queryPipeline: this.provider.getPipeline(), actionCause: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeClickEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClickEvent(event, info, identifier, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  getBaseSearchEventRequest(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      return Object.assign(Object.assign(Object.assign({}, yield this.getBaseEventRequest(Object.assign(Object.assign({}, metadata), (_b = (_a = this.provider).getGeneratedAnswerMetadata) === null || _b === void 0 ? void 0 : _b.call(_a)))), this.provider.getSearchEventRequestPayload()), { queryPipeline: this.provider.getPipeline(), actionCause: event });
    });
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      return Object.assign(Object.assign(Object.assign({}, this.getOrigins()), this.getSplitTestRun()), { customData, language: this.provider.getLanguage(), facetState: this.provider.getFacetState ? this.provider.getFacetState() : [], anonymous: this.provider.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getOrigins() {
    var _a, _b;
    return {
      originContext: (_b = (_a = this.provider).getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: this.provider.getOriginLevel1(),
      originLevel2: this.provider.getOriginLevel2(),
      originLevel3: this.provider.getOriginLevel3()
    };
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getSplitTestRun() {
    const splitTestRunName = this.provider.getSplitTestRunName ? this.provider.getSplitTestRunName() : "";
    const splitTestRunVersion = this.provider.getSplitTestRunVersion ? this.provider.getSplitTestRunVersion() : "";
    return Object.assign(Object.assign({}, splitTestRunName && { splitTestRunName }), splitTestRunVersion && { splitTestRunVersion });
  }
  makeLikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.likeGeneratedAnswer, metadata);
  }
  logLikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents.dislikeGeneratedAnswer, metadata);
  }
  logDislikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenGeneratedAnswerSource(metadata) {
    return this.makeCustomEvent(SearchPageEvents.openGeneratedAnswerSource, metadata);
  }
  logOpenGeneratedAnswerSource(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenGeneratedAnswerSource(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCitationClick(info, citation) {
    return this.makeClickEvent(SearchPageEvents.generatedAnswerCitationClick, Object.assign(Object.assign({}, info), { documentPosition: 1 }), { contentIDKey: citation.documentId.contentIdKey, contentIDValue: citation.documentId.contentIdValue }, citation);
  }
  logGeneratedAnswerCitationClick(info, citation) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCitationClick(info, citation)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerSourceHover(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerSourceHover, metadata);
  }
  logGeneratedAnswerSourceHover(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerSourceHover(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCopyToClipboard(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCopyToClipboard, metadata);
  }
  logGeneratedAnswerCopyToClipboard(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCopyToClipboard(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerHideAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerHideAnswers, metadata);
  }
  logGeneratedAnswerHideAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerHideAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerShowAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerShowAnswers, metadata);
  }
  logGeneratedAnswerShowAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerShowAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerExpand(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerExpand, metadata);
  }
  logGeneratedAnswerExpand(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerExpand(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerCollapse(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerCollapse, metadata);
  }
  logGeneratedAnswerCollapse(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCollapse(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerFeedbackSubmit(meta) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmit, meta);
  }
  logGeneratedAnswerFeedbackSubmit(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmit(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerFeedbackSubmitV2(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerFeedbackSubmitV2, metadata);
  }
  logGeneratedAnswerFeedbackSubmitV2(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmitV2(meta)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRephraseGeneratedAnswer(meta) {
    return this.makeSearchEvent(SearchPageEvents.rephraseGeneratedAnswer, meta);
  }
  logRephraseGeneratedAnswer(meta) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRephraseGeneratedAnswer(meta)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRetryGeneratedAnswer() {
    return this.makeSearchEvent(SearchPageEvents.retryGeneratedAnswer);
  }
  logRetryGeneratedAnswer() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRetryGeneratedAnswer()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerStreamEnd(metadata) {
    return this.makeCustomEvent(SearchPageEvents.generatedAnswerStreamEnd, metadata);
  }
  logGeneratedAnswerStreamEnd(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerStreamEnd(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
};
var SVCPluginEventTypes = Object.assign({}, BasePluginEventTypes);
var allSVCEventTypes = Object.keys(SVCPluginEventTypes).map((key) => SVCPluginEventTypes[key]);
var SVCPlugin = class extends BasePlugin {
  constructor({ client, uuidGenerator = v42 }) {
    super({ client, uuidGenerator });
    this.ticket = {};
  }
  getApi(name) {
    const superCall = super.getApi(name);
    if (superCall !== null)
      return superCall;
    switch (name) {
      case "setTicket":
        return this.setTicket;
      default:
        return null;
    }
  }
  addHooks() {
    this.addHooksForEvent();
    this.addHooksForPageView();
    this.addHooksForSVCEvents();
  }
  setTicket(ticket) {
    this.ticket = ticket;
  }
  clearPluginData() {
    this.ticket = {};
  }
  addHooksForSVCEvents() {
    this.client.registerBeforeSendEventHook((eventType, ...[payload]) => {
      return allSVCEventTypes.indexOf(eventType) !== -1 ? this.addSVCDataToPayload(eventType, payload) : payload;
    });
    this.client.registerAfterSendEventHook((eventType, ...[payload]) => {
      if (allSVCEventTypes.indexOf(eventType) !== -1) {
        this.updateLocationInformation(eventType, payload);
      }
      return payload;
    });
  }
  addHooksForPageView() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.pageview, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["page"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addHooksForEvent() {
    this.client.addEventTypeMapping(SVCPluginEventTypes.event, {
      newEventType: EventType.collect,
      variableLengthArgumentsNames: ["eventCategory", "eventAction", "eventLabel", "eventValue"],
      addVisitorIdParameter: true,
      usesMeasurementProtocol: true
    });
  }
  addSVCDataToPayload(eventType, payload) {
    var _a;
    const svcPayload = Object.assign(Object.assign(Object.assign(Object.assign({}, this.getLocationInformation(eventType, payload)), this.getDefaultContextInformation(eventType)), this.action ? { svcAction: this.action } : {}), Object.keys((_a = this.actionData) !== null && _a !== void 0 ? _a : {}).length > 0 ? { svcActionData: this.actionData } : {});
    const ticketPayload = this.getTicketPayload();
    this.clearData();
    return Object.assign(Object.assign(Object.assign({}, ticketPayload), svcPayload), payload);
  }
  getTicketPayload() {
    return convertTicketToMeasurementProtocol(this.ticket);
  }
};
SVCPlugin.Id = "svc";
var CaseAssistEvents;
(function(CaseAssistEvents2) {
  CaseAssistEvents2["click"] = "click";
  CaseAssistEvents2["flowStart"] = "flowStart";
})(CaseAssistEvents || (CaseAssistEvents = {}));
var CaseAssistActions;
(function(CaseAssistActions2) {
  CaseAssistActions2["enterInterface"] = "ticket_create_start";
  CaseAssistActions2["fieldUpdate"] = "ticket_field_update";
  CaseAssistActions2["fieldSuggestionClick"] = "ticket_classification_click";
  CaseAssistActions2["documentSuggestionClick"] = "documentSuggestionClick";
  CaseAssistActions2["documentSuggestionQuickview"] = "documentSuggestionQuickview";
  CaseAssistActions2["suggestionRate"] = "suggestion_rate";
  CaseAssistActions2["nextCaseStep"] = "ticket_next_stage";
  CaseAssistActions2["caseCancelled"] = "ticket_cancel";
  CaseAssistActions2["caseSolved"] = "ticket_cancel";
  CaseAssistActions2["caseCreated"] = "ticket_create";
})(CaseAssistActions || (CaseAssistActions = {}));
var CaseCancelledReasons;
(function(CaseCancelledReasons2) {
  CaseCancelledReasons2["quit"] = "Quit";
  CaseCancelledReasons2["solved"] = "Solved";
})(CaseCancelledReasons || (CaseCancelledReasons = {}));
var CaseAssistClient = class {
  constructor(options, provider) {
    var _a;
    this.options = options;
    this.provider = provider;
    const analyticsEnabled = ((_a = options.enableAnalytics) !== null && _a !== void 0 ? _a : true) && !doNotTrack2();
    this.coveoAnalyticsClient = analyticsEnabled ? new CoveoAnalyticsClient(options) : new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.options);
    this.svc = new SVCPlugin({ client: this.coveoAnalyticsClient });
  }
  logEnterInterface(meta) {
    this.svc.setAction(CaseAssistActions.enterInterface);
    this.svc.setTicket(meta.ticket);
    return this.sendFlowStartEvent();
  }
  logUpdateCaseField(meta) {
    this.svc.setAction(CaseAssistActions.fieldUpdate, {
      fieldName: meta.fieldName
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectFieldSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.fieldSuggestionClick, meta.suggestion);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logSelectDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionClick, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logQuickviewDocumentSuggestion(meta) {
    return this.logClickEvent(CaseAssistActions.documentSuggestionQuickview, meta.suggestion.suggestion, {
      contentIDKey: "permanentId",
      contentIDValue: meta.suggestion.permanentId
    });
  }
  logRateDocumentSuggestion(meta) {
    this.svc.setAction(CaseAssistActions.suggestionRate, Object.assign({ rate: meta.rating }, meta.suggestion));
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logMoveToNextCaseStep(meta) {
    this.svc.setAction(CaseAssistActions.nextCaseStep, {
      stage: meta === null || meta === void 0 ? void 0 : meta.stage
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCancelled(meta) {
    this.svc.setAction(CaseAssistActions.caseCancelled, {
      reason: CaseCancelledReasons.quit
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseSolved(meta) {
    this.svc.setAction(CaseAssistActions.caseSolved, {
      reason: CaseCancelledReasons.solved
    });
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  logCaseCreated(meta) {
    this.svc.setAction(CaseAssistActions.caseCreated);
    this.svc.setTicket(meta.ticket);
    return this.sendClickEvent();
  }
  sendFlowStartEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.flowStart, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  sendClickEvent() {
    return this.coveoAnalyticsClient.sendEvent("event", "svc", CaseAssistEvents.click, this.provider ? {
      searchHub: this.provider.getOriginLevel1()
    } : null);
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const customData = Object.assign({}, metadata);
      return Object.assign(Object.assign({}, this.getOrigins()), { customData, language: (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getLanguage(), anonymous: (_b = this.provider) === null || _b === void 0 ? void 0 : _b.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getOrigins() {
    var _a, _b, _c, _d, _e;
    return {
      originContext: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: (_c = this.provider) === null || _c === void 0 ? void 0 : _c.getOriginLevel1(),
      originLevel2: (_d = this.provider) === null || _d === void 0 ? void 0 : _d.getOriginLevel2(),
      originLevel3: (_e = this.provider) === null || _e === void 0 ? void 0 : _e.getOriginLevel3()
    };
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const payload = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { searchQueryUid: (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.getSearchUID()) !== null && _b !== void 0 ? _b : "", actionCause: event });
      return this.coveoAnalyticsClient.sendClickEvent(payload);
    });
  }
};

// node_modules/@coveo/headless/dist/esm/features/search-hub/search-hub-state.js
var getSearchHubInitialState = () => "default";

// node_modules/@coveo/headless/dist/esm/api/analytics/base-analytics.js
var getLanguage = (state) => {
  const langKey = state.configuration.search.locale.split("-")[0];
  if (!langKey || langKey.length !== 2) {
    return "en";
  }
  return langKey;
};
var BaseAnalyticsProvider = class {
  constructor(getState) {
    __publicField(this, "getState");
    __publicField(this, "state");
    this.getState = getState;
    this.state = getState();
  }
  getLanguage() {
    return getLanguage(this.state);
  }
  getBaseMetadata() {
    const { context, configuration: configuration2 } = this.state;
    const contextValues = (context == null ? void 0 : context.contextValues) || {};
    const formattedObject = {};
    for (const [key, value] of Object.entries(contextValues)) {
      const formattedKey = `context_${key}`;
      formattedObject[formattedKey] = value;
    }
    if (configuration2.analytics.analyticsMode === "legacy") {
      formattedObject.coveoHeadlessVersion = VERSION;
    }
    return formattedObject;
  }
  getOriginContext() {
    return this.state.configuration.analytics.originContext;
  }
  getOriginLevel1() {
    return this.state.searchHub || getSearchHubInitialState();
  }
  getOriginLevel2() {
    return this.state.configuration.analytics.originLevel2;
  }
  getOriginLevel3() {
    return this.state.configuration.analytics.originLevel3;
  }
  getIsAnonymous() {
    return this.state.configuration.analytics.anonymous;
  }
};

// node_modules/@coveo/headless/dist/esm/api/analytics/coveo-analytics-utils.js
var getVisitorID = (options) => new CoveoAnalyticsClient(options).getCurrentVisitorId();
var wrapPreprocessRequest = (logger, preprocessRequest) => {
  return typeof preprocessRequest === "function" ? (...args) => {
    const untaintedOutput = clone(args[0]);
    try {
      return preprocessRequest.apply(preprocessRequest, args);
    } catch (e) {
      logger.error(e, "Error in analytics preprocessRequest. Returning original request.");
      return untaintedOutput;
    }
  } : void 0;
};
var wrapAnalyticsClientSendEventHook = (logger, hook) => {
  return (...args) => {
    const untaintedOutput = clone(args[1]);
    try {
      return hook.apply(hook, args);
    } catch (e) {
      logger.error(e, "Error in analytics hook. Returning original request.");
      return untaintedOutput;
    }
  };
};

// node_modules/@coveo/headless/dist/esm/api/analytics/case-assist-analytics.js
var CaseAssistAnalyticsProvider = class extends BaseAnalyticsProvider {
  getSearchUID() {
    var _a;
    return ((_a = this.state.documentSuggestion) == null ? void 0 : _a.status.lastResponseId) ?? "";
  }
};
var configureCaseAssistAnalytics = ({ logger, getState, analyticsClientMiddleware = (_, p) => p, preprocessRequest, provider = new CaseAssistAnalyticsProvider(getState) }) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(state.configuration.organizationId, state.configuration.environment, "analytics");
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CaseAssistClient({
    enableAnalytics: enableAnalytics2,
    token,
    endpoint,
    runtimeEnvironment,
    preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
    beforeSendHooks: [
      wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
      (type, payload) => {
        logger.info({
          ...payload,
          type,
          endpoint,
          token
        }, "Analytics request");
        return payload;
      }
    ]
  }, provider);
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};

// node_modules/@coveo/headless/dist/esm/features/facets/automatic-facet-set/automatic-facet-set-constants.js
var DESIRED_COUNT_MINIMUM = 1;
var DESIRED_COUNT_MAXIMUM = 20;
var DESIRED_COUNT_DEFAULT = 5;
var NUMBER_OF_VALUE_MINIMUM = 1;
var NUMBER_OF_VALUE_DEFAULT = 8;

// node_modules/@coveo/headless/dist/esm/features/facets/automatic-facet-set/automatic-facet-set-state.js
function getAutomaticFacetSetInitialState() {
  return {
    desiredCount: DESIRED_COUNT_DEFAULT,
    numberOfValues: NUMBER_OF_VALUE_DEFAULT,
    set: {}
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-selectors.js
function isFacetResponse(state, response) {
  return !!response && response.facetId in state.facetSet;
}
var baseFacetResponseSelector = (state, id) => {
  var _a;
  return (_a = state.search) == null ? void 0 : _a.response.facets.find((response) => response.facetId === id);
};
var facetRequestSelector = (state, id) => {
  var _a;
  return (_a = state.facetSet[id]) == null ? void 0 : _a.request;
};
var facetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  return isFacetResponse(state, response) ? response : void 0;
};
var facetResponseSelectedValuesSelector = (state, facetId2) => {
  var _a;
  return ((_a = facetResponseSelector(state, facetId2)) == null ? void 0 : _a.values.filter((value) => value.state === "selected")) || [];
};
var facetResponseActiveValuesSelector = (state, facetId2) => {
  var _a;
  return ((_a = facetResponseSelector(state, facetId2)) == null ? void 0 : _a.values.filter((value) => value.state !== "idle")) || [];
};
var isFacetLoadingResponseSelector = (state) => state.search.isLoading;

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-utils.js
function partitionIntoParentsAndValues(nestedValues) {
  if (!nestedValues) {
    return { parents: [], values: [] };
  }
  let parents = [];
  let values = nestedValues;
  while (values.length && values[0].children.length) {
    parents = [...parents, ...values];
    values = values[0].children;
  }
  const selectedLeafValue = values.find((v) => v.state === "selected");
  if (selectedLeafValue) {
    parents = [...parents, selectedLeafValue];
    values = [];
  }
  return { parents, values };
}
function findActiveValueAncestry(valuesAsTree) {
  const { activeValue, ancestryMap } = getActiveValueAndAncestryFromValueTree(valuesAsTree);
  return activeValue ? getActiveValueAncestry(activeValue, ancestryMap) : [];
}
function getActiveValueAndAncestryFromValueTree(valuesAsTrees) {
  const valueToVisit = [...valuesAsTrees];
  const ancestryMap = /* @__PURE__ */ new Map();
  while (valueToVisit.length > 0) {
    const currentValue = valueToVisit.shift();
    if (currentValue.state === "selected") {
      return { activeValue: currentValue, ancestryMap };
    }
    if (ancestryMap) {
      for (const childValue of currentValue.children) {
        ancestryMap.set(childValue, currentValue);
      }
    }
    valueToVisit.unshift(...currentValue.children);
  }
  return {};
}
function getActiveValueAncestry(activeValue, valueToParentMap) {
  const activeValueAncestry = [];
  if (!activeValue) {
    return [];
  }
  let lastParent = activeValue;
  do {
    activeValueAncestry.unshift(lastParent);
    lastParent = valueToParentMap.get(lastParent);
  } while (lastParent);
  return activeValueAncestry;
}

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-set-selectors.js
function isCategoryFacetResponse(state, response) {
  return !!response && response.facetId in state.categoryFacetSet;
}
var categoryFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isCategoryFacetResponse(state, response)) {
    return response;
  }
  return void 0;
};
var categoryFacetRequestSelector = (state, id) => {
  var _a;
  return (_a = state.categoryFacetSet[id]) == null ? void 0 : _a.request;
};
var categoryFacetResponseSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = categoryFacetResponseSelector(state, facetId2);
  return findActiveValueAncestry((facetResponse == null ? void 0 : facetResponse.values) ?? []);
};
var categoryFacetRequestSelectedValuesSelector = (state, facetId2) => {
  const facetRequest = categoryFacetRequestSelector(state, facetId2);
  return findActiveValueAncestry((facetRequest == null ? void 0 : facetRequest.currentValues) ?? []);
};

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-set-state.js
function getCategoryFacetSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-set-state.js
function getDateFacetSetSliceInitialState(request) {
  return { request };
}
function getDateFacetSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-set-state.js
function getNumericFacetSetSliceInitialState(request) {
  return { request };
}
function getNumericFacetSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-state.js
function getFacetSetSliceInitialState(request) {
  return { request, hasBreadcrumbs: true };
}
function getFacetSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-analytics-actions-utils.js
var buildFacetBaseMetadata = (facetId2, state) => {
  const facet = getFacetRequest(state, facetId2);
  const facetField = facet ? facet.field : "";
  const facetTitle = getFacetTitle(facetField, facetId2);
  return { facetId: facetId2, facetField, facetTitle };
};
function buildFacetSelectionChangeMetadata(payload, state) {
  const { facetId: facetId2, facetValue } = payload;
  const base = buildFacetBaseMetadata(facetId2, state);
  const facetType = getFacetType(state, facetId2);
  return {
    ...base,
    facetValue: facetType === "hierarchical" ? getCategoryFacetSelectedValue(state, facetId2) : facetValue
  };
}
function getStateNeededForFacetMetadata(s) {
  return {
    facetSet: s.facetSet ?? getFacetSetInitialState(),
    categoryFacetSet: s.categoryFacetSet ?? getCategoryFacetSetInitialState(),
    dateFacetSet: s.dateFacetSet ?? getDateFacetSetInitialState(),
    numericFacetSet: s.numericFacetSet ?? getNumericFacetSetInitialState(),
    automaticFacetSet: s.automaticFacetSet ?? getAutomaticFacetSetInitialState()
  };
}
var buildFacetStateMetadata = (state) => {
  const facetState = [];
  getFacetRequests(state).forEach((facetRequest, facetIndex) => {
    const facetType = getFacetType(state, facetRequest.facetId);
    const facetRequestAnalytics = mapFacetRequestToAnalytics(facetRequest, facetIndex + 1);
    if (isCategoryFacetRequest(facetRequest)) {
      const hasSelectedValue = !!categoryFacetRequestSelectedValuesSelector(state, facetRequest.facetId).length;
      if (!hasSelectedValue) {
        return;
      }
      facetState.push({
        ...facetRequestAnalytics,
        ...mapCategoryFacetValueToAnalytics(state, facetRequest.facetId),
        facetType,
        state: "selected"
      });
      return;
    }
    facetRequest.currentValues.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(facetValue, facetValueIndex + 1, facetType);
      const facetDisplayValueAnalytics = isSpecificFacetRequest(facetRequest) ? mapFacetDisplayValueToAnalytics(facetValue) : mapRangeDisplayFacetValueToAnalytics(facetValue);
      facetState.push({
        ...facetRequestAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  getAutomaticFacets(state).forEach((facet, facetIndex) => {
    const facetAnalytics = mapAutomaticFacetToAnalytics(facet, facetIndex + 1);
    facet.values.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(facetValue, facetValueIndex + 1, "specific");
      const facetDisplayValueAnalytics = mapFacetDisplayValueToAnalytics(facetValue);
      facetState.push({
        ...facetAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  return facetState;
};
var isSpecificFacetRequest = (request) => request.type === "specific";
var isCategoryFacetRequest = (request) => request.type === "hierarchical";
var getFacetRequests = (state) => {
  return [
    ...Object.values(state.facetSet),
    ...Object.values(state.categoryFacetSet),
    ...Object.values(state.dateFacetSet),
    ...Object.values(state.numericFacetSet)
  ].map((facet) => facet.request);
};
var getAutomaticFacets = (state) => {
  return [...Object.values(state.automaticFacetSet.set)].map((facet) => facet.response);
};
var mapFacetValueToAnalytics = (facetValue, valuePosition, facetType) => {
  return {
    state: facetValue.state,
    valuePosition,
    facetType
  };
};
var mapRangeDisplayFacetValueToAnalytics = (facetValue) => {
  return {
    displayValue: `${facetValue.start}..${facetValue.end}`,
    value: `${facetValue.start}..${facetValue.end}`,
    start: facetValue.start,
    end: facetValue.end,
    endInclusive: facetValue.endInclusive
  };
};
var mapFacetDisplayValueToAnalytics = (facetValue) => {
  return {
    displayValue: facetValue.value,
    value: facetValue.value
  };
};
var getCategoryFacetSelectedValue = (state, facetId2) => {
  const selectedCategoryFacetValues = categoryFacetRequestSelectedValuesSelector(state, facetId2);
  return selectedCategoryFacetValues.map((selectedCategoryFacetValue) => selectedCategoryFacetValue.value).join(";");
};
var mapCategoryFacetValueToAnalytics = (state, facetId2) => {
  const valuePosition = 1;
  const value = getCategoryFacetSelectedValue(state, facetId2);
  return {
    value,
    valuePosition,
    displayValue: value
  };
};
var mapAutomaticFacetToAnalytics = (facet, facetPosition) => {
  return {
    title: getFacetTitle(facet.field, facet.field),
    field: facet.field,
    id: facet.field,
    facetPosition
  };
};
var mapFacetRequestToAnalytics = (request, facetPosition) => {
  return {
    title: getFacetTitle(request.field, request.facetId),
    field: request.field,
    id: request.facetId,
    facetPosition
  };
};
var getFacetTitle = (field2, facetId2) => {
  return `${field2}_${facetId2}`;
};
var getFacetRequest = (state, facetId2) => {
  var _a, _b, _c, _d, _e;
  return ((_a = state.facetSet[facetId2]) == null ? void 0 : _a.request) || ((_b = state.categoryFacetSet[facetId2]) == null ? void 0 : _b.request) || ((_c = state.dateFacetSet[facetId2]) == null ? void 0 : _c.request) || ((_d = state.numericFacetSet[facetId2]) == null ? void 0 : _d.request) || ((_e = state.automaticFacetSet.set[facetId2]) == null ? void 0 : _e.response);
};
var getFacetType = (state, facetId2) => {
  const facet = getFacetRequest(state, facetId2);
  return facet ? facet.type : "specific";
};

// node_modules/@coveo/headless/dist/esm/features/configuration/configuration-selectors.js
var selectLocale = (state) => state.configuration.search.locale;
var selectTimezone = (state) => state.configuration.search.timezone;
var selectAgentId = (state) => {
  var _a, _b;
  return (_b = (_a = state.configuration) == null ? void 0 : _a.knowledge) == null ? void 0 : _b.agentId;
};

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-selectors.js
var generativeQuestionAnsweringIdSelector = (state) => {
  var _a, _b, _c, _d;
  if (isGeneratedAnswerFeatureEnabledWithAnswerAPI(state) || isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
    return (_a = state.generatedAnswer) == null ? void 0 : _a.answerId;
  }
  if (isSearchSection(state)) {
    return (_d = (_c = (_b = state.search) == null ? void 0 : _b.response) == null ? void 0 : _c.extendedResults) == null ? void 0 : _d.generativeQuestionAnsweringId;
  }
  return void 0;
};
var isGeneratedAnswerFeatureEnabledWithAnswerAPI = (state) => {
  var _a;
  return "answer" in state && "generatedAnswer" in state && !isNullOrUndefined((_a = state.generatedAnswer) == null ? void 0 : _a.answerConfigurationId);
};
var isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI = (state) => {
  const agentId = selectAgentId(state);
  return "answerGenerationApi" in state && "generatedAnswer" in state && typeof agentId === "string" && agentId.trim().length > 0;
};
var isSearchSection = (state) => "search" in state && state.search !== void 0 && typeof state.search === "object";
var selectFieldsToIncludeInCitation = (state) => {
  var _a;
  return (_a = state.generatedAnswer) == null ? void 0 : _a.fieldsToIncludeInCitations;
};
var citationSourceSelector = createSelector((state) => {
  var _a;
  return (_a = state.generatedAnswer) == null ? void 0 : _a.citations;
}, (_state, citationId) => citationId, (citations, citationId) => citations == null ? void 0 : citations.find((citation) => citation.id === citationId));

// node_modules/@coveo/headless/dist/esm/features/query/query-state.js
var getQueryInitialState = () => ({
  q: "",
  enableQuerySyntax: false
});

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/criteria.js
var SortOrder;
(function(SortOrder2) {
  SortOrder2["Ascending"] = "ascending";
  SortOrder2["Descending"] = "descending";
})(SortOrder || (SortOrder = {}));
var SortBy;
(function(SortBy3) {
  SortBy3["Relevancy"] = "relevancy";
  SortBy3["QRE"] = "qre";
  SortBy3["Date"] = "date";
  SortBy3["Field"] = "field";
  SortBy3["NoSort"] = "nosort";
})(SortBy || (SortBy = {}));
var buildCriterionExpression = (criterion) => {
  if (isArray(criterion)) {
    return criterion.map((c) => buildCriterionExpression(c)).join(",");
  }
  switch (criterion.by) {
    case SortBy.Relevancy:
    case SortBy.QRE:
    case SortBy.NoSort:
      return criterion.by;
    case SortBy.Date:
      return `date ${criterion.order}`;
    case SortBy.Field:
      return `@${criterion.field} ${criterion.order}`;
    default:
      return "";
  }
};
var buildRelevanceSortCriterion = () => ({
  by: SortBy.Relevancy
});
var buildDateSortCriterion = (order) => ({
  by: SortBy.Date,
  order
});
var buildFieldSortCriterion = (field2, order) => ({
  by: SortBy.Field,
  order,
  field: field2
});
var buildQueryRankingExpressionSortCriterion = () => ({
  by: SortBy.QRE
});
var buildNoSortCriterion = () => ({ by: SortBy.NoSort });
var criterionDefinition = new RecordValue({
  values: {
    by: new EnumValue({ enum: SortBy, required: true }),
    order: new EnumValue({ enum: SortOrder }),
    field: new StringValue()
  }
});

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/sort-criteria-state.js
function getSortCriteriaInitialState() {
  return buildCriterionExpression(buildRelevanceSortCriterion());
}

// node_modules/@coveo/headless/dist/esm/api/analytics/coveo.analytics/cookie.js
var Cookie2 = class _Cookie {
  static set(name, value, expire) {
    let domain, expirationDate, domainParts;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    const host = window.location.hostname;
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
    if (ipv4Regex.test(host) || ipv6Regex.test(host)) {
      writeCookie2(name, value, expirationDate);
    } else if (host.indexOf(".") === -1) {
      writeCookie2(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie2(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    const cookiePrefix = name + "=";
    const cookieArray = document.cookie.split(";");
    for (let i = 0; i < cookieArray.length; i++) {
      let cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    _Cookie.set(name, "", -1);
  }
};
function writeCookie2(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}

// node_modules/@coveo/headless/dist/esm/api/analytics/coveo.analytics/detector.js
function hasNavigator2() {
  return typeof navigator !== "undefined";
}
function hasLocalStorage2() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage2() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage2() {
  return Boolean(hasNavigator2() && navigator.cookieEnabled);
}

// node_modules/@coveo/headless/dist/esm/api/analytics/coveo.analytics/storage.js
var preferredStorage = null;
function getAvailableStorage2() {
  if (preferredStorage) {
    return preferredStorage;
  }
  if (hasLocalStorage2()) {
    return localStorage;
  }
  if (hasCookieStorage2()) {
    return new CookieStorage2();
  }
  if (hasSessionStorage2()) {
    return sessionStorage;
  }
  return new NullStorage2();
}
var _CookieStorage = class _CookieStorage {
  getItem(key) {
    return Cookie2.get(`${_CookieStorage.prefix}${key}`);
  }
  removeItem(key) {
    Cookie2.erase(`${_CookieStorage.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie2.set(`${_CookieStorage.prefix}${key}`, data, expire);
  }
};
__publicField(_CookieStorage, "prefix", "coveo_");
var CookieStorage2 = _CookieStorage;
var NullStorage2 = class {
  getItem(_key) {
    return null;
  }
  removeItem(_key) {
  }
  setItem(_key, _data) {
  }
};

// node_modules/@coveo/headless/dist/esm/api/analytics/coveo.analytics/history-store.js
var STORE_KEY2 = "__coveo.analytics.history";
var MAX_NUMBER_OF_HISTORY_ELEMENTS2 = 20;
var MIN_THRESHOLD_FOR_DUPLICATE_VALUE2 = 1e3 * 60;
var MAX_VALUE_SIZE2 = 75;
var _HistoryStore = class _HistoryStore {
  constructor(store) {
    __publicField(this, "store");
    this.store = store || getAvailableStorage2();
  }
  static getInstance(store) {
    if (!_HistoryStore.instance) {
      _HistoryStore.instance = new _HistoryStore(store);
    }
    return _HistoryStore.instance;
  }
  /**
   * @deprecated Synchronous method is deprecated, use addElementAsync instead. This method will NOT work with react-native.
   */
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  async addElementAsync(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = await this.getHistoryWithInternalTimeAsync();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  /**
   * @deprecated Synchronous method is deprecated, use getHistoryAsync instead. This method will NOT work with react-native.
   */
  getHistory() {
    const history3 = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history3));
  }
  async getHistoryAsync() {
    const history3 = await this.getHistoryWithInternalTimeAsync();
    return this.stripEmptyQueries(this.stripInternalTime(history3));
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY2);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  async getHistoryWithInternalTimeAsync() {
    try {
      const elements = await this.store.getItem(STORE_KEY2);
      if (elements) {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  setHistory(history3) {
    try {
      this.store.setItem(STORE_KEY2, JSON.stringify(history3.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS2)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY2);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    const currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE2);
    }
    return part;
  }
  isValidEntry(elem) {
    const lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value === elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE2;
    }
    return true;
  }
  stripInternalTime(history3) {
    if (Array.isArray(history3)) {
      return history3.map((part) => {
        const { name, time, value } = part;
        return { name, time, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time };
    }
    return part;
  }
  stripEmptyQueries(history3) {
    return history3.map((part) => this.stripEmptyQuery(part));
  }
};
__publicField(_HistoryStore, "instance", null);
var HistoryStore2 = _HistoryStore;
var history_store_default = HistoryStore2;

// node_modules/@coveo/headless/dist/esm/api/analytics/search-analytics.js
var _SearchAnalyticsProvider = class _SearchAnalyticsProvider extends BaseAnalyticsProvider {
  constructor() {
    super(...arguments);
    __publicField(this, "getFacetRequest", (id) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      return ((_b = (_a = this.state.facetSet) == null ? void 0 : _a[id]) == null ? void 0 : _b.request) || ((_d = (_c = this.state.categoryFacetSet) == null ? void 0 : _c[id]) == null ? void 0 : _d.request) || ((_f = (_e = this.state.dateFacetSet) == null ? void 0 : _e[id]) == null ? void 0 : _f.request) || ((_h = (_g = this.state.numericFacetSet) == null ? void 0 : _g[id]) == null ? void 0 : _h.request) || ((_j = (_i = this.state.automaticFacetSet) == null ? void 0 : _i.set[id]) == null ? void 0 : _j.response);
    });
  }
  getFacetState() {
    return buildFacetStateMetadata(getStateNeededForFacetMetadata(this.getState()));
  }
  getPipeline() {
    var _a;
    return this.state.pipeline || ((_a = this.state.search) == null ? void 0 : _a.response.pipeline) || _SearchAnalyticsProvider.fallbackPipelineName;
  }
  getSearchEventRequestPayload() {
    return {
      queryText: this.queryText,
      responseTime: this.responseTime,
      results: this.resultURIs,
      numberOfResults: this.numberOfResults
    };
  }
  getSearchUID() {
    var _a, _b;
    const newState = this.getState();
    return ((_a = newState.search) == null ? void 0 : _a.searchResponseId) || ((_b = newState.search) == null ? void 0 : _b.response.searchUid) || getSearchInitialState().response.searchUid;
  }
  getSplitTestRunName() {
    var _a;
    return (_a = this.state.search) == null ? void 0 : _a.response.splitTestRun;
  }
  getSplitTestRunVersion() {
    var _a;
    const hasSplitTestRun = !!this.getSplitTestRunName();
    const effectivePipelineWithSplitTestRun = ((_a = this.state.search) == null ? void 0 : _a.response.pipeline) || this.state.pipeline || _SearchAnalyticsProvider.fallbackPipelineName;
    return hasSplitTestRun ? effectivePipelineWithSplitTestRun : void 0;
  }
  getBaseMetadata() {
    const state = this.getState();
    const baseObject = super.getBaseMetadata();
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (generativeQuestionAnsweringId) {
      baseObject.generativeQuestionAnsweringId = generativeQuestionAnsweringId;
    }
    return baseObject;
  }
  getFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = (facetRequest == null ? void 0 : facetRequest.field) ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetValue,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetClearAllMetadata(facetId2) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = (facetRequest == null ? void 0 : facetRequest.field) ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetUpdateSortMetadata(facetId2, criteria) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = (facetRequest == null ? void 0 : facetRequest.field) ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      criteria,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getRangeBreadcrumbFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = (facetRequest == null ? void 0 : facetRequest.field) ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetRangeEnd: facetValue.end,
      facetRangeEndInclusive: facetValue.endInclusive,
      facetRangeStart: facetValue.start,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getResultSortMetadata() {
    return {
      ...this.getBaseMetadata(),
      resultsSortBy: this.state.sortCriteria ?? getSortCriteriaInitialState()
    };
  }
  getStaticFilterToggleMetadata(staticFilterId, staticFilterValue) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId,
      staticFilterValue
    };
  }
  getStaticFilterClearAllMetadata(staticFilterId) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId
    };
  }
  getUndoTriggerQueryMetadata(undoneQuery) {
    return {
      ...this.getBaseMetadata(),
      undoneQuery
    };
  }
  getCategoryBreadcrumbFacetMetadata(categoryFacetId, categoryFacetPath) {
    const facetRequest = this.getFacetRequest(categoryFacetId);
    const categoryFacetField = (facetRequest == null ? void 0 : facetRequest.field) ?? "";
    return {
      ...this.getBaseMetadata(),
      categoryFacetId,
      categoryFacetField,
      categoryFacetPath,
      categoryFacetTitle: `${categoryFacetField}_${categoryFacetId}`
    };
  }
  getOmniboxAnalyticsMetadata(id, suggestion) {
    var _a;
    const querySuggest = (_a = this.state.querySuggest) == null ? void 0 : _a[id];
    const suggestions = querySuggest.completions.map((completion) => completion.expression);
    const lastIndex = querySuggest.partialQueries.length - 1;
    const partialQuery = querySuggest.partialQueries[lastIndex] || "";
    const querySuggestResponseId = querySuggest.responseId;
    return {
      ...this.getBaseMetadata(),
      suggestionRanking: suggestions.indexOf(suggestion),
      partialQuery,
      partialQueries: querySuggest.partialQueries.length > 0 ? querySuggest.partialQueries : "",
      suggestions: suggestions.length > 0 ? suggestions : "",
      querySuggestResponseId
    };
  }
  getInterfaceChangeMetadata() {
    return {
      ...this.getBaseMetadata(),
      interfaceChangeTo: this.state.configuration.analytics.originLevel2
    };
  }
  getOmniboxFromLinkMetadata(metadata) {
    return {
      ...this.getBaseMetadata(),
      ...metadata
    };
  }
  getGeneratedAnswerMetadata() {
    var _a;
    const state = this.getState();
    const formattedObject = {};
    if (((_a = state.generatedAnswer) == null ? void 0 : _a.isVisible) !== void 0) {
      formattedObject.showGeneratedAnswer = state.generatedAnswer.isVisible;
    }
    return formattedObject;
  }
  get resultURIs() {
    var _a;
    return (_a = this.results) == null ? void 0 : _a.map((r) => ({
      documentUri: r.uri,
      documentUriHash: r.raw.urihash
    }));
  }
  get results() {
    var _a;
    return (_a = this.state.search) == null ? void 0 : _a.response.results;
  }
  get queryText() {
    var _a;
    return ((_a = this.state.query) == null ? void 0 : _a.q) || getQueryInitialState().q;
  }
  get responseTime() {
    var _a;
    return ((_a = this.state.search) == null ? void 0 : _a.duration) || getSearchInitialState().duration;
  }
  get numberOfResults() {
    var _a;
    return ((_a = this.state.search) == null ? void 0 : _a.response.totalCountFiltered) || getSearchInitialState().response.totalCountFiltered;
  }
};
__publicField(_SearchAnalyticsProvider, "fallbackPipelineName", "default");
var SearchAnalyticsProvider = _SearchAnalyticsProvider;
var configureLegacyAnalytics = ({ logger, getState, analyticsClientMiddleware = (_, p) => p, preprocessRequest, provider }) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(state.configuration.organizationId, state.configuration.environment, "analytics");
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CoveoSearchPageClient({
    token,
    endpoint,
    runtimeEnvironment,
    preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
    beforeSendHooks: [
      wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
      (type, payload) => {
        logger.info({
          ...payload,
          type,
          endpoint,
          token
        }, "Analytics request");
        return payload;
      }
    ]
  }, provider);
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};
var getPageID = () => {
  const actions = history_store_default.getInstance().getHistory();
  const lastPageView = actions.reverse().find((action) => {
    return action.name === "PageView" && action.value;
  });
  if (!lastPageView) {
    return "";
  }
  return lastPageView.value;
};

// node_modules/@coveo/headless/dist/esm/features/folding/folding-utils.js
function getAllIncludedResultsFrom(relevantResult) {
  const foldedResults = getChildResultsRecursively(relevantResult);
  const parentResults = [relevantResult, ...foldedResults].filter((result) => result.parentResult).map((result) => result.parentResult);
  const resultsInCollection = removeDuplicates([relevantResult, ...foldedResults, ...parentResults], (result) => result.uniqueId);
  return resultsInCollection;
}
function getChildResultsRecursively(result) {
  if (!result.childResults) {
    return [];
  }
  return result.childResults.flatMap((childResult) => [
    childResult,
    ...getChildResultsRecursively(childResult)
  ]);
}

// node_modules/@coveo/headless/dist/esm/features/pipeline/pipeline-state.js
var getPipelineInitialState = () => "";

// node_modules/@coveo/headless/dist/esm/features/analytics/analytics-utils.js
function makeBasicNewSearchAnalyticsAction(actionCause, getState) {
  return {
    ...new SearchAnalyticsProvider(getState).getBaseMetadata(),
    actionCause,
    type: actionCause
  };
}
function makeInstantlyCallable(action) {
  return Object.assign(action, { instantlyCallable: true });
}
function makePreparableAnalyticsAction(prefix, buildEvent) {
  const createAnalyticsAction = (body) => makeInstantlyCallable(createAsyncThunk(prefix, body));
  const rootAction = createAnalyticsAction(async (_, { getState, extra }) => {
    const { analyticsClientMiddleware, preprocessRequest, logger } = extra;
    return await (await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    })).log({ state: getState(), extra });
  });
  const prepare = async ({ getState, analyticsClientMiddleware, preprocessRequest, logger }) => {
    const { description, log } = await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    });
    return {
      description,
      action: createAnalyticsAction(async (_, { getState: getNewState, extra: newExtra }) => {
        return await log({ state: getNewState(), extra: newExtra });
      })
    };
  };
  Object.assign(rootAction, {
    prepare
  });
  return rootAction;
}
var makeAnalyticsActionFactory = (configurator, legacyGetBuilderConverter, providerClass) => {
  function makeAnalyticsAction2(...params) {
    const options = params.length === 1 ? {
      ...params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[0].__legacy__getBuilder),
      analyticsConfigurator: configurator,
      providerClass
    } : {
      prefix: params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[1]),
      __legacy__provider: params[2],
      analyticsConfigurator: configurator,
      providerClass
    };
    return internalMakeAnalyticsAction(options);
  }
  return makeAnalyticsAction2;
};
var shouldSendLegacyEvent = (state) => state.configuration.analytics.analyticsMode === "legacy";
var shouldSendNextEvent = (state) => state.configuration.analytics.analyticsMode === "next";
var internalMakeAnalyticsAction = ({ prefix, __legacy__getBuilder, __legacy__provider, analyticsPayloadBuilder, analyticsType, analyticsConfigurator, providerClass }) => {
  __legacy__provider ?? (__legacy__provider = (getState) => new providerClass(getState));
  return makePreparableAnalyticsAction(prefix, async ({ getState, analyticsClientMiddleware, preprocessRequest, logger }) => {
    const loggers = [];
    const analyticsAction = {
      log: async ({ state: state2 }) => {
        for (const log of loggers) {
          await log(state2);
        }
      }
    };
    const state = getState();
    const client = analyticsConfigurator({
      getState,
      logger,
      analyticsClientMiddleware,
      preprocessRequest,
      provider: __legacy__provider(getState)
    });
    const builder = await __legacy__getBuilder(client, getState());
    analyticsAction.description = builder == null ? void 0 : builder.description;
    loggers.push(async (state2) => {
      if (shouldSendLegacyEvent(state2)) {
        await logLegacyEvent(builder, __legacy__provider, state2, logger, client.coveoAnalyticsClient);
      }
    });
    const { emit: emit2 } = getRelayInstanceFromState(state);
    loggers.push(async (state2) => {
      if (shouldSendNextEvent(state2) && analyticsType && analyticsPayloadBuilder) {
        const payload = analyticsPayloadBuilder(state2);
        await logNextEvent(emit2, analyticsType, payload);
      }
    });
    return analyticsAction;
  });
};
async function logLegacyEvent(builder, __legacy__provider, state, logger, client) {
  __legacy__provider(() => state);
  const response = await (builder == null ? void 0 : builder.log({
    searchUID: __legacy__provider(() => state).getSearchUID()
  }));
  logger.info({ client, response }, "Analytics response");
}
var fromLogToLegacyBuilderFactory = (actionCause) => {
  const fromLogToLegacyBuilder = (log) => {
    return (client, state) => Promise.resolve({
      description: { actionCause },
      log: async (_metadata) => {
        log(client, state);
      }
    });
  };
  return fromLogToLegacyBuilder;
};
var makeAnalyticsAction = makeAnalyticsActionFactory((options) => configureLegacyAnalytics({
  ...options,
  provider: options.provider || new SearchAnalyticsProvider(options.getState)
}), (original2) => original2, SearchAnalyticsProvider);
var makeCaseAssistAnalyticsAction = makeAnalyticsActionFactory(configureCaseAssistAnalytics, fromLogToLegacyBuilderFactory("caseAssist"), CaseAssistAnalyticsProvider);
var partialDocumentInformation = (result, state) => {
  var _a;
  const paginationBasedIndex = (index) => {
    var _a2;
    return index + (((_a2 = state.pagination) == null ? void 0 : _a2.firstResult) ?? 0);
  };
  let resultIndex = -1;
  const parentResults = (_a = state.search) == null ? void 0 : _a.results;
  resultIndex = findPositionWithUniqueId(result, parentResults);
  if (resultIndex < 0) {
    resultIndex = findPositionInChildResults(result, parentResults);
  }
  if (resultIndex < 0) {
    resultIndex = 0;
  }
  return buildPartialDocumentInformation(result, paginationBasedIndex(resultIndex), state);
};
var partialCitationInformation = (citation, state) => {
  return {
    sourceName: getCitationSourceName(citation),
    documentPosition: 1,
    documentTitle: citation.title,
    documentUri: citation.uri,
    documentUrl: citation.clickUri,
    queryPipeline: state.pipeline || getPipelineInitialState()
  };
};
function getCitationSourceName(citation) {
  const source = citation.source;
  if (isNullOrUndefined(source)) {
    return "unknown";
  }
  return source;
}
var citationDocumentIdentifier = (citation) => {
  return {
    contentIdKey: "permanentid",
    contentIdValue: citation.permanentid || ""
  };
};
function buildPartialDocumentInformation(result, resultIndex, state) {
  const collection = result.raw.collection;
  const collectionName = typeof collection === "string" ? collection : "default";
  return {
    collectionName,
    documentAuthor: getDocumentAuthor(result),
    documentPosition: resultIndex + 1,
    documentTitle: result.title,
    documentUri: result.uri,
    documentUriHash: result.raw.urihash,
    documentUrl: result.clickUri,
    rankingModifier: result.rankingModifier || "",
    sourceName: getSourceName(result),
    queryPipeline: state.pipeline || getPipelineInitialState()
  };
}
var documentIdentifier = (result) => {
  if (!result.raw.permanentid) {
    console.warn("Missing field permanentid on result. This might cause many issues with your Coveo deployment. See https://docs.coveo.com/en/1913 and https://docs.coveo.com/en/1640 for more information.", result);
  }
  return {
    contentIDKey: "permanentid",
    contentIDValue: result.raw.permanentid || ""
  };
};
var rawPartialDefinition = {
  urihash: new StringValue(),
  sourcetype: new StringValue(),
  permanentid: new StringValue()
};
var resultPartialDefinition = {
  uniqueId: requiredNonEmptyString,
  raw: new RecordValue({ values: rawPartialDefinition }),
  title: requiredNonEmptyString,
  uri: requiredNonEmptyString,
  clickUri: requiredNonEmptyString,
  rankingModifier: new StringValue({ required: false, emptyAllowed: true })
};
function partialRawPayload(raw) {
  return Object.assign({}, ...Object.keys(rawPartialDefinition).map((key) => ({ [key]: raw[key] })));
}
function partialResultPayload(result) {
  return Object.assign({}, ...Object.keys(resultPartialDefinition).map((key) => ({
    [key]: result[key]
  })), { raw: partialRawPayload(result.raw) });
}
function getDocumentAuthor(result) {
  const author = result.raw.author;
  if (isNullOrUndefined(author)) {
    return "unknown";
  }
  return Array.isArray(author) ? author.join(";") : `${author}`;
}
function getSourceName(result) {
  const source = result.raw.source;
  if (isNullOrUndefined(source)) {
    return "unknown";
  }
  return source;
}
var validateResultPayload = (result) => new Schema(resultPartialDefinition).validate(partialResultPayload(result));
function findPositionInChildResults(targetResult, parentResults) {
  for (const [i, parent] of parentResults.entries()) {
    const children = getAllIncludedResultsFrom(parent);
    const childIndex = findPositionWithUniqueId(targetResult, children);
    if (childIndex !== -1) {
      return i;
    }
  }
  return -1;
}
function findPositionWithUniqueId(targetResult, results = []) {
  return results.findIndex(({ uniqueId }) => uniqueId === targetResult.uniqueId);
}
async function logNextEvent(emitEvent, type, payload) {
  await emitEvent(type, payload);
  return;
}

// node_modules/@coveo/headless/dist/esm/features/analytics/search-action-cause.js
var SearchPageEvents2;
(function(SearchPageEvents3) {
  SearchPageEvents3["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents3["interfaceChange"] = "interfaceChange";
  SearchPageEvents3["didYouMeanAutomatic"] = "didYouMeanAutomatic";
  SearchPageEvents3["didYouMeanClick"] = "didYouMeanClick";
  SearchPageEvents3["resultsSort"] = "resultsSort";
  SearchPageEvents3["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents3["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents3["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents3["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents3["documentOpen"] = "documentOpen";
  SearchPageEvents3["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents3["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents3["searchFromLink"] = "searchFromLink";
  SearchPageEvents3["triggerQuery"] = "query";
  SearchPageEvents3["browseResults"] = "browseResults";
  SearchPageEvents3["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents3["facetClearAll"] = "facetClearAll";
  SearchPageEvents3["facetSelect"] = "facetSelect";
  SearchPageEvents3["facetDeselect"] = "facetDeselect";
  SearchPageEvents3["facetExclude"] = "facetExclude";
  SearchPageEvents3["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents3["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents3["documentSuggestion"] = "documentSuggestion";
  SearchPageEvents3["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents3["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents3["queryError"] = "query";
  SearchPageEvents3["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents3["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents3["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents3["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents3["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents3["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents3["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents3["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents3["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents3["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents3["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents3["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents3["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents3["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents3["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents3["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents3["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents3["caseAttach"] = "caseAttach";
  SearchPageEvents3["caseDetach"] = "caseDetach";
  SearchPageEvents3["generatedAnswerCitationDocumentAttach"] = "generatedAnswerCitationDocumentAttach";
  SearchPageEvents3["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents3["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents3["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents3["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents3["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents3["contextChanged"] = "contextChanged";
  SearchPageEvents3["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents3["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents3["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents3["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents3["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents3["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents3["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents3["expandToFullUI"] = "expandToFullUI";
  SearchPageEvents3["createArticle"] = "createArticle";
  SearchPageEvents3["recentQueriesClick"] = "recentQueriesClick";
  SearchPageEvents3["clearRecentQueries"] = "clearRecentQueries";
})(SearchPageEvents2 || (SearchPageEvents2 = {}));

// node_modules/@coveo/headless/dist/esm/features/analytics/analytics-actions.js
var validateEvent = (p) => validatePayload(p, {
  evt: requiredNonEmptyString,
  type: nonEmptyString
});
var logSearchEvent = (p) => makeAnalyticsAction("analytics/generic/search", (client) => {
  validateEvent(p);
  const { evt, meta } = p;
  return client.makeSearchEvent(evt, meta);
});
var logClickEvent = (p) => makeAnalyticsAction("analytics/generic/click", (client, state) => {
  validateResultPayload(p.result);
  validateEvent(p);
  return client.makeClickEvent(p.evt, partialDocumentInformation(p.result, state), documentIdentifier(p.result), p.meta);
});
var logCustomEvent = (p) => makeAnalyticsAction("analytics/generic/custom", (client) => {
  validateEvent(p);
  return client.makeCustomEventWithType(p.evt, p.type, p.meta);
});
var logInterfaceLoad = () => makeAnalyticsAction("analytics/interface/load", (client) => client.makeInterfaceLoad());
var logInterfaceChange = () => makeAnalyticsAction("analytics/interface/change", (client, state) => client.makeInterfaceChange({
  interfaceChangeTo: state.configuration.analytics.originLevel2
}));
var logSearchFromLink = () => makeAnalyticsAction("analytics/interface/searchFromLink", (client) => client.makeSearchFromLink());
var logOmniboxFromLink = (metadata) => makeAnalyticsAction("analytics/interface/omniboxFromLink", (client) => client.makeOmniboxFromLink(metadata));
var interfaceLoad = () => ({
  actionCause: SearchPageEvents2.interfaceLoad
});
var interfaceChange = () => ({
  actionCause: SearchPageEvents2.interfaceChange
});
var searchFromLink = () => ({
  actionCause: SearchPageEvents2.searchFromLink
});
var omniboxFromLink = () => ({
  actionCause: SearchPageEvents2.omniboxFromLink
});

// node_modules/@coveo/headless/dist/esm/features/configuration/configuration-actions.js
var originSchemaOnConfigUpdate = () => nonEmptyString;
var originSchemaOnUpdate = () => requiredNonEmptyString;
var updateBasicConfiguration = createAction("configuration/updateBasicConfiguration", (payload) => validatePayload(payload, {
  accessToken: nonEmptyString,
  environment: new StringValue({
    required: false,
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  }),
  organizationId: nonEmptyString
}));
var updateSearchConfiguration = createAction("configuration/updateSearchConfiguration", (payload) => {
  return validatePayload(payload, {
    proxyBaseUrl: new StringValue({ required: false, url: true }),
    pipeline: new StringValue({ required: false, emptyAllowed: true }),
    searchHub: nonEmptyString,
    timezone: nonEmptyString,
    locale: nonEmptyString,
    authenticationProviders: new ArrayValue({
      required: false,
      each: requiredNonEmptyString
    })
  });
});
var analyticsConfigurationSchema = {
  enabled: new BooleanValue({ default: true }),
  originContext: originSchemaOnConfigUpdate(),
  originLevel2: originSchemaOnConfigUpdate(),
  originLevel3: originSchemaOnConfigUpdate(),
  proxyBaseUrl: new StringValue({ required: false, url: true }),
  runtimeEnvironment: new Value(),
  anonymous: new BooleanValue({ default: false }),
  deviceId: nonEmptyString,
  userDisplayName: nonEmptyString,
  documentLocation: nonEmptyString,
  trackingId: optionalTrackingId,
  analyticsMode: new StringValue({
    constrainTo: ["legacy", "next"],
    required: false,
    default: "next"
  }),
  source: new RecordValue({
    options: { required: false },
    values: COVEO_FRAMEWORK.reduce((acc, framework) => {
      acc[framework] = optionalNonEmptyVersionString;
      return acc;
    }, {})
  })
};
var updateAnalyticsConfiguration = createAction("configuration/updateAnalyticsConfiguration", (payload) => {
  return validatePayload(payload, analyticsConfigurationSchema);
});
var disableAnalytics = createAction("configuration/analytics/disable");
var enableAnalytics = createAction("configuration/analytics/enable");
var setOriginLevel2 = createAction("configuration/analytics/originlevel2", (payload) => validatePayload(payload, { originLevel2: originSchemaOnUpdate() }));
var setOriginLevel3 = createAction("configuration/analytics/originlevel3", (payload) => validatePayload(payload, { originLevel3: originSchemaOnUpdate() }));
var setAgentId = createAction("knowledge/setAgentId", (payload) => validatePayload(payload, new StringValue({ required: true })));

// node_modules/@coveo/headless/dist/esm/features/search-parameters/search-parameter-schema.js
var searchParametersDefinition = {
  q: new StringValue(),
  enableQuerySyntax: new BooleanValue(),
  aq: new StringValue(),
  cq: new StringValue(),
  firstResult: new NumberValue({ min: 0 }),
  numberOfResults: new NumberValue({ min: 0 }),
  sortCriteria: new StringValue(),
  f: new RecordValue(),
  fExcluded: new RecordValue(),
  cf: new RecordValue(),
  nf: new RecordValue(),
  mnf: new RecordValue(),
  df: new RecordValue(),
  debug: new BooleanValue(),
  sf: new RecordValue(),
  tab: new StringValue(),
  af: new RecordValue()
};

// node_modules/@coveo/headless/dist/esm/features/search-parameters/search-parameter-actions.js
var restoreSearchParameters = createAction("searchParameters/restore", (payload) => validatePayload(payload, searchParametersDefinition));
var restoreTab = createAction("searchParameters/restoreTab", (payload) => validatePayload(payload, requiredNonEmptyString));

// node_modules/@coveo/headless/dist/esm/features/debug/debug-actions.js
var enableDebug = createAction("debug/enable");
var disableDebug = createAction("debug/disable");

// node_modules/@coveo/headless/dist/esm/features/debug/debug-state.js
var getDebugInitialState = () => false;

// node_modules/@coveo/headless/dist/esm/features/debug/debug-slice.js
var debugReducer = createReducer(getDebugInitialState(), (builder) => {
  builder.addCase(enableDebug, () => true).addCase(disableDebug, () => false).addCase(restoreSearchParameters, (state, action) => {
    return action.payload.debug ?? state;
  });
});

// node_modules/@coveo/headless/dist/esm/features/history/history-actions.js
var undo = createAction("history/undo");
var redo = createAction("history/redo");
var snapshot = createAction("history/snapshot");
var back = createAsyncThunk("history/back", async (_, { dispatch }) => {
  dispatch(undo());
  await dispatch(change());
});
var forward = createAsyncThunk("history/forward", async (_, { dispatch }) => {
  dispatch(redo());
  await dispatch(change());
});
var change = createAsyncThunk("history/change", async (_, { getState }) => {
  const s = getState();
  return s.history.present;
});

// node_modules/@coveo/headless/dist/esm/features/pipeline/pipeline-actions.js
var setPipeline = createAction("pipeline/set", (payload) => validatePayload(payload, new StringValue({ required: true, emptyAllowed: true })));

// node_modules/@coveo/headless/dist/esm/features/pipeline/pipeline-slice.js
var pipelineReducer = createReducer(getPipelineInitialState(), (builder) => {
  builder.addCase(setPipeline, (_, action) => action.payload).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.pipeline) ?? state;
  }).addCase(updateSearchConfiguration, (state, action) => action.payload.pipeline || state);
});

// node_modules/@coveo/headless/dist/esm/features/breadcrumb/breadcrumb-actions.js
var deselectAllBreadcrumbs = createAction("breadcrumb/deselectAll");
var deselectAllNonBreadcrumbs = createAction("breadcrumb/deselectAllNonBreadcrumbs");

// node_modules/@coveo/headless/dist/esm/features/facets/generic/facet-actions.js
var updateFacetAutoSelection = createAction("facet/updateFacetAutoSelection", (payload) => validatePayload(payload, {
  allow: new BooleanValue({ required: true })
}));

// node_modules/@coveo/headless/dist/esm/api/analytics/instant-result-analytics.js
var InstantResultsAnalyticsProvider = class extends SearchAnalyticsProvider {
  constructor(getState) {
    super(getState);
    __publicField(this, "getState");
    this.getState = getState;
  }
  get activeInstantResultQuery() {
    const state = this.getState().instantResults;
    for (const id in state) {
      for (const query2 in state[id].cache) {
        if (state[id].cache[query2].isActive) {
          return state[id].q;
        }
      }
    }
    return null;
  }
  get activeInstantResultCache() {
    const state = this.getState().instantResults;
    for (const id in state) {
      for (const query2 in state[id].cache) {
        if (state[id].cache[query2].isActive) {
          return state[id].cache[query2];
        }
      }
    }
    return null;
  }
  get results() {
    var _a;
    return (_a = this.activeInstantResultCache) == null ? void 0 : _a.results;
  }
  get queryText() {
    return this.activeInstantResultQuery ?? getQueryInitialState().q;
  }
  get responseTime() {
    var _a;
    return ((_a = this.activeInstantResultCache) == null ? void 0 : _a.duration) ?? getSearchInitialState().duration;
  }
  get numberOfResults() {
    var _a;
    return ((_a = this.activeInstantResultCache) == null ? void 0 : _a.totalCountFiltered) ?? getSearchInitialState().response.totalCountFiltered;
  }
  getSearchUID() {
    var _a;
    const searchUid = (_a = this.activeInstantResultCache) == null ? void 0 : _a.searchUid;
    return searchUid || super.getSearchUID();
  }
};

// node_modules/@coveo/headless/dist/esm/features/instant-results/instant-result-analytics-actions.js
var logInstantResultOpen = (result) => makeAnalyticsAction({
  prefix: "analytics/instantResult/open",
  __legacy__getBuilder: (client, state) => {
    validateResultPayload(result);
    return client.makeDocumentOpen(partialDocumentInformation(result, state), documentIdentifier(result));
  },
  __legacy__provider: (getState) => new InstantResultsAnalyticsProvider(getState),
  analyticsType: "itemClick",
  analyticsPayloadBuilder: (state) => {
    const docInfo = partialDocumentInformation(result, state);
    const docId = documentIdentifier(result);
    return {
      responseId: result.searchUid ?? "",
      position: docInfo.documentPosition,
      itemMetadata: {
        uniqueFieldName: docId.contentIDKey,
        uniqueFieldValue: docId.contentIDValue,
        title: docInfo.documentTitle,
        author: docInfo.documentAuthor,
        url: docInfo.documentUrl
      }
    };
  }
});
var logInstantResultsSearch = () => makeAnalyticsAction("analytics/instantResult/searchboxAsYouType", (client) => client.makeSearchboxAsYouType(), (getState) => new InstantResultsAnalyticsProvider(getState));
var searchboxAsYouType = () => ({
  actionCause: SearchPageEvents2.searchboxAsYouType
});

// node_modules/@coveo/headless/dist/esm/features/instant-results/instant-results-actions.js
var instantResultsRegisterDefinition = {
  id: requiredNonEmptyString
};
var instantResultsQueryDefinition = {
  ...instantResultsRegisterDefinition,
  q: requiredEmptyAllowedString
};
var registerInstantResults = createAction("instantResults/register", (payload) => validatePayload(payload, instantResultsRegisterDefinition));
var updateInstantResultsQuery = createAction("instantResults/updateQuery", (payload) => validatePayload(payload, instantResultsQueryDefinition));
var clearExpiredResults = createAction("instantResults/clearExpired", (payload) => validatePayload(payload, instantResultsRegisterDefinition));

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-actions.js
var numberValue = new NumberValue({ required: true, min: 0 });
var registerNumberOfResults = createAction("pagination/registerNumberOfResults", (payload) => validatePayload(payload, numberValue));
var updateNumberOfResults = createAction("pagination/updateNumberOfResults", (payload) => validatePayload(payload, numberValue));
var registerPage = createAction("pagination/registerPage", (payload) => validatePayload(payload, numberValue));
var updatePage = createAction("pagination/updatePage", (payload) => validatePayload(payload, numberValue));
var nextPage = createAction("pagination/nextPage");
var previousPage = createAction("pagination/previousPage");

// node_modules/@coveo/headless/dist/esm/features/query/query-actions.js
var updateQuery = createAction("query/updateQuery", (payload) => validatePayload(payload, {
  q: new StringValue(),
  enableQuerySyntax: new BooleanValue()
}));

// node_modules/@coveo/headless/dist/esm/features/configuration/analytics-params.js
var fromAnalyticsStateToAnalyticsParams = (s, navigatorContext, eventDescription) => {
  return {
    analytics: {
      clientId: navigatorContext.clientId,
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: navigatorContext.referrer,
      documentLocation: navigatorContext.location,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause
      },
      ...eventDescription && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.deviceId && { deviceId: s.deviceId },
      ...s.trackingId && { trackingId: s.trackingId },
      ...{
        capture: navigatorContext.capture ?? navigatorContext.clientId !== ""
      },
      ...{ source: getAnalyticsSource(s) }
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/search-and-folding/search-and-folding-request.js
var buildSearchAndFoldingLoadCollectionRequest = (state, navigatorContext, eventDescription) => {
  var _a, _b, _c, _d;
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: navigatorContext.referrer,
    timezone: state.configuration.search.timezone,
    ...((_a = state.advancedSearchQueries) == null ? void 0 : _a.aq) && {
      aq: state.advancedSearchQueries.aq
    },
    ...((_b = state.advancedSearchQueries) == null ? void 0 : _b.cq) && {
      cq: state.advancedSearchQueries.cq
    },
    ...((_c = state.advancedSearchQueries) == null ? void 0 : _c.lq) && {
      lq: state.advancedSearchQueries.lq
    },
    ...((_d = state.advancedSearchQueries) == null ? void 0 : _d.dq) && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && fromAnalyticsStateToAnalyticsParams(state.configuration.analytics, navigatorContext, eventDescription),
    ...state.excerptLength && !isNullOrUndefined(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/configuration/legacy-analytics-params.js
var fromAnalyticsStateToAnalyticsParams2 = async (s, eventDescription) => {
  const isNextAnalytics = s.analyticsMode === "next";
  return {
    analytics: {
      clientId: await getVisitorID(s),
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: s.originLevel3,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause,
        customData: eventDescription.customData
      },
      ...eventDescription && !isNextAnalytics && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.documentLocation && { documentLocation: s.documentLocation },
      ...s.deviceId && { deviceId: s.deviceId },
      ...getPageID() && { pageId: getPageID() },
      ...isNextAnalytics && s.trackingId && { trackingId: s.trackingId },
      ...{ capture: isNextAnalytics },
      ...isNextAnalytics && { source: getAnalyticsSource(s) }
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/search-and-folding/legacy/search-and-folding-request.js
var buildSearchAndFoldingLoadCollectionRequest2 = async (state, eventDescription) => {
  var _a, _b, _c, _d;
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: state.configuration.analytics.originLevel3,
    timezone: state.configuration.search.timezone,
    ...state.configuration.analytics.enabled && {
      actionsHistory: history_store_default.getInstance().getHistory()
    },
    ...((_a = state.advancedSearchQueries) == null ? void 0 : _a.aq) && {
      aq: state.advancedSearchQueries.aq
    },
    ...((_b = state.advancedSearchQueries) == null ? void 0 : _b.cq) && {
      cq: state.advancedSearchQueries.cq
    },
    ...((_c = state.advancedSearchQueries) == null ? void 0 : _c.lq) && {
      lq: state.advancedSearchQueries.lq
    },
    ...((_d = state.advancedSearchQueries) == null ? void 0 : _d.dq) && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && await fromAnalyticsStateToAnalyticsParams2(state.configuration.analytics, eventDescription),
    ...state.excerptLength && !isNullOrUndefined(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/advanced-search-queries/advanced-search-queries-state.js
var getAdvancedSearchQueriesInitialState = () => ({
  cq: "",
  cqWasSet: false,
  aq: "",
  aqWasSet: false,
  lq: "",
  lqWasSet: false,
  dq: "",
  dqWasSet: false,
  defaultFilters: {
    cq: "",
    aq: "",
    lq: "",
    dq: ""
  }
});

// node_modules/@coveo/headless/dist/esm/features/search/search-analytics-actions.js
var logFetchMoreResults = () => makeAnalyticsAction("search/logFetchMoreResults", (client) => client.makeFetchMoreResults());
var logQueryError = (error) => makeAnalyticsAction("search/queryError", (client, state) => {
  var _a, _b, _c, _d;
  return client.makeQueryError({
    query: ((_a = state.query) == null ? void 0 : _a.q) || getQueryInitialState().q,
    aq: ((_b = state.advancedSearchQueries) == null ? void 0 : _b.aq) || getAdvancedSearchQueriesInitialState().aq,
    cq: ((_c = state.advancedSearchQueries) == null ? void 0 : _c.cq) || getAdvancedSearchQueriesInitialState().cq,
    dq: ((_d = state.advancedSearchQueries) == null ? void 0 : _d.dq) || getAdvancedSearchQueriesInitialState().dq,
    errorType: error.type,
    errorMessage: error.message
  });
});

// node_modules/@coveo/headless/dist/esm/api/search/date/relative-date.js
var import_dayjs2 = __toESM(require_dayjs_min(), 1);
var import_quarterOfYear = __toESM(require_quarterOfYear(), 1);

// node_modules/@coveo/headless/dist/esm/api/search/date/date-format.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_customParseFormat = __toESM(require_customParseFormat(), 1);
import_dayjs.default.extend(import_customParseFormat.default);
var API_DATE_FORMAT = "YYYY/MM/DD@HH:mm:ss";
var API_DATE_MINIMUM = "1401-01-01";
function parseDate(date, format) {
  const parsedDate = (0, import_dayjs.default)(date, format);
  if (!parsedDate.isValid() && !format) {
    return (0, import_dayjs.default)(date, API_DATE_FORMAT);
  }
  return parsedDate;
}
function formatDateForSearchApi(date) {
  return date.format(API_DATE_FORMAT);
}
function isSearchApiDate(date) {
  return formatDateForSearchApi(parseDate(date)) === date;
}
function validateAbsoluteDate(date, dateFormat) {
  const dayJSDate = parseDate(date, dateFormat);
  if (!dayJSDate.isValid()) {
    const provideFormat = ". Please provide a date format string in the configuration options. See https://day.js.org/docs/en/parse/string-format for more information.";
    const withFormat = ` with the format "${dateFormat}"`;
    throw new Error(`Could not parse the provided date "${date}"${dateFormat ? withFormat : provideFormat}`);
  }
  assertDateAboveAPIMinimum(dayJSDate);
}
function assertDateAboveAPIMinimum(date) {
  if (date.isBefore(API_DATE_MINIMUM)) {
    throw new Error(`Date is before year 1401, which is unsupported by the API: ${date}`);
  }
}

// node_modules/@coveo/headless/dist/esm/api/search/date/relative-date.js
import_dayjs2.default.extend(import_quarterOfYear.default);
var validRelativeDatePeriods = ["past", "now", "next"];
var validRelativeDateUnits = [
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year"
];
var buildRelativeDateDefinition = (period) => {
  const isNow = period === "now";
  return {
    amount: new NumberValue({ required: !isNow, min: 1 }),
    unit: new StringValue({
      required: !isNow,
      constrainTo: validRelativeDateUnits
    }),
    period: new StringValue({
      required: true,
      constrainTo: validRelativeDatePeriods
    })
  };
};
function validateRelativeDate(date) {
  if (typeof date === "string" && !isRelativeDateFormat(date)) {
    throw new Error(`The value "${date}" is not respecting the relative date format "period-amount-unit"`);
  }
  const relativeDate = typeof date === "string" ? parseRelativeDate(date) : date;
  new Schema(buildRelativeDateDefinition(relativeDate.period)).validate(relativeDate);
  const dayJsDate = relativeToAbsoluteDate(relativeDate);
  const stringifiedDate = JSON.stringify(relativeDate);
  if (!dayJsDate.isValid()) {
    throw new Error(`Date is invalid: ${stringifiedDate}`);
  }
  assertDateAboveAPIMinimum(dayJsDate);
}
function serializeRelativeDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
    case "next":
      return `${period}-${amount}-${unit}`;
    case "now":
      return period;
  }
}
function relativeToAbsoluteDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
      return (0, import_dayjs2.default)().subtract(amount, unit);
    case "next":
      return (0, import_dayjs2.default)().add(amount, unit);
    case "now":
      return (0, import_dayjs2.default)();
  }
}
function formatRelativeDateForSearchApi(relativeDate) {
  return formatDateForSearchApi(relativeToAbsoluteDate(parseRelativeDate(relativeDate)));
}
function splitDate(date) {
  return date.toLocaleLowerCase().split("-");
}
function isRelativeDateFormat(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return true;
  }
  if (!validRelativeDatePeriods.includes(period)) {
    return false;
  }
  if (!validRelativeDateUnits.includes(unit)) {
    return false;
  }
  const intAmount = parseInt(amount);
  if (Number.isNaN(intAmount) || intAmount <= 0) {
    return false;
  }
  return true;
}
function isRelativeDate(date) {
  return !!date && typeof date === "object" && "period" in date;
}
function parseRelativeDate(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return {
      period: "now"
    };
  }
  return {
    period,
    amount: amount ? parseInt(amount) : void 0,
    unit: unit ? unit : void 0
  };
}
function deserializeRelativeDate(date) {
  validateRelativeDate(date);
  return parseRelativeDate(date);
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/interfaces/request.js
function isDateFacetRequest(request) {
  return request.type === "dateRange";
}

// node_modules/@coveo/headless/dist/esm/features/search/search-mappings.js
function formatStartFacetValue(value) {
  return `start${value}`;
}
function formatEndFacetValue(value) {
  return `end${value}`;
}
var initialSearchMappings = () => ({
  dateFacetValueMap: {}
});
function mapDateRangeRequest(value, facetId2, mappings) {
  let start = value.start;
  let end = value.end;
  if (isRelativeDateFormat(start)) {
    start = formatRelativeDateForSearchApi(start);
    mappings.dateFacetValueMap[facetId2][formatStartFacetValue(start)] = value.start;
  }
  if (isRelativeDateFormat(end)) {
    end = formatRelativeDateForSearchApi(end);
    mappings.dateFacetValueMap[facetId2][formatEndFacetValue(end)] = value.end;
  }
  return { ...value, start, end };
}
function mapFacetRequest(facetRequest, mappings) {
  if (isDateFacetRequest(facetRequest)) {
    const { facetId: facetId2, currentValues } = facetRequest;
    mappings.dateFacetValueMap[facetId2] = {};
    return {
      ...facetRequest,
      currentValues: currentValues.map((value) => mapDateRangeRequest(value, facetId2, mappings))
    };
  }
  return facetRequest;
}
function mapSearchRequest(searchRequest) {
  var _a;
  const mappings = initialSearchMappings();
  const request = {
    ...searchRequest,
    facets: (_a = searchRequest.facets) == null ? void 0 : _a.map((facetRequest) => mapFacetRequest(facetRequest, mappings))
  };
  return { request, mappings };
}
function mapDateRangeResponse(value, facetId2, mappings) {
  return {
    ...value,
    start: mappings.dateFacetValueMap[facetId2][formatStartFacetValue(value.start)] || value.start,
    end: mappings.dateFacetValueMap[facetId2][formatEndFacetValue(value.end)] || value.end
  };
}
function isDateFacetResponse(facetResponse, mappings) {
  return facetResponse.facetId in mappings.dateFacetValueMap;
}
function mapFacetResponse(facetResponse, mappings) {
  if (isDateFacetResponse(facetResponse, mappings)) {
    return {
      ...facetResponse,
      values: facetResponse.values.map((value) => mapDateRangeResponse(value, facetResponse.facetId, mappings))
    };
  }
  return facetResponse;
}
function mapSearchResponse(response, mappings) {
  var _a;
  if ("success" in response) {
    const success = {
      ...response.success,
      facets: (_a = response.success.facets) == null ? void 0 : _a.map((facetResponse) => mapFacetResponse(facetResponse, mappings))
    };
    return { success };
  }
  return response;
}

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-actions.js
var enableDidYouMean = createAction("didYouMean/enable");
var disableDidYouMean = createAction("didYouMean/disable");
var disableAutomaticQueryCorrection = createAction("didYouMean/automaticCorrections/disable");
var enableAutomaticQueryCorrection = createAction("didYouMean/automaticCorrections/enable");
var applyDidYouMeanCorrection = createAction("didYouMean/correction", (payload) => validatePayload(payload, requiredNonEmptyString));
var setCorrectionMode = createAction("didYouMean/automaticCorrections/mode", (payload) => validatePayload(payload, new StringValue({
  constrainTo: ["next", "legacy"],
  emptyAllowed: false,
  required: true
})));

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-analytics-actions.js
var logDidYouMeanClick = () => makeAnalyticsAction("analytics/didyoumean/click", (client) => client.makeDidYouMeanClick());
var logDidYouMeanAutomatic = () => makeAnalyticsAction("analytics/didyoumean/automatic", (client) => client.makeDidYouMeanAutomatic());
var didYouMeanClick = () => ({
  actionCause: SearchPageEvents2.didYouMeanClick
});
var didYouMeanAutomatic = () => ({
  actionCause: SearchPageEvents2.didYouMeanAutomatic
});

// node_modules/@coveo/headless/dist/esm/features/context/context-state.js
function getContextInitialState() {
  return {
    contextValues: {}
  };
}

// node_modules/@coveo/headless/dist/esm/features/dictionary-field-context/dictionary-field-context-state.js
function getDictionaryFieldContextInitialState() {
  return {
    contextValues: {}
  };
}

// node_modules/@coveo/headless/dist/esm/features/facet-options/facet-options-state.js
function getFacetOptionsSliceInitialState() {
  return { enabled: true, tabs: {} };
}
function getFacetOptionsInitialState() {
  return {
    freezeFacetOrder: false,
    facets: {}
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-order/facet-order-state.js
function getFacetOrderInitialState() {
  return [];
}

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-state.js
function getPaginationInitialState() {
  return {
    firstResult: 0,
    defaultNumberOfResults: 10,
    numberOfResults: 10,
    totalCountFiltered: 0
  };
}

// node_modules/@coveo/headless/dist/esm/features/query-set/query-set-state.js
function getQuerySetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/static-filter-set/static-filter-set-state.js
function getStaticFilterSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/tab-set/tab-set-state.js
function getTabSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/history/history-state.js
function getHistoryInitialState() {
  return extractHistory({});
}
function extractHistory(state) {
  return {
    context: state.context || getContextInitialState(),
    dictionaryFieldContext: state.dictionaryFieldContext || getDictionaryFieldContextInitialState(),
    facetSet: state.facetSet || getFacetSetInitialState(),
    numericFacetSet: state.numericFacetSet || getNumericFacetSetInitialState(),
    dateFacetSet: state.dateFacetSet || getDateFacetSetInitialState(),
    categoryFacetSet: state.categoryFacetSet || getCategoryFacetSetInitialState(),
    automaticFacetSet: state.automaticFacetSet ?? getAutomaticFacetSetInitialState(),
    pagination: state.pagination || getPaginationInitialState(),
    query: state.query || getQueryInitialState(),
    tabSet: state.tabSet || getTabSetInitialState(),
    advancedSearchQueries: state.advancedSearchQueries || getAdvancedSearchQueriesInitialState(),
    staticFilterSet: state.staticFilterSet || getStaticFilterSetInitialState(),
    querySet: state.querySet || getQuerySetInitialState(),
    sortCriteria: state.sortCriteria || getSortCriteriaInitialState(),
    pipeline: state.pipeline || getPipelineInitialState(),
    searchHub: state.searchHub || getSearchHubInitialState(),
    facetOptions: state.facetOptions || getFacetOptionsInitialState(),
    facetOrder: state.facetOrder ?? getFacetOrderInitialState(),
    debug: state.debug ?? getDebugInitialState()
  };
}

// node_modules/@coveo/headless/dist/esm/features/triggers/trigger-analytics-actions.js
var logUndoTriggerQueryPayloadDefinition = new RecordValue({
  values: {
    undoneQuery: requiredEmptyAllowedString
  },
  options: { required: true }
});
var logTriggerQuery = () => makeAnalyticsAction("analytics/trigger/query", (client, state) => {
  var _a;
  if ((_a = state.triggers) == null ? void 0 : _a.queryModification.newQuery) {
    return client.makeTriggerQuery();
  }
  return null;
});
var logUndoTriggerQuery = (payload) => makeAnalyticsAction("analytics/trigger/query/undo", (client) => {
  validatePayload(payload, logUndoTriggerQueryPayloadDefinition);
  return client.makeUndoTriggerQuery(payload);
});
var logNotifyTrigger = () => makeAnalyticsAction("analytics/trigger/notify", (client, state) => {
  var _a;
  if (!((_a = state.triggers) == null ? void 0 : _a.notifications.length)) {
    return null;
  }
  return client.makeTriggerNotify({
    notifications: state.triggers.notifications
  });
});
var logTriggerRedirect = () => makeAnalyticsAction("analytics/trigger/redirect", (client, state) => {
  var _a;
  if ((_a = state.triggers) == null ? void 0 : _a.redirectTo) {
    return client.makeTriggerRedirect({
      redirectedTo: state.triggers.redirectTo
    });
  }
  return null;
});
var logTriggerExecute = () => makeAnalyticsAction("analytics/trigger/execute", (client, state) => {
  var _a;
  if (!((_a = state.triggers) == null ? void 0 : _a.executions.length)) {
    return null;
  }
  return client.makeTriggerExecute({
    executions: state.triggers.executions
  });
});

// node_modules/@coveo/headless/dist/esm/features/triggers/triggers-actions.js
var updateIgnoreQueryTrigger = createAction("trigger/query/ignore", (q) => validatePayload(q, new StringValue({ emptyAllowed: true, required: true })));
var applyQueryTriggerModification = createAction("trigger/query/modification", (payload) => validatePayload(payload, new RecordValue({
  values: { originalQuery: nonEmptyString, modification: nonEmptyString }
})));

// node_modules/@coveo/headless/dist/esm/features/facets/generic/interfaces/generic-facet-request.js
function getFacetRequests2(state) {
  return Object.values(state).map((slice) => slice.request);
}

// node_modules/@coveo/headless/dist/esm/utils/facet-utils.js
function sortFacets(facets, sortOrder) {
  const payloadMap = {};
  facets.forEach((f3) => {
    payloadMap[f3.facetId] = f3;
  });
  const sortedFacets = [];
  sortOrder.forEach((facetId2) => {
    if (facetId2 in payloadMap) {
      sortedFacets.push(payloadMap[facetId2]);
      delete payloadMap[facetId2];
    }
  });
  const remainingFacets = Object.values(payloadMap);
  return [...sortedFacets, ...remainingFacets];
}
function getRangeFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    if (request.generateAutomaticRanges && !hasActiveValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
var sortCriteriaMap = {
  alphanumericDescending: { type: "alphanumeric", order: "descending" },
  alphanumericNaturalDescending: {
    type: "alphanumericNatural",
    order: "descending"
  }
};
function getSpecificFacetRequests(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getAllFacets(state) {
  return [
    ...getSpecificFacetRequests(state.facetSet ?? {}),
    ...getRangeFacetRequests(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getAllEnabledFacets(state) {
  return getAllFacets(state).filter(({ facetId: facetId2 }) => {
    var _a, _b;
    return ((_b = (_a = state.facetOptions) == null ? void 0 : _a.facets[facetId2]) == null ? void 0 : _b.enabled) ?? true;
  });
}
function getFacets(state) {
  return sortFacets(getAllEnabledFacets(state), state.facetOrder ?? []);
}

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-constants.js
var minimumPage = 1;
var maximumNumberOfResultsFromIndex = 5e3;

// node_modules/@coveo/headless/dist/esm/features/search/legacy/search-request.js
var buildSearchRequest = async (state, eventDescription) => {
  var _a;
  const cq = buildConstantQuery(state);
  const facets = getFacets(state);
  const automaticFacets = getAutomaticFacets2(state);
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest2(state, eventDescription);
  const getNumberOfResultsWithinIndexLimit2 = () => {
    if (!state.pagination) {
      return void 0;
    }
    const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
    if (isOverIndexLimit) {
      return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
    }
    return state.pagination.numberOfResults;
  };
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit2(),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...((_a = state.folding) == null ? void 0 : _a.enabled) && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getAutomaticFacets2(state) {
  var _a;
  const facets = (_a = state.automaticFacetSet) == null ? void 0 : _a.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function buildConstantQuery(state) {
  var _a;
  const cq = ((_a = state.advancedSearchQueries) == null ? void 0 : _a.cq.trim()) || "";
  const activeTab = Object.values(state.tabSet || {}).find((tab) => tab.isActive);
  const tabExpression = (activeTab == null ? void 0 : activeTab.expression.trim()) || "";
  const filterExpressions = getStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}
function getStaticFilterExpressions(state) {
  const filters = Object.values(state.staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter((value) => value.state === "selected" && !!value.expression.trim());
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
}

// node_modules/@coveo/headless/dist/esm/features/search/legacy/search-actions-thunk-processor.js
var AsyncSearchThunkProcessor = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    __publicField(this, "config");
    __publicField(this, "onUpdateQueryForCorrection");
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    var _a;
    const startedAt = Date.now();
    const response = mapSearchResponse(await this.extra.apiClient.search(request, options), mappings);
    const duration = Date.now() - startedAt;
    const queryExecuted = ((_a = this.getState().query) == null ? void 0 : _a.q) || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !isNullOrUndefined(queryCorrection) && !isNullOrUndefined(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(originalFetchedResponse);
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse) {
    var _a;
    const state = this.getState();
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    (_a = this.analyticsAction) == null ? void 0 : _a.call(this)(this.dispatch, () => this.getStateAfterResponse(originalFetchedResponse.queryExecuted, originalFetchedResponse.duration, state, successResponse), this.extra);
  }
  async processQueryTriggersOrContinue(fetched) {
    var _a, _b;
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = ((_a = successResponse.triggers.find((trigger) => trigger.type === "query")) == null ? void 0 : _a.content) || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = (_b = this.getState().triggers) == null ? void 0 : _b.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    if (this.analyticsAction) {
      await this.dispatch(this.analyticsAction);
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery,
      analyticsAction: logTriggerQuery()
    };
  }
  getStateAfterResponse(query2, duration, previousState, response) {
    var _a;
    return {
      ...previousState,
      query: {
        q: query2,
        enableQuerySyntax: ((_a = previousState.query) == null ? void 0 : _a.enableQuerySyntax) ?? getQueryInitialState().enableQuerySyntax
      },
      search: {
        ...getSearchInitialState(),
        duration,
        response,
        results: response.results
      }
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery(),
      analyticsAction: this.analyticsAction
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const fetched = await this.fetchFromAPI(await buildSearchRequest(this.getState()), { origin: "mainSearch" });
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(applyQueryTriggerModification({
      newQuery: modified,
      originalQuery: this.getCurrentQuery()
    }));
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(await buildSearchRequest(this.getState()), { origin: "mainSearch" });
    return fetched;
  }
  getCurrentQuery() {
    var _a;
    const state = this.getState();
    return ((_a = state.query) == null ? void 0 : _a.q) !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get analyticsAction() {
    return this.config.analyticsAction;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// node_modules/@coveo/headless/dist/esm/features/search/legacy/search-actions.js
var executeSearch = createAsyncThunk("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  return await legacyExecuteSearch(state, config, searchAction);
});
var fetchPage = createAsyncThunk("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchPage(state, config, searchAction);
});
var fetchMoreResults = createAsyncThunk("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  return await legacyFetchMoreResults(config, state);
});
var fetchFacetValues = createAsyncThunk("search/fetchFacetValues", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchFacetValues(config, searchAction, state);
});
var fetchInstantResults = createAsyncThunk("search/fetchInstantResults", async (payload, config) => {
  return legacyFetchInstantResults(payload, config);
});
var buildFetchMoreRequest = async (state, eventDescription) => {
  var _a, _b;
  const mappedRequest = await buildSearchRequest(state, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (((_a = state.pagination) == null ? void 0 : _a.firstResult) ?? 0) + (((_b = state.search) == null ? void 0 : _b.results.length) ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest = async (state, q, numberOfResults) => {
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest2(state);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory = (state) => {
  var _a;
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...((_a = state.query) == null ? void 0 : _a.q) && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
async function legacyFetchInstantResults(payload, config) {
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const state = config.getState();
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: logInstantResultsSearch() }, (modification) => {
    config.dispatch(updateInstantResultsQuery({ q: modification, id: payload.id }));
  });
  const request = await buildInstantResultSearchRequest(state, q, maxResultsPerQuery);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      analyticsAction: processed.analyticsAction,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
}
async function legacyFetchPage(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: searchAction
  });
  const request = await buildSearchRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchMoreResults(config, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await logFetchMoreResults().prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({
    ...config,
    analyticsAction: logFetchMoreResults()
  });
  const request = await buildFetchMoreRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchFacetValues(config, searchAction, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const request = await buildFetchFacetValuesRequest(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
}
async function legacyExecuteSearch(state, config, searchAction) {
  addEntryInActionsHistory(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const request = await buildSearchRequest(state, eventDescription);
  const processor = new AsyncSearchThunkProcessor({ ...config, analyticsAction: searchAction });
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}

// node_modules/@coveo/headless/dist/esm/features/static-filter-set/static-filter-set-selectors.js
var selectStaticFilterExpressions = createSelector((state) => state.staticFilterSet, (staticFilterSet) => {
  const filters = Object.values(staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter((value) => value.state === "selected" && !!value.expression.trim());
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
});

// node_modules/@coveo/headless/dist/esm/features/search/search-request.js
var buildSearchRequest2 = async (state, navigatorContext, eventDescription) => {
  var _a;
  const cq = buildConstantQuery2(state);
  const facets = getFacets2(state);
  const automaticFacets = getAutomaticFacets3(state);
  const sharedWithFoldingRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest2(state, eventDescription) : buildSearchAndFoldingLoadCollectionRequest(state, navigatorContext, eventDescription);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...((_a = state.folding) == null ? void 0 : _a.enabled) && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getNumberOfResultsWithinIndexLimit(state) {
  if (!state.pagination) {
    return void 0;
  }
  const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
  if (isOverIndexLimit) {
    return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
  }
  return state.pagination.numberOfResults;
}
function getFacets2(state) {
  return sortFacets(getAllEnabledFacets2(state), state.facetOrder ?? []);
}
function getAutomaticFacets3(state) {
  var _a;
  const facets = (_a = state.automaticFacetSet) == null ? void 0 : _a.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest2).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest2(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function getAllEnabledFacets2(state) {
  return getAllFacets2(state).filter(({ facetId: facetId2 }) => {
    var _a, _b;
    return ((_b = (_a = state.facetOptions) == null ? void 0 : _a.facets[facetId2]) == null ? void 0 : _b.enabled) ?? true;
  });
}
function getAllFacets2(state) {
  return [
    ...getSpecificFacetRequests2(state.facetSet ?? {}),
    ...getRangeFacetRequests2(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests2(state.dateFacetSet ?? {}),
    ...getFacetRequests2(state.categoryFacetSet ?? {})
  ];
}
function getSpecificFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getRangeFacetRequests2(state) {
  return getFacetRequests2(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    const hasPreviousStateValues = currentValues.some((value) => value.previousState);
    if (request.generateAutomaticRanges && !hasActiveValues && !hasPreviousStateValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
function buildConstantQuery2(state) {
  var _a;
  const cq = ((_a = state.advancedSearchQueries) == null ? void 0 : _a.cq.trim()) || "";
  const activeTab = Object.values(state.tabSet || {}).find((tab) => tab.isActive);
  const tabExpression = (activeTab == null ? void 0 : activeTab.expression.trim()) || "";
  const filterExpressions = selectStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}

// node_modules/@coveo/headless/dist/esm/features/search/search-actions-thunk-processor.js
var AsyncSearchThunkProcessor2 = class {
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery({ q: modification }));
  }) {
    __publicField(this, "config");
    __publicField(this, "onUpdateQueryForCorrection");
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options) {
    var _a;
    const startedAt = Date.now();
    const response = mapSearchResponse(await this.extra.apiClient.search(request, options), mappings);
    const duration = Date.now() - startedAt;
    const queryExecuted = ((_a = this.getState().query) == null ? void 0 : _a.q) || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !isNullOrUndefined(queryCorrection) && !isNullOrUndefined(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(originalFetchedResponse);
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    var _a, _b;
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = ((_a = successResponse.triggers.find((trigger) => trigger.type === "query")) == null ? void 0 : _a.content) || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = (_b = this.getState().triggers) == null ? void 0 : _b.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger(""));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery()
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const state = this.getState();
    const { actionCause } = didYouMeanAutomatic();
    const fetched = await this.fetchFromAPI(await buildSearchRequest2(state, this.extra.navigatorContext, {
      actionCause
    }), { origin: "mainSearch" });
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(applyQueryTriggerModification({
      newQuery: modified,
      originalQuery: this.getCurrentQuery()
    }));
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(await buildSearchRequest2(this.getState(), this.extra.navigatorContext), { origin: "mainSearch" });
    return fetched;
  }
  getCurrentQuery() {
    var _a;
    const state = this.getState();
    return ((_a = state.query) == null ? void 0 : _a.q) !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};

// node_modules/@coveo/headless/dist/esm/features/search/search-actions.js
var prepareForSearchWithQuery = createAsyncThunk("search/prepareForSearchWithQuery", (payload, thunk2) => {
  const { dispatch } = thunk2;
  validatePayload(payload, {
    q: new StringValue(),
    enableQuerySyntax: new BooleanValue(),
    clearFilters: new BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deselectAllBreadcrumbs());
    dispatch(deselectAllNonBreadcrumbs());
  }
  dispatch(updateFacetAutoSelection({ allow: true }));
  dispatch(updateQuery({ q: payload.q, enableQuerySyntax: payload.enableQuerySyntax }));
  dispatch(updatePage(1));
});
var updateSearchAction = createAction("search/updateSearchAction");
var executeSearch2 = createAsyncThunk("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyExecuteSearch(state, config, searchAction.legacy);
  }
  addEntryInActionsHistory2(state);
  const analyticsAction = searchAction.next ? buildSearchReduxAction(searchAction.next) : void 0;
  const request = await buildSearchRequest2(state, config.extra.navigatorContext, analyticsAction);
  const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: analyticsAction ?? {} });
  const fetched = await processor.fetchFromAPI(request, {
    origin: "mainSearch"
  });
  return await processor.process(fetched);
});
var fetchPage2 = createAsyncThunk("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  addEntryInActionsHistory2(state);
  if (state.configuration.analytics.analyticsMode === "legacy" || !searchAction.next) {
    return legacyFetchPage(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction: searchAction.next
  });
  const request = await buildSearchRequest2(state, config.extra.navigatorContext, searchAction.next);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchMoreResults2 = createAsyncThunk("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchMoreResults(config, state);
  }
  const analyticsAction = makeBasicNewSearchAnalyticsAction(SearchPageEvents2.browseResults, config.getState);
  const processor = new AsyncSearchThunkProcessor2({
    ...config,
    analyticsAction
  });
  const request = await buildFetchMoreRequest2(state, config.extra.navigatorContext, analyticsAction);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
var fetchFacetValues2 = createAsyncThunk("search/fetchFacetValues", async (searchAction, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyExecuteSearch(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction: {} });
  const request = await buildFetchFacetValuesRequest2(state, config.extra.navigatorContext);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
});
var fetchInstantResults2 = createAsyncThunk("search/fetchInstantResults", async (payload, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchInstantResults(payload, config);
  }
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const analyticsAction = buildSearchReduxAction(searchboxAsYouType());
  const request = await buildInstantResultSearchRequest2(state, config.extra.navigatorContext, q, maxResultsPerQuery, analyticsAction);
  const processor = new AsyncSearchThunkProcessor2({ ...config, analyticsAction }, (modification) => {
    config.dispatch(updateInstantResultsQuery({ q: modification, id: payload.id }));
  });
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
});
var buildFetchMoreRequest2 = async (state, navigatorContext, eventDescription) => {
  var _a, _b;
  const mappedRequest = await buildSearchRequest2(state, navigatorContext, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (((_a = state.pagination) == null ? void 0 : _a.firstResult) ?? 0) + (((_b = state.search) == null ? void 0 : _b.results.length) ?? 0)
  };
  return mappedRequest;
};
var buildInstantResultSearchRequest2 = async (state, navigatorContext, q, numberOfResults, eventDescription) => {
  const sharedWithFoldingRequest = buildSearchAndFoldingLoadCollectionRequest(state, navigatorContext, eventDescription);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
var buildFetchFacetValuesRequest2 = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest2(state, navigatorContext, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
var addEntryInActionsHistory2 = (state) => {
  var _a;
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "Query",
      ...((_a = state.query) == null ? void 0 : _a.q) && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
var buildSearchReduxAction = (action) => ({
  actionCause: action.actionCause,
  type: action.actionCause
});

// node_modules/@coveo/headless/dist/esm/features/result-templates/result-templates-helpers.js
var getResultProperty = (result, property) => {
  const anyResult = result;
  if (!isNullOrUndefined(anyResult[property])) {
    return anyResult[property];
  }
  if (!isNullOrUndefined(result.raw[property])) {
    return result.raw[property];
  }
  return null;
};
var fieldsMustBeDefined = (fieldNames) => {
  return (result) => {
    return fieldNames.every((fieldName) => !isNullOrUndefined(getResultProperty(result, fieldName)));
  };
};
var fieldsMustNotBeDefined = (fieldNames) => {
  return (result) => {
    return fieldNames.every((fieldName) => isNullOrUndefined(getResultProperty(result, fieldName)));
  };
};
var fieldMustMatch = (fieldName, valuesToMatch) => {
  return (result) => {
    const fieldValues = getFieldValuesFromResult(fieldName, result);
    return valuesToMatch.some((valueToMatch) => fieldValues.some((fieldValue) => `${fieldValue}`.toLowerCase() === valueToMatch.toLowerCase()));
  };
};
var fieldMustNotMatch = (fieldName, blacklistedValues) => {
  return (result) => {
    const fieldValues = getFieldValuesFromResult(fieldName, result);
    return blacklistedValues.every((blacklistedValue) => fieldValues.every((fieldValue) => `${fieldValue}`.toLowerCase() !== blacklistedValue.toLowerCase()));
  };
};
var getFieldValuesFromResult = (fieldName, result) => {
  const rawValue = getResultProperty(result, fieldName);
  return isArray2(rawValue) ? rawValue : [rawValue];
};
var ResultTemplatesHelpers = {
  getResultProperty,
  fieldsMustBeDefined,
  fieldsMustNotBeDefined,
  fieldMustMatch,
  fieldMustNotMatch
};

// node_modules/@coveo/headless/dist/esm/features/search/search-selectors.js
function firstSearchExecutedSelector(state) {
  return state.search.response.searchUid !== "";
}
function resultFromFieldSelector(state, contentIdKey, contentIdValue) {
  return state.search.results.find((result) => getResultProperty(result, contentIdKey) === contentIdValue);
}
var selectSearchActionCause = createSelector((state) => state.search, (state) => {
  var _a;
  return ((_a = state == null ? void 0 : state.searchAction) == null ? void 0 : _a.actionCause) || "";
});

// node_modules/@coveo/headless/dist/esm/features/error/error-actions.js
var setError = createAction("app/setError");

// node_modules/@coveo/headless/dist/esm/features/search/search-slice.js
function handleRejectedSearch(state, action) {
  const error = action.payload ?? null;
  if (error) {
    state.response = getSearchInitialState().response;
    state.results = [];
    state.questionAnswer = emptyQuestionAnswer();
  }
  state.error = error;
  state.isLoading = false;
}
function handleFulfilledSearch(state, action) {
  state.error = null;
  state.response = action.payload.response;
  state.queryExecuted = action.payload.queryExecuted;
  state.duration = action.payload.duration;
  state.isLoading = false;
}
function handleFulfilledNewSearch(state, action) {
  handleFulfilledSearch(state, action);
  state.results = action.payload.response.results.map((result) => ({
    ...result,
    searchUid: action.payload.response.searchUid
  }));
  state.searchResponseId = action.payload.response.searchUid;
  state.questionAnswer = action.payload.response.questionAnswer;
  state.extendedResults = action.payload.response.extendedResults;
}
function handlePendingSearch(state, action) {
  state.isLoading = true;
  state.searchAction = action.meta.arg.next;
  state.requestId = action.meta.requestId;
}
function handlePendingFetchMoreResults(state, action) {
  state.isLoading = true;
  state.searchAction = { actionCause: SearchPageEvents2.browseResults };
  state.requestId = action.meta.requestId;
}
var searchReducer = createReducer(getSearchInitialState(), (builder) => {
  builder.addCase(executeSearch2.rejected, (state, action) => handleRejectedSearch(state, action));
  builder.addCase(fetchMoreResults2.rejected, (state, action) => handleRejectedSearch(state, action));
  builder.addCase(fetchPage2.rejected, (state, action) => handleRejectedSearch(state, action));
  builder.addCase(executeSearch2.fulfilled, (state, action) => {
    handleFulfilledNewSearch(state, action);
  });
  builder.addCase(fetchMoreResults2.fulfilled, (state, action) => {
    handleFulfilledSearch(state, action);
    state.results = [
      ...state.results,
      ...action.payload.response.results.map((result) => ({
        ...result,
        searchUid: action.payload.response.searchUid
      }))
    ];
  });
  builder.addCase(fetchPage2.fulfilled, (state, action) => {
    handleFulfilledSearch(state, action);
    state.results = [
      ...action.payload.response.results.map((result) => ({
        ...result,
        searchUid: action.payload.response.searchUid
      }))
    ];
  });
  builder.addCase(fetchFacetValues2.fulfilled, (state, action) => {
    state.response.facets = action.payload.response.facets;
    state.response.searchUid = action.payload.response.searchUid;
  });
  builder.addCase(executeSearch2.pending, handlePendingSearch);
  builder.addCase(fetchMoreResults2.pending, handlePendingFetchMoreResults);
  builder.addCase(fetchPage2.pending, handlePendingSearch);
  builder.addCase(updateSearchAction, (state, action) => {
    state.searchAction = action.payload;
  });
  builder.addCase(setError, (state, action) => {
    state.error = action.payload;
    state.isLoading = false;
  });
});

// node_modules/@coveo/headless/dist/esm/features/search-hub/search-hub-actions.js
var setSearchHub = createAction("searchHub/set", (payload) => validatePayload(payload, new StringValue({ required: true, emptyAllowed: true })));

// node_modules/@coveo/headless/dist/esm/features/search-hub/search-hub-slice.js
var searchHubReducer = createReducer(getSearchHubInitialState(), (builder) => {
  builder.addCase(setSearchHub, (_, action) => action.payload).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.searchHub) ?? state;
  }).addCase(updateSearchConfiguration, (state, action) => action.payload.searchHub || state);
});

// node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs
var QueryStatus = ((QueryStatus2) => {
  QueryStatus2["uninitialized"] = "uninitialized";
  QueryStatus2["pending"] = "pending";
  QueryStatus2["fulfilled"] = "fulfilled";
  QueryStatus2["rejected"] = "rejected";
  return QueryStatus2;
})(QueryStatus || {});
function getRequestStatusFlags(status) {
  return {
    status,
    isUninitialized: status === "uninitialized",
    isLoading: status === "pending",
    isSuccess: status === "fulfilled",
    isError: status === "rejected"
    /* rejected */
  };
}
var isPlainObject22 = isPlainObject;
function copyWithStructuralSharing(oldObj, newObj) {
  if (oldObj === newObj || !(isPlainObject22(oldObj) && isPlainObject22(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
    return newObj;
  }
  const newKeys = Object.keys(newObj);
  const oldKeys = Object.keys(oldObj);
  let isSameObject = newKeys.length === oldKeys.length;
  const mergeObj = Array.isArray(newObj) ? [] : {};
  for (const key of newKeys) {
    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
    if (isSameObject)
      isSameObject = oldObj[key] === mergeObj[key];
  }
  return isSameObject ? oldObj : mergeObj;
}
function countObjectKeys(obj) {
  let count = 0;
  for (const _key in obj) {
    count++;
  }
  return count;
}
var flatten = (arr) => [].concat(...arr);
function isAbsoluteUrl(url) {
  return new RegExp(`(^|:)//`).test(url);
}
function isDocumentVisible() {
  if (typeof document === "undefined") {
    return true;
  }
  return document.visibilityState !== "hidden";
}
function isNotNullish(v) {
  return v != null;
}
function isOnline() {
  return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
}
var withoutTrailingSlash = (url) => url.replace(/\/$/, "");
var withoutLeadingSlash = (url) => url.replace(/^\//, "");
function joinUrls(base, url) {
  if (!base) {
    return url;
  }
  if (!url) {
    return base;
  }
  if (isAbsoluteUrl(url)) {
    return url;
  }
  const delimiter2 = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
  base = withoutTrailingSlash(base);
  url = withoutLeadingSlash(url);
  return `${base}${delimiter2}${url}`;
}
function getOrInsert(map, key, value) {
  if (map.has(key))
    return map.get(key);
  return map.set(key, value).get(key);
}
var defaultFetchFn = (...args) => fetch(...args);
var defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;
var defaultIsJsonContentType = (headers) => (
  /*applicat*/
  /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "")
);
function stripUndefined(obj) {
  if (!isPlainObject(obj)) {
    return obj;
  }
  const copy = {
    ...obj
  };
  for (const [k, v] of Object.entries(copy)) {
    if (v === void 0)
      delete copy[k];
  }
  return copy;
}
function fetchBaseQuery({
  baseUrl,
  prepareHeaders = (x) => x,
  fetchFn = defaultFetchFn,
  paramsSerializer,
  isJsonContentType = defaultIsJsonContentType,
  jsonContentType = "application/json",
  jsonReplacer,
  timeout: defaultTimeout,
  responseHandler: globalResponseHandler,
  validateStatus: globalValidateStatus,
  ...baseFetchOptions
} = {}) {
  if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
    console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
  }
  return async (arg, api, extraOptions) => {
    const {
      getState,
      extra,
      endpoint,
      forced,
      type
    } = api;
    let meta;
    let {
      url,
      headers = new Headers(baseFetchOptions.headers),
      params = void 0,
      responseHandler = globalResponseHandler ?? "json",
      validateStatus = globalValidateStatus ?? defaultValidateStatus,
      timeout = defaultTimeout,
      ...rest
    } = typeof arg == "string" ? {
      url: arg
    } : arg;
    let abortController, signal = api.signal;
    if (timeout) {
      abortController = new AbortController();
      api.signal.addEventListener("abort", abortController.abort);
      signal = abortController.signal;
    }
    let config = {
      ...baseFetchOptions,
      signal,
      ...rest
    };
    headers = new Headers(stripUndefined(headers));
    config.headers = await prepareHeaders(headers, {
      getState,
      arg,
      extra,
      endpoint,
      forced,
      type,
      extraOptions
    }) || headers;
    const isJsonifiable = (body) => typeof body === "object" && (isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === "function");
    if (!config.headers.has("content-type") && isJsonifiable(config.body)) {
      config.headers.set("content-type", jsonContentType);
    }
    if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {
      config.body = JSON.stringify(config.body, jsonReplacer);
    }
    if (params) {
      const divider = ~url.indexOf("?") ? "&" : "?";
      const query2 = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
      url += divider + query2;
    }
    url = joinUrls(baseUrl, url);
    const request = new Request(url, config);
    const requestClone = new Request(url, config);
    meta = {
      request: requestClone
    };
    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {
      timedOut = true;
      abortController.abort();
    }, timeout);
    try {
      response = await fetchFn(request);
    } catch (e) {
      return {
        error: {
          status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
          error: String(e)
        },
        meta
      };
    } finally {
      if (timeoutId)
        clearTimeout(timeoutId);
      abortController == null ? void 0 : abortController.signal.removeEventListener("abort", abortController.abort);
    }
    const responseClone = response.clone();
    meta.response = responseClone;
    let resultData;
    let responseText = "";
    try {
      let handleResponseError;
      await Promise.all([
        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),
        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
        // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
        responseClone.text().then((r) => responseText = r, () => {
        })
      ]);
      if (handleResponseError)
        throw handleResponseError;
    } catch (e) {
      return {
        error: {
          status: "PARSING_ERROR",
          originalStatus: response.status,
          data: responseText,
          error: String(e)
        },
        meta
      };
    }
    return validateStatus(response, resultData) ? {
      data: resultData,
      meta
    } : {
      error: {
        status: response.status,
        data: resultData
      },
      meta
    };
  };
  async function handleResponse(response, responseHandler) {
    if (typeof responseHandler === "function") {
      return responseHandler(response);
    }
    if (responseHandler === "content-type") {
      responseHandler = isJsonContentType(response.headers) ? "json" : "text";
    }
    if (responseHandler === "json") {
      const text = await response.text();
      return text.length ? JSON.parse(text) : null;
    }
    return response.text();
  }
}
var HandledError = class {
  constructor(value, meta = void 0) {
    this.value = value;
    this.meta = meta;
  }
};
async function defaultBackoff(attempt2 = 0, maxRetries = 5) {
  const attempts = Math.min(attempt2, maxRetries);
  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));
  await new Promise((resolve) => setTimeout((res) => resolve(res), timeout));
}
function fail(error, meta) {
  throw Object.assign(new HandledError({
    error,
    meta
  }), {
    throwImmediately: true
  });
}
var EMPTY_OPTIONS = {};
var retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {
  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);
  const [maxRetries] = possibleMaxRetries.slice(-1);
  const defaultRetryCondition = (_, __, {
    attempt: attempt2
  }) => attempt2 <= maxRetries;
  const options = {
    maxRetries,
    backoff: defaultBackoff,
    retryCondition: defaultRetryCondition,
    ...defaultOptions,
    ...extraOptions
  };
  let retry22 = 0;
  while (true) {
    try {
      const result = await baseQuery(args, api, extraOptions);
      if (result.error) {
        throw new HandledError(result);
      }
      return result;
    } catch (e) {
      retry22++;
      if (e.throwImmediately) {
        if (e instanceof HandledError) {
          return e.value;
        }
        throw e;
      }
      if (e instanceof HandledError && !options.retryCondition(e.value.error, args, {
        attempt: retry22,
        baseQueryApi: api,
        extraOptions
      })) {
        return e.value;
      }
      await options.backoff(retry22, options.maxRetries);
    }
  }
};
var retry2 = Object.assign(retryWithBackoff, {
  fail
});
var onFocus = createAction("__rtkq/focused");
var onFocusLost = createAction("__rtkq/unfocused");
var onOnline = createAction("__rtkq/online");
var onOffline = createAction("__rtkq/offline");
function isQueryDefinition(e) {
  return e.type === "query";
}
function isMutationDefinition(e) {
  return e.type === "mutation";
}
function isInfiniteQueryDefinition(e) {
  return e.type === "infinitequery";
}
function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
  if (isFunction(description)) {
    return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
  }
  if (Array.isArray(description)) {
    return description.map(expandTagDescription).map(assertTagTypes);
  }
  return [];
}
function isFunction(t) {
  return typeof t === "function";
}
function expandTagDescription(description) {
  return typeof description === "string" ? {
    type: description
  } : description;
}
function asSafePromise(promise, fallback) {
  return promise.catch(fallback);
}
var forceQueryFnSymbol = Symbol("forceQueryFn");
var isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === "function";
function buildInitiate({
  serializeQueryArgs,
  queryThunk,
  infiniteQueryThunk,
  mutationThunk,
  api,
  context
}) {
  const runningQueries = /* @__PURE__ */ new Map();
  const runningMutations = /* @__PURE__ */ new Map();
  const {
    unsubscribeQueryResult,
    removeMutationResult,
    updateSubscriptionOptions
  } = api.internalActions;
  return {
    buildInitiateQuery,
    buildInitiateInfiniteQuery,
    buildInitiateMutation,
    getRunningQueryThunk,
    getRunningMutationThunk,
    getRunningQueriesThunk,
    getRunningMutationsThunk
  };
  function getRunningQueryThunk(endpointName, queryArgs) {
    return (dispatch) => {
      var _a;
      const endpointDefinition = context.endpointDefinitions[endpointName];
      const queryCacheKey = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
    };
  }
  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
    return (dispatch) => {
      var _a;
      return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];
    };
  }
  function getRunningQueriesThunk() {
    return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
  }
  function getRunningMutationsThunk() {
    return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
  }
  function middlewareWarning(dispatch) {
    if (true) {
      if (middlewareWarning.triggered)
        return;
      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
      middlewareWarning.triggered = true;
      if (typeof returnedValue !== "object" || typeof (returnedValue == null ? void 0 : returnedValue.type) === "string") {
        throw new Error(false ? formatProdErrorMessage(34) : `Warning: Middleware for RTK-Query API at reducerPath "${api.reducerPath}" has not been added to the store.
You must add the middleware for RTK-Query to function correctly!`);
      }
    }
  }
  function buildInitiateAnyQuery(endpointName, endpointDefinition) {
    const queryAction = (arg, {
      subscribe = true,
      forceRefetch,
      subscriptionOptions,
      [forceQueryFnSymbol]: forceQueryFn,
      ...rest
    } = {}) => (dispatch, getState) => {
      var _a;
      const queryCacheKey = serializeQueryArgs({
        queryArgs: arg,
        endpointDefinition,
        endpointName
      });
      let thunk2;
      const commonThunkArgs = {
        ...rest,
        type: "query",
        subscribe,
        forceRefetch,
        subscriptionOptions,
        endpointName,
        originalArgs: arg,
        queryCacheKey,
        [forceQueryFnSymbol]: forceQueryFn
      };
      if (isQueryDefinition(endpointDefinition)) {
        thunk2 = queryThunk(commonThunkArgs);
      } else {
        const {
          direction,
          initialPageParam
        } = rest;
        thunk2 = infiniteQueryThunk({
          ...commonThunkArgs,
          // Supply these even if undefined. This helps with a field existence
          // check over in `buildSlice.ts`
          direction,
          initialPageParam
        });
      }
      const selector = api.endpoints[endpointName].select(arg);
      const thunkResult = dispatch(thunk2);
      const stateAfter = selector(getState());
      middlewareWarning(dispatch);
      const {
        requestId,
        abort
      } = thunkResult;
      const skippedSynchronously = stateAfter.requestId !== requestId;
      const runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
      const selectFromState = () => selector(getState());
      const statePromise = Object.assign(forceQueryFn ? (
        // a query has been forced (upsertQueryData)
        // -> we want to resolve it once data has been written with the data that will be written
        thunkResult.then(selectFromState)
      ) : skippedSynchronously && !runningQuery ? (
        // a query has been skipped due to a condition and we do not have any currently running query
        // -> we want to resolve it immediately with the current data
        Promise.resolve(stateAfter)
      ) : (
        // query just started or one is already in flight
        // -> wait for the running query, then resolve with data from after that
        Promise.all([runningQuery, thunkResult]).then(selectFromState)
      ), {
        arg,
        requestId,
        subscriptionOptions,
        queryCacheKey,
        abort,
        async unwrap() {
          const result = await statePromise;
          if (result.isError) {
            throw result.error;
          }
          return result.data;
        },
        refetch: () => dispatch(queryAction(arg, {
          subscribe: false,
          forceRefetch: true
        })),
        unsubscribe() {
          if (subscribe)
            dispatch(unsubscribeQueryResult({
              queryCacheKey,
              requestId
            }));
        },
        updateSubscriptionOptions(options) {
          statePromise.subscriptionOptions = options;
          dispatch(updateSubscriptionOptions({
            endpointName,
            requestId,
            queryCacheKey,
            options
          }));
        }
      });
      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
        const running = getOrInsert(runningQueries, dispatch, {});
        running[queryCacheKey] = statePromise;
        statePromise.then(() => {
          delete running[queryCacheKey];
          if (!countObjectKeys(running)) {
            runningQueries.delete(dispatch);
          }
        });
      }
      return statePromise;
    };
    return queryAction;
  }
  function buildInitiateQuery(endpointName, endpointDefinition) {
    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
    return queryAction;
  }
  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
    return infiniteQueryAction;
  }
  function buildInitiateMutation(endpointName) {
    return (arg, {
      track = true,
      fixedCacheKey
    } = {}) => (dispatch, getState) => {
      const thunk2 = mutationThunk({
        type: "mutation",
        endpointName,
        originalArgs: arg,
        track,
        fixedCacheKey
      });
      const thunkResult = dispatch(thunk2);
      middlewareWarning(dispatch);
      const {
        requestId,
        abort,
        unwrap
      } = thunkResult;
      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({
        data
      })), (error) => ({
        error
      }));
      const reset = () => {
        dispatch(removeMutationResult({
          requestId,
          fixedCacheKey
        }));
      };
      const ret = Object.assign(returnValuePromise, {
        arg: thunkResult.arg,
        requestId,
        abort,
        unwrap,
        reset
      });
      const running = runningMutations.get(dispatch) || {};
      runningMutations.set(dispatch, running);
      running[requestId] = ret;
      ret.then(() => {
        delete running[requestId];
        if (!countObjectKeys(running)) {
          runningMutations.delete(dispatch);
        }
      });
      if (fixedCacheKey) {
        running[fixedCacheKey] = ret;
        ret.then(() => {
          if (running[fixedCacheKey] === ret) {
            delete running[fixedCacheKey];
            if (!countObjectKeys(running)) {
              runningMutations.delete(dispatch);
            }
          }
        });
      }
      return ret;
    };
  }
}
function defaultTransformResponse(baseQueryReturnValue) {
  return baseQueryReturnValue;
}
var addShouldAutoBatch = (arg = {}) => {
  return {
    ...arg,
    [SHOULD_AUTOBATCH]: true
  };
};
function buildThunks({
  reducerPath,
  baseQuery,
  context: {
    endpointDefinitions
  },
  serializeQueryArgs,
  api,
  assertTagType,
  selectors
}) {
  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {
    const endpointDefinition = endpointDefinitions[endpointName];
    const queryCacheKey = serializeQueryArgs({
      queryArgs: arg,
      endpointDefinition,
      endpointName
    });
    dispatch(api.internalActions.queryResultPatched({
      queryCacheKey,
      patches
    }));
    if (!updateProvided) {
      return;
    }
    const newValue = api.endpoints[endpointName].select(arg)(
      // Work around TS 4.1 mismatch
      getState()
    );
    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
    dispatch(api.internalActions.updateProvidedBy({
      queryCacheKey,
      providedTags
    }));
  };
  function addToStart(items, item, max = 0) {
    const newItems = [item, ...items];
    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
  }
  function addToEnd(items, item, max = 0) {
    const newItems = [...items, item];
    return max && newItems.length > max ? newItems.slice(1) : newItems;
  }
  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {
    const endpointDefinition = api.endpoints[endpointName];
    const currentState = endpointDefinition.select(arg)(
      // Work around TS 4.1 mismatch
      getState()
    );
    const ret = {
      patches: [],
      inversePatches: [],
      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
    };
    if (currentState.status === "uninitialized") {
      return ret;
    }
    let newValue;
    if ("data" in currentState) {
      if (isDraftable(currentState.data)) {
        const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
        ret.patches.push(...patches);
        ret.inversePatches.push(...inversePatches);
        newValue = value;
      } else {
        newValue = updateRecipe(currentState.data);
        ret.patches.push({
          op: "replace",
          path: [],
          value: newValue
        });
        ret.inversePatches.push({
          op: "replace",
          path: [],
          value: currentState.data
        });
      }
    }
    if (ret.patches.length === 0) {
      return ret;
    }
    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
    return ret;
  };
  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {
    const res = dispatch(api.endpoints[endpointName].initiate(arg, {
      subscribe: false,
      forceRefetch: true,
      [forceQueryFnSymbol]: () => ({
        data: value
      })
    }));
    return res;
  };
  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {
    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
  };
  const executeEndpoint = async (arg, {
    signal,
    abort,
    rejectWithValue,
    fulfillWithValue,
    dispatch,
    getState,
    extra
  }) => {
    var _a;
    const endpointDefinition = endpointDefinitions[arg.endpointName];
    try {
      let transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
      const baseQueryApi = {
        signal,
        abort,
        dispatch,
        getState,
        extra,
        endpoint: arg.endpointName,
        type: arg.type,
        forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
        queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
      };
      const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
      let finalQueryReturnValue;
      const fetchPage3 = async (data, param, maxPages, previous) => {
        if (param == null && data.pages.length) {
          return Promise.resolve({
            data
          });
        }
        const finalQueryArg = {
          queryArg: arg.originalArgs,
          pageParam: param
        };
        const pageResponse = await executeRequest(finalQueryArg);
        const addTo = previous ? addToStart : addToEnd;
        return {
          data: {
            pages: addTo(data.pages, pageResponse.data, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          }
        };
      };
      async function executeRequest(finalQueryArg) {
        let result;
        const {
          extraOptions
        } = endpointDefinition;
        if (forceQueryFn) {
          result = forceQueryFn();
        } else if (endpointDefinition.query) {
          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
        } else {
          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));
        }
        if (typeof process !== "undefined" && true) {
          const what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
          let err;
          if (!result) {
            err = `${what} did not return anything.`;
          } else if (typeof result !== "object") {
            err = `${what} did not return an object.`;
          } else if (result.error && result.data) {
            err = `${what} returned an object containing both \`error\` and \`result\`.`;
          } else if (result.error === void 0 && result.data === void 0) {
            err = `${what} returned an object containing neither a valid \`error\` and \`result\`. At least one of them should not be \`undefined\``;
          } else {
            for (const key of Object.keys(result)) {
              if (key !== "error" && key !== "data" && key !== "meta") {
                err = `The object returned by ${what} has the unknown property ${key}.`;
                break;
              }
            }
          }
          if (err) {
            console.error(`Error encountered handling the endpoint ${arg.endpointName}.
                  ${err}
                  It needs to return an object with either the shape \`{ data: <value> }\` or \`{ error: <value> }\` that may contain an optional \`meta\` property.
                  Object returned was:`, result);
          }
        }
        if (result.error)
          throw new HandledError(result.error, result.meta);
        const transformedResponse = await transformResponse(result.data, result.meta, finalQueryArg);
        return {
          ...result,
          data: transformedResponse
        };
      }
      if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
        const {
          infiniteQueryOptions
        } = endpointDefinition;
        const {
          maxPages = Infinity
        } = infiniteQueryOptions;
        let result;
        const blankData = {
          pages: [],
          pageParams: []
        };
        const cachedData = (_a = selectors.selectQueryEntry(getState(), arg.queryCacheKey)) == null ? void 0 : _a.data;
        const isForcedQueryNeedingRefetch = (
          // arg.forceRefetch
          isForcedQuery(arg, getState()) && !arg.direction
        );
        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
        if ("direction" in arg && arg.direction && existingData.pages.length) {
          const previous = arg.direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const param = pageParamFn(infiniteQueryOptions, existingData);
          result = await fetchPage3(existingData, param, maxPages, previous);
        } else {
          const {
            initialPageParam = infiniteQueryOptions.initialPageParam
          } = arg;
          const cachedPageParams = (cachedData == null ? void 0 : cachedData.pageParams) ?? [];
          const firstPageParam = cachedPageParams[0] ?? initialPageParam;
          const totalPages = cachedPageParams.length;
          result = await fetchPage3(existingData, firstPageParam, maxPages);
          if (forceQueryFn) {
            result = {
              data: result.data.pages[0]
            };
          }
          for (let i = 1; i < totalPages; i++) {
            const param = getNextPageParam(infiniteQueryOptions, result.data);
            result = await fetchPage3(result.data, param, maxPages);
          }
        }
        finalQueryReturnValue = result;
      } else {
        finalQueryReturnValue = await executeRequest(arg.originalArgs);
      }
      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
        fulfilledTimeStamp: Date.now(),
        baseQueryMeta: finalQueryReturnValue.meta
      }));
    } catch (error) {
      let catchedError = error;
      if (catchedError instanceof HandledError) {
        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
        try {
          return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), addShouldAutoBatch({
            baseQueryMeta: catchedError.meta
          }));
        } catch (e) {
          catchedError = e;
        }
      }
      if (typeof process !== "undefined" && true) {
        console.error(`An unhandled error occurred processing a request for the endpoint "${arg.endpointName}".
In the case of an unhandled error, no tags will be "provided" or "invalidated".`, catchedError);
      } else {
        console.error(catchedError);
      }
      throw catchedError;
    }
  };
  function isForcedQuery(arg, state) {
    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);
    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;
    const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);
    if (refetchVal) {
      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
    }
    return false;
  }
  const createQueryThunk = () => {
    const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {
      getPendingMeta({
        arg
      }) {
        const endpointDefinition = endpointDefinitions[arg.endpointName];
        return addShouldAutoBatch({
          startedTimeStamp: Date.now(),
          ...isInfiniteQueryDefinition(endpointDefinition) ? {
            direction: arg.direction
          } : {}
        });
      },
      condition(queryThunkArg, {
        getState
      }) {
        var _a;
        const state = getState();
        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);
        const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
        const currentArg = queryThunkArg.originalArgs;
        const previousArg = requestState == null ? void 0 : requestState.originalArgs;
        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
        const direction = queryThunkArg.direction;
        if (isUpsertQuery(queryThunkArg)) {
          return true;
        }
        if ((requestState == null ? void 0 : requestState.status) === "pending") {
          return false;
        }
        if (isForcedQuery(queryThunkArg, state)) {
          return true;
        }
        if (isQueryDefinition(endpointDefinition) && ((_a = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _a.call(endpointDefinition, {
          currentArg,
          previousArg,
          endpointState: requestState,
          state
        }))) {
          return true;
        }
        if (fulfilledVal && !direction) {
          return false;
        }
        return true;
      },
      dispatchConditionRejection: true
    });
    return generatedQueryThunk;
  };
  const queryThunk = createQueryThunk();
  const infiniteQueryThunk = createQueryThunk();
  const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {
    getPendingMeta() {
      return addShouldAutoBatch({
        startedTimeStamp: Date.now()
      });
    }
  });
  const hasTheForce = (options) => "force" in options;
  const hasMaxAge = (options) => "ifOlderThan" in options;
  const prefetch = (endpointName, arg, options) => (dispatch, getState) => {
    const force = hasTheForce(options) && options.force;
    const maxAge = hasMaxAge(options) && options.ifOlderThan;
    const queryAction = (force2 = true) => {
      const options2 = {
        forceRefetch: force2,
        isPrefetch: true
      };
      return api.endpoints[endpointName].initiate(arg, options2);
    };
    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());
    if (force) {
      dispatch(queryAction());
    } else if (maxAge) {
      const lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;
      if (!lastFulfilledTs) {
        dispatch(queryAction());
        return;
      }
      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
      if (shouldRetrigger) {
        dispatch(queryAction());
      }
    } else {
      dispatch(queryAction(false));
    }
  };
  function matchesEndpoint(endpointName) {
    return (action) => {
      var _a, _b;
      return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;
    };
  }
  function buildMatchThunkActions(thunk2, endpointName) {
    return {
      matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
      matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
      matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
    };
  }
  return {
    queryThunk,
    mutationThunk,
    infiniteQueryThunk,
    prefetch,
    updateQueryData,
    upsertQueryData,
    patchQueryData,
    buildMatchThunkActions
  };
}
function getNextPageParam(options, {
  pages,
  pageParams
}) {
  const lastIndex = pages.length - 1;
  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);
}
function getPreviousPageParam(options, {
  pages,
  pageParams
}) {
  var _a;
  return (_a = options.getPreviousPageParam) == null ? void 0 : _a.call(options, pages[0], pages, pageParams[0], pageParams);
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
}
function updateQuerySubstateIfExists(state, queryCacheKey, update) {
  const substate = state[queryCacheKey];
  if (substate) {
    update(substate);
  }
}
function getMutationCacheKey(id) {
  return ("arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;
}
function updateMutationSubstateIfExists(state, id, update) {
  const substate = state[getMutationCacheKey(id)];
  if (substate) {
    update(substate);
  }
}
var initialState = {};
function buildSlice({
  reducerPath,
  queryThunk,
  mutationThunk,
  serializeQueryArgs,
  context: {
    endpointDefinitions: definitions,
    apiUid,
    extractRehydrationInfo,
    hasRehydrationInfo
  },
  assertTagType,
  config
}) {
  const resetApiState = createAction(`${reducerPath}/resetApiState`);
  function writePendingCacheEntry(draft, arg, upserting, meta) {
    var _a;
    draft[_a = arg.queryCacheKey] ?? (draft[_a] = {
      status: "uninitialized",
      endpointName: arg.endpointName
    });
    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
      substate.status = "pending";
      substate.requestId = upserting && substate.requestId ? (
        // for `upsertQuery` **updates**, keep the current `requestId`
        substate.requestId
      ) : (
        // for normal queries or `upsertQuery` **inserts** always update the `requestId`
        meta.requestId
      );
      if (arg.originalArgs !== void 0) {
        substate.originalArgs = arg.originalArgs;
      }
      substate.startedTimeStamp = meta.startedTimeStamp;
      const endpointDefinition = definitions[meta.arg.endpointName];
      if (isInfiniteQueryDefinition(endpointDefinition) && "direction" in arg) {
        ;
        substate.direction = arg.direction;
      }
    });
  }
  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {
    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {
      if (substate.requestId !== meta.requestId && !upserting)
        return;
      const {
        merge
      } = definitions[meta.arg.endpointName];
      substate.status = "fulfilled";
      if (merge) {
        if (substate.data !== void 0) {
          const {
            fulfilledTimeStamp,
            arg,
            baseQueryMeta,
            requestId
          } = meta;
          let newData = produce(substate.data, (draftSubstateData) => {
            return merge(draftSubstateData, payload, {
              arg: arg.originalArgs,
              baseQueryMeta,
              fulfilledTimeStamp,
              requestId
            });
          });
          substate.data = newData;
        } else {
          substate.data = payload;
        }
      } else {
        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;
      }
      delete substate.error;
      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
    });
  }
  const querySlice = createSlice({
    name: `${reducerPath}/queries`,
    initialState,
    reducers: {
      removeQueryResult: {
        reducer(draft, {
          payload: {
            queryCacheKey
          }
        }) {
          delete draft[queryCacheKey];
        },
        prepare: prepareAutoBatched()
      },
      cacheEntriesUpserted: {
        reducer(draft, action) {
          for (const entry of action.payload) {
            const {
              queryDescription: arg,
              value
            } = entry;
            writePendingCacheEntry(draft, arg, true, {
              arg,
              requestId: action.meta.requestId,
              startedTimeStamp: action.meta.timestamp
            });
            writeFulfilledCacheEntry(
              draft,
              {
                arg,
                requestId: action.meta.requestId,
                fulfilledTimeStamp: action.meta.timestamp,
                baseQueryMeta: {}
              },
              value,
              // We know we're upserting here
              true
            );
          }
        },
        prepare: (payload) => {
          const queryDescriptions = payload.map((entry) => {
            const {
              endpointName,
              arg,
              value
            } = entry;
            const endpointDefinition = definitions[endpointName];
            const queryDescription = {
              type: "query",
              endpointName,
              originalArgs: entry.arg,
              queryCacheKey: serializeQueryArgs({
                queryArgs: arg,
                endpointDefinition,
                endpointName
              })
            };
            return {
              queryDescription,
              value
            };
          });
          const result = {
            payload: queryDescriptions,
            meta: {
              [SHOULD_AUTOBATCH]: true,
              requestId: nanoid(),
              timestamp: Date.now()
            }
          };
          return result;
        }
      },
      queryResultPatched: {
        reducer(draft, {
          payload: {
            queryCacheKey,
            patches
          }
        }) {
          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {
            substate.data = applyPatches(substate.data, patches.concat());
          });
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(queryThunk.pending, (draft, {
        meta,
        meta: {
          arg
        }
      }) => {
        const upserting = isUpsertQuery(arg);
        writePendingCacheEntry(draft, arg, upserting, meta);
      }).addCase(queryThunk.fulfilled, (draft, {
        meta,
        payload
      }) => {
        const upserting = isUpsertQuery(meta.arg);
        writeFulfilledCacheEntry(draft, meta, payload, upserting);
      }).addCase(queryThunk.rejected, (draft, {
        meta: {
          condition,
          arg,
          requestId
        },
        error,
        payload
      }) => {
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
          if (condition) {
          } else {
            if (substate.requestId !== requestId)
              return;
            substate.status = "rejected";
            substate.error = payload ?? error;
          }
        });
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          queries
        } = extractRehydrationInfo(action);
        for (const [key, entry] of Object.entries(queries)) {
          if (
            // do not rehydrate entries that were currently in flight.
            (entry == null ? void 0 : entry.status) === "fulfilled" || (entry == null ? void 0 : entry.status) === "rejected"
          ) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  const mutationSlice = createSlice({
    name: `${reducerPath}/mutations`,
    initialState,
    reducers: {
      removeMutationResult: {
        reducer(draft, {
          payload
        }) {
          const cacheKey = getMutationCacheKey(payload);
          if (cacheKey in draft) {
            delete draft[cacheKey];
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(mutationThunk.pending, (draft, {
        meta,
        meta: {
          requestId,
          arg,
          startedTimeStamp
        }
      }) => {
        if (!arg.track)
          return;
        draft[getMutationCacheKey(meta)] = {
          requestId,
          status: "pending",
          endpointName: arg.endpointName,
          startedTimeStamp
        };
      }).addCase(mutationThunk.fulfilled, (draft, {
        payload,
        meta
      }) => {
        if (!meta.arg.track)
          return;
        updateMutationSubstateIfExists(draft, meta, (substate) => {
          if (substate.requestId !== meta.requestId)
            return;
          substate.status = "fulfilled";
          substate.data = payload;
          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
        });
      }).addCase(mutationThunk.rejected, (draft, {
        payload,
        error,
        meta
      }) => {
        if (!meta.arg.track)
          return;
        updateMutationSubstateIfExists(draft, meta, (substate) => {
          if (substate.requestId !== meta.requestId)
            return;
          substate.status = "rejected";
          substate.error = payload ?? error;
        });
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          mutations
        } = extractRehydrationInfo(action);
        for (const [key, entry] of Object.entries(mutations)) {
          if (
            // do not rehydrate entries that were currently in flight.
            ((entry == null ? void 0 : entry.status) === "fulfilled" || (entry == null ? void 0 : entry.status) === "rejected") && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
            key !== (entry == null ? void 0 : entry.requestId)
          ) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  const invalidationSlice = createSlice({
    name: `${reducerPath}/invalidation`,
    initialState,
    reducers: {
      updateProvidedBy: {
        reducer(draft, action) {
          var _a, _b;
          const {
            queryCacheKey,
            providedTags
          } = action.payload;
          for (const tagTypeSubscriptions of Object.values(draft)) {
            for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
              const foundAt = idSubscriptions.indexOf(queryCacheKey);
              if (foundAt !== -1) {
                idSubscriptions.splice(foundAt, 1);
              }
            }
          }
          for (const {
            type,
            id
          } of providedTags) {
            const subscribedQueries = (_a = draft[type] ?? (draft[type] = {}))[_b = id || "__internal_without_id"] ?? (_a[_b] = []);
            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
            if (!alreadySubscribed) {
              subscribedQueries.push(queryCacheKey);
            }
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, (draft, {
        payload: {
          queryCacheKey
        }
      }) => {
        for (const tagTypeSubscriptions of Object.values(draft)) {
          for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
            const foundAt = idSubscriptions.indexOf(queryCacheKey);
            if (foundAt !== -1) {
              idSubscriptions.splice(foundAt, 1);
            }
          }
        }
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        var _a, _b;
        const {
          provided
        } = extractRehydrationInfo(action);
        for (const [type, incomingTags] of Object.entries(provided)) {
          for (const [id, cacheKeys] of Object.entries(incomingTags)) {
            const subscribedQueries = (_a = draft[type] ?? (draft[type] = {}))[_b = id || "__internal_without_id"] ?? (_a[_b] = []);
            for (const queryCacheKey of cacheKeys) {
              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
            }
          }
        }
      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
        const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
        const {
          queryCacheKey
        } = action.meta.arg;
        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({
          queryCacheKey,
          providedTags
        }));
      });
    }
  });
  const subscriptionSlice = createSlice({
    name: `${reducerPath}/subscriptions`,
    initialState,
    reducers: {
      updateSubscriptionOptions(d, a) {
      },
      unsubscribeQueryResult(d, a) {
      },
      internal_getRTKQSubscriptions() {
      }
    }
  });
  const internalSubscriptionsSlice = createSlice({
    name: `${reducerPath}/internalSubscriptions`,
    initialState,
    reducers: {
      subscriptionsUpdated: {
        reducer(state, action) {
          return applyPatches(state, action.payload);
        },
        prepare: prepareAutoBatched()
      }
    }
  });
  const configSlice = createSlice({
    name: `${reducerPath}/config`,
    initialState: {
      online: isOnline(),
      focused: isDocumentVisible(),
      middlewareRegistered: false,
      ...config
    },
    reducers: {
      middlewareRegistered(state, {
        payload
      }) {
        state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
      }
    },
    extraReducers: (builder) => {
      builder.addCase(onOnline, (state) => {
        state.online = true;
      }).addCase(onOffline, (state) => {
        state.online = false;
      }).addCase(onFocus, (state) => {
        state.focused = true;
      }).addCase(onFocusLost, (state) => {
        state.focused = false;
      }).addMatcher(hasRehydrationInfo, (draft) => ({
        ...draft
      }));
    }
  });
  const combinedReducer = combineReducers({
    queries: querySlice.reducer,
    mutations: mutationSlice.reducer,
    provided: invalidationSlice.reducer,
    subscriptions: internalSubscriptionsSlice.reducer,
    config: configSlice.reducer
  });
  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);
  const actions = {
    ...configSlice.actions,
    ...querySlice.actions,
    ...subscriptionSlice.actions,
    ...internalSubscriptionsSlice.actions,
    ...mutationSlice.actions,
    ...invalidationSlice.actions,
    resetApiState
  };
  return {
    reducer,
    actions
  };
}
var skipToken = Symbol.for("RTKQ/skipToken");
var initialSubState = {
  status: "uninitialized"
  /* uninitialized */
};
var defaultQuerySubState = produce(initialSubState, () => {
});
var defaultMutationSubState = produce(initialSubState, () => {
});
function buildSelectors({
  serializeQueryArgs,
  reducerPath,
  createSelector: createSelector2
}) {
  const selectSkippedQuery = (state) => defaultQuerySubState;
  const selectSkippedMutation = (state) => defaultMutationSubState;
  return {
    buildQuerySelector,
    buildInfiniteQuerySelector,
    buildMutationSelector,
    selectInvalidatedBy,
    selectCachedArgsForQuery,
    selectApiState,
    selectQueries,
    selectMutations,
    selectQueryEntry,
    selectConfig
  };
  function withRequestFlags(substate) {
    return {
      ...substate,
      ...getRequestStatusFlags(substate.status)
    };
  }
  function selectApiState(rootState) {
    const state = rootState[reducerPath];
    if (true) {
      if (!state) {
        if (selectApiState.triggered)
          return state;
        selectApiState.triggered = true;
        console.error(`Error: No data found at \`state.${reducerPath}\`. Did you forget to add the reducer to the store?`);
      }
    }
    return state;
  }
  function selectQueries(rootState) {
    var _a;
    return (_a = selectApiState(rootState)) == null ? void 0 : _a.queries;
  }
  function selectQueryEntry(rootState, cacheKey) {
    var _a;
    return (_a = selectQueries(rootState)) == null ? void 0 : _a[cacheKey];
  }
  function selectMutations(rootState) {
    var _a;
    return (_a = selectApiState(rootState)) == null ? void 0 : _a.mutations;
  }
  function selectConfig(rootState) {
    var _a;
    return (_a = selectApiState(rootState)) == null ? void 0 : _a.config;
  }
  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
    return (queryArgs) => {
      if (queryArgs === skipToken) {
        return createSelector2(selectSkippedQuery, combiner);
      }
      const serializedArgs = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;
      return createSelector2(selectQuerySubstate, combiner);
    };
  }
  function buildQuerySelector(endpointName, endpointDefinition) {
    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
  }
  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
    const {
      infiniteQueryOptions
    } = endpointDefinition;
    function withInfiniteQueryResultFlags(substate) {
      const stateWithRequestFlags = {
        ...substate,
        ...getRequestStatusFlags(substate.status)
      };
      const {
        isLoading,
        isError: isError2,
        direction
      } = stateWithRequestFlags;
      const isForward = direction === "forward";
      const isBackward = direction === "backward";
      return {
        ...stateWithRequestFlags,
        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data),
        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data),
        isFetchingNextPage: isLoading && isForward,
        isFetchingPreviousPage: isLoading && isBackward,
        isFetchNextPageError: isError2 && isForward,
        isFetchPreviousPageError: isError2 && isBackward
      };
    }
    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
  }
  function buildMutationSelector() {
    return (id) => {
      let mutationId;
      if (typeof id === "object") {
        mutationId = getMutationCacheKey(id) ?? skipToken;
      } else {
        mutationId = id;
      }
      const selectMutationSubstate = (state) => {
        var _a, _b;
        return ((_b = (_a = selectApiState(state)) == null ? void 0 : _a.mutations) == null ? void 0 : _b[mutationId]) ?? defaultMutationSubState;
      };
      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
      return createSelector2(finalSelectMutationSubstate, withRequestFlags);
    };
  }
  function selectInvalidatedBy(state, tags) {
    const apiState = state[reducerPath];
    const toInvalidate = /* @__PURE__ */ new Set();
    for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {
      const provided = apiState.provided[tag.type];
      if (!provided) {
        continue;
      }
      let invalidateSubscriptions = (tag.id !== void 0 ? (
        // id given: invalidate all queries that provide this type & id
        provided[tag.id]
      ) : (
        // no id: invalidate all queries that provide this type
        flatten(Object.values(provided))
      )) ?? [];
      for (const invalidate of invalidateSubscriptions) {
        toInvalidate.add(invalidate);
      }
    }
    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {
      const querySubState = apiState.queries[queryCacheKey];
      return querySubState ? [{
        queryCacheKey,
        endpointName: querySubState.endpointName,
        originalArgs: querySubState.originalArgs
      }] : [];
    }));
  }
  function selectCachedArgsForQuery(state, queryName) {
    return Object.values(selectQueries(state)).filter(
      (entry) => (entry == null ? void 0 : entry.endpointName) === queryName && entry.status !== "uninitialized"
      /* uninitialized */
    ).map((entry) => entry.originalArgs);
  }
  function getHasNextPage(options, data) {
    if (!data)
      return false;
    return getNextPageParam(options, data) != null;
  }
  function getHasPreviousPage(options, data) {
    if (!data || !options.getPreviousPageParam)
      return false;
    return getPreviousPageParam(options, data) != null;
  }
}
var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var defaultSerializeQueryArgs = ({
  endpointName,
  queryArgs
}) => {
  let serialized = "";
  const cached = cache == null ? void 0 : cache.get(queryArgs);
  if (typeof cached === "string") {
    serialized = cached;
  } else {
    const stringified = JSON.stringify(queryArgs, (key, value) => {
      value = typeof value === "bigint" ? {
        $bigint: value.toString()
      } : value;
      value = isPlainObject(value) ? Object.keys(value).sort().reduce((acc, key2) => {
        acc[key2] = value[key2];
        return acc;
      }, {}) : value;
      return value;
    });
    if (isPlainObject(queryArgs)) {
      cache == null ? void 0 : cache.set(queryArgs, stringified);
    }
    serialized = stringified;
  }
  return `${endpointName}(${serialized})`;
};
function buildCreateApi(...modules) {
  return function baseCreateApi(options) {
    const extractRehydrationInfo = weakMapMemoize((action) => {
      var _a;
      return (_a = options.extractRehydrationInfo) == null ? void 0 : _a.call(options, action, {
        reducerPath: options.reducerPath ?? "api"
      });
    });
    const optionsWithDefaults = {
      reducerPath: "api",
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: false,
      refetchOnFocus: false,
      refetchOnReconnect: false,
      invalidationBehavior: "delayed",
      ...options,
      extractRehydrationInfo,
      serializeQueryArgs(queryArgsApi) {
        let finalSerializeQueryArgs = defaultSerializeQueryArgs;
        if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
          finalSerializeQueryArgs = (queryArgsApi2) => {
            const initialResult = endpointSQA(queryArgsApi2);
            if (typeof initialResult === "string") {
              return initialResult;
            } else {
              return defaultSerializeQueryArgs({
                ...queryArgsApi2,
                queryArgs: initialResult
              });
            }
          };
        } else if (options.serializeQueryArgs) {
          finalSerializeQueryArgs = options.serializeQueryArgs;
        }
        return finalSerializeQueryArgs(queryArgsApi);
      },
      tagTypes: [...options.tagTypes || []]
    };
    const context = {
      endpointDefinitions: {},
      batch(fn) {
        fn();
      },
      apiUid: nanoid(),
      extractRehydrationInfo,
      hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)
    };
    const api = {
      injectEndpoints,
      enhanceEndpoints({
        addTagTypes,
        endpoints
      }) {
        if (addTagTypes) {
          for (const eT of addTagTypes) {
            if (!optionsWithDefaults.tagTypes.includes(eT)) {
              ;
              optionsWithDefaults.tagTypes.push(eT);
            }
          }
        }
        if (endpoints) {
          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
            if (typeof partialDefinition === "function") {
              partialDefinition(context.endpointDefinitions[endpointName]);
            } else {
              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
            }
          }
        }
        return api;
      }
    };
    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));
    function injectEndpoints(inject) {
      const evaluatedEndpoints = inject.endpoints({
        query: (x) => ({
          ...x,
          type: "query"
          /* query */
        }),
        mutation: (x) => ({
          ...x,
          type: "mutation"
          /* mutation */
        }),
        infiniteQuery: (x) => ({
          ...x,
          type: "infinitequery"
          /* infinitequery */
        })
      });
      for (const [endpointName, definition4] of Object.entries(evaluatedEndpoints)) {
        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {
          if (inject.overrideExisting === "throw") {
            throw new Error(false ? formatProdErrorMessage(39) : `called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
          } else if (typeof process !== "undefined" && true) {
            console.error(`called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
          }
          continue;
        }
        if (typeof process !== "undefined" && true) {
          if (isInfiniteQueryDefinition(definition4)) {
            const {
              infiniteQueryOptions
            } = definition4;
            const {
              maxPages,
              getPreviousPageParam: getPreviousPageParam2
            } = infiniteQueryOptions;
            if (typeof maxPages === "number") {
              if (maxPages < 1) {
                throw new Error(false ? formatProdErrorMessage(40) : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);
              }
              if (typeof getPreviousPageParam2 !== "function") {
                throw new Error(false ? formatProdErrorMessage(41) : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);
              }
            }
          }
        }
        context.endpointDefinitions[endpointName] = definition4;
        for (const m of initializedModules) {
          m.injectEndpoint(endpointName, definition4);
        }
      }
      return api;
    }
    return api.injectEndpoints({
      endpoints: options.endpoints
    });
  };
}
var _NEVER = Symbol();
function assertCast(v) {
}
function safeAssign(target, ...args) {
  return Object.assign(target, ...args);
}
var buildBatchedActionsHandler = ({
  api,
  queryThunk,
  internalState
}) => {
  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;
  let previousSubscriptions = null;
  let updateSyncTimer = null;
  const {
    updateSubscriptionOptions,
    unsubscribeQueryResult
  } = api.internalActions;
  const actuallyMutateSubscriptions = (mutableState, action) => {
    var _a, _b, _c;
    if (updateSubscriptionOptions.match(action)) {
      const {
        queryCacheKey,
        requestId,
        options
      } = action.payload;
      if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {
        mutableState[queryCacheKey][requestId] = options;
      }
      return true;
    }
    if (unsubscribeQueryResult.match(action)) {
      const {
        queryCacheKey,
        requestId
      } = action.payload;
      if (mutableState[queryCacheKey]) {
        delete mutableState[queryCacheKey][requestId];
      }
      return true;
    }
    if (api.internalActions.removeQueryResult.match(action)) {
      delete mutableState[action.payload.queryCacheKey];
      return true;
    }
    if (queryThunk.pending.match(action)) {
      const {
        meta: {
          arg,
          requestId
        }
      } = action;
      const substate = mutableState[_b = arg.queryCacheKey] ?? (mutableState[_b] = {});
      substate[`${requestId}_running`] = {};
      if (arg.subscribe) {
        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
      }
      return true;
    }
    let mutated = false;
    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {
      const state = mutableState[action.meta.arg.queryCacheKey] || {};
      const key = `${action.meta.requestId}_running`;
      mutated || (mutated = !!state[key]);
      delete state[key];
    }
    if (queryThunk.rejected.match(action)) {
      const {
        meta: {
          condition,
          arg,
          requestId
        }
      } = action;
      if (condition && arg.subscribe) {
        const substate = mutableState[_c = arg.queryCacheKey] ?? (mutableState[_c] = {});
        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
        mutated = true;
      }
    }
    return mutated;
  };
  const getSubscriptions = () => internalState.currentSubscriptions;
  const getSubscriptionCount = (queryCacheKey) => {
    const subscriptions = getSubscriptions();
    const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};
    return countObjectKeys(subscriptionsForQueryArg);
  };
  const isRequestSubscribed = (queryCacheKey, requestId) => {
    var _a;
    const subscriptions = getSubscriptions();
    return !!((_a = subscriptions == null ? void 0 : subscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);
  };
  const subscriptionSelectors = {
    getSubscriptions,
    getSubscriptionCount,
    isRequestSubscribed
  };
  return (action, mwApi) => {
    if (!previousSubscriptions) {
      previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
    }
    if (api.util.resetApiState.match(action)) {
      previousSubscriptions = internalState.currentSubscriptions = {};
      updateSyncTimer = null;
      return [true, false];
    }
    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {
      return [false, subscriptionSelectors];
    }
    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
    let actionShouldContinue = true;
    if (didMutate) {
      if (!updateSyncTimer) {
        updateSyncTimer = setTimeout(() => {
          const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
          const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);
          mwApi.next(api.internalActions.subscriptionsUpdated(patches));
          previousSubscriptions = newSubscriptions;
          updateSyncTimer = null;
        }, 500);
      }
      const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
    }
    return [actionShouldContinue, false];
  };
};
function isObjectEmpty(obj) {
  for (const k in obj) {
    return false;
  }
  return true;
}
var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
var buildCacheCollectionHandler = ({
  reducerPath,
  api,
  queryThunk,
  context,
  internalState,
  selectors: {
    selectQueryEntry,
    selectConfig
  }
}) => {
  const {
    removeQueryResult,
    unsubscribeQueryResult,
    cacheEntriesUpserted
  } = api.internalActions;
  const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
  function anySubscriptionsRemainingForKey(queryCacheKey) {
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    return !!subscriptions && !isObjectEmpty(subscriptions);
  }
  const currentRemovalTimeouts = {};
  const handler = (action, mwApi, internalState2) => {
    const state = mwApi.getState();
    const config = selectConfig(state);
    if (canTriggerUnsubscribe(action)) {
      let queryCacheKeys;
      if (cacheEntriesUpserted.match(action)) {
        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);
      } else {
        const {
          queryCacheKey
        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
        queryCacheKeys = [queryCacheKey];
      }
      handleUnsubscribeMany(queryCacheKeys, mwApi, config);
    }
    if (api.util.resetApiState.match(action)) {
      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {
        if (timeout)
          clearTimeout(timeout);
        delete currentRemovalTimeouts[key];
      }
    }
    if (context.hasRehydrationInfo(action)) {
      const {
        queries
      } = context.extractRehydrationInfo(action);
      handleUnsubscribeMany(Object.keys(queries), mwApi, config);
    }
  };
  function handleUnsubscribeMany(cacheKeys, api2, config) {
    const state = api2.getState();
    for (const queryCacheKey of cacheKeys) {
      const entry = selectQueryEntry(state, queryCacheKey);
      handleUnsubscribe(queryCacheKey, entry == null ? void 0 : entry.endpointName, api2, config);
    }
  }
  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
    const endpointDefinition = context.endpointDefinitions[endpointName];
    const keepUnusedDataFor = (endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) ?? config.keepUnusedDataFor;
    if (keepUnusedDataFor === Infinity) {
      return;
    }
    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
      const currentTimeout = currentRemovalTimeouts[queryCacheKey];
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
          api2.dispatch(removeQueryResult({
            queryCacheKey
          }));
        }
        delete currentRemovalTimeouts[queryCacheKey];
      }, finalKeepUnusedDataFor * 1e3);
    }
  }
  return handler;
};
var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
var buildCacheLifecycleHandler = ({
  api,
  reducerPath,
  context,
  queryThunk,
  mutationThunk,
  internalState,
  selectors: {
    selectQueryEntry,
    selectApiState
  }
}) => {
  const isQueryThunk = isAsyncThunkAction(queryThunk);
  const isMutationThunk = isAsyncThunkAction(mutationThunk);
  const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
  const lifecycleMap = {};
  function resolveLifecycleEntry(cacheKey, data, meta) {
    const lifecycle = lifecycleMap[cacheKey];
    if (lifecycle == null ? void 0 : lifecycle.valueResolved) {
      lifecycle.valueResolved({
        data,
        meta
      });
      delete lifecycle.valueResolved;
    }
  }
  function removeLifecycleEntry(cacheKey) {
    const lifecycle = lifecycleMap[cacheKey];
    if (lifecycle) {
      delete lifecycleMap[cacheKey];
      lifecycle.cacheEntryRemoved();
    }
  }
  const handler = (action, mwApi, stateBefore) => {
    const cacheKey = getCacheKey(action);
    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
      if (!oldEntry && newEntry) {
        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
      }
    }
    if (queryThunk.pending.match(action)) {
      checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
    } else if (api.internalActions.cacheEntriesUpserted.match(action)) {
      for (const {
        queryDescription,
        value
      } of action.payload) {
        const {
          endpointName,
          originalArgs,
          queryCacheKey
        } = queryDescription;
        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
        resolveLifecycleEntry(queryCacheKey, value, {});
      }
    } else if (mutationThunk.pending.match(action)) {
      const state = mwApi.getState()[reducerPath].mutations[cacheKey];
      if (state) {
        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
      }
    } else if (isFulfilledThunk(action)) {
      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
      removeLifecycleEntry(cacheKey);
    } else if (api.util.resetApiState.match(action)) {
      for (const cacheKey2 of Object.keys(lifecycleMap)) {
        removeLifecycleEntry(cacheKey2);
      }
    }
  };
  function getCacheKey(action) {
    if (isQueryThunk(action))
      return action.meta.arg.queryCacheKey;
    if (isMutationThunk(action)) {
      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;
    }
    if (api.internalActions.removeQueryResult.match(action))
      return action.payload.queryCacheKey;
    if (api.internalActions.removeMutationResult.match(action))
      return getMutationCacheKey(action.payload);
    return "";
  }
  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
    const endpointDefinition = context.endpointDefinitions[endpointName];
    const onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;
    if (!onCacheEntryAdded)
      return;
    const lifecycle = {};
    const cacheEntryRemoved = new Promise((resolve) => {
      lifecycle.cacheEntryRemoved = resolve;
    });
    const cacheDataLoaded = Promise.race([new Promise((resolve) => {
      lifecycle.valueResolved = resolve;
    }), cacheEntryRemoved.then(() => {
      throw neverResolvedError;
    })]);
    cacheDataLoaded.catch(() => {
    });
    lifecycleMap[queryCacheKey] = lifecycle;
    const selector = api.endpoints[endpointName].select(endpointDefinition.type === "query" ? originalArgs : queryCacheKey);
    const extra = mwApi.dispatch((_, __, extra2) => extra2);
    const lifecycleApi = {
      ...mwApi,
      getCacheEntry: () => selector(mwApi.getState()),
      requestId,
      extra,
      updateCachedData: endpointDefinition.type === "query" ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
      cacheDataLoaded,
      cacheEntryRemoved
    };
    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
    Promise.resolve(runningHandler).catch((e) => {
      if (e === neverResolvedError)
        return;
      throw e;
    });
  }
  return handler;
};
var buildDevCheckHandler = ({
  api,
  context: {
    apiUid
  },
  reducerPath
}) => {
  return (action, mwApi) => {
    var _a, _b;
    if (api.util.resetApiState.match(action)) {
      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
    }
    if (typeof process !== "undefined" && true) {
      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === "conflict") {
        console.warn(`There is a mismatch between slice and middleware for the reducerPath "${reducerPath}".
You can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === "api" ? `
If you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : ""}`);
      }
    }
  };
};
var buildInvalidationByTagsHandler = ({
  reducerPath,
  context,
  context: {
    endpointDefinitions
  },
  mutationThunk,
  queryThunk,
  api,
  assertTagType,
  refetchQuery,
  internalState
}) => {
  const {
    removeQueryResult
  } = api.internalActions;
  const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
  const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));
  let pendingTagInvalidations = [];
  const handler = (action, mwApi) => {
    if (isThunkActionWithTags(action)) {
      invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
    } else if (isQueryEnd(action)) {
      invalidateTags([], mwApi);
    } else if (api.util.invalidateTags.match(action)) {
      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
    }
  };
  function hasPendingRequests(state) {
    var _a;
    const {
      queries,
      mutations
    } = state;
    for (const cacheRecord of [queries, mutations]) {
      for (const key in cacheRecord) {
        if (((_a = cacheRecord[key]) == null ? void 0 : _a.status) === "pending")
          return true;
      }
    }
    return false;
  }
  function invalidateTags(newTags, mwApi) {
    const rootState = mwApi.getState();
    const state = rootState[reducerPath];
    pendingTagInvalidations.push(...newTags);
    if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
      return;
    }
    const tags = pendingTagInvalidations;
    pendingTagInvalidations = [];
    if (tags.length === 0)
      return;
    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
    context.batch(() => {
      const valuesArray = Array.from(toInvalidate.values());
      for (const {
        queryCacheKey
      } of valuesArray) {
        const querySubState = state.queries[queryCacheKey];
        const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};
        if (querySubState) {
          if (countObjectKeys(subscriptionSubState) === 0) {
            mwApi.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== "uninitialized") {
            mwApi.dispatch(refetchQuery(querySubState));
          }
        }
      }
    });
  }
  return handler;
};
var buildPollingHandler = ({
  reducerPath,
  queryThunk,
  api,
  refetchQuery,
  internalState
}) => {
  const currentPolls = {};
  const handler = (action, mwApi) => {
    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
      updatePollingInterval(action.payload, mwApi);
    }
    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
      updatePollingInterval(action.meta.arg, mwApi);
    }
    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
      startNextPoll(action.meta.arg, mwApi);
    }
    if (api.util.resetApiState.match(action)) {
      clearPolls();
    }
  };
  function getCacheEntrySubscriptions(queryCacheKey, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === "uninitialized")
      return;
    return subscriptions;
  }
  function startNextPoll({
    queryCacheKey
  }, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === "uninitialized")
      return;
    const {
      lowestPollingInterval,
      skipPollingIfUnfocused
    } = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval))
      return;
    const currentPoll = currentPolls[queryCacheKey];
    if (currentPoll == null ? void 0 : currentPoll.timeout) {
      clearTimeout(currentPoll.timeout);
      currentPoll.timeout = void 0;
    }
    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    currentPolls[queryCacheKey] = {
      nextPollTimestamp,
      pollingInterval: lowestPollingInterval,
      timeout: setTimeout(() => {
        if (state.config.focused || !skipPollingIfUnfocused) {
          api2.dispatch(refetchQuery(querySubState));
        }
        startNextPoll({
          queryCacheKey
        }, api2);
      }, lowestPollingInterval)
    };
  }
  function updatePollingInterval({
    queryCacheKey
  }, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === "uninitialized") {
      return;
    }
    const {
      lowestPollingInterval
    } = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) {
      cleanupPollForKey(queryCacheKey);
      return;
    }
    const currentPoll = currentPolls[queryCacheKey];
    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
      startNextPoll({
        queryCacheKey
      }, api2);
    }
  }
  function cleanupPollForKey(key) {
    const existingPoll = currentPolls[key];
    if (existingPoll == null ? void 0 : existingPoll.timeout) {
      clearTimeout(existingPoll.timeout);
    }
    delete currentPolls[key];
  }
  function clearPolls() {
    for (const key of Object.keys(currentPolls)) {
      cleanupPollForKey(key);
    }
  }
  function findLowestPollingInterval(subscribers = {}) {
    let skipPollingIfUnfocused = false;
    let lowestPollingInterval = Number.POSITIVE_INFINITY;
    for (let key in subscribers) {
      if (!!subscribers[key].pollingInterval) {
        lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
        skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;
      }
    }
    return {
      lowestPollingInterval,
      skipPollingIfUnfocused
    };
  }
  return handler;
};
var buildQueryLifecycleHandler = ({
  api,
  context,
  queryThunk,
  mutationThunk
}) => {
  const isPendingThunk = isPending(queryThunk, mutationThunk);
  const isRejectedThunk = isRejected(queryThunk, mutationThunk);
  const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
  const lifecycleMap = {};
  const handler = (action, mwApi) => {
    var _a, _b;
    if (isPendingThunk(action)) {
      const {
        requestId,
        arg: {
          endpointName,
          originalArgs
        }
      } = action.meta;
      const endpointDefinition = context.endpointDefinitions[endpointName];
      const onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;
      if (onQueryStarted) {
        const lifecycle = {};
        const queryFulfilled = new Promise((resolve, reject) => {
          lifecycle.resolve = resolve;
          lifecycle.reject = reject;
        });
        queryFulfilled.catch(() => {
        });
        lifecycleMap[requestId] = lifecycle;
        const selector = api.endpoints[endpointName].select(endpointDefinition.type === "query" ? originalArgs : requestId);
        const extra = mwApi.dispatch((_, __, extra2) => extra2);
        const lifecycleApi = {
          ...mwApi,
          getCacheEntry: () => selector(mwApi.getState()),
          requestId,
          extra,
          updateCachedData: endpointDefinition.type === "query" ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
          queryFulfilled
        };
        onQueryStarted(originalArgs, lifecycleApi);
      }
    } else if (isFullfilledThunk(action)) {
      const {
        requestId,
        baseQueryMeta
      } = action.meta;
      (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({
        data: action.payload,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    } else if (isRejectedThunk(action)) {
      const {
        requestId,
        rejectedWithValue,
        baseQueryMeta
      } = action.meta;
      (_b = lifecycleMap[requestId]) == null ? void 0 : _b.reject({
        error: action.payload ?? action.error,
        isUnhandledError: !rejectedWithValue,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    }
  };
  return handler;
};
var buildWindowEventHandler = ({
  reducerPath,
  context,
  api,
  refetchQuery,
  internalState
}) => {
  const {
    removeQueryResult
  } = api.internalActions;
  const handler = (action, mwApi) => {
    if (onFocus.match(action)) {
      refetchValidQueries(mwApi, "refetchOnFocus");
    }
    if (onOnline.match(action)) {
      refetchValidQueries(mwApi, "refetchOnReconnect");
    }
  };
  function refetchValidQueries(api2, type) {
    const state = api2.getState()[reducerPath];
    const queries = state.queries;
    const subscriptions = internalState.currentSubscriptions;
    context.batch(() => {
      for (const queryCacheKey of Object.keys(subscriptions)) {
        const querySubState = queries[queryCacheKey];
        const subscriptionSubState = subscriptions[queryCacheKey];
        if (!subscriptionSubState || !querySubState)
          continue;
        const shouldRefetch = Object.values(subscriptionSubState).some((sub) => sub[type] === true) || Object.values(subscriptionSubState).every((sub) => sub[type] === void 0) && state.config[type];
        if (shouldRefetch) {
          if (countObjectKeys(subscriptionSubState) === 0) {
            api2.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== "uninitialized") {
            api2.dispatch(refetchQuery(querySubState));
          }
        }
      }
    });
  }
  return handler;
};
function buildMiddleware(input) {
  const {
    reducerPath,
    queryThunk,
    api,
    context
  } = input;
  const {
    apiUid
  } = context;
  const actions = {
    invalidateTags: createAction(`${reducerPath}/invalidateTags`)
  };
  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);
  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
  const middleware = (mwApi) => {
    let initialized2 = false;
    const internalState = {
      currentSubscriptions: {}
    };
    const builderArgs = {
      ...input,
      internalState,
      refetchQuery,
      isThisApiSliceAction
    };
    const handlers = handlerBuilders.map((build) => build(builderArgs));
    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
    const windowEventsHandler = buildWindowEventHandler(builderArgs);
    return (next) => {
      return (action) => {
        if (!isAction(action)) {
          return next(action);
        }
        if (!initialized2) {
          initialized2 = true;
          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
        }
        const mwApiWithNext = {
          ...mwApi,
          next
        };
        const stateBefore = mwApi.getState();
        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
        let res;
        if (actionShouldContinue) {
          res = next(action);
        } else {
          res = internalProbeResult;
        }
        if (!!mwApi.getState()[reducerPath]) {
          windowEventsHandler(action, mwApiWithNext, stateBefore);
          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
            for (const handler of handlers) {
              handler(action, mwApiWithNext, stateBefore);
            }
          }
        }
        return res;
      };
    };
  };
  return {
    middleware,
    actions
  };
  function refetchQuery(querySubState) {
    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
      subscribe: false,
      forceRefetch: true
    });
  }
}
var coreModuleName = Symbol();
var coreModule = ({
  createSelector: createSelector2 = createSelector
} = {}) => ({
  name: coreModuleName,
  init(api, {
    baseQuery,
    tagTypes,
    reducerPath,
    serializeQueryArgs,
    keepUnusedDataFor,
    refetchOnMountOrArgChange,
    refetchOnFocus,
    refetchOnReconnect,
    invalidationBehavior
  }, context) {
    enablePatches();
    assertCast(serializeQueryArgs);
    const assertTagType = (tag) => {
      if (typeof process !== "undefined" && true) {
        if (!tagTypes.includes(tag.type)) {
          console.error(`Tag type '${tag.type}' was used, but not specified in \`tagTypes\`!`);
        }
      }
      return tag;
    };
    Object.assign(api, {
      reducerPath,
      endpoints: {},
      internalActions: {
        onOnline,
        onOffline,
        onFocus,
        onFocusLost
      },
      util: {}
    });
    const selectors = buildSelectors({
      serializeQueryArgs,
      reducerPath,
      createSelector: createSelector2
    });
    const {
      selectInvalidatedBy,
      selectCachedArgsForQuery,
      buildQuerySelector,
      buildInfiniteQuerySelector,
      buildMutationSelector
    } = selectors;
    safeAssign(api.util, {
      selectInvalidatedBy,
      selectCachedArgsForQuery
    });
    const {
      queryThunk,
      infiniteQueryThunk,
      mutationThunk,
      patchQueryData,
      updateQueryData,
      upsertQueryData,
      prefetch,
      buildMatchThunkActions
    } = buildThunks({
      baseQuery,
      reducerPath,
      context,
      api,
      serializeQueryArgs,
      assertTagType,
      selectors
    });
    const {
      reducer,
      actions: sliceActions
    } = buildSlice({
      context,
      queryThunk,
      infiniteQueryThunk,
      mutationThunk,
      serializeQueryArgs,
      reducerPath,
      assertTagType,
      config: {
        refetchOnFocus,
        refetchOnReconnect,
        refetchOnMountOrArgChange,
        keepUnusedDataFor,
        reducerPath,
        invalidationBehavior
      }
    });
    safeAssign(api.util, {
      patchQueryData,
      updateQueryData,
      upsertQueryData,
      prefetch,
      resetApiState: sliceActions.resetApiState,
      upsertQueryEntries: sliceActions.cacheEntriesUpserted
    });
    safeAssign(api.internalActions, sliceActions);
    const {
      middleware,
      actions: middlewareActions
    } = buildMiddleware({
      reducerPath,
      context,
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      api,
      assertTagType,
      selectors
    });
    safeAssign(api.util, middlewareActions);
    safeAssign(api, {
      reducer,
      middleware
    });
    const {
      buildInitiateQuery,
      buildInitiateInfiniteQuery,
      buildInitiateMutation,
      getRunningMutationThunk,
      getRunningMutationsThunk,
      getRunningQueriesThunk,
      getRunningQueryThunk
    } = buildInitiate({
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      api,
      serializeQueryArgs,
      context
    });
    safeAssign(api.util, {
      getRunningMutationThunk,
      getRunningMutationsThunk,
      getRunningQueryThunk,
      getRunningQueriesThunk
    });
    return {
      name: coreModuleName,
      injectEndpoint(endpointName, definition4) {
        var _a;
        const anyApi = api;
        const endpoint = (_a = anyApi.endpoints)[endpointName] ?? (_a[endpointName] = {});
        if (isQueryDefinition(definition4)) {
          safeAssign(endpoint, {
            name: endpointName,
            select: buildQuerySelector(endpointName, definition4),
            initiate: buildInitiateQuery(endpointName, definition4)
          }, buildMatchThunkActions(queryThunk, endpointName));
        }
        if (isMutationDefinition(definition4)) {
          safeAssign(endpoint, {
            name: endpointName,
            select: buildMutationSelector(),
            initiate: buildInitiateMutation(endpointName)
          }, buildMatchThunkActions(mutationThunk, endpointName));
        }
        if (isInfiniteQueryDefinition(definition4)) {
          safeAssign(endpoint, {
            name: endpointName,
            select: buildInfiniteQuerySelector(endpointName, definition4),
            initiate: buildInitiateInfiniteQuery(endpointName, definition4)
          }, buildMatchThunkActions(queryThunk, endpointName));
        }
      }
    };
  }
});
var createApi = buildCreateApi(coreModule());

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-slice.js
var dynamicBaseQuery = async (args, api, extraOptions) => {
  const state = api.getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const answerConfigurationId = state.generatedAnswer.answerConfigurationId;
  const updatedArgs = {
    ...args,
    headers: {
      ...(args == null ? void 0 : args.headers) || {},
      Authorization: `Bearer ${accessToken}`
    }
  };
  try {
    const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
    const data = fetchBaseQuery({
      baseUrl: `${platformEndpoint}/rest/organizations/${organizationId}/answer/v1/configs/${answerConfigurationId}`
    })(updatedArgs, api, extraOptions);
    return { data };
  } catch (error) {
    return { error };
  }
};
var answerSlice = createApi({
  reducerPath: "answer",
  baseQuery: retry2(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/answer-generation-api.js
var answerGenerationApi = createApi({
  reducerPath: "answerGenerationApi",
  refetchOnMountOrArgChange: true,
  baseQuery: retry2(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});

// node_modules/@coveo/headless/dist/esm/features/query/query-selectors.js
var selectQuery = (state) => state.query;
var selectEnableQuerySyntax = (state) => {
  var _a;
  return (_a = state.query) == null ? void 0 : _a.enableQuerySyntax;
};

// node_modules/@coveo/headless/dist/esm/features/generated-answer/answer-api-selectors.js
var selectAnswerTriggerParams = createSelector((state) => {
  var _a;
  return (_a = selectQuery(state)) == null ? void 0 : _a.q;
}, (state) => state.search.requestId, (state) => state.generatedAnswer.cannotAnswer, (state) => state.configuration.analytics.analyticsMode, (state) => {
  var _a;
  return (_a = state.search.searchAction) == null ? void 0 : _a.actionCause;
}, (q, requestId, cannotAnswer, analyticsMode, actionCause) => ({
  q,
  requestId,
  cannotAnswer,
  analyticsMode,
  actionCause
}));
var selectAnswerApiQueryParams = createSelector((state) => {
  var _a;
  return (_a = state.generatedAnswer) == null ? void 0 : _a.answerApiQueryParams;
}, (answerApiQueryParams) => answerApiQueryParams);

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/answer-generation-api-state.js
var initialAnswerGenerationServerState = () => ({
  contentFormat: void 0,
  answer: void 0,
  citations: void 0,
  error: void 0,
  generated: false,
  isStreaming: false,
  isLoading: true
});

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/streaming/answer-draft-reducer/answer-draft-reducer.js
var setAnswerId = (draft, answerId) => {
  if (answerId) {
    draft.answerId = answerId;
  }
};
var initializeStreamingAnswer = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var setAnswer = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var setCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var endStreaming = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var setAnswerError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code ?? 500
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(`Generated answer error: ${errorMessage} (code: ${message.code})`);
};

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/streaming/server-state-event-handler/server-state-event-handler.js
var serverStateEventHandler = {
  handleOpen: (response, updateCachedData) => {
    const answerId = response.headers.get("x-answer-id");
    if (answerId) {
      updateCachedData((draft) => {
        setAnswerId(draft, answerId);
      });
    }
  },
  handleMessage: {
    "agentInteraction.answerHeader": (_message, updateCachedData) => {
      updateCachedData((draft) => {
        initializeStreamingAnswer(draft, { contentFormat: "text/markdown" });
      });
    },
    "generativeengines.messageType": (message, updateCachedData) => {
      var _a;
      if ((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.textDelta) {
        updateCachedData((draft) => {
          setAnswer(draft, message.payload);
        });
      }
    },
    "agentInteraction.citations": (message, updateCachedData) => {
      var _a;
      if (((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.citations) !== void 0) {
        updateCachedData((draft) => {
          setCitations(draft, message.payload);
        });
      }
    },
    "generativeengines.endOfStreamType": (message, updateCachedData) => {
      updateCachedData((draft) => {
        endStreaming(draft, message.payload);
      });
    },
    error: (message, updateCachedData) => {
      if (message.finishReason === "ERROR") {
        updateCachedData((draft) => {
          setAnswerError(draft, message);
        });
      }
    }
  }
};

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/streaming/answer-streaming-runner.js
var streamAnswerWithStrategy = (endpointUrl, args, api, strategy) => {
  const { dispatch, updateCachedData, getState } = api;
  const { configuration: { accessToken } } = getState();
  return fetchEventSource(endpointUrl, {
    method: "POST",
    body: JSON.stringify(args),
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "text/event-stream",
      "Content-Type": "application/json",
      "Accept-Encoding": "*"
    },
    fetch,
    onopen: async (response) => {
      serverStateEventHandler.handleOpen(response, updateCachedData);
      strategy.handleOpen(response, dispatch);
    },
    onclose: () => {
      var _a;
      (_a = strategy.handleClose) == null ? void 0 : _a.call(strategy, dispatch);
    },
    onerror: (error) => {
      strategy.handleError(error);
    },
    onmessage: (event) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const message = parsePayload(event.data);
      if (!message) {
        return;
      }
      (_b = (_a = serverStateEventHandler.handleMessage).error) == null ? void 0 : _b.call(_a, message, updateCachedData);
      (_d = (_c = strategy.handleMessage).error) == null ? void 0 : _d.call(_c, message, dispatch);
      const messageType = message.payloadType;
      (_f = (_e = serverStateEventHandler.handleMessage)[messageType]) == null ? void 0 : _f.call(_e, message, updateCachedData);
      (_h = (_g = strategy.handleMessage)[messageType]) == null ? void 0 : _h.call(_g, message, dispatch);
    }
  });
};
function parsePayload(payload) {
  if (!(payload == null ? void 0 : payload.length)) {
    return null;
  }
  try {
    return JSON.parse(payload);
  } catch (err) {
    console.warn("Failed to parse message", {
      payload,
      error: err
    });
    return null;
  }
}

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/endpoints/follow-up/url-builders/endpoint-url-builder.js
var buildFollowUpEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const { organizationId, environment, knowledge: { agentId } } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId == null ? void 0 : agentId.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for follow up endpoint");
  }
  const basePath2 = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath2}/${trimmedAgentId}/follow-up`;
};

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/endpoints/follow-up/follow-up-endpoint.js
var followUpEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateFollowUpAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        var _a, _b;
        const { strategyKey, ...params } = args;
        const endpointUrl = buildFollowUpEndpointUrl(getState());
        await streamAnswerWithStrategy(endpointUrl, params, {
          getState,
          updateCachedData,
          dispatch
        }, (_b = (_a = streamingStrategyCreators)[strategyKey]) == null ? void 0 : _b.call(_a));
      }
    })
  })
});
var initiateFollowUpEndpoint = (args) => {
  return followUpEndpoint.endpoints.generateFollowUpAnswer.initiate(args);
};

// node_modules/@coveo/headless/dist/esm/features/follow-up-answers/follow-up-answer-request.js
var constructGenerateFollowUpAnswerParams = (followUpQuestion, state) => {
  var _a;
  const conversationId = ((_a = state.followUpAnswers) == null ? void 0 : _a.conversationId) ?? "";
  return {
    conversationId,
    q: followUpQuestion
  };
};

// node_modules/@coveo/headless/dist/esm/features/follow-up-answers/follow-up-answers-actions.js
var stringValue = new StringValue({ required: true });
var setIsEnabled = createAction("followUpAnswers/setIsEnabled", (payload) => validatePayload(payload, new BooleanValue({ required: true })));
var setFollowUpAnswersConversationId = createAction("followUpAnswers/setFollowUpAnswersConversationId", (payload) => validatePayload(payload, requiredNonEmptyString));
var createFollowUpAnswer = createAction("followUpAnswers/createFollowUpAnswer", (payload) => validatePayload(payload, {
  question: requiredNonEmptyString
}));
var setActiveFollowUpAnswerId = createAction("followUpAnswers/setActiveFollowUpAnswerId", (payload) => validatePayload(payload, requiredNonEmptyString));
var setFollowUpAnswerContentFormat = createAction("followUpAnswers/setFollowUpAnswerContentFormat", (payload) => validatePayload(payload, {
  contentFormat: answerContentFormatSchema,
  answerId: requiredNonEmptyString
}));
var setFollowUpIsLoading = createAction("followUpAnswers/setFollowUpIsLoading", (payload) => validatePayload(payload, {
  isLoading: new BooleanValue({ required: true }),
  answerId: requiredNonEmptyString
}));
var followUpMessageChunkReceived = createAction("followUpAnswers/followUpMessageChunkReceived", (payload) => validatePayload(payload, {
  textDelta: stringValue,
  answerId: requiredNonEmptyString
}));
var followUpCitationsReceived = createAction("followUpAnswers/followUpCitationsReceived", (payload) => validatePayload(payload, {
  citations: new ArrayValue({
    required: true,
    each: new RecordValue({
      values: citationSchema
    })
  }),
  answerId: requiredNonEmptyString
}));
var followUpCompleted = createAction("followUpAnswers/followUpCompleted", (payload) => validatePayload(payload, {
  answerId: requiredNonEmptyString,
  cannotAnswer: new BooleanValue({ required: false })
}));
var followUpFailed = createAction("followUpAnswers/followUpFailed", (payload) => validatePayload(payload, {
  message: new StringValue(),
  code: new NumberValue({ min: 0 }),
  answerId: requiredNonEmptyString
}));
var likeFollowUp = createAction("followUpAnswers/likeFollowUp", (payload) => validatePayload(payload, {
  answerId: requiredNonEmptyString
}));
var dislikeFollowUp = createAction("followUpAnswers/dislikeFollowUp", (payload) => validatePayload(payload, {
  answerId: requiredNonEmptyString
}));
var submitFollowUpFeedback = createAction("followUpAnswers/submitFollowUpFeedback", (payload) => validatePayload(payload, {
  answerId: requiredNonEmptyString
}));
var resetFollowUpAnswers = createAction("followUpAnswers/resetFollowUpAnswers");
var generateFollowUpAnswer = createAsyncThunk("generatedAnswerWithFollowUps/generateFollowUpAnswer", async (question, { getState, dispatch, extra: { logger } }) => {
  var _a;
  const state = getState();
  const agentId = (_a = selectAgentId(state)) == null ? void 0 : _a.trim();
  const generateFollowUpAnswerParams = constructGenerateFollowUpAnswerParams(question, state);
  if (!agentId) {
    logger.warn("Missing agentId in engine configuration. The generateFollowUpAnswer action requires an agent ID.");
    return;
  }
  if (!generateFollowUpAnswerParams.conversationId) {
    logger.warn("Missing conversationId when generating a follow-up answer. The generateFollowUpAnswer action requires an existing conversation.");
    return;
  }
  dispatch(createFollowUpAnswer({ question }));
  await dispatch(initiateFollowUpEndpoint({
    strategyKey: "follow-up-answer",
    ...generateFollowUpAnswerParams
  }));
});

// node_modules/@coveo/headless/dist/esm/features/follow-up-answers/follow-up-answer-strategy.js
var createFollowUpAnswerStrategy = () => {
  let answerId = null;
  return {
    handleOpen: (response, dispatch) => {
      answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setActiveFollowUpAnswerId(answerId));
        dispatch(setFollowUpIsLoading({ answerId, isLoading: true }));
        dispatch(setFollowUpAnswerContentFormat({
          contentFormat: "text/markdown",
          answerId
        }));
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "generativeengines.messageType": (message, dispatch) => {
        var _a;
        if ((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.textDelta) {
          dispatch(followUpMessageChunkReceived({
            textDelta: message.payload.textDelta,
            answerId
          }));
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        var _a;
        if (((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.citations) !== void 0) {
          dispatch(followUpCitationsReceived({
            citations: message.payload.citations,
            answerId
          }));
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        var _a;
        const answerGenerated = ((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.answerGenerated) ?? false;
        dispatch(followUpCompleted({
          cannotAnswer: !answerGenerated,
          answerId
        }));
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(followUpFailed({
            answerId,
            message: message.errorMessage,
            code: message.code
          }));
        }
      }
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-analytics-actions.js
var parseEvaluationDetails = (detail) => {
  if (detail === "yes") {
    return true;
  }
  if (detail === "no") {
    return false;
  }
  return void 0;
};
var logRetryGeneratedAnswer = () => makeAnalyticsAction("analytics/generatedAnswer/retry", (client) => client.makeRetryGeneratedAnswer());
var logOpenGeneratedAnswerSource = (citationId) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/openAnswerSource",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const citation = citationSourceSelector(state, citationId);
    if (!generativeQuestionAnsweringId || !citation) {
      return null;
    }
    return client.makeGeneratedAnswerCitationClick(partialCitationInformation(citation, state), {
      generativeQuestionAnsweringId,
      citationId: citation.id,
      documentId: citationDocumentIdentifier(citation)
    });
  },
  analyticsType: "Rga.CitationClick",
  analyticsPayloadBuilder: (state) => {
    const citation = citationSourceSelector(state, citationId);
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      citationId,
      itemMetadata: {
        uniqueFieldName: "permanentid",
        uniqueFieldValue: (citation == null ? void 0 : citation.permanentid) ?? "",
        title: citation == null ? void 0 : citation.title,
        url: citation == null ? void 0 : citation.clickUri
      }
    };
  }
});
var logHoverCitation = (citationId, citationHoverTimeInMs) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/hoverCitation",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const citation = citationSourceSelector(state, citationId);
    if (!generativeQuestionAnsweringId || !citation) {
      return null;
    }
    return client.makeGeneratedAnswerSourceHover({
      generativeQuestionAnsweringId,
      permanentId: citation.permanentid,
      citationId: citation.id,
      citationHoverTimeMs: citationHoverTimeInMs
    });
  },
  analyticsType: "Rga.CitationHover",
  analyticsPayloadBuilder: (state) => {
    const citation = citationSourceSelector(state, citationId);
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      citationId,
      itemMetadata: {
        uniqueFieldName: "permanentid",
        uniqueFieldValue: (citation == null ? void 0 : citation.permanentid) ?? "",
        title: citation == null ? void 0 : citation.title,
        url: citation == null ? void 0 : citation.clickUri
      },
      citationHoverTimeInMs
    };
  }
});
var logLikeGeneratedAnswer = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/like",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeLikeGeneratedAnswer({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "like"
    };
  }
});
var logDislikeGeneratedAnswer = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/dislike",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeDislikeGeneratedAnswer({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "dislike"
    };
  }
});
var logGeneratedAnswerFeedback = (feedback) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/sendFeedback",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerFeedbackSubmitV2({
      generativeQuestionAnsweringId,
      ...feedback
    });
  },
  analyticsType: "Rga.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const { helpful, readable, documented, hallucinationFree, correctTopic, documentUrl, details } = feedback;
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      helpful,
      details: {
        readable: parseEvaluationDetails(readable),
        documented: parseEvaluationDetails(documented),
        correctTopic: parseEvaluationDetails(correctTopic),
        hallucinationFree: parseEvaluationDetails(hallucinationFree)
      },
      additionalNotes: details,
      correctAnswerUrl: documentUrl
    };
  }
});
var logGeneratedAnswerStreamEnd = (answerGenerated) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/streamEnd",
  __legacy__getBuilder: (client, state) => {
    var _a, _b;
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const answerTextIsEmpty = answerGenerated ? !((_a = state.generatedAnswer) == null ? void 0 : _a.answer) || !((_b = state.generatedAnswer) == null ? void 0 : _b.answer.length) : void 0;
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerStreamEnd({
      generativeQuestionAnsweringId,
      answerGenerated,
      answerTextIsEmpty
    });
  },
  analyticsType: "Rga.AnswerReceived",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      answerGenerated: answerGenerated ?? false
    };
  }
});
var logGeneratedAnswerResponseLinked = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/responseLinked",
  __legacy__getBuilder: () => {
    return null;
  },
  analyticsType: "Rga.ResponseLinked",
  analyticsPayloadBuilder: (state) => {
    var _a, _b;
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      responseId: ((_a = state.search) == null ? void 0 : _a.searchResponseId) || ((_b = state.search) == null ? void 0 : _b.response.searchUid) || ""
    };
  }
});
var logGeneratedAnswerShowAnswers = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/show",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerShowAnswers({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "show"
    };
  }
});
var logGeneratedAnswerHideAnswers = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/hide",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerHideAnswers({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "hide"
    };
  }
});
var logGeneratedAnswerExpand = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/expand",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerExpand({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "expand"
    };
  }
});
var logGeneratedAnswerCollapse = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/collapse",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerCollapse({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "collapse"
    };
  }
});
var logCopyGeneratedAnswer = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/copy",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerCopyToClipboard({
      generativeQuestionAnsweringId
    });
  },
  analyticsType: "Rga.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      action: "copyToClipboard"
    };
  }
});
var generatedAnswerAnalyticsClient = {
  logCopyGeneratedAnswer,
  logGeneratedAnswerHideAnswers,
  logGeneratedAnswerShowAnswers,
  logGeneratedAnswerStreamEnd,
  logGeneratedAnswerFeedback,
  logDislikeGeneratedAnswer,
  logLikeGeneratedAnswer,
  logHoverCitation,
  logOpenGeneratedAnswerSource,
  logRetryGeneratedAnswer,
  logGeneratedAnswerExpand,
  logGeneratedAnswerCollapse
};

// node_modules/@coveo/headless/dist/esm/features/generated-answer/head-answer-strategy.js
var createHeadAnswerStrategy = () => {
  return {
    handleOpen: (response, dispatch) => {
      const answerId = response.headers.get("x-answer-id");
      if (answerId) {
        dispatch(setAnswerId2(answerId));
      }
    },
    handleError: (error) => {
      throw error;
    },
    handleMessage: {
      "agentInteraction.answerHeader": (message, dispatch) => {
        var _a;
        if ((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.conversationId) {
          dispatch(setFollowUpAnswersConversationId(message.payload.conversationId));
        }
        if (message.payload.followUpEnabled) {
          dispatch(setIsEnabled(message.payload.followUpEnabled));
        }
        dispatch(setAnswerContentFormat("text/markdown"));
        dispatch(setIsStreaming(true));
        dispatch(setIsLoading(false));
      },
      "generativeengines.messageType": (message, dispatch) => {
        var _a;
        if ((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.textDelta) {
          dispatch(updateMessage({ textDelta: message.payload.textDelta }));
        }
      },
      "agentInteraction.citations": (message, dispatch) => {
        var _a;
        if (((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.citations) !== void 0) {
          dispatch(updateCitations({ citations: message.payload.citations }));
        }
      },
      "generativeengines.endOfStreamType": (message, dispatch) => {
        var _a;
        const answerGenerated = ((_a = message == null ? void 0 : message.payload) == null ? void 0 : _a.answerGenerated) ?? false;
        dispatch(setIsAnswerGenerated(answerGenerated));
        dispatch(setCannotAnswer(!answerGenerated));
        dispatch(setIsStreaming(false));
        dispatch(setIsLoading(false));
        dispatch(logGeneratedAnswerStreamEnd(answerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
      },
      error: (message, dispatch) => {
        if (message.finishReason === "ERROR") {
          dispatch(updateError(message));
        }
      }
    }
  };
};

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/streaming/strategies/streaming-strategy-creators.js
var streamingStrategyCreators = {
  "head-answer": createHeadAnswerStrategy,
  "follow-up-answer": createFollowUpAnswerStrategy
};

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/endpoints/answer/url-builders/endpoint-url-builder.js
var buildAnswerEndpointUrl = (state) => {
  const { configuration: configuration2 } = state;
  const { organizationId, environment, knowledge: { agentId } } = configuration2;
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  const trimmedAgentId = agentId == null ? void 0 : agentId.trim();
  if (!platformEndpoint || !organizationId || !trimmedAgentId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/api/preview/organizations/${organizationId}/agents`;
  return `${platformEndpoint}${basePath2}/${trimmedAgentId}/answer`;
};

// node_modules/@coveo/headless/dist/esm/api/knowledge/answer-generation/endpoints/answer/answer-endpoint.js
var answerEndpoint = answerGenerationApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    generateAnswer: builder.query({
      queryFn: () => {
        return {
          data: initialAnswerGenerationServerState()
        };
      },
      async onQueryStarted(args, { getState, updateCachedData, dispatch }) {
        var _a, _b;
        const { strategyKey, ...params } = args;
        const endpointUrl = buildAnswerEndpointUrl(getState());
        await streamAnswerWithStrategy(endpointUrl, params, {
          getState,
          updateCachedData,
          dispatch
        }, (_b = (_a = streamingStrategyCreators)[strategyKey]) == null ? void 0 : _b.call(_a));
      }
    })
  })
});
var initiateAnswerEndpoint = (args) => {
  return answerEndpoint.endpoints.generateAnswer.initiate(args);
};
var selectAnswer = (args, state) => {
  return answerEndpoint.endpoints.generateAnswer.select(args)(state);
};

// node_modules/@coveo/headless/dist/esm/features/advanced-search-queries/advanced-search-query-selectors.js
var selectAdvancedSearchQueries = createSelector((state) => state.advancedSearchQueries, (advancedSearchQueries) => {
  if (!advancedSearchQueries) {
    return {};
  }
  const { aq, cq, dq, lq } = advancedSearchQueries;
  return {
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq }
  };
});

// node_modules/@coveo/headless/dist/esm/features/context/context-selector.js
var selectContext = (state) => state.context;

// node_modules/@coveo/headless/dist/esm/features/pipeline/select-pipeline.js
var selectPipeline = (state) => state.pipeline;

// node_modules/@coveo/headless/dist/esm/features/search-hub/search-hub-selectors.js
var selectSearchHub = (state) => state.searchHub;

// node_modules/@coveo/headless/dist/esm/features/tab-set/tab-set-selectors.js
var selectActiveTab = createSelector((state) => state, (tabSetState) => {
  if (!tabSetState) {
    return "";
  }
  for (const tabId in tabSetState) {
    if (tabSetState[tabId].isActive) {
      return tabSetState[tabId].id;
    }
  }
  return "";
});
var selectActiveTabExpression = createSelector((state) => state, (tabSetState) => {
  const activeTabId = selectActiveTab(tabSetState);
  return activeTabId && tabSetState ? tabSetState[activeTabId].expression : "";
});

// node_modules/@coveo/headless/dist/esm/features/dictionary-field-context/dictionary-field-context-selectors.js
var selectDictionaryFieldContext = (state) => {
  if (!state.dictionaryFieldContext || !Object.keys(state.dictionaryFieldContext.contextValues).length) {
    return void 0;
  }
  return state.dictionaryFieldContext.contextValues;
};

// node_modules/@coveo/headless/dist/esm/features/excerpt-length/excerpt-length-selectors.js
var selectExcerptLength = (state) => {
  var _a;
  return (_a = state.excerptLength) == null ? void 0 : _a.length;
};

// node_modules/@coveo/headless/dist/esm/features/facet-options/facet-options-selectors.js
var isFacetEnabledSelector = (state, id) => {
  var _a;
  return ((_a = state.facetOptions.facets[id]) == null ? void 0 : _a.enabled) ?? true;
};
var selectFacetOptions = (state) => {
  const { freezeFacetOrder } = state.facetOptions ?? {};
  return freezeFacetOrder !== void 0 ? { freezeFacetOrder } : void 0;
};

// node_modules/@coveo/headless/dist/esm/features/folding/folding-selectors.js
var selectFoldingQueryParams = (state) => {
  if (!state.folding) {
    return void 0;
  }
  return {
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: state.folding.filterFieldRange
  };
};

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/sort-criteria-selectors.js
var selectSortCriteria = (state) => state.sortCriteria;

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-request.js
var buildStreamingRequest = async (state) => {
  var _a;
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: getOrganizationEndpoint(state.configuration.organizationId, state.configuration.environment),
    streamId: (_a = state.search.extendedResults) == null ? void 0 : _a.generativeQuestionAnsweringId
  };
};
var constructAnswerAPIQueryParams = (state, navigatorContext) => {
  var _a, _b, _c;
  const q = (_a = selectQuery(state)) == null ? void 0 : _a.q;
  const { aq, cq, dq, lq } = buildAdvancedSearchQueryParams(state);
  const context = selectContext(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(state.configuration.analytics, navigatorContext, { actionCause: selectSearchActionCause(state) });
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  const facetParams = getGeneratedFacetParams(state);
  const tab = selectActiveTab(state.tabSet) || "default";
  const locale = selectLocale(state);
  const timezone2 = selectTimezone(state);
  const referrer = navigatorContext.referrer || "";
  const facetOptions = selectFacetOptions(state);
  const sortCriteria = selectSortCriteria(state);
  const actionsHistory = getActionsHistory(state);
  const excerptLength = selectExcerptLength(state);
  const foldingParams = selectFoldingQueryParams(state);
  const dictionaryFieldContext = selectDictionaryFieldContext(state);
  return {
    q,
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq },
    ...state.query && { enableQuerySyntax: selectEnableQuerySyntax(state) },
    ...(context == null ? void 0 : context.contextValues) && {
      context: context.contextValues
    },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...(searchHub == null ? void 0 : searchHub.length) && { searchHub },
    ...(pipeline == null ? void 0 : pipeline.length) && { pipeline },
    ...facetParams.length && { facets: facetParams },
    ...state.fields && { fieldsToInclude: state.fields.fieldsToInclude },
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    tab,
    locale,
    timezone: timezone2,
    ...state.debug !== void 0 && { debug: state.debug },
    referrer,
    ...actionsHistory,
    ...foldingParams ?? {},
    ...excerptLength && { excerptLength },
    ...dictionaryFieldContext && {
      dictionaryFieldContext
    },
    sortCriteria,
    ...facetOptions && { facetOptions },
    ...analyticsParams,
    ...((_b = state.insightCaseContext) == null ? void 0 : _b.caseContext) && {
      caseContext: (_c = state.insightCaseContext) == null ? void 0 : _c.caseContext
    }
  };
};
var constructGenerateHeadAnswerParams = (state, navigatorContext) => {
  var _a;
  const q = (_a = selectQuery(state)) == null ? void 0 : _a.q;
  const facetParams = getGeneratedFacetParams(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams(state.configuration.analytics, navigatorContext, { actionCause: selectSearchActionCause(state) });
  const locale = selectLocale(state);
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  return {
    q: q || "",
    ...facetParams.length && { facets: facetParams },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...(searchHub == null ? void 0 : searchHub.length) && { searchHub },
    ...(pipeline == null ? void 0 : pipeline.length) && { pipeline },
    ...analyticsParams,
    locale
  };
};
var getGeneratedFacetParams = (state) => {
  var _a;
  return (_a = getFacets(state)) == null ? void 0 : _a.map((facetRequest) => mapFacetRequest(facetRequest, initialSearchMappings())).sort((a, b) => a.facetId > b.facetId ? 1 : b.facetId > a.facetId ? -1 : 0);
};
var getActionsHistory = (state) => ({
  actionsHistory: state.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : []
});
var buildAdvancedSearchQueryParams = (state) => {
  const advancedSearchQueryParams = selectAdvancedSearchQueries(state);
  const mergedCq = buildConstantQuery2(state);
  return {
    ...advancedSearchQueryParams,
    ...mergedCq && { cq: mergedCq }
  };
};

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-response-format.js
var generatedContentFormat = ["text/plain", "text/markdown"];

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-actions.js
var stringValue2 = new StringValue({ required: true });
var optionalStringValue = new StringValue();
var booleanValue = new BooleanValue({ required: true });
var citationSchema = {
  id: stringValue2,
  title: stringValue2,
  uri: stringValue2,
  permanentid: stringValue2,
  clickUri: optionalStringValue
};
var answerContentFormatSchema = new StringValue({
  required: true,
  constrainTo: generatedContentFormat
});
var setIsVisible = createAction("generatedAnswer/setIsVisible", (payload) => validatePayload(payload, booleanValue));
var setAnswerId2 = createAction("generatedAnswer/setAnswerId", (payload) => validatePayload(payload, requiredNonEmptyString));
var setAnswerGenerationMode = createAction("generatedAnswer/setAnswerGenerationMode", (payload) => validatePayload(payload, new StringValue({
  constrainTo: ["automatic", "manual"],
  required: false,
  default: "automatic"
})));
var setIsEnabled2 = createAction("generatedAnswer/setIsEnabled", (payload) => validatePayload(payload, booleanValue));
var updateMessage = createAction("generatedAnswer/updateMessage", (payload) => validatePayload(payload, {
  textDelta: stringValue2
}));
var updateCitations = createAction("generatedAnswer/updateCitations", (payload) => validatePayload(payload, {
  citations: new ArrayValue({
    required: true,
    each: new RecordValue({
      values: citationSchema
    })
  })
}));
var updateError = createAction("generatedAnswer/updateError", (payload) => validatePayload(payload, {
  message: optionalStringValue,
  code: new NumberValue({ min: 0 })
}));
var resetAnswer = createAction("generatedAnswer/resetAnswer");
var likeGeneratedAnswer = createAction("generatedAnswer/like");
var dislikeGeneratedAnswer = createAction("generatedAnswer/dislike");
var openGeneratedAnswerFeedbackModal = createAction("generatedAnswer/feedbackModal/open");
var expandGeneratedAnswer = createAction("generatedAnswer/expand");
var collapseGeneratedAnswer = createAction("generatedAnswer/collapse");
var setId = createAction("generatedAnswer/setId", (payload) => validatePayload(payload, {
  id: new StringValue({
    required: true
  })
}));
var closeGeneratedAnswerFeedbackModal = createAction("generatedAnswer/feedbackModal/close");
var sendGeneratedAnswerFeedback = createAction("generatedAnswer/sendFeedback");
var setIsLoading = createAction("generatedAnswer/setIsLoading", (payload) => validatePayload(payload, booleanValue));
var setIsStreaming = createAction("generatedAnswer/setIsStreaming", (payload) => validatePayload(payload, booleanValue));
var setAnswerContentFormat = createAction("generatedAnswer/setAnswerContentFormat", (payload) => validatePayload(payload, answerContentFormatSchema));
var updateResponseFormat = createAction("generatedAnswer/updateResponseFormat", (payload) => validatePayload(payload, {
  contentFormat: new ArrayValue({
    each: answerContentFormatSchema,
    default: ["text/plain"]
  })
}));
var updateAnswerConfigurationId = createAction("knowledge/updateAnswerConfigurationId", (payload) => validatePayload(payload, stringValue2));
var registerFieldsToIncludeInCitations = createAction("generatedAnswer/registerFieldsToIncludeInCitations", (payload) => validatePayload(payload, nonEmptyStringArray));
var setIsAnswerGenerated = createAction("generatedAnswer/setIsAnswerGenerated", (payload) => validatePayload(payload, booleanValue));
var setCannotAnswer = createAction("generatedAnswer/setCannotAnswer", (payload) => validatePayload(payload, booleanValue));
var setAnswerApiQueryParams = createAction("generatedAnswer/setAnswerApiQueryParams", (payload) => validatePayload(payload, new RecordValue({})));
var streamAnswer = createAsyncThunk("generatedAnswer/streamAnswer", async (params, config) => {
  var _a;
  const state = config.getState();
  const { dispatch, extra, getState } = config;
  const { search } = getState();
  const { queryExecuted } = search;
  const { setAbortControllerRef } = params;
  const request = await buildStreamingRequest(state);
  const handleStreamPayload = (payloadType, payload) => {
    switch (payloadType) {
      case "genqa.headerMessageType": {
        const header = JSON.parse(payload);
        dispatch(setAnswerContentFormat(header.contentFormat));
        break;
      }
      case "genqa.messageType":
        dispatch(updateMessage(JSON.parse(payload)));
        break;
      case "genqa.citationsType":
        dispatch(updateCitations(JSON.parse(payload)));
        break;
      case "genqa.endOfStreamType": {
        const isAnswerGenerated = JSON.parse(payload).answerGenerated;
        const cannotAnswer = queryExecuted.length !== 0 && !isAnswerGenerated;
        dispatch(setCannotAnswer(cannotAnswer));
        dispatch(setIsStreaming(false));
        dispatch(setIsAnswerGenerated(isAnswerGenerated));
        dispatch(logGeneratedAnswerStreamEnd(isAnswerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
        break;
      }
      default:
        if (state.debug) {
          extra.logger.warn(`Unknown payloadType: "${payloadType}"`);
        }
    }
  };
  dispatch(setIsLoading(true));
  const currentStreamRequestMatchesOriginalStreamRequest = (request2) => {
    return request2.streamId === config.getState().search.extendedResults.generativeQuestionAnsweringId;
  };
  const abortController = (_a = extra.streamingClient) == null ? void 0 : _a.streamGeneratedAnswer(request, {
    write: (data) => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(setIsLoading(false));
        if (data.payload && data.payloadType) {
          handleStreamPayload(data.payloadType, data.payload);
        }
      }
    },
    abort: (error) => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(updateError(error));
      }
    },
    close: () => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(setIsStreaming(false));
      }
    },
    resetAnswer: () => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(resetAnswer());
      }
    }
  });
  if (abortController) {
    setAbortControllerRef(abortController);
  } else {
    dispatch(setIsLoading(false));
  }
});
var generateAnswer = createAsyncThunk("generatedAnswer/generateAnswer", async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
  dispatch(resetAnswer());
  const state = getState();
  if (state.generatedAnswer.answerConfigurationId) {
    const answerApiQueryParams = constructAnswerAPIQueryParams(state, navigatorContext);
    dispatch(setAnswerApiQueryParams(answerApiQueryParams));
    await dispatch(fetchAnswer(answerApiQueryParams));
  } else {
    logger.warn("[WARNING] Missing answerConfigurationId in engine configuration. The generateAnswer action requires an answer configuration ID to use CRGA with the Answer API.");
  }
});
var generateHeadAnswer = createAsyncThunk("generatedAnswerWithFollowUps/generateHeadAnswer", async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
  const state = getState();
  const agentId = selectAgentId(state);
  if (!agentId) {
    logger.warn("Missing agentId in engine configuration. The generateHeadAnswer action requires an agent ID.");
    return;
  }
  dispatch(resetAnswer());
  const generateHeadAnswerParams = constructGenerateHeadAnswerParams(state, navigatorContext);
  const headAnswerEndpointArgs = {
    ...generateHeadAnswerParams,
    strategyKey: "head-answer"
  };
  dispatch(setAnswerApiQueryParams(generateHeadAnswerParams));
  await dispatch(initiateAnswerEndpoint(headAnswerEndpointArgs));
});

// node_modules/@coveo/headless/dist/esm/api/knowledge/stream-answer-api.js
var handleHeaderMessage = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
var handleMessage = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
var handleCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
var handleEndOfStream = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
var handleError = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(`Generated answer error: ${errorMessage} (code: ${message.code})`);
};
var updateCacheWithEvent = (event, draft, dispatch) => {
  const message = JSON.parse(event.data);
  if (message.finishReason === "ERROR" && message.errorMessage) {
    handleError(draft, message);
  }
  const parsedPayload = message.payload.length ? JSON.parse(message.payload) : {};
  switch (message.payloadType) {
    case "genqa.headerMessageType":
      if (parsedPayload.contentFormat) {
        handleHeaderMessage(draft, parsedPayload);
        dispatch(setAnswerContentFormat(parsedPayload.contentFormat));
      }
      break;
    case "genqa.messageType":
      if (parsedPayload.textDelta) {
        handleMessage(draft, parsedPayload);
        dispatch(updateMessage({ textDelta: parsedPayload.textDelta }));
      }
      break;
    case "genqa.citationsType":
      if (parsedPayload.citations) {
        handleCitations(draft, parsedPayload);
        dispatch(updateCitations({ citations: parsedPayload.citations }));
      }
      break;
    case "genqa.endOfStreamType":
      handleEndOfStream(draft, parsedPayload);
      dispatch(logGeneratedAnswerStreamEnd(parsedPayload.answerGenerated ?? false));
      dispatch(logGeneratedAnswerResponseLinked());
      break;
  }
};
var buildAnswerEndpoint = (platformEndpoint, organizationId, answerConfigurationId, insightId) => {
  if (!platformEndpoint || !organizationId || !answerConfigurationId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/rest/organizations/${organizationId}`;
  const prefix = insightId ? `insight/v1/configs/${insightId}/answer` : `answer/v1/configs`;
  return `${platformEndpoint}${basePath2}/${prefix}/${answerConfigurationId}/generate`;
};
var answerApi = answerSlice.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    getAnswer: builder.query({
      queryFn: () => ({
        data: {
          contentFormat: void 0,
          answer: void 0,
          citations: void 0,
          error: void 0,
          generated: false,
          isStreaming: true,
          isLoading: true
        }
      }),
      serializeQueryArgs: ({ endpointName, queryArgs }) => {
        const { analytics: _analytics, ...queryArgsWithoutAnalytics } = queryArgs;
        return `${endpointName}(${JSON.stringify(queryArgsWithoutAnalytics)})`;
      },
      async onCacheEntryAdded(args, { getState, cacheDataLoaded, updateCachedData, dispatch }) {
        await cacheDataLoaded;
        const { configuration: configuration2, generatedAnswer, insightConfiguration } = getState();
        const { organizationId, environment, accessToken } = configuration2;
        const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
        const answerEndpoint2 = buildAnswerEndpoint(platformEndpoint, organizationId, generatedAnswer.answerConfigurationId, insightConfiguration == null ? void 0 : insightConfiguration.insightId);
        await fetchEventSource(answerEndpoint2, {
          method: "POST",
          body: JSON.stringify(args),
          headers: {
            Authorization: `Bearer ${accessToken}`,
            Accept: "application/json",
            "Content-Type": "application/json",
            "Accept-Encoding": "*"
          },
          fetch,
          onopen: async (res) => {
            const answerId = res.headers.get("x-answer-id");
            if (answerId) {
              updateCachedData((draft) => {
                draft.answerId = answerId;
                dispatch(setAnswerId2(answerId));
              });
            }
          },
          onmessage: (event) => {
            updateCachedData((draft) => {
              updateCacheWithEvent(event, draft, dispatch);
            });
          },
          onerror: (error) => {
            throw error;
          },
          onclose: () => {
            updateCachedData((draft) => {
              dispatch(setCannotAnswer(!draft.generated));
            });
          }
        });
      }
    })
  })
});
var fetchAnswer = (fetchAnswerParams) => {
  return answerApi.endpoints.getAnswer.initiate(fetchAnswerParams);
};
var selectAnswer2 = (state) => {
  const params = selectAnswerApiQueryParams(state);
  return answerApi.endpoints.getAnswer.select(params ?? skipToken)(state);
};

// node_modules/@coveo/headless/dist/esm/features/debug/version-slice.js
var versionReducer = createReducer(VERSION, (builder) => builder);

// node_modules/@coveo/headless/dist/esm/app/analytics-middleware.js
function isAnalyticsAction(action) {
  var _a;
  const analytics = (_a = action.payload) == null ? void 0 : _a.analyticsAction;
  return isActionWithType(action) && !isNullOrUndefined(analytics);
}
function isActionWithType(action) {
  return "type" in action;
}
var analyticsMiddleware = (api) => (next) => (action) => {
  let analytics;
  if (isAnalyticsAction(action)) {
    analytics = action.payload.analyticsAction;
    delete action.payload.analyticsAction;
  }
  const ret = next(action);
  if (isActionWithType(action)) {
    if (action.type === "search/executeSearch/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with search:", action);
    }
    if (action.type === "recommendation/get/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with recommendation:", action);
    }
    if (action.type === "productRecommendations/get/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with product recommendation:", action);
    }
  }
  if (analytics !== void 0) {
    api.dispatch(analytics);
  }
  return ret;
};

// node_modules/@coveo/headless/dist/esm/features/tab-set/tab-set-actions.js
var registerTab = createAction("tab/register", (payload) => {
  const schema = new RecordValue({
    values: {
      id: requiredNonEmptyString,
      expression: requiredEmptyAllowedString
    }
  });
  return validatePayload(payload, schema);
});
var updateActiveTab = createAction("tab/updateActiveTab", (id) => {
  return validatePayload(id, requiredNonEmptyString);
});

// node_modules/@coveo/headless/dist/esm/features/configuration/configuration-state.js
var import_dayjs3 = __toESM(require_dayjs_min(), 1);
var import_timezone = __toESM(require_timezone(), 1);
var import_utc = __toESM(require_utc(), 1);
import_dayjs3.default.extend(import_utc.default);
import_dayjs3.default.extend(import_timezone.default);
var getConfigurationInitialState = () => ({
  organizationId: "",
  accessToken: "",
  search: {
    locale: "en-US",
    timezone: import_dayjs3.default.tz.guess(),
    authenticationProviders: []
  },
  analytics: {
    enabled: true,
    originContext: "Search",
    originLevel2: "default",
    originLevel3: "default",
    anonymous: false,
    deviceId: "",
    userDisplayName: "",
    documentLocation: "",
    analyticsMode: "next",
    source: {}
  },
  knowledge: {
    answerConfigurationId: "",
    agentId: void 0
  },
  environment: "prod"
});

// node_modules/@coveo/headless/dist/esm/features/configuration/magic-cookie.js
var pendragonCookieValueMatcher = /(^|; )Coveo-Pendragon=([^;]*)/;
function getMagicCookie() {
  var _a;
  if (typeof window === "undefined") {
    return false;
  } else {
    return ((_a = pendragonCookieValueMatcher.exec(document.cookie)) == null ? void 0 : _a.pop()) || null;
  }
}

// node_modules/@coveo/headless/dist/esm/features/configuration/configuration-slice.js
var configurationReducer = createReducer(getConfigurationInitialState(), (builder) => builder.addCase(updateBasicConfiguration, (state, action) => {
  handleUpdateBasicConfiguration(state, action.payload);
}).addCase(updateSearchConfiguration, (state, action) => {
  handleUpdateSearchConfiguration(state, action.payload);
}).addCase(updateAnalyticsConfiguration, (state, action) => {
  handleUpdateAnalyticsConfiguration(state, action.payload);
}).addCase(disableAnalytics, (state) => {
  state.analytics.enabled = false;
}).addCase(enableAnalytics, (state) => {
  state.analytics.enabled = true;
}).addCase(setOriginLevel2, (state, action) => {
  state.analytics.originLevel2 = action.payload.originLevel2;
}).addCase(setOriginLevel3, (state, action) => {
  state.analytics.originLevel3 = action.payload.originLevel3;
}).addCase(updateActiveTab, (state, action) => {
  state.analytics.originLevel2 = action.payload;
}).addCase(restoreTab, (state, action) => {
  state.analytics.originLevel2 = action.payload;
}).addCase(restoreSearchParameters, (state, action) => {
  if (!isNullOrUndefined(action.payload.tab)) {
    state.analytics.originLevel2 = action.payload.tab;
  }
}).addCase(setAgentId, (state, { payload }) => {
  state.knowledge.agentId = payload;
}));
function handleUpdateBasicConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!isNullOrUndefined(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateSearchConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.proxyBaseUrl)) {
    state.search.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!isNullOrUndefined(payload.locale)) {
    state.search.locale = payload.locale;
  }
  if (!isNullOrUndefined(payload.timezone)) {
    state.search.timezone = payload.timezone;
  }
  if (!isNullOrUndefined(payload.authenticationProviders)) {
    state.search.authenticationProviders = payload.authenticationProviders;
  }
}
function handleUpdateAnalyticsConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!isNullOrUndefined(payload.originContext)) {
    state.analytics.originContext = payload.originContext;
  }
  if (!isNullOrUndefined(payload.originLevel2)) {
    state.analytics.originLevel2 = payload.originLevel2;
  }
  if (!isNullOrUndefined(payload.originLevel3)) {
    state.analytics.originLevel3 = payload.originLevel3;
  }
  if (!isNullOrUndefined(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!isNullOrUndefined(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
  if (!isNullOrUndefined(payload.analyticsMode)) {
    state.analytics.analyticsMode = payload.analyticsMode;
  }
  if (!isNullOrUndefined(payload.source)) {
    state.analytics.source = payload.source;
  }
  try {
    const magicCookie = getMagicCookie();
    if (magicCookie) {
      state.analytics.analyticsMode = "next";
      state.analytics.trackingId = magicCookie;
    }
  } catch (_) {
  }
  if (!isNullOrUndefined(payload.runtimeEnvironment)) {
    state.analytics.runtimeEnvironment = payload.runtimeEnvironment;
  }
  if (!isNullOrUndefined(payload.anonymous)) {
    state.analytics.anonymous = payload.anonymous;
  }
  if (!isNullOrUndefined(payload.deviceId)) {
    state.analytics.deviceId = payload.deviceId;
  }
  if (!isNullOrUndefined(payload.userDisplayName)) {
    state.analytics.userDisplayName = payload.userDisplayName;
  }
  if (!isNullOrUndefined(payload.documentLocation)) {
    state.analytics.documentLocation = payload.documentLocation;
  }
}

// node_modules/@coveo/headless/dist/esm/app/common-reducers.js
var configuration = configurationReducer;

// node_modules/@coveo/headless/dist/esm/app/instantly-callable-middleware.js
function isInstantlyCallableThunkAction(action) {
  return action.instantlyCallable;
}
var instantlyCallableThunkActionMiddleware = () => (next) => (action) => next(isInstantlyCallableThunkAction(action) ? action() : action);

// node_modules/@coveo/headless/dist/esm/app/listener-middleware/generate-answer-listener-middleware.js
var generateAnswerListener = createListenerMiddleware();
generateAnswerListener.startListening({
  actionCreator: executeSearch2.pending,
  effect: async (_action, listenerApi) => {
    var _a;
    const state = listenerApi.getState();
    const q = (_a = selectQuery(state)) == null ? void 0 : _a.q;
    const queryIsEmpty = !q || q.trim() === "";
    if (!isGeneratedAnswerFeatureEnabledWithAnswerGenerationAPI(state)) {
      return;
    }
    listenerApi.dispatch(resetAnswer());
    listenerApi.dispatch(resetFollowUpAnswers());
    if (queryIsEmpty) {
      return;
    }
    listenerApi.dispatch(generateHeadAnswer());
  }
});

// node_modules/@coveo/headless/dist/esm/app/logger-middlewares.js
var logActionErrorMiddleware = (logger) => () => (next) => (action) => {
  var _a;
  const unknownAction = action;
  if (!unknownAction.error) {
    return next(action);
  }
  const error = unknownAction.error;
  if (!((_a = unknownAction.payload) == null ? void 0 : _a.ignored)) {
    logger.error({ error, action }, `Action dispatch error ${unknownAction.type}`);
  }
  if (unknownAction.error.name === "SchemaValidationError") {
    return;
  }
  return next(action);
};
var logActionMiddleware = (logger) => (api) => (next) => (action) => {
  logger.debug({
    action,
    nextState: api.getState()
  }, `Action dispatched: ${action.type}`);
  return next(action);
};

// node_modules/@coveo/headless/dist/esm/app/navigator-context-provider.js
var getNavigatorContext = (relay, customProvider) => {
  const { referrer, userAgent, location, clientId } = relay.getMeta("");
  const customContext = customProvider ? customProvider() : {};
  return { ...customContext, referrer, userAgent, location, clientId };
};

// node_modules/@coveo/headless/dist/esm/app/reducer-manager.js
function createReducerManager(initialReducers, preloadedState) {
  const reducers = { ...initialReducers };
  let crossReducer;
  const rootReducer = (combined) => {
    return (state, action) => {
      const intermediate = combined(state, action);
      const final = crossReducer ? crossReducer(intermediate, action) : intermediate;
      return final;
    };
  };
  return {
    get combinedReducer() {
      const placeholderReducers = fromEntries(Object.entries(preloadedState).filter(([key]) => !(key in reducers)).map(([key, value]) => [key, () => value]));
      return rootReducer(combineReducers({ ...placeholderReducers, ...reducers }));
    },
    containsAll(newReducers) {
      const keys2 = Object.keys(newReducers);
      return keys2.every((key) => key in reducers);
    },
    add(newReducers) {
      Object.keys(newReducers).filter((key) => !(key in reducers)).forEach((key) => {
        reducers[key] = newReducers[key];
      });
    },
    addCrossReducer(reducer) {
      crossReducer = reducer;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/jwt-utils.js
function parseJWT(token) {
  if (!token || !isJWTToken(token)) {
    return null;
  }
  try {
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const base64decoded = atob(base64);
    const jsonPayload = decodeURIComponent(base64decoded.split("").map((character) => {
      return `%${`00${character.charCodeAt(0).toString(16)}`.slice(-2)}`;
    }).join(""));
    return JSON.parse(jsonPayload);
  } catch (_) {
    return null;
  }
}
function shouldRenewJWT(token, bufferSeconds = 60) {
  if (!token) {
    return false;
  }
  const parsedToken = parseJWT(token);
  if (!parsedToken || typeof parsedToken.exp !== "number") {
    return false;
  }
  const nowSeconds = Math.floor(Date.now() / 1e3);
  return parsedToken.exp <= nowSeconds + bufferSeconds;
}
function isJWTToken(token) {
  if (!token) {
    return false;
  }
  return /^[A-Za-z0-9_-]{2,}(?:\.[A-Za-z0-9_-]{2,}){2}$/.test(token);
}

// node_modules/@coveo/headless/dist/esm/app/renew-access-token-middleware.js
function createRenewAccessTokenMiddleware(logger, renewToken) {
  let accessTokenRenewalsAttempts = 0;
  let pendingTokenRenewal = null;
  const resetRenewalTriesAfterDelay = debounce(() => {
    accessTokenRenewalsAttempts = 0;
  }, 500);
  const handleTokenRenewal = async (store, handleErrors = false) => {
    const isTokenRenewalPending = !pendingTokenRenewal;
    if (isTokenRenewalPending && renewToken) {
      pendingTokenRenewal = (async () => {
        if (handleErrors) {
          attempt(renewToken);
        }
        return await renewToken();
      })().finally(() => {
        pendingTokenRenewal = null;
      });
    }
    const accessToken = await pendingTokenRenewal;
    if (isTokenRenewalPending && accessToken) {
      store.dispatch(updateBasicConfiguration({ accessToken }));
    }
    return accessToken;
  };
  const handleProactiveTokenRenewal = async (store) => {
    const state = store.getState();
    const accessToken = getAccessTokenFromState(state);
    if (!accessToken || !shouldRenewJWT(accessToken)) {
      return;
    }
    logger.debug("Access token is expired or about to expire, attempting renewal.");
    try {
      const newAccessToken = await handleTokenRenewal(store);
      if (newAccessToken) {
        logger.debug("Access token was renewed.");
      } else {
        logger.warn("Access token renewal returned an empty token. Please check the #renewAccessToken function.");
      }
    } catch (error) {
      logger.warn(error, "Access token renewal failed. A retry will occur if necessary.");
    }
  };
  const handleExpiredToken = async (store, payload, action) => {
    if (accessTokenRenewalsAttempts >= 5) {
      logger.warn("Attempted to renew the token but was not successful. Please check the #renewAccessToken function.");
      dispatchError(store, payload.error);
      return payload;
    }
    accessTokenRenewalsAttempts++;
    resetRenewalTriesAfterDelay();
    await handleTokenRenewal(store, true);
    store.dispatch(action);
    return;
  };
  return (store) => (next) => async (action) => {
    const isThunk = typeof action === "function";
    const hasRenewFunction = typeof renewToken === "function";
    if (!isThunk) {
      return next(action);
    }
    if (hasRenewFunction) {
      await handleProactiveTokenRenewal(store);
    }
    const payload = await next(action);
    if (!isExpiredTokenError(payload)) {
      return payload;
    }
    if (!hasRenewFunction) {
      logger.warn("Unable to renew the expired token because a renew function was not provided. Please specify the #renewAccessToken option when initializing the engine.");
      dispatchError(store, payload.error);
      return payload;
    }
    return await handleExpiredToken(store, payload, action);
  };
}
function isExpiredTokenError(action) {
  var _a;
  return typeof action === "object" && action !== null && "error" in action && // biome-ignore lint/suspicious/noExplicitAny: any action is possible here.
  ((_a = action.error) == null ? void 0 : _a.name) === new UnauthorizedTokenError().name;
}
function dispatchError(store, error) {
  store.dispatch(setError({
    status: 401,
    statusCode: 401,
    message: error.message,
    type: error.name
  }));
}
async function attempt(fn) {
  try {
    return await fn();
  } catch (_) {
    return "";
  }
}
function getAccessTokenFromState(state) {
  return state.configuration.accessToken;
}

// node_modules/@coveo/headless/dist/esm/app/state-key.js
var stateKeyDescription = "coveo-headless-internal-state";
var stateKey = Symbol.for(stateKeyDescription);

// node_modules/@coveo/headless/dist/esm/app/store.js
function configureStore2({ reducer, preloadedState, middlewares = [], thunkExtraArguments, name }) {
  return configureStore({
    reducer,
    preloadedState,
    devTools: {
      stateSanitizer: (state) => state.history ? { ...state, history: "<<OMIT>>" } : state,
      name,
      shouldHotReload: false
      // KIT-961 -> Redux dev tool + hot reloading interacts badly with replaceReducers mechanism.
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ thunk: { extraArgument: thunkExtraArguments } }).prepend(...middlewares).concat(logActionMiddleware(thunkExtraArguments.logger))
  });
}

// node_modules/@coveo/headless/dist/esm/app/engine.js
function getUpdateAnalyticsConfigurationPayload(configuration2, logger) {
  const { analytics } = configuration2;
  const { analyticsClientMiddleware: _, ...payload } = analytics ?? {};
  const payloadWithURL = {
    ...payload,
    ...(analytics == null ? void 0 : analytics.proxyBaseUrl) && {
      apiBaseUrl: analytics.proxyBaseUrl,
      nexApiBaseUrl: analytics.proxyBaseUrl
    }
  };
  if (payloadWithURL.analyticsMode !== "next" && doNotTrack()) {
    logger.info("Analytics disabled since doNotTrack is active.");
    return {
      ...payloadWithURL,
      enabled: false
    };
  }
  return payloadWithURL;
}
function buildEngine(options, thunkExtraArguments) {
  const reducers = {
    ...options.reducers,
    configuration,
    version: versionReducer
  };
  const engine = buildCoreEngine({ ...options, reducers }, thunkExtraArguments, configuration);
  const { accessToken, environment, organizationId } = options.configuration;
  engine.dispatch(updateBasicConfiguration({
    accessToken,
    environment,
    organizationId
  }));
  const analyticsPayload = getUpdateAnalyticsConfigurationPayload(options.configuration, engine.logger);
  if (analyticsPayload) {
    engine.dispatch(updateAnalyticsConfiguration(analyticsPayload));
  }
  return engine;
}
function buildCoreEngine(options, thunkExtraArguments, configurationReducer2) {
  const { reducers, navigatorContextProvider } = options;
  const reducerManager = createReducerManager({ ...reducers, configurationReducer: configurationReducer2 }, options.preloadedState ?? {});
  if (options.crossReducer) {
    reducerManager.addCrossReducer(options.crossReducer);
  }
  const logger = thunkExtraArguments.logger;
  const thunkExtraArgumentsWithRelay = {
    ...thunkExtraArguments,
    get relay() {
      return getRelayInstanceFromState(engine.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    }
  };
  const store = createStore2(options, thunkExtraArgumentsWithRelay, reducerManager);
  const engine = {
    addReducers(reducers2) {
      if (reducerManager.containsAll(reducers2)) {
        return;
      }
      reducerManager.add(reducers2);
      store.replaceReducer(reducerManager.combinedReducer);
    },
    dispatch: store.dispatch,
    subscribe: store.subscribe,
    enableAnalytics() {
      store.dispatch(enableAnalytics());
    },
    disableAnalytics() {
      store.dispatch(disableAnalytics());
    },
    get state() {
      return store.getState();
    },
    get relay() {
      return getRelayInstanceFromState(this.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    },
    logger,
    store
  };
  return engine;
}
function createStore2(options, thunkExtraArguments, reducerManager) {
  const { preloadedState, configuration: configuration2 } = options;
  const name = configuration2.name || "coveo-headless";
  const middlewares = createMiddleware(options, thunkExtraArguments.logger);
  return configureStore2({
    preloadedState,
    reducer: reducerManager.combinedReducer,
    middlewares,
    thunkExtraArguments,
    name
  });
}
function createMiddleware(options, logger) {
  const { renewAccessToken } = options.configuration;
  const renewTokenMiddleware = createRenewAccessTokenMiddleware(logger, renewAccessToken);
  return [
    instantlyCallableThunkActionMiddleware,
    renewTokenMiddleware,
    logActionErrorMiddleware(logger),
    analyticsMiddleware
  ].concat(answerApi.middleware, answerGenerationApi.middleware, generateAnswerListener.middleware, options.middlewares || []);
}
var nextAnalyticsUsageWithServiceFeatureWarning = '[Warning] A component from the Coveo Headless library has been instantiated with the Analytics Mode: "Next".\nHowever, this mode is not available for Coveo for Service features, and this configuration may not work as expected.\nPlease switch back to the "legacy" analytics mode to ensure proper functionality.\nFor more information, refer to the documentation: https://docs.coveo.com/en/o3r90189/build-a-search-ui/event-protocol';
function warnIfUsingNextAnalyticsModeForServiceFeature(analyticsMode) {
  if (analyticsMode === "next") {
    console.warn(nextAnalyticsUsageWithServiceFeatureWarning);
  }
}

// node_modules/@coveo/headless/dist/esm/app/logger.js
var import_pino = __toESM(require_browser(), 1);
function buildLogger(options) {
  return (0, import_pino.pino)({
    name: "@coveo/headless",
    level: (options == null ? void 0 : options.level) || "warn",
    formatters: {
      log: options == null ? void 0 : options.logFormatter
    }
  });
}

// node_modules/@coveo/headless/dist/esm/app/thunk-extra-arguments.js
function buildThunkExtraArguments(configuration2, logger) {
  const analyticsClientMiddleware = getAnalyticsClientMiddleware(configuration2);
  const validatePayload2 = validatePayloadAndThrow;
  const preprocessRequest = getPreprocessRequest(configuration2);
  return {
    analyticsClientMiddleware,
    validatePayload: validatePayload2,
    preprocessRequest,
    logger
  };
}
function getAnalyticsClientMiddleware(configuration2) {
  const { analytics } = configuration2;
  const NoopAnalyticsMiddleware = (_, p) => p;
  return (analytics == null ? void 0 : analytics.analyticsClientMiddleware) || NoopAnalyticsMiddleware;
}
function getPreprocessRequest(configuration2) {
  return configuration2.preprocessRequest || NoopPreprocessRequest;
}

// node_modules/@coveo/headless/dist/esm/app/search-engine/jwt-reducer.js
var possiblyWarnOnMismatch = (token, tokenProp, stateProp, defaultProp, payload, logger) => {
  const tokenValue = token[tokenProp];
  if (isNullOrUndefined(tokenValue)) {
    return;
  }
  if (isNullOrUndefined(payload)) {
    return;
  }
  if (payload === tokenValue) {
    return;
  }
  if (payload === defaultProp) {
    return;
  }
  logger.warn(`Mismatch on access token (JWT Token) ${tokenProp} and engine configuration.`);
  logger.warn(`To remove this warning, make sure that access token value [${tokenValue}] matches engine configuration value [${stateProp}]`);
};
var shouldReconcileValues = (tokenValue, stateValue) => {
  if (isNullOrUndefined(tokenValue)) {
    return false;
  }
  if (stateValue === tokenValue) {
    return false;
  }
  return true;
};
var decodeJSONWebToken = (token) => {
  const parsed = parseJWT(token);
  return parsed ? parsed : false;
};
var updateSearchHub = (jwt, state) => {
  if (shouldReconcileValues(jwt.searchHub, state.searchHub)) {
    state.searchHub = jwt.searchHub;
  }
  return state;
};
var handleMismatchOnSearchHub = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(jwt, "searchHub", state.searchHub, getSearchHubInitialState(), payload, logger);
  return updateSearchHub(jwt, state);
};
var updatePipeline = (jwt, state) => {
  if (shouldReconcileValues(jwt.pipeline, state.pipeline)) {
    state.pipeline = jwt.pipeline;
  }
  return state;
};
var handleMismatchOnPipeline = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(jwt, "pipeline", state.pipeline, getPipelineInitialState(), payload, logger);
  return updatePipeline(jwt, state);
};
var updateUserDisplayName = (jwt, state) => {
  if (shouldReconcileValues(jwt.userDisplayName, state.configuration.analytics.userDisplayName)) {
    state.configuration.analytics.userDisplayName = jwt.userDisplayName;
  }
  return state;
};
var handleMismatchOnUserDisplayName = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(jwt, "userDisplayName", state.configuration.analytics.userDisplayName, getConfigurationInitialState().analytics.userDisplayName, payload, logger);
  return updateUserDisplayName(jwt, state);
};
var jwtReducer = (logger) => {
  return createReducer({}, (builder) => {
    builder.addCase(setSearchHub, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnSearchHub(jwt, state, action.payload, logger);
    }).addCase(setPipeline, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnPipeline(jwt, state, action.payload, logger);
    }).addCase(updateBasicConfiguration, (state, action) => {
      if (state.configuration.accessToken !== action.payload.accessToken) {
        return state;
      }
      const { accessToken } = action.payload;
      if (!accessToken) {
        return state;
      }
      const jwt = decodeJSONWebToken(accessToken);
      if (!jwt) {
        return state;
      }
      return [updatePipeline, updateSearchHub, updateUserDisplayName].reduce((resultingState, updateProp) => updateProp(jwt, resultingState), state);
    }).addCase(updateSearchConfiguration, (state, action) => {
      var _a;
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      const searchHubReconciled = handleMismatchOnSearchHub(jwt, state, action.payload.searchHub, logger);
      const pipelineReconciled = handleMismatchOnPipeline(jwt, searchHubReconciled, (_a = action.payload) == null ? void 0 : _a.pipeline, logger);
      return pipelineReconciled;
    }).addCase(updateAnalyticsConfiguration, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnUserDisplayName(jwt, state, action.payload.userDisplayName, logger);
    });
  });
};

// node_modules/@coveo/headless/dist/esm/app/engine-configuration.js
var engineConfigurationDefinitions = {
  organizationId: requiredNonEmptyString,
  accessToken: requiredNonEmptyString,
  name: new StringValue({
    required: false,
    emptyAllowed: false
  }),
  analytics: new RecordValue({
    options: {
      required: false
    },
    values: {
      enabled: new BooleanValue({
        required: false
      }),
      originContext: new StringValue({
        required: false
      }),
      originLevel2: new StringValue({
        required: false
      }),
      originLevel3: new StringValue({
        required: false
      }),
      analyticsMode: new StringValue({
        constrainTo: ["legacy", "next"],
        required: false,
        default: "next"
      }),
      proxyBaseUrl: new StringValue({
        required: false,
        url: true
      }),
      trackingId: new StringValue({
        required: false,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  environment: new StringValue({
    required: false,
    default: "prod",
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  })
};
function getSampleEngineConfiguration() {
  return {
    organizationId: "searchuisamples",
    // deepcode ignore HardcodedNonCryptoSecret: Public key freely available for our documentation
    accessToken: "xx564559b1-0045-48e1-953c-3addd1ee4457"
  };
}

// node_modules/@coveo/headless/dist/esm/app/search-engine/search-engine-configuration.js
var searchEngineConfigurationSchema = new Schema({
  ...engineConfigurationDefinitions,
  search: new RecordValue({
    options: {
      required: false
    },
    values: {
      pipeline: new StringValue({ required: false, emptyAllowed: true }),
      searchHub: nonEmptyString,
      locale: nonEmptyString,
      timezone: nonEmptyString,
      authenticationProviders: new ArrayValue({
        required: false,
        each: requiredNonEmptyString
      }),
      proxyBaseUrl: new StringValue({ required: false, url: true })
    }
  })
});
function getSampleSearchEngineConfiguration() {
  return {
    ...getSampleEngineConfiguration(),
    search: {
      searchHub: "default"
    }
  };
}

// node_modules/@coveo/headless/dist/esm/app/search-engine/search-engine.js
var searchEngineReducers = { debug: debugReducer, pipeline: pipelineReducer, searchHub: searchHubReducer, search: searchReducer };
function getUpdateSearchConfigurationPayload(configuration2) {
  const { search, organizationId, environment } = configuration2;
  const apiBaseUrl = (search == null ? void 0 : search.proxyBaseUrl) ? search.proxyBaseUrl : getSearchApiBaseUrl(organizationId, environment);
  const payloadWithURL = {
    ...search,
    apiBaseUrl
  };
  return payloadWithURL;
}
function buildSearchEngine(options) {
  const logger = buildLogger(options.loggerOptions);
  const { configuration: configuration2 } = options;
  validateConfiguration(configuration2, logger);
  const searchAPIClient = createSearchAPIClient(configuration2, logger);
  const generatedAnswerClient = createGeneratedAnswerAPIClient(logger);
  const thunkArguments = {
    ...buildThunkExtraArguments(configuration2, logger),
    apiClient: searchAPIClient,
    streamingClient: generatedAnswerClient
  };
  const augmentedOptions = {
    ...options,
    reducers: searchEngineReducers,
    crossReducer: jwtReducer(logger)
  };
  const engine = buildEngine(augmentedOptions, thunkArguments);
  const search = getUpdateSearchConfigurationPayload(configuration2);
  if (search) {
    engine.dispatch(updateSearchConfiguration(search));
  }
  return {
    ...engine,
    get state() {
      return engine.state;
    },
    executeFirstSearch(analyticsEvent = logInterfaceLoad()) {
      if (firstSearchExecutedSelector(engine.state)) {
        return;
      }
      const action = executeSearch2({
        legacy: analyticsEvent,
        next: interfaceLoad()
      });
      engine.dispatch(action);
    },
    executeFirstSearchAfterStandaloneSearchBoxRedirect(analytics) {
      const { cause, metadata } = analytics;
      if (firstSearchExecutedSelector(engine.state)) {
        return;
      }
      const isOmniboxFromLink = metadata && cause === "omniboxFromLink";
      const action = executeSearch2({
        legacy: isOmniboxFromLink ? logOmniboxFromLink(metadata) : logSearchFromLink(),
        next: isOmniboxFromLink ? omniboxFromLink() : searchFromLink()
      });
      engine.dispatch(action);
    }
  };
}
function validateConfiguration(configuration2, logger) {
  try {
    searchEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error(error, "Search engine configuration error");
    throw error;
  }
}
function createSearchAPIClient(configuration2, logger) {
  const { search } = configuration2;
  return new SearchAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest,
    postprocessSearchResponseMiddleware: (search == null ? void 0 : search.preprocessSearchResponseMiddleware) || NoopPostprocessSearchResponseMiddleware,
    postprocessFacetSearchResponseMiddleware: (search == null ? void 0 : search.preprocessFacetSearchResponseMiddleware) || NoopPostprocessFacetSearchResponseMiddleware,
    postprocessQuerySuggestResponseMiddleware: (search == null ? void 0 : search.preprocessQuerySuggestResponseMiddleware) || NoopPostprocessQuerySuggestResponseMiddleware
  });
}
function createGeneratedAnswerAPIClient(logger) {
  return new GeneratedAnswerAPIClient({
    logger
  });
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-validate-payload.js
var facetValueDefinition = {
  value: requiredNonEmptyString,
  numberOfResults: new NumberValue({ min: 0 }),
  state: requiredNonEmptyString
};

// node_modules/@coveo/headless/dist/esm/features/facets/generic/facet-actions-validation.js
var facetIdDefinition = requiredNonEmptyString;

// node_modules/@coveo/headless/dist/esm/features/facets/automatic-facet-set/automatic-facet-set-actions.js
var numberOfValuesDefinition = new NumberValue({
  min: NUMBER_OF_VALUE_MINIMUM,
  default: NUMBER_OF_VALUE_DEFAULT,
  required: false
});
var desiredCountDefinition = new NumberValue({
  min: DESIRED_COUNT_MINIMUM,
  max: DESIRED_COUNT_MAXIMUM,
  default: DESIRED_COUNT_DEFAULT,
  required: false
});
var optionsSchema = {
  desiredCount: desiredCountDefinition,
  numberOfValues: numberOfValuesDefinition
};
var setOptions = createAction("automaticFacet/setOptions", (payload) => validatePayload(payload, optionsSchema));
var deselectAllAutomaticFacetValues = createAction("automaticFacet/deselectAll", (payload) => validatePayload(payload, facetIdDefinition));
var fieldDefinition = requiredNonEmptyString;
var toggleSelectAutomaticFacetValue = createAction("automaticFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  field: fieldDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
}));

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-validate-payload.js
var categoryFacetValueDefinition = {
  state: new Value({ required: true }),
  numberOfResults: new NumberValue({ required: true, min: 0 }),
  value: new StringValue({ required: true, emptyAllowed: true }),
  path: new ArrayValue({ required: true, each: requiredNonEmptyString }),
  moreValuesAvailable: new BooleanValue({ required: false })
};
function validateCategoryFacetValue(payload) {
  payload.children.forEach((child) => {
    validateCategoryFacetValue(child);
  });
  validatePayloadAndThrow({
    state: payload.state,
    numberOfResults: payload.numberOfResults,
    value: payload.value,
    path: payload.path,
    moreValuesAvailable: payload.moreValuesAvailable
  }, categoryFacetValueDefinition);
}

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-set-actions.js
var categoryFacetPayloadDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  delimitingCharacter: new StringValue({ required: false, emptyAllowed: true }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  basePath: new ArrayValue({ required: false, each: requiredNonEmptyString }),
  filterByBasePath: new BooleanValue({ required: false })
};
var registerCategoryFacet = createAction("categoryFacet/register", (payload) => validatePayload(payload, categoryFacetPayloadDefinition));
var toggleSelectCategoryFacetValue = createAction("categoryFacet/toggleSelectValue", (payload) => {
  try {
    validatePayloadAndThrow(payload.facetId, requiredNonEmptyString);
    validateCategoryFacetValue(payload.selection);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
var deselectAllCategoryFacetValues = createAction("categoryFacet/deselectAll", (payload) => validatePayload(payload, categoryFacetPayloadDefinition.facetId));
var updateCategoryFacetNumberOfValues = createAction("categoryFacet/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: categoryFacetPayloadDefinition.facetId,
  numberOfValues: categoryFacetPayloadDefinition.numberOfValues
}));
var updateCategoryFacetSortCriterion = createAction("categoryFacet/updateSortCriterion", (payload) => validatePayload(payload, {
  facetId: categoryFacetPayloadDefinition.facetId,
  criterion: new Value()
}));
var updateCategoryFacetBasePath = createAction("categoryFacet/updateBasePath", (payload) => validatePayload(payload, {
  facetId: categoryFacetPayloadDefinition.facetId,
  basePath: new ArrayValue({ each: requiredNonEmptyString })
}));

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-set-analytics-actions.js
var categoryFacetBreadcrumbPayloadDefinition = {
  categoryFacetId: facetIdDefinition,
  categoryFacetPath: new ArrayValue({
    required: true,
    each: requiredNonEmptyString
  })
};
var getCategoryFacetMetadata = (state, { categoryFacetId, categoryFacetPath }) => {
  const facet = state.categoryFacetSet[categoryFacetId];
  const categoryFacetField = facet == null ? void 0 : facet.request.field;
  const categoryFacetTitle = `${categoryFacetField}_${categoryFacetId}`;
  return {
    categoryFacetId,
    categoryFacetPath,
    categoryFacetField,
    categoryFacetTitle
  };
};
var logCategoryFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/categoryFacet/breadcrumb", (client, state) => {
  validatePayload(payload, categoryFacetBreadcrumbPayloadDefinition);
  return client.makeBreadcrumbFacet(getCategoryFacetMetadata(state, payload));
});
var categoryBreadcrumbFacet = () => ({
  actionCause: SearchPageEvents2.breadcrumbFacet
});

// node_modules/@coveo/headless/dist/esm/features/facet-options/facet-options-actions.js
var updateFacetOptions = createAction("facetOptions/update", (payload = { freezeFacetOrder: true }) => validatePayload(payload, {
  freezeFacetOrder: new BooleanValue({ required: false })
}));
var enableFacet = createAction("facetOptions/facet/enable", (payload) => validatePayload(payload, facetIdDefinition));
var disableFacet = createAction("facetOptions/facet/disable", (payload) => validatePayload(payload, facetIdDefinition));

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/generic/generic-facet-search-validate-payload.js
var facetSearchOptionsDefinition = {
  facetId: facetIdDefinition,
  captions: new RecordValue({ options: { required: false } }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  query: new StringValue({ required: false, emptyAllowed: true })
};

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/category/category-facet-search-actions.js
var categoryFacetSearchResultDefinition = {
  path: new ArrayValue({
    required: true,
    each: requiredNonEmptyString
  }),
  displayValue: requiredEmptyAllowedString,
  rawValue: requiredEmptyAllowedString,
  count: new NumberValue({ required: true, min: 0 })
};
var selectCategoryFacetSearchResult = createAction("categoryFacet/selectSearchResult", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  value: new RecordValue({ values: categoryFacetSearchResultDefinition })
}));
var registerCategoryFacetSearch = createAction("categoryFacetSearch/register", (payload) => validatePayload(payload, facetSearchOptionsDefinition));

// node_modules/@coveo/headless/dist/esm/features/facets/generic/facet-reducer-helpers.js
function handleFacetSortCriterionUpdate(state, payload) {
  var _a;
  const { facetId: facetId2, criterion } = payload;
  const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.sortCriteria = criterion;
}
function handleFacetDeselectAll(facetRequest) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetRequest.currentValues.map((value) => ({
    ...value,
    ...{ previousState: value.state !== "idle" ? value.state : void 0 },
    state: "idle"
  }));
  facetRequest.preventAutoSelect = true;
}
function handleFacetUpdateNumberOfValues(facetRequest, numberOfValues2) {
  if (!facetRequest) {
    return;
  }
  facetRequest.numberOfValues = numberOfValues2;
}

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-reducer-helpers.js
function handleCategoryFacetDeselectAll(state, facetId2) {
  const slice = state[facetId2];
  if (!slice) {
    return;
  }
  slice.request.numberOfValues = slice.initialNumberOfValues;
  slice.request.currentValues = [];
  slice.request.preventAutoSelect = true;
}
function selectPath(request, path, initialNumberOfValues) {
  request.currentValues = buildCurrentValuesFromPath(path, initialNumberOfValues);
  request.numberOfValues = path.length ? 1 : initialNumberOfValues;
  request.preventAutoSelect = true;
}
function buildCurrentValuesFromPath(path, retrieveCount) {
  if (!path.length) {
    return [];
  }
  const root = buildCategoryFacetValueRequest(path[0], retrieveCount);
  let curr = root;
  for (const segment of path.splice(1)) {
    const next = buildCategoryFacetValueRequest(segment, retrieveCount);
    curr.children.push(next);
    curr = next;
  }
  curr.state = "selected";
  curr.retrieveChildren = true;
  return [root];
}
function buildCategoryFacetValueRequest(value, retrieveCount) {
  return {
    value,
    retrieveCount,
    children: [],
    state: "idle",
    retrieveChildren: false
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-set-slice.js
var categoryFacetSetReducer = createReducer(getCategoryFacetSetInitialState(), (builder) => {
  builder.addCase(registerCategoryFacet, (state, action) => {
    const options = action.payload;
    const { facetId: facetId2 } = options;
    if (facetId2 in state) {
      return;
    }
    const request = buildCategoryFacetRequest(options);
    const initialNumberOfValues = request.numberOfValues;
    state[facetId2] = { request, initialNumberOfValues };
  }).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.categoryFacetSet) ?? state;
  }).addCase(restoreSearchParameters, (state, action) => {
    const cf = action.payload.cf || {};
    Object.keys(state).forEach((id) => {
      const request = state[id].request;
      const path = cf[id] || [];
      if (path.length || request.currentValues.length) {
        selectPath(request, path, state[id].initialNumberOfValues);
      }
    });
  }).addCase(updateCategoryFacetSortCriterion, (state, action) => {
    var _a;
    const { facetId: facetId2, criterion } = action.payload;
    const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!request) {
      return;
    }
    request.sortCriteria = criterion;
  }).addCase(updateCategoryFacetBasePath, (state, action) => {
    var _a;
    const { facetId: facetId2, basePath: basePath2 } = action.payload;
    const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!request) {
      return;
    }
    request.basePath = [...basePath2];
  }).addCase(toggleSelectCategoryFacetValue, (state, action) => {
    var _a;
    const { facetId: facetId2, selection, retrieveCount } = action.payload;
    const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!request) {
      return;
    }
    const { path } = selection;
    const pathToSelection = path.slice(0, path.length - 1);
    const children = ensurePathAndReturnChildren(request, pathToSelection, retrieveCount);
    if (children.length) {
      const lastSelectedParent = children[0];
      lastSelectedParent.retrieveChildren = true;
      lastSelectedParent.state = "selected";
      lastSelectedParent.previousState = "idle";
      lastSelectedParent.children = [];
      return;
    }
    const newParent = buildCategoryFacetValueRequest2(selection.value, retrieveCount);
    newParent.state = "selected";
    newParent.previousState = "idle";
    children.push(newParent);
    request.numberOfValues = 1;
  }).addCase(deselectAllCategoryFacetValues, (state, action) => {
    const facetId2 = action.payload;
    handleCategoryFacetDeselectAll(state, facetId2);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.keys(state).forEach((facetId2) => handleCategoryFacetDeselectAll(state, facetId2));
  }).addCase(updateFacetAutoSelection, (state, action) => Object.keys(state).forEach((facetId2) => {
    state[facetId2].request.preventAutoSelect = !action.payload.allow;
  })).addCase(updateCategoryFacetNumberOfValues, (state, action) => {
    var _a;
    const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
    const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!request) {
      return;
    }
    if (!request.currentValues.length) {
      return handleFacetUpdateNumberOfValues(request, numberOfValues2);
    }
    handleCategoryFacetNestedNumberOfValuesUpdate(state, action.payload);
  }).addCase(selectCategoryFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const facet = state[facetId2];
    if (!facet) {
      return;
    }
    const path = [...value.path, value.rawValue];
    selectPath(facet.request, path, facet.initialNumberOfValues);
  }).addCase(fetchFacetValues2.fulfilled, (state, action) => {
    handleCategoryFacetResponseUpdate(state, action.payload.response.facets);
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    handleCategoryFacetResponseUpdate(state, action.payload.response.facets);
  }).addCase(disableFacet, (state, action) => {
    handleCategoryFacetDeselectAll(state, action.payload);
  });
});
var defaultCategoryFacetOptions = {
  delimitingCharacter: ";",
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 5,
  sortCriteria: "occurrences",
  basePath: [],
  filterByBasePath: true,
  resultsMustMatch: "atLeastOneValue"
};
function ensurePathAndReturnChildren(request, path, retrieveCount) {
  let children = request.currentValues;
  for (const segment of path) {
    let parent = children[0];
    const missingParent = !parent;
    if (missingParent || segment !== parent.value) {
      parent = buildCategoryFacetValueRequest2(segment, retrieveCount);
      children.length = 0;
      children.push(parent);
    }
    parent.retrieveChildren = false;
    parent.previousState = void 0;
    parent.state = "idle";
    children = parent.children;
  }
  return children;
}
function buildCategoryFacetRequest(config) {
  return {
    ...defaultCategoryFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "hierarchical",
    ...config
  };
}
function buildCategoryFacetValueRequest2(value, retrieveCount) {
  return {
    value,
    state: "idle",
    children: [],
    retrieveChildren: true,
    retrieveCount
  };
}
function handleCategoryFacetResponseUpdate(state, facets) {
  facets.forEach((response) => {
    var _a;
    if (!isCategoryFacetResponse2(state, response)) {
      return;
    }
    const id = response.facetId;
    const request = (_a = state[id]) == null ? void 0 : _a.request;
    if (!request) {
      return;
    }
    const requestWasInvalid = isRequestInvalid(request, response);
    request.currentValues = requestWasInvalid ? [] : request.currentValues;
    request.preventAutoSelect = false;
  });
}
function handleCategoryFacetNestedNumberOfValuesUpdate(state, payload) {
  var _a;
  const { facetId: facetId2, numberOfValues: numberOfValues2 } = payload;
  let selectedValue = (_a = state[facetId2]) == null ? void 0 : _a.request.currentValues[0];
  if (!selectedValue) {
    return;
  }
  while (selectedValue.children.length && (selectedValue == null ? void 0 : selectedValue.state) !== "selected") {
    selectedValue = selectedValue.children[0];
  }
  selectedValue.retrieveCount = numberOfValues2;
}
function isCategoryFacetResponse2(state, response) {
  const id = response.facetId;
  return id in state;
}
function isRequestInvalid(request, response) {
  const requestParents = findActiveValueAncestry(request.currentValues);
  const responseParents = findActiveValueAncestry(response.values);
  return requestParents.length !== responseParents.length;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/_common/facet-option-definitions.js
var facetId = new StringValue({
  regex: /^[a-zA-Z0-9-_]+$/
});
var field = new StringValue({ required: true });
var basePath = new ArrayValue({
  each: new StringValue()
});
var delimitingCharacter = new StringValue();
var filterByBasePath = new BooleanValue();
var filterFacetCount = new BooleanValue();
var injectionDepth = new NumberValue({ min: 0 });
var numberOfValues = new NumberValue({ min: 1 });
var generateAutomaticRanges = new BooleanValue({
  required: true
});
var captions = new RecordValue();
var query = new StringValue();
var facetSearchOptionDefinitions = {
  captions,
  numberOfValues,
  query
};
var facetSearch = new RecordValue({
  values: facetSearchOptionDefinitions
});
var allowedValues = new RecordValue({
  options: { required: false },
  values: {
    type: new StringValue({
      constrainTo: ["simple"],
      emptyAllowed: false,
      required: true
    }),
    values: new ArrayValue({
      required: true,
      max: 25,
      each: new StringValue({ emptyAllowed: false, required: true })
    })
  }
});
var hasBreadcrumbs = new BooleanValue();
var customSort = new ArrayValue({
  min: 1,
  max: 25,
  required: false,
  each: new StringValue({ emptyAllowed: false, required: true })
});

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-actions.js
var facetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: new StringValue({ required: true, emptyAllowed: true }),
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  resultsMustMatch: new Value({ required: false }),
  allowedValues,
  customSort
};
var registerFacet = createAction("facet/register", (payload) => validatePayload(payload, facetRegistrationOptionsDefinition));
var toggleSelectFacetValue = createAction("facet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
}));
var toggleExcludeFacetValue = createAction("facet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
}));
var deselectAllFacetValues = createAction("facet/deselectAll", (payload) => validatePayload(payload, facetIdDefinition));
var updateFacetSortCriterion = createAction("facet/updateSortCriterion", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  criterion: new Value({ required: true })
}));
var updateFacetNumberOfValues = createAction("facet/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  numberOfValues: new NumberValue({ required: true, min: 1 })
}));
var updateFacetIsFieldExpanded = createAction("facet/updateIsFieldExpanded", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  isFieldExpanded: new BooleanValue({ required: true })
}));
var updateFreezeCurrentValues = createAction("facet/updateFreezeCurrentValues", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  freezeCurrentValues: new BooleanValue({ required: true })
}));

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-analytics-actions.js
var logFacetShowMore = (facetId2) => makeAnalyticsAction("analytics/facet/showMore", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const metadata = buildFacetBaseMetadata(facetId2, getStateNeededForFacetMetadata(state));
  return client.makeFacetShowMore(metadata);
});
var logFacetShowLess = (facetId2) => makeAnalyticsAction("analytics/facet/showLess", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const metadata = buildFacetBaseMetadata(facetId2, getStateNeededForFacetMetadata(state));
  return client.makeFacetShowLess(metadata);
});
var logFacetUpdateSort = (payload) => makeAnalyticsAction("analytics/facet/sortChange", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new Value({
      required: true
    })
  });
  const { facetId: facetId2, criterion } = payload;
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const base = buildFacetBaseMetadata(facetId2, stateForAnalytics);
  const metadata = { ...base, criteria: criterion };
  return client.makeFacetUpdateSort(metadata);
});
var logFacetClearAll = (facetId2) => makeAnalyticsAction("analytics/facet/reset", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetBaseMetadata(facetId2, stateForAnalytics);
  return client.makeFacetClearAll(metadata);
});
var logFacetSelect = (payload) => makeAnalyticsAction("analytics/facet/select", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetSelect(metadata);
});
var logFacetExclude = (payload) => makeAnalyticsAction("analytics/facet/exclude", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetExclude(metadata);
});
var logFacetDeselect = (payload) => makeAnalyticsAction("analytics/facet/deselect", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetDeselect(metadata);
});
var logFacetUnexclude = (payload) => makeAnalyticsAction("analytics/facet/unexclude", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetUnexclude(metadata);
});
var logFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/facet/breadcrumb", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const metadata = buildFacetSelectionChangeMetadata(payload, getStateNeededForFacetMetadata(state));
  return client.makeBreadcrumbFacet(metadata);
});
var facetClearAll = () => {
  return {
    actionCause: SearchPageEvents2.facetClearAll
  };
};
var facetSelect = () => ({
  actionCause: SearchPageEvents2.facetSelect
});
var facetExclude = () => ({
  actionCause: SearchPageEvents2.facetExclude
});
var facetDeselect = () => ({
  actionCause: SearchPageEvents2.facetDeselect
});
var facetUnexclude = () => ({
  actionCause: SearchPageEvents2.facetUnexclude
});
var breadcrumbFacet = () => ({
  actionCause: SearchPageEvents2.breadcrumbFacet
});

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/specific/specific-facet-search-actions.js
var selectFacetSearchResultPayloadDefinition = {
  facetId: facetIdDefinition,
  value: new RecordValue({
    values: {
      displayValue: requiredEmptyAllowedString,
      rawValue: requiredEmptyAllowedString,
      count: new NumberValue({ required: true, min: 0 })
    }
  })
};
var registerFacetSearch = createAction("facetSearch/register", (payload) => validatePayload(payload, facetSearchOptionsDefinition));
var updateFacetSearch = createAction("facetSearch/update", (payload) => validatePayload(payload, facetSearchOptionsDefinition));
var selectFacetSearchResult = createAction("facetSearch/toggleSelectValue", (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition));
var excludeFacetSearchResult = createAction("facetSearch/toggleExcludeValue", (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition));

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-slice.js
var facetSetReducer = createReducer(getFacetSetInitialState(), (builder) => {
  builder.addCase(registerFacet, (state, action) => {
    const { facetId: facetId2 } = action.payload;
    if (facetId2 in state) {
      return;
    }
    state[facetId2] = getFacetSetSliceInitialState(buildFacetRequest(action.payload));
  }).addCase(change.fulfilled, (_, action) => {
    if (!action.payload) {
      return;
    }
    if (Object.keys(action.payload.facetSet).length === 0) {
      return;
    }
    return action.payload.facetSet;
  }).addCase(restoreSearchParameters, (state, action) => {
    const f3 = action.payload.f || {};
    const fExcluded = action.payload.fExcluded || {};
    const facetIds = Object.keys(state);
    facetIds.forEach((id) => {
      const { request } = state[id];
      const selectedValues = f3[id] || [];
      const excludedValues = fExcluded[id] || [];
      const activeValueCount = selectedValues.length + excludedValues.length;
      const idleValues = request.currentValues.filter((facetValue) => !selectedValues.includes(facetValue.value) && !excludedValues.includes(facetValue.value));
      request.currentValues = [
        ...selectedValues.map(buildSelectedFacetValueRequest),
        ...excludedValues.map(buildExcludedFacetValueRequest),
        ...idleValues.map(restoreFacetValueToIdleState)
      ];
      request.preventAutoSelect = activeValueCount > 0;
      request.numberOfValues = Math.max(activeValueCount, request.numberOfValues);
    });
  }).addCase(toggleSelectFacetValue, (state, action) => {
    var _a;
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.currentValues.find((req) => req.value === selection.value);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    const isSelected = existingValue.state === "selected";
    existingValue.previousState = existingValue.state;
    existingValue.state = isSelected ? "idle" : "selected";
    facetRequest.freezeCurrentValues = true;
  }).addCase(toggleExcludeFacetValue, (state, action) => {
    var _a;
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.currentValues.find((req) => req.value === selection.value);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    const isExcluded = existingValue.state === "excluded";
    existingValue.previousState = existingValue.state;
    existingValue.state = isExcluded ? "idle" : "excluded";
    facetRequest.freezeCurrentValues = true;
  }).addCase(updateFreezeCurrentValues, (state, action) => {
    var _a;
    const { facetId: facetId2, freezeCurrentValues } = action.payload;
    const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.freezeCurrentValues = freezeCurrentValues;
  }).addCase(deselectAllFacetValues, (state, action) => {
    var _a;
    handleFacetDeselectAll((_a = state[action.payload]) == null ? void 0 : _a.request);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.values(state).filter((slice) => slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
  }).addCase(deselectAllNonBreadcrumbs, (state) => {
    Object.values(state).filter((slice) => !slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
  }).addCase(updateFacetAutoSelection, (state, action) => Object.values(state).forEach((slice) => {
    slice.request.preventAutoSelect = !action.payload.allow;
  })).addCase(updateFacetSortCriterion, (state, action) => {
    handleFacetSortCriterionUpdate(state, action.payload);
  }).addCase(updateFacetNumberOfValues, (state, action) => {
    var _a;
    const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
    handleFacetUpdateNumberOfValues((_a = state[facetId2]) == null ? void 0 : _a.request, numberOfValues2);
  }).addCase(updateFacetIsFieldExpanded, (state, action) => {
    var _a;
    const { facetId: facetId2, isFieldExpanded } = action.payload;
    const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.isFieldExpanded = isFieldExpanded;
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    facets.forEach((facetResponse) => {
      var _a;
      return mutateStateFromFacetResponse((_a = state[facetResponse.facetId]) == null ? void 0 : _a.request, facetResponse);
    });
  }).addCase(fetchFacetValues2.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    facets.forEach((facetResponse) => {
      var _a;
      return mutateStateFromFacetResponse((_a = state[facetResponse.facetId]) == null ? void 0 : _a.request, facetResponse);
    });
  }).addCase(selectFacetSearchResult, (state, action) => {
    var _a;
    const { facetId: facetId2, value } = action.payload;
    const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    const { rawValue } = value;
    const { currentValues } = facetRequest;
    const matchingValue = currentValues.find((v) => v.value === rawValue);
    if (matchingValue) {
      matchingValue.state = "selected";
      return;
    }
    const searchResultValue = buildSelectedFacetValueRequest(rawValue);
    insertNewValue(facetRequest, searchResultValue);
    facetRequest.freezeCurrentValues = true;
    facetRequest.preventAutoSelect = true;
  }).addCase(excludeFacetSearchResult, (state, action) => {
    var _a;
    const { facetId: facetId2, value } = action.payload;
    const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    const { rawValue } = value;
    const { currentValues } = facetRequest;
    const matchingValue = currentValues.find((v) => v.value === rawValue);
    if (matchingValue) {
      matchingValue.state = "excluded";
      return;
    }
    const searchResultValue = buildExcludedFacetValueRequest(rawValue);
    insertNewValue(facetRequest, searchResultValue);
    facetRequest.freezeCurrentValues = true;
    facetRequest.preventAutoSelect = true;
  }).addCase(disableFacet, (state, action) => {
    if (!(action.payload in state)) {
      return;
    }
    const { request } = state[action.payload];
    handleFacetDeselectAll(request);
  });
});
function insertNewValue(facetRequest, facetValue) {
  const { currentValues } = facetRequest;
  const firstIdleIndex = currentValues.findIndex((v) => v.state === "idle");
  const indexToInsertAt = firstIdleIndex === -1 ? currentValues.length : firstIdleIndex;
  facetRequest.currentValues.splice(indexToInsertAt, 0, facetValue);
  if (firstIdleIndex > -1) {
    facetRequest.currentValues.pop();
  }
  facetRequest.numberOfValues = facetRequest.currentValues.length;
}
function mutateStateFromFacetResponse(facetRequest, facetResponse) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetResponse.values.map(convertFacetValueToRequest);
  facetRequest.freezeCurrentValues = false;
  facetRequest.preventAutoSelect = false;
}
var defaultFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "automatic",
  resultsMustMatch: "atLeastOneValue"
};
function buildFacetRequest(config) {
  return {
    ...defaultFacetOptions,
    type: "specific",
    currentValues: [],
    freezeCurrentValues: false,
    isFieldExpanded: false,
    preventAutoSelect: false,
    ...config
  };
}
function convertFacetValueToRequest(facetValue) {
  const { value, state } = facetValue;
  return { value, state };
}
function buildSelectedFacetValueRequest(value) {
  return { value, state: "selected" };
}
function buildExcludedFacetValueRequest(value) {
  return { value, state: "excluded" };
}
function restoreFacetValueToIdleState(facetValue) {
  return { ...facetValue, state: "idle" };
}

// node_modules/@coveo/headless/dist/esm/features/facets/generic/facet-generic-analytics-actions.js
var logClearBreadcrumbs = () => makeAnalyticsAction("analytics/facet/deselectAllBreadcrumbs", (client) => {
  return client.makeBreadcrumbResetAll();
});

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/date-facet/date-range.js
function buildDateRange(config) {
  const start = buildDate(config.start, config);
  const end = buildDate(config.end, config);
  const endInclusive = config.endInclusive ?? false;
  const state = config.state ?? "idle";
  return {
    start,
    end,
    endInclusive,
    state
  };
}
function buildDate(rawDate, options) {
  const { dateFormat } = options;
  if (isRelativeDate(rawDate)) {
    validateRelativeDate(rawDate);
    return serializeRelativeDate(rawDate);
  }
  if (typeof rawDate === "string" && isRelativeDateFormat(rawDate)) {
    validateRelativeDate(rawDate);
    return rawDate;
  }
  validateAbsoluteDate(rawDate, dateFormat);
  return formatDateForSearchApi(parseDate(rawDate, dateFormat));
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/range-facet-actions.js
var updateRangeFacetSortCriterion = createAction("rangeFacet/updateSortCriterion", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  criterion: new Value({ required: true })
}));

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/range-facet-validate-payload.js
var numericFacetValueDefinition = {
  state: requiredNonEmptyString,
  start: new NumberValue({ required: true }),
  end: new NumberValue({ required: true }),
  endInclusive: new BooleanValue({ required: true }),
  numberOfResults: new NumberValue({ required: true, min: 0 })
};
var dateFacetValueDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new BooleanValue({ required: true }),
  state: requiredNonEmptyString,
  numberOfResults: new NumberValue({ required: true, min: 0 })
};
var rangeFacetSelectionPayloadDefinition = (selection) => ({
  facetId: facetIdDefinition,
  selection: typeof selection.start === "string" ? new RecordValue({ values: dateFacetValueDefinition }) : new RecordValue({ values: numericFacetValueDefinition })
});

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-actions.js
var dateRangeRequestDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new BooleanValue({ required: true }),
  state: requiredNonEmptyString
};
var dateFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  currentValues: new ArrayValue({
    required: false,
    each: new RecordValue({ values: dateRangeRequestDefinition })
  }),
  generateAutomaticRanges: new BooleanValue({ required: true }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  rangeAlgorithm: new Value({ required: false })
};
function getAbsoluteDate(date) {
  return isRelativeDateFormat(date) ? formatRelativeDateForSearchApi(date) : date;
}
function validateManualDateRanges(options) {
  if (!options.currentValues) {
    return;
  }
  options.currentValues.forEach((value) => {
    const { start, end } = buildDateRange(value);
    if (parseDate(getAbsoluteDate(start)).isAfter(parseDate(getAbsoluteDate(end)))) {
      throw new Error(`The start value is greater than the end value for the date range ${value.start} to ${value.end}`);
    }
  });
}
var registerDateFacet = createAction("dateFacet/register", (payload) => {
  try {
    validatePayloadAndThrow(payload, dateFacetRegistrationOptionsDefinition);
    validateManualDateRanges(payload);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
var toggleSelectDateFacetValue = createAction("dateFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: dateFacetValueDefinition })
}));
var toggleExcludeDateFacetValue = createAction("dateFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: dateFacetValueDefinition })
}));
var updateDateFacetValues = createAction("dateFacet/updateFacetValues", (payload) => {
  try {
    validatePayloadAndThrow(payload, {
      facetId: facetIdDefinition,
      values: new ArrayValue({
        each: new RecordValue({ values: dateFacetValueDefinition })
      })
    });
    validateManualDateRanges({ currentValues: payload.values });
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
var updateDateFacetSortCriterion = updateRangeFacetSortCriterion;
var deselectAllDateFacetValues = deselectAllFacetValues;

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/range-facet-analytics-actions.js
var getRangeFacetMetadata = (state, { facetId: facetId2, selection }) => {
  const facet = state.dateFacetSet[facetId2] || state.numericFacetSet[facetId2];
  const facetField = facet.request.field;
  const facetTitle = `${facetField}_${facetId2}`;
  return {
    facetId: facetId2,
    facetField,
    facetTitle,
    facetRangeEndInclusive: selection.endInclusive,
    facetRangeEnd: `${selection.end}`,
    facetRangeStart: `${selection.start}`
  };
};
var rangeBreadcrumbFacet = () => ({
  actionCause: SearchPageEvents2.breadcrumbFacet
});

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-analytics-actions.js
var logDateFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/dateFacet/breadcrumb", (client, state) => {
  validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection));
  const metadata = getRangeFacetMetadata(state, payload);
  return client.makeBreadcrumbFacet(metadata);
});
var dateBreadcrumbFacet = rangeBreadcrumbFacet;

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-selectors.js
function isDateFacetResponse2(state, response) {
  return !!response && response.facetId in state.dateFacetSet;
}
var dateFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isDateFacetResponse2(state, response)) {
    return response;
  }
  return void 0;
};
var dateFacetSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = dateFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state === "selected");
};
var dateFacetActiveValuesSelector = (state, facetId2) => {
  const facetResponse = dateFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state !== "idle");
};

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/range-facet-reducers.js
var defaultRangeFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "ascending",
  rangeAlgorithm: "even",
  resultsMustMatch: "atLeastOneValue"
};
function registerRangeFacet(state, slice) {
  const { request } = slice;
  const { facetId: facetId2 } = request;
  if (facetId2 in state) {
    return;
  }
  const numberOfValues2 = calculateNumberOfValues(request);
  request.numberOfValues = numberOfValues2;
  state[facetId2] = slice;
}
function updateRangeValues(state, facetId2, values) {
  var _a;
  const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
  if (!request) {
    return;
  }
  request.currentValues = values;
  request.numberOfValues = calculateNumberOfValues(request);
}
function toggleSelectRangeValue(state, facetId2, selection) {
  var _a;
  const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isSelected = value.state === "selected";
  value.previousState = value.state;
  value.state = isSelected ? "idle" : "selected";
  request.preventAutoSelect = true;
}
function toggleExcludeRangeValue(state, facetId2, selection) {
  var _a;
  const request = (_a = state[facetId2]) == null ? void 0 : _a.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isExcluded = value.state === "excluded";
  value.previousState = value.state;
  value.state = isExcluded ? "idle" : "excluded";
  request.preventAutoSelect = true;
}
function handleRangeFacetDeselectAll(state, facetId2) {
  var _a;
  const facetRequest = (_a = state[facetId2]) == null ? void 0 : _a.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues.forEach((request) => {
    if (request.state !== "idle") {
      request.previousState = request.state;
    }
    request.state = "idle";
  });
}
function handleRangeFacetSearchParameterRestoration(state, rangeFacets) {
  Object.entries(state).forEach(([facetId2, { request }]) => {
    const rangesToSelect = rangeFacets[facetId2] || [];
    request.currentValues.forEach((range) => {
      const found = !!findRange(rangesToSelect, range);
      if (found) {
        range.state = "selected";
      }
      return range;
    });
    const missingRanges = rangesToSelect.filter((range) => !findRange(request.currentValues, range));
    const currentValues = request.currentValues;
    currentValues.push(...missingRanges);
    request.numberOfValues = Math.max(request.numberOfValues, currentValues.length);
  });
}
function onRangeFacetRequestFulfilled(state, facets, convert) {
  facets.forEach((facetResponse) => {
    var _a;
    const id = facetResponse.facetId;
    const facetRequest = (_a = state[id]) == null ? void 0 : _a.request;
    if (!facetRequest) {
      return;
    }
    const values = convert(facetResponse.values);
    facetRequest.currentValues = values;
    facetRequest.preventAutoSelect = false;
  });
}
function findRange(values, value) {
  const { start, end } = value;
  return values.find((range) => range.start === start && range.end === end);
}
function calculateNumberOfValues(request) {
  const { generateAutomaticRanges: generateAutomaticRanges2, currentValues, numberOfValues: numberOfValues2 } = request;
  return generateAutomaticRanges2 ? Math.max(numberOfValues2, currentValues.length) : currentValues.length;
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-set-slice.js
var dateFacetSetReducer = createReducer(getDateFacetSetInitialState(), (builder) => {
  builder.addCase(registerDateFacet, (state, action) => {
    const { payload } = action;
    const request = buildDateFacetRequest(payload);
    registerRangeFacet(state, getDateFacetSetSliceInitialState(request));
  }).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.dateFacetSet) ?? state;
  }).addCase(restoreSearchParameters, (state, action) => {
    const df = action.payload.df || {};
    handleRangeFacetSearchParameterRestoration(state, df);
  }).addCase(toggleSelectDateFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleSelectRangeValue(state, facetId2, selection);
  }).addCase(toggleExcludeDateFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleExcludeRangeValue(state, facetId2, selection);
  }).addCase(updateDateFacetValues, (state, action) => {
    const { facetId: facetId2, values } = action.payload;
    updateRangeValues(state, facetId2, values);
  }).addCase(deselectAllDateFacetValues, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.keys(state).forEach((facetId2) => {
      handleRangeFacetDeselectAll(state, facetId2);
    });
  }).addCase(updateDateFacetSortCriterion, (state, action) => {
    handleFacetSortCriterionUpdate(state, action.payload);
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    onRangeFacetRequestFulfilled(state, facets, convertToDateRangeRequests);
  }).addCase(disableFacet, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  });
});
function buildDateFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "dateRange",
    ...config
  };
}
function convertToDateRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-actions.js
var numericFacetRequestDefinition = {
  state: requiredNonEmptyString,
  start: new NumberValue({ required: true }),
  end: new NumberValue({ required: true }),
  endInclusive: new BooleanValue({ required: true })
};
var numericFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  currentValues: new ArrayValue({
    required: false,
    each: new RecordValue({ values: numericFacetRequestDefinition })
  }),
  generateAutomaticRanges: new BooleanValue({ required: true }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  rangeAlgorithm: new Value({ required: false })
};
function validateManualNumericRanges(options) {
  if (!options.currentValues) {
    return;
  }
  options.currentValues.forEach(({ start, end }) => {
    if (start > end) {
      throw new Error(`The start value is greater than the end value for the numeric range ${start} to ${end}`);
    }
  });
}
var registerNumericFacet = createAction("numericFacet/register", (payload) => {
  try {
    validatePayload(payload, numericFacetRegistrationOptionsDefinition);
    validateManualNumericRanges(payload);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
var toggleSelectNumericFacetValue = createAction("numericFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: numericFacetValueDefinition })
}));
var toggleExcludeNumericFacetValue = createAction("numericFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: numericFacetValueDefinition })
}));
var updateNumericFacetValues = createAction("numericFacet/updateFacetValues", (payload) => {
  try {
    validatePayloadAndThrow(payload, {
      facetId: facetIdDefinition,
      values: new ArrayValue({
        each: new RecordValue({ values: numericFacetValueDefinition })
      })
    });
    validateManualNumericRanges({ currentValues: payload.values });
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
var updateNumericFacetSortCriterion = updateRangeFacetSortCriterion;
var deselectAllNumericFacetValues = deselectAllFacetValues;

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-analytics-actions.js
var logNumericFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/numericFacet/breadcrumb", (client, state) => {
  validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection));
  const metadata = getRangeFacetMetadata(state, payload);
  return client.makeBreadcrumbFacet(metadata);
});
var numericBreadcrumbFacet = rangeBreadcrumbFacet;

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-selectors.js
function isNumericFacetResponse(state, response) {
  return !!response && response.facetId in state.numericFacetSet;
}
var numericFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isNumericFacetResponse(state, response)) {
    return response;
  }
  return void 0;
};
var numericFacetActiveValuesSelector = (state, facetId2) => {
  const facetResponse = numericFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state !== "idle");
};
var numericFacetSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = numericFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state === "selected");
};

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-set-slice.js
var numericFacetSetReducer = createReducer(getNumericFacetSetInitialState(), (builder) => {
  builder.addCase(registerNumericFacet, (state, action) => {
    const { payload } = action;
    const request = buildNumericFacetRequest(payload);
    registerRangeFacet(state, getNumericFacetSetSliceInitialState(request));
  }).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.numericFacetSet) ?? state;
  }).addCase(restoreSearchParameters, (state, action) => {
    const nf = action.payload.nf || {};
    handleRangeFacetSearchParameterRestoration(state, nf);
  }).addCase(toggleSelectNumericFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleSelectRangeValue(state, facetId2, selection);
  }).addCase(toggleExcludeNumericFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleExcludeRangeValue(state, facetId2, selection);
  }).addCase(updateNumericFacetValues, (state, action) => {
    const { facetId: facetId2, values } = action.payload;
    updateRangeValues(state, facetId2, values);
  }).addCase(deselectAllNumericFacetValues, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.keys(state).forEach((facetId2) => {
      handleRangeFacetDeselectAll(state, facetId2);
    });
  }).addCase(updateNumericFacetSortCriterion, (state, action) => {
    handleFacetSortCriterionUpdate(state, action.payload);
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    onRangeFacetRequestFulfilled(state, facets, convertToNumericRangeRequests);
  }).addCase(disableFacet, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  });
});
function buildNumericFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "numericalRange",
    ...config
  };
}
function convertToNumericRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}

// node_modules/@coveo/headless/dist/esm/features/static-filter-set/static-filter-set-schema.js
var staticFilterIdSchema = requiredNonEmptyString;
var staticFilterValueSchema = new RecordValue({
  options: { required: true },
  values: {
    caption: requiredEmptyAllowedString,
    expression: requiredEmptyAllowedString,
    state: new StringValue({
      constrainTo: ["idle", "selected", "excluded"]
    })
  }
});
var staticFilterValuesSchema = new ArrayValue({
  required: true,
  each: staticFilterValueSchema
});

// node_modules/@coveo/headless/dist/esm/features/static-filter-set/static-filter-set-actions.js
var registerStaticFilter = createAction("staticFilter/register", (payload) => {
  const schema = {
    id: staticFilterIdSchema,
    values: staticFilterValuesSchema
  };
  return validatePayload(payload, schema);
});
var toggleSelectStaticFilterValue = createAction("staticFilter/toggleSelect", (payload) => {
  const schema = {
    id: staticFilterIdSchema,
    value: staticFilterValueSchema
  };
  return validatePayload(payload, schema);
});
var toggleExcludeStaticFilterValue = createAction("staticFilter/toggleExclude", (payload) => {
  const schema = {
    id: staticFilterIdSchema,
    value: staticFilterValueSchema
  };
  return validatePayload(payload, schema);
});
var deselectAllStaticFilterValues = createAction("staticFilter/deselectAllFilterValues", (payload) => {
  return validatePayload(payload, staticFilterIdSchema);
});
var logStaticFilterSelect = (metadata) => makeAnalyticsAction("analytics/staticFilter/select", (client) => client.makeStaticFilterSelect(metadata));
var logStaticFilterDeselect = (metadata) => makeAnalyticsAction("analytics/staticFilter/deselect", (client) => client.makeStaticFilterDeselect(metadata));
var logStaticFilterClearAll = (metadata) => makeAnalyticsAction("analytics/staticFilter/clearAll", (client) => client.makeStaticFilterClearAll(metadata));

// node_modules/@coveo/headless/dist/esm/controllers/controller/headless-controller.js
function buildController(engine) {
  let prevState;
  const listeners = /* @__PURE__ */ new Map();
  const hasNoListeners = () => listeners.size === 0;
  const hasStateChanged = (currentState) => {
    try {
      const stringifiedState = JSON.stringify(currentState);
      const hasChanged = prevState !== stringifiedState;
      prevState = stringifiedState;
      return hasChanged;
    } catch (e) {
      console.warn('Could not detect if state has changed, check the controller "get state method"', e);
      return true;
    }
  };
  return {
    subscribe(listener2) {
      listener2();
      const symbol = Symbol();
      let unsubscribe;
      if (hasNoListeners()) {
        prevState = JSON.stringify(this.state);
        unsubscribe = engine.subscribe(() => {
          if (hasStateChanged(this.state)) {
            listeners.forEach((listener3) => listener3());
          }
        });
      }
      listeners.set(symbol, listener2);
      return () => {
        listeners.delete(symbol);
        if (hasNoListeners()) {
          unsubscribe == null ? void 0 : unsubscribe();
        }
      };
    },
    get state() {
      return {};
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/breadcrumb-manager/headless-core-breadcrumb-manager.js
var getBreadcrumbs = (config) => {
  return Object.keys(config.facetSet).map((facetId2) => {
    const values = config.facetValuesSelector(config.engine.state, facetId2).map((selection) => ({
      value: selection,
      deselect: () => {
        if (selection.state === "selected") {
          config.executeToggleSelect({ facetId: facetId2, selection });
        } else if (selection.state === "excluded") {
          config.executeToggleExclude({ facetId: facetId2, selection });
        }
      }
    }));
    return {
      facetId: facetId2,
      field: config.facetSet[facetId2].request.field,
      values
    };
  }).filter((breadcrumb) => breadcrumb.values.length);
};
function buildCoreBreadcrumbManager(engine) {
  const controller = buildController(engine);
  const { dispatch } = engine;
  return {
    ...controller,
    get state() {
      return {
        facetBreadcrumbs: [],
        categoryFacetBreadcrumbs: [],
        numericFacetBreadcrumbs: [],
        dateFacetBreadcrumbs: [],
        staticFilterBreadcrumbs: [],
        hasBreadcrumbs: false
      };
    },
    deselectAll: () => {
      dispatch(deselectAllBreadcrumbs());
    },
    deselectBreadcrumb(value) {
      value.deselect();
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/breadcrumb-manager/headless-breadcrumb-manager.js
function buildBreadcrumbManager(engine) {
  if (!loadBreadcrumbManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildCoreBreadcrumbManager(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().facetSet,
      executeToggleSelect: ({ facetId: facetId2, selection }) => {
        dispatch(toggleSelectFacetValue({ facetId: facetId2, selection }));
        dispatch(updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false }));
        dispatch(executeSearch2({
          legacy: logFacetBreadcrumb({
            facetId: facetId2,
            facetValue: selection.value
          }),
          next: breadcrumbFacet()
        }));
      },
      executeToggleExclude: ({ facetId: facetId2, selection }) => {
        dispatch(toggleExcludeFacetValue({ facetId: facetId2, selection }));
        dispatch(updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false }));
        dispatch(executeSearch2({
          legacy: logFacetBreadcrumb({
            facetId: facetId2,
            facetValue: selection.value
          }),
          next: breadcrumbFacet()
        }));
      },
      facetValuesSelector: facetResponseActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getNumericFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().numericFacetSet,
      executeToggleSelect: (payload) => {
        dispatch(toggleSelectNumericFacetValue(payload));
        dispatch(executeSearch2({
          legacy: logNumericFacetBreadcrumb(payload),
          next: numericBreadcrumbFacet()
        }));
      },
      executeToggleExclude: (payload) => {
        dispatch(toggleExcludeNumericFacetValue(payload));
        dispatch(executeSearch2({
          legacy: logNumericFacetBreadcrumb(payload),
          next: numericBreadcrumbFacet()
        }));
      },
      facetValuesSelector: numericFacetActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getDateFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().dateFacetSet,
      executeToggleSelect: (payload) => {
        dispatch(toggleSelectDateFacetValue(payload));
        dispatch(executeSearch2({
          legacy: logDateFacetBreadcrumb(payload),
          next: dateBreadcrumbFacet()
        }));
      },
      executeToggleExclude: (payload) => {
        dispatch(toggleExcludeDateFacetValue(payload));
        dispatch(executeSearch2({
          legacy: logDateFacetBreadcrumb(payload),
          next: dateBreadcrumbFacet()
        }));
      },
      facetValuesSelector: dateFacetActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getCategoryFacetBreadcrumbs = () => {
    return Object.keys(getState().categoryFacetSet).map(buildCategoryFacetBreadcrumb).filter((breadcrumb) => breadcrumb.path.length);
  };
  const buildCategoryFacetBreadcrumb = (facetId2) => {
    const path = categoryFacetResponseSelectedValuesSelector(getState(), facetId2);
    return {
      facetId: facetId2,
      field: getState().categoryFacetSet[facetId2].request.field,
      path,
      deselect: () => {
        dispatch(deselectAllCategoryFacetValues(facetId2));
        dispatch(executeSearch2({
          legacy: logCategoryFacetBreadcrumb({
            categoryFacetPath: path.map((categoryFacetValue) => categoryFacetValue.value),
            categoryFacetId: facetId2
          }),
          next: categoryBreadcrumbFacet()
        }));
      }
    };
  };
  const getStaticFilterBreadcrumbs = () => {
    const set2 = getState().staticFilterSet ?? {};
    return Object.values(set2).map(buildStaticFilterBreadcrumb);
  };
  const buildStaticFilterBreadcrumb = (filter) => {
    const { id, values: filterValues } = filter;
    const values = filterValues.filter((value) => value.state !== "idle").map((value) => buildStaticFilterBreadcrumbValue(id, value));
    return { id, values };
  };
  const buildStaticFilterBreadcrumbValue = (id, value) => {
    return {
      value,
      deselect: () => {
        const { caption, expression } = value;
        if (value.state === "selected") {
          dispatch(toggleSelectStaticFilterValue({ id, value }));
        } else if (value.state === "excluded") {
          dispatch(toggleExcludeStaticFilterValue({ id, value }));
        }
        dispatch(executeSearch2({
          legacy: logStaticFilterDeselect({
            staticFilterId: id,
            staticFilterValue: { caption, expression }
          })
        }));
      }
    };
  };
  const getAutomaticFacetBreadcrumbs = () => {
    var _a;
    const set2 = ((_a = getState().automaticFacetSet) == null ? void 0 : _a.set) ?? {};
    return Object.values(set2).map((slice) => buildAutomaticFacetBreadcrumb(slice.response)).filter((breadcrumb) => breadcrumb.values.length > 0);
  };
  const buildAutomaticFacetBreadcrumb = (response) => {
    const { field: field2, label } = response;
    const values = response.values.filter((value) => value.state !== "idle").map((value) => buildAutomaticFacetBreadcrumbValue(field2, value));
    return {
      facetId: field2,
      field: field2,
      label,
      values
    };
  };
  const buildAutomaticFacetBreadcrumbValue = (field2, selection) => {
    return {
      value: selection,
      deselect: () => {
        dispatch(toggleSelectAutomaticFacetValue({
          field: field2,
          selection
        }));
        dispatch(executeSearch2({
          legacy: logFacetBreadcrumb({
            facetId: field2,
            facetValue: selection.value
          }),
          next: breadcrumbFacet()
        }));
      }
    };
  };
  function hasBreadcrumbs2() {
    return !![
      ...getFacetBreadcrumbs(),
      ...getNumericFacetBreadcrumbs(),
      ...getDateFacetBreadcrumbs(),
      ...getCategoryFacetBreadcrumbs(),
      ...getStaticFilterBreadcrumbs(),
      ...getAutomaticFacetBreadcrumbs()
    ].length;
  }
  return {
    ...controller,
    get state() {
      return {
        facetBreadcrumbs: getFacetBreadcrumbs(),
        categoryFacetBreadcrumbs: getCategoryFacetBreadcrumbs(),
        numericFacetBreadcrumbs: getNumericFacetBreadcrumbs(),
        dateFacetBreadcrumbs: getDateFacetBreadcrumbs(),
        staticFilterBreadcrumbs: getStaticFilterBreadcrumbs(),
        automaticFacetBreadcrumbs: getAutomaticFacetBreadcrumbs(),
        hasBreadcrumbs: hasBreadcrumbs2()
      };
    },
    deselectAll: () => {
      controller.deselectAll();
      dispatch(executeSearch2({
        legacy: logClearBreadcrumbs(),
        next: { actionCause: SearchPageEvents2.breadcrumbResetAll }
      }));
    }
  };
}
function loadBreadcrumbManagerReducers(engine) {
  engine.addReducers({
    configuration,
    search: searchReducer,
    facetSet: facetSetReducer,
    numericFacetSet: numericFacetSetReducer,
    dateFacetSet: dateFacetSetReducer,
    categoryFacetSet: categoryFacetSetReducer
  });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/context/context-actions.js
var nonEmptyArray = new ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
var nonEmptyPayload = (contextKey, contextValue) => {
  validatePayload(contextKey, requiredNonEmptyString);
  if (isString(contextValue)) {
    validatePayload(contextValue, requiredNonEmptyString);
  } else {
    validatePayload(contextValue, nonEmptyArray);
  }
  return { payload: { contextKey, contextValue } };
};
var setContext = createAction("context/set", (payload) => {
  for (const [k, v] of Object.entries(payload)) {
    nonEmptyPayload(k, v);
  }
  return { payload };
});
var addContext = createAction("context/add", (payload) => nonEmptyPayload(payload.contextKey, payload.contextValue));
var removeContext = createAction("context/remove", (payload) => validatePayload(payload, requiredNonEmptyString));

// node_modules/@coveo/headless/dist/esm/features/context/context-slice.js
var contextReducer = createReducer(getContextInitialState(), (builder) => {
  builder.addCase(setContext, (state, action) => {
    state.contextValues = action.payload;
  }).addCase(addContext, (state, action) => {
    state.contextValues[action.payload.contextKey] = action.payload.contextValue;
  }).addCase(removeContext, (state, action) => {
    delete state.contextValues[action.payload];
  }).addCase(change.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    state.contextValues = action.payload.context.contextValues;
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/core/context/headless-context-reserved-keys.js
var ReservedContextKeys = ["caseId", "caseNumber"];
var ReservedContextKeysToControllerMap = {
  caseId: "caseContext",
  caseNumber: "caseContext"
};
var ReservedContextKeyError = class extends Error {
  constructor(key) {
    super(`The key "${key}" is reserved for internal use. Use ${ReservedContextKeysToControllerMap[key]} to set this value.}`);
  }
};
function isReservedContextKey(contextKey) {
  return ReservedContextKeys.includes(contextKey);
}

// node_modules/@coveo/headless/dist/esm/controllers/core/context/headless-core-context.js
var initialStateSchema = new Schema({
  values: new RecordValue({
    options: { required: false }
  })
});
function buildCoreContext(engine, props = {}) {
  if (!loadContextReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const initialState2 = validateInitialState(engine, initialStateSchema, props.initialState, "buildContext");
  if (initialState2.values) {
    dispatch(setContext(initialState2.values));
  }
  return {
    ...controller,
    get state() {
      return {
        values: getState().context.contextValues
      };
    },
    set(context) {
      dispatch(setContext(context));
    },
    ...getState().configuration.analytics.analyticsMode === "legacy" ? legacyCoreContext(dispatch) : nextCoreContext(dispatch)
  };
}
var legacyCoreContext = (dispatch) => ({
  add(contextKey, contextValue) {
    dispatch(addContext({ contextKey, contextValue }));
  },
  remove(key) {
    dispatch(removeContext(key));
  }
});
var nextCoreContext = (dispatch) => ({
  add(contextKey, contextValue) {
    if (isReservedContextKey(contextKey)) {
      throw new ReservedContextKeyError(contextKey);
    }
    dispatch(addContext({ contextKey, contextValue }));
  },
  remove(contextKey) {
    if (isReservedContextKey(contextKey)) {
      throw new ReservedContextKeyError(contextKey);
    }
    dispatch(removeContext(contextKey));
  }
});
function loadContextReducers(engine) {
  engine.addReducers({ context: contextReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/context/headless-context.js
function buildContext(engine, props) {
  return buildCoreContext(engine, props);
}

// node_modules/@coveo/headless/dist/esm/features/facet-options/facet-options-slice.js
var facetOptionsReducer = createReducer(getFacetOptionsInitialState(), (builder) => {
  builder.addCase(updateFacetOptions, (state, action) => {
    return { ...state, ...action.payload };
  }).addCase(executeSearch2.fulfilled, (state) => {
    state.freezeFacetOrder = false;
  }).addCase(executeSearch2.rejected, (state) => {
    state.freezeFacetOrder = false;
  }).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.facetOptions) ?? state;
  }).addCase(registerCategoryFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(registerFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(registerDateFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(registerNumericFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(enableFacet, (state, action) => {
    state.facets[action.payload].enabled = true;
  }).addCase(disableFacet, (state, action) => {
    state.facets[action.payload].enabled = false;
  }).addCase(restoreSearchParameters, (state, action) => {
    [
      ...Object.keys(action.payload.f ?? {}),
      ...Object.keys(action.payload.fExcluded ?? {}),
      ...Object.keys(action.payload.cf ?? {}),
      ...Object.keys(action.payload.nf ?? {}),
      ...Object.keys(action.payload.df ?? {})
    ].forEach((facetId2) => {
      if (!(facetId2 in state)) {
        state.facets[facetId2] = getFacetOptionsSliceInitialState();
      }
      state.facets[facetId2].enabled = true;
    });
  });
});
function handleRegisterFacetTabs(tabs, state, facetId2) {
  const newFacetState = {
    ...getFacetOptionsSliceInitialState(),
    tabs: tabs ?? {}
  };
  state.facets[facetId2] = newFacetState;
}

// node_modules/@coveo/headless/dist/esm/features/facet-options/facet-options-utils.js
var isFacetVisibleOnTab = (facetTabs, activeTab) => {
  var _a;
  if (typeof facetTabs === "object" && Object.keys({ ...facetTabs }).length === 0 || !activeTab || !facetTabs) {
    return true;
  }
  if ((_a = facetTabs.excluded) == null ? void 0 : _a.includes(activeTab)) {
    return false;
  }
  if (facetTabs.included && (facetTabs.included.length === 0 || facetTabs.included.includes(activeTab))) {
    return true;
  }
  return false;
};

// node_modules/@coveo/headless/dist/esm/features/tab-set/tab-set-slice.js
var tabSetReducer = createReducer(getTabSetInitialState(), (builder) => {
  builder.addCase(registerTab, (state, action) => {
    const tab = action.payload;
    const { id } = tab;
    if (id in state) {
      return;
    }
    state[id] = { ...tab, isActive: false };
  }).addCase(updateActiveTab, (state, action) => {
    const id = action.payload;
    activateTabIfIdExists(state, id);
  }).addCase(restoreTab, (state, action) => {
    const id = action.payload;
    activateTabIfIdExists(state, id);
  }).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.tabSet) ?? state;
  }).addCase(restoreSearchParameters, (state, action) => {
    const id = action.payload.tab;
    if (!isNullOrUndefined(id)) {
      Object.keys(state).forEach((tabId) => {
        state[tabId].isActive = tabId === id;
      });
    }
  });
});
function activateTabIfIdExists(state, id) {
  const hasId = id in state;
  if (!hasId) {
    return;
  }
  Object.keys(state).forEach((tabId) => {
    state[tabId].isActive = tabId === id;
  });
}

// node_modules/@coveo/headless/dist/esm/controllers/core/tab-manager/headless-core-tab-manager.js
function buildCoreTabManager(engine) {
  if (!loadTabReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const currentTab = createSelector((state) => state.tabSet, (state) => {
    const activeTab = Object.values(state).find((tab) => tab.isActive);
    return (activeTab == null ? void 0 : activeTab.id) ?? "";
  });
  return {
    ...controller,
    get state() {
      return { activeTab: currentTab(engine.state) };
    }
  };
}
function loadTabReducers(engine) {
  engine.addReducers({ tabSet: tabSetReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/facet-conditions-manager/headless-facet-conditions-manager.js
function buildCoreFacetConditionsManager(engine, props) {
  if (!loadFacetConditionsManagerReducers(engine)) {
    throw loadReducerError;
  }
  const tabManager = buildCoreTabManager(engine);
  const isFacetEnabled = (facetId2) => {
    var _a;
    return ((_a = engine.state.facetOptions.facets[facetId2]) == null ? void 0 : _a.enabled) ?? false;
  };
  const getFacetValuesById = (facetId2) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    return ((_c = (_b = (_a = engine.state.facetSet) == null ? void 0 : _a[facetId2]) == null ? void 0 : _b.request) == null ? void 0 : _c.currentValues) ?? ((_f = (_e = (_d = engine.state.categoryFacetSet) == null ? void 0 : _d[facetId2]) == null ? void 0 : _e.request) == null ? void 0 : _f.currentValues) ?? ((_i = (_h = (_g = engine.state.numericFacetSet) == null ? void 0 : _g[facetId2]) == null ? void 0 : _h.request) == null ? void 0 : _i.currentValues) ?? ((_l = (_k = (_j = engine.state.dateFacetSet) == null ? void 0 : _j[facetId2]) == null ? void 0 : _k.request) == null ? void 0 : _l.currentValues) ?? null;
  };
  const isFacetRegistered = (facetId2) => facetId2 in engine.state.facetOptions.facets;
  const selectTabSettings = (facetId2) => {
    var _a;
    return (_a = engine.state.facetOptions.facets[facetId2]) == null ? void 0 : _a.tabs;
  };
  const getRelevantStateHash = () => getObjectHash({
    isFacetRegistered: isFacetRegistered(props.facetId),
    parentFacets: props.conditions.map(({ parentFacetId }) => isFacetRegistered(parentFacetId) ? {
      enabled: isFacetEnabled(parentFacetId),
      values: getFacetValuesById(parentFacetId)
    } : null),
    isTabEnabled: isFacetVisibleOnTab(selectTabSettings(props.facetId), tabManager.state.activeTab)
  });
  const relevantStateHasChanged = () => {
    const newStateHash = getRelevantStateHash();
    if (newStateHash === relevantStateHash) {
      return false;
    }
    relevantStateHash = newStateHash;
    return true;
  };
  const areConditionsMet = () => {
    return props.conditions.length > 0 ? props.conditions.some((condition) => {
      if (!isFacetEnabled(condition.parentFacetId)) {
        return false;
      }
      const values = getFacetValuesById(condition.parentFacetId);
      if (values === null) {
        return false;
      }
      return condition.condition(values);
    }) : true;
  };
  const unfreezeFacetValues = () => {
    if (engine.state.facetSet) {
      Object.entries(engine.state.facetSet).forEach(([facetId2, slice]) => slice.request.freezeCurrentValues && engine.dispatch(updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false })));
    }
  };
  const ensureConditions = () => {
    if (!isFacetRegistered(props.facetId)) {
      return;
    }
    const isEnabled = isFacetEnabled(props.facetId);
    const conditionsMet = areConditionsMet();
    const isVisibleOnTab = isFacetVisibleOnTab(selectTabSettings(props.facetId), tabManager.state.activeTab);
    const shouldBeEnabled = conditionsMet && isVisibleOnTab;
    if (isEnabled !== shouldBeEnabled) {
      engine.dispatch(shouldBeEnabled ? enableFacet(props.facetId) : disableFacet(props.facetId));
      unfreezeFacetValues();
    }
  };
  let relevantStateHash = getRelevantStateHash();
  const unsubscribe = engine.subscribe(() => {
    if (relevantStateHasChanged()) {
      ensureConditions();
    }
  });
  ensureConditions();
  return {
    stopWatching() {
      unsubscribe();
    }
  };
}
function loadFacetConditionsManagerReducers(engine) {
  engine.addReducers({ facetOptions: facetOptionsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/dictionary-field-context/dictionary-field-context-actions.js
var setContext2 = createAction("dictionaryFieldContext/set", (payload) => {
  const objSchema = new RecordValue({ options: { required: true } });
  const objError = validatePayload(payload, objSchema).error;
  if (objError) {
    return { payload, error: objError };
  }
  const values = Object.values(payload);
  const valueSchema = new ArrayValue({ each: requiredEmptyAllowedString });
  const valuesError = validatePayload(values, valueSchema).error;
  if (valuesError) {
    return { payload, error: valuesError };
  }
  return { payload };
});
var addContext2 = createAction("dictionaryFieldContext/add", (payload) => {
  const schema = new RecordValue({
    options: { required: true },
    values: {
      field: requiredEmptyAllowedString,
      key: requiredEmptyAllowedString
    }
  });
  return validatePayload(payload, schema);
});
var removeContext2 = createAction("dictionaryFieldContext/remove", (payload) => {
  return validatePayload(payload, requiredEmptyAllowedString);
});

// node_modules/@coveo/headless/dist/esm/features/dictionary-field-context/dictionary-field-context-slice.js
var dictionaryFieldContextReducer = createReducer(getDictionaryFieldContextInitialState(), (builder) => {
  builder.addCase(setContext2, (state, action) => {
    state.contextValues = action.payload;
  }).addCase(addContext2, (state, action) => {
    const { field: field2, key } = action.payload;
    state.contextValues[field2] = key;
  }).addCase(removeContext2, (state, action) => {
    delete state.contextValues[action.payload];
  }).addCase(change.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    state.contextValues = action.payload.dictionaryFieldContext.contextValues;
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/dictionary-field-context/headless-dictionary-field-context.js
function buildDictionaryFieldContext(engine) {
  if (!loadReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      return {
        values: getState().dictionaryFieldContext.contextValues
      };
    },
    set(context) {
      dispatch(setContext2(context));
    },
    add(field2, key) {
      dispatch(addContext2({ field: field2, key }));
    },
    remove(field2) {
      dispatch(removeContext2(field2));
    }
  };
}
function loadReducers(engine) {
  engine.addReducers({ dictionaryFieldContext: dictionaryFieldContextReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-selectors.js
var hasQueryCorrectionSelector = (state) => state.queryCorrection.correctedQuery !== "" || state.wasCorrectedTo !== "";

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-state.js
var emptyLegacyCorrection = () => ({
  correctedQuery: "",
  wordCorrections: [],
  originalQuery: ""
});
var emptyNextCorrection = () => ({
  correctedQuery: "",
  corrections: [],
  originalQuery: ""
});
function getDidYouMeanInitialState() {
  return {
    enableDidYouMean: false,
    wasCorrectedTo: "",
    wasAutomaticallyCorrected: false,
    queryCorrection: emptyLegacyCorrection(),
    originalQuery: "",
    automaticallyCorrectQuery: true,
    queryCorrectionMode: "legacy"
  };
}

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-slice-functions.js
var setToNonEmptyQueryCorrection = (state, correction) => {
  var _a;
  const nonOptionalQueryCorrection = {
    ...emptyNextCorrection(),
    ...correction,
    correctedQuery: (correction == null ? void 0 : correction.correctedQuery) || ((_a = correction == null ? void 0 : correction.corrections[0]) == null ? void 0 : _a.correctedQuery) || ""
  };
  state.queryCorrection = nonOptionalQueryCorrection;
  state.wasCorrectedTo = nonOptionalQueryCorrection.correctedQuery;
};

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-slice.js
var didYouMeanReducer = createReducer(getDidYouMeanInitialState(), (builder) => {
  builder.addCase(enableDidYouMean, (state) => {
    state.enableDidYouMean = true;
  }).addCase(disableDidYouMean, (state) => {
    state.enableDidYouMean = false;
  }).addCase(enableAutomaticQueryCorrection, (state) => {
    state.automaticallyCorrectQuery = true;
  }).addCase(disableAutomaticQueryCorrection, (state) => {
    state.automaticallyCorrectQuery = false;
  }).addCase(executeSearch2.pending, (state) => {
    state.queryCorrection = emptyLegacyCorrection();
    state.wasAutomaticallyCorrected = false;
    state.wasCorrectedTo = "";
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const { queryCorrection, queryCorrections } = action.payload.response;
    if (state.queryCorrectionMode === "legacy") {
      const nonOptionalQueryCorrections = (queryCorrections == null ? void 0 : queryCorrections[0]) ? queryCorrections[0] : emptyLegacyCorrection();
      state.queryCorrection = nonOptionalQueryCorrections;
    }
    if (state.queryCorrectionMode === "next") {
      setToNonEmptyQueryCorrection(state, queryCorrection);
    }
    state.wasAutomaticallyCorrected = action.payload.automaticallyCorrected;
    state.originalQuery = action.payload.originalQuery;
  }).addCase(applyDidYouMeanCorrection, (state, action) => {
    state.wasCorrectedTo = action.payload;
  }).addCase(setCorrectionMode, (state, action) => {
    state.queryCorrectionMode = action.payload;
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/core/did-you-mean/headless-core-did-you-mean.js
function buildCoreDidYouMean(engine, props = {}) {
  var _a, _b;
  if (!loadDidYouMeanReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  dispatch(enableDidYouMean());
  if (((_a = props.options) == null ? void 0 : _a.automaticallyCorrectQuery) === false) {
    dispatch(disableAutomaticQueryCorrection());
  }
  dispatch(setCorrectionMode(((_b = props.options) == null ? void 0 : _b.queryCorrectionMode) || "next"));
  const getState = () => engine.state;
  const hasQueryCorrection = () => hasQueryCorrectionSelector(getState().didYouMean);
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        originalQuery: state.didYouMean.originalQuery,
        wasCorrectedTo: state.didYouMean.wasCorrectedTo,
        wasAutomaticallyCorrected: state.didYouMean.wasAutomaticallyCorrected,
        queryCorrection: state.didYouMean.queryCorrection,
        hasQueryCorrection: hasQueryCorrection()
      };
    },
    applyCorrection() {
      dispatch(applyDidYouMeanCorrection(this.state.queryCorrection.correctedQuery));
    },
    updateQueryCorrectionMode(queryCorrectionMode) {
      dispatch(setCorrectionMode(queryCorrectionMode));
    }
  };
}
function loadDidYouMeanReducers(engine) {
  engine.addReducers({ configuration, didYouMean: didYouMeanReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/did-you-mean/headless-did-you-mean.js
function buildDidYouMean(engine, props = {}) {
  const controller = buildCoreDidYouMean(engine, props);
  const { dispatch } = engine;
  return {
    ...controller,
    get state() {
      return controller.state;
    },
    applyCorrection() {
      controller.applyCorrection();
      dispatch(executeSearch2({
        legacy: logDidYouMeanClick(),
        next: didYouMeanClick()
      }));
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facet-manager/headless-core-facet-manager.js
function buildCoreFacetManager(engine) {
  if (!loadFacetManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    sort(facets) {
      return sortFacets(facets, this.state.facetIds);
    },
    get state() {
      const facets = getState().search.response.facets;
      const facetIds = facets.map((f3) => f3.facetId);
      return { facetIds };
    }
  };
}
function loadFacetManagerReducers(engine) {
  engine.addReducers({ search: searchReducer, facetOptions: facetOptionsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/facet-manager/headless-facet-manager.js
function buildFacetManager(engine) {
  return buildCoreFacetManager(engine);
}

// node_modules/@coveo/headless/dist/esm/features/facets/automatic-facet-set/automatic-facet-set-slice.js
var automaticFacetSetReducer = createReducer(getAutomaticFacetSetInitialState(), (builder) => {
  builder.addCase(executeSearch2.fulfilled, (state, action) => {
    var _a;
    state.set = {};
    const facets = (_a = action.payload.response.generateAutomaticFacets) == null ? void 0 : _a.facets;
    facets == null ? void 0 : facets.forEach((response) => {
      state.set[response.field] = { response };
    });
  }).addCase(setOptions, (state, action) => {
    if (action.payload.desiredCount) {
      state.desiredCount = action.payload.desiredCount;
    }
    if (action.payload.numberOfValues) {
      state.numberOfValues = action.payload.numberOfValues;
    }
  }).addCase(toggleSelectAutomaticFacetValue, (state, action) => {
    var _a;
    const { field: field2, selection } = action.payload;
    const facet = (_a = state.set[field2]) == null ? void 0 : _a.response;
    if (!facet) {
      return;
    }
    const value = facet.values.find((value2) => value2.value === selection.value);
    if (!value) {
      return;
    }
    const isSelected = value.state === "selected";
    value.state = isSelected ? "idle" : "selected";
  }).addCase(deselectAllAutomaticFacetValues, (state, action) => {
    var _a;
    const field2 = action.payload;
    const facet = (_a = state.set[field2]) == null ? void 0 : _a.response;
    if (!facet) {
      return;
    }
    for (const value of facet.values) {
      value.state = "idle";
    }
  }).addCase(restoreSearchParameters, (state, action) => {
    var _a, _b;
    const af = action.payload.af ?? {};
    const currentFields = Object.keys(state.set);
    for (const field2 in af) {
      if (!state.set[field2]) {
        const response = buildTemporaryAutomaticFacetResponse(field2);
        const values = af[field2].map((value) => buildTemporarySelectedFacetValue(value));
        response.values.push(...values);
        state.set[field2] = { response };
      }
    }
    for (const field2 of currentFields) {
      if (!(field2 in af)) {
        const facet = (_a = state.set[field2]) == null ? void 0 : _a.response;
        for (const value of facet.values) {
          value.state = "idle";
        }
      }
    }
    for (const field2 in af) {
      const facet = (_b = state.set[field2]) == null ? void 0 : _b.response;
      if (facet) {
        const stateFacetValues = facet.values;
        const urlFacetValues = new Set(af[field2]);
        for (const value of stateFacetValues) {
          if (urlFacetValues.has(value.value)) {
            value.state = "selected";
            urlFacetValues.delete(value.value);
          } else {
            value.state = "idle";
          }
        }
        for (const value of urlFacetValues) {
          facet.values.push(buildTemporarySelectedFacetValue(value));
        }
      }
    }
  }).addCase(change.fulfilled, (_, action) => {
    if (!action.payload) {
      return;
    }
    if (Object.keys(action.payload.automaticFacetSet.set).length === 0) {
      return;
    }
    return action.payload.automaticFacetSet;
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.values(state.set).forEach(({ response }) => {
      response.values.forEach((value) => {
        value.state = "idle";
      });
    });
  });
});
function buildTemporaryAutomaticFacetResponse(field2) {
  return {
    field: field2,
    values: [],
    moreValuesAvailable: false,
    label: "",
    indexScore: 0
  };
}
function buildTemporarySelectedFacetValue(value) {
  return {
    value,
    state: "selected",
    numberOfResults: 0
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-utils.js
var isFacetValueSelected = (value) => {
  return value.state === "selected";
};
var isFacetValueExcluded = (value) => {
  return value.state === "excluded";
};
var getLegacyAnalyticsActionForToggleFacetSelect = (facetId2, selection) => {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  return isFacetValueSelected(selection) ? logFacetDeselect(payload) : logFacetSelect(payload);
};
var getAnalyticsActionForToggleFacetSelect = (selection) => isFacetValueSelected(selection) ? facetDeselect() : facetSelect();
var getLegacyAnalyticsActionForToggleFacetExclude = (facetId2, selection) => {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  return isFacetValueExcluded(selection) ? logFacetUnexclude(payload) : logFacetExclude(payload);
};
var getAnalyticsActionForToggleFacetExclude = (selection) => isFacetValueExcluded(selection) ? facetUnexclude() : facetExclude();

// node_modules/@coveo/headless/dist/esm/controllers/facets/automatic-facet/headless-automatic-facet.js
function buildAutomaticFacet(engine, props) {
  const { dispatch } = engine;
  const controller = buildController(engine);
  const { field: field2 } = props;
  return {
    ...controller,
    toggleSelect(selection) {
      dispatch(toggleSelectAutomaticFacetValue({ field: field2, selection }));
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggleFacetSelect(field2, selection),
        next: getAnalyticsActionForToggleFacetSelect(selection)
      }));
    },
    deselectAll() {
      dispatch(deselectAllAutomaticFacetValues(field2));
      dispatch(executeSearch2({
        legacy: logFacetClearAll(field2),
        next: facetClearAll()
      }));
    },
    get state() {
      var _a, _b;
      const response = (_b = (_a = engine.state.automaticFacetSet) == null ? void 0 : _a.set[field2]) == null ? void 0 : _b.response;
      const defaultState = { field: "", values: [], label: "" };
      return response ? {
        field: response.field,
        label: response.label,
        values: response.values
      } : defaultState;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/automatic-facet-generator/headless-automatic-facet-generator-options.js
function buildOptions(options) {
  return {
    desiredCount: options.desiredCount,
    numberOfValues: options.numberOfValues
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/automatic-facet-generator/headless-automatic-facet-generator.js
function buildAutomaticFacetGenerator(engine, props) {
  if (!loadAutomaticFacetGeneratorReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const options = buildOptions(props.options);
  dispatch(setOptions(options));
  const controller = buildController(engine);
  return {
    ...controller,
    get state() {
      var _a;
      const automaticFacets = ((_a = engine.state.search.response.generateAutomaticFacets) == null ? void 0 : _a.facets.map((facet) => buildAutomaticFacet(engine, { field: facet.field }))) ?? [];
      return {
        automaticFacets
      };
    }
  };
}
function loadAutomaticFacetGeneratorReducers(engine) {
  engine.addReducers({ automaticFacetSet: automaticFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/sort/sort.js
var SortBy2;
(function(SortBy3) {
  SortBy3["Relevance"] = "relevance";
  SortBy3["Fields"] = "fields";
})(SortBy2 || (SortBy2 = {}));
var SortDirection;
(function(SortDirection2) {
  SortDirection2["Ascending"] = "asc";
  SortDirection2["Descending"] = "desc";
})(SortDirection || (SortDirection = {}));

// node_modules/@coveo/headless/dist/esm/features/commerce/sort/sort.js
var sortCriterionDefinition = new RecordValue({
  options: {
    required: false
  },
  values: {
    by: new EnumValue({ enum: SortBy2, required: true }),
    fields: new ArrayValue({
      each: new RecordValue({
        values: {
          field: new StringValue({ required: true }),
          direction: new EnumValue({ enum: SortDirection }),
          displayName: new StringValue()
        }
      })
    })
  }
});

// node_modules/@coveo/headless/dist/esm/api/commerce/commerce-api-client.js
var isErrorResponse2 = (r) => {
  return r.error !== void 0;
};
function getCommerceApiBaseUrl(organizationId, environment = "prod") {
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  return `${platformEndpoint}/rest/organizations/${organizationId}/commerce/v2`;
}

// node_modules/@coveo/headless/dist/esm/features/commerce/context/cart/cart-state.js
var getProductsFromCartState = (state) => getProductsFromCart(state.cartItems, state.cart);
function getProductsFromCart(items, itemMap) {
  const productsMap = items.reduce((acc, key) => {
    const { productId, quantity } = itemMap[key];
    if (!(productId in acc)) {
      acc[productId] = {
        productId,
        quantity: 0
      };
    }
    acc[productId].quantity += quantity;
    return acc;
  }, {});
  return [...Object.values(productsMap)];
}

// node_modules/@coveo/headless/dist/esm/features/commerce/common/base-commerce-api-request-builder.js
var buildBaseCommerceAPIRequest = (state, navigatorContext) => {
  const { view, location, custom, ...restOfContext } = state.commerceContext;
  return {
    accessToken: state.configuration.accessToken,
    url: state.configuration.commerce.apiBaseUrl ?? getCommerceApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    organizationId: state.configuration.organizationId,
    trackingId: state.configuration.analytics.trackingId,
    ...restOfContext,
    ...state.configuration.analytics.enabled ? { clientId: navigatorContext.clientId } : {},
    context: {
      user: {
        ...location,
        ...navigatorContext.userAgent ? { userAgent: navigatorContext.userAgent } : {}
      },
      view: {
        ...view,
        ...navigatorContext.referrer ? { referrer: navigatorContext.referrer } : {}
      },
      capture: navigatorContext.capture ?? (state.configuration.analytics.enabled && navigatorContext.clientId !== ""),
      cart: getProductsFromCartState(state.cart),
      source: getAnalyticsSource(state.configuration.analytics),
      ...custom ? { custom } : {}
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/commerce/common/paginated-commerce-api-request-builder.js
var buildPaginatedCommerceAPIRequest = (state, navigatorContext, slotId) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    ...effectivePagination(state, slotId)
  };
};
var effectivePagination = (state, slotId) => {
  var _a, _b;
  const effectiveSlice = slotId ? (_a = state.commercePagination) == null ? void 0 : _a.recommendations[slotId] : (_b = state.commercePagination) == null ? void 0 : _b.principal;
  return effectiveSlice && {
    page: effectiveSlice.page,
    ...effectiveSlice.perPage && {
      perPage: effectiveSlice.perPage
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/commerce/common/filterable-commerce-api-request-builder.js
var buildFilterableCommerceAPIRequest = (state, navigatorContext) => {
  return {
    ...buildPaginatedCommerceAPIRequest(state, navigatorContext),
    facets: [...getFacets3(state)],
    ...state.commerceSort && {
      sort: getSort(state.commerceSort.appliedSort)
    }
  };
};
function getFacets3(state) {
  if (!state.facetOrder || !state.commerceFacetSet) {
    return [];
  }
  return state.facetOrder.filter((facetId2) => {
    var _a;
    return (_a = state.commerceFacetSet) == null ? void 0 : _a[facetId2];
  }).map((facetId2) => {
    var _a, _b;
    return ((_b = (_a = state.manualNumericFacetSet) == null ? void 0 : _a[facetId2]) == null ? void 0 : _b.manualRange) ? {
      facetId: facetId2,
      field: facetId2,
      numberOfValues: 1,
      isFieldExpanded: false,
      preventAutoSelect: true,
      type: "numericalRange",
      values: [state.manualNumericFacetSet[facetId2].manualRange],
      initialNumberOfValues: 1
    } : state.commerceFacetSet[facetId2].request;
  }).filter((facet) => facet && facet.values.length > 0);
}
function getSort(appliedSort) {
  if (appliedSort.by === SortBy2.Relevance) {
    return {
      sortCriteria: SortBy2.Relevance
    };
  } else {
    return {
      sortCriteria: SortBy2.Fields,
      fields: appliedSort.fields.map(({ name, direction }) => ({
        field: name,
        direction
      }))
    };
  }
}

// node_modules/@coveo/headless/dist/esm/features/commerce/facets/facet-search-set/category/commerce-category-facet-search-request-builder.js
var buildCategoryFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  var _a, _b;
  const baseFacetQuery = state.categoryFacetSearchSet[facetId2].options.query;
  const facetQuery = `*${baseFacetQuery}*`;
  const categoryFacet = (_a = state.commerceFacetSet[getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2)]) == null ? void 0 : _a.request;
  const path = categoryFacet && isCategoryFacetRequest2(categoryFacet) ? categoryFacet && getPathToSelectedCategoryFacetItem(categoryFacet) : [];
  const ignorePaths = path.length ? [path] : [];
  const query2 = isFieldSuggestionsRequest ? baseFacetQuery : (_b = state.commerceQuery) == null ? void 0 : _b.query;
  const numberOfValues2 = state.categoryFacetSearchSet[facetId2].options.numberOfValues;
  const { url, accessToken, organizationId, trackingId, language, country, currency, clientId, context, ...restOfCommerceAPIRequest } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    ignorePaths,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};
function isCategoryFacetRequest2(request) {
  return request.type === "hierarchical";
}
var getPathToSelectedCategoryFacetItem = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.values[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};

// node_modules/@coveo/headless/dist/esm/features/commerce/facets/facet-search-set/regular/commerce-regular-facet-search-request-builder.js
var buildFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  var _a;
  const baseFacetQuery = state.facetSearchSet[facetId2].options.query;
  const numberOfValues2 = state.facetSearchSet[facetId2].options.numberOfValues;
  const facetQuery = `*${baseFacetQuery}*`;
  const query2 = !isFieldSuggestionsRequest ? (_a = state.commerceQuery) == null ? void 0 : _a.query : baseFacetQuery;
  const { url, accessToken, organizationId, trackingId, language, country, currency, clientId, context, ...restOfCommerceAPIRequest } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};

// node_modules/@coveo/headless/dist/esm/features/commerce/facets/facet-search-set/commerce-facet-search-actions.js
var getExecuteFacetSearchThunkPayloadCreator = (isFieldSuggestionsRequest) => async ({ facetId: facetId2, facetSearchType }, { getState, extra: { validatePayload: validatePayload2, navigatorContext, apiClient } }) => {
  const state = getState();
  validatePayload2(facetId2, requiredNonEmptyString);
  const req = isRegularFacetSearchState(state, facetId2) || isRegularFieldSuggestionsState(state, facetId2) ? buildFacetSearchRequest(facetId2, state, isFieldSuggestionsRequest, navigatorContext) : buildCategoryFacetSearchRequest(facetId2, state, isFieldSuggestionsRequest, navigatorContext);
  const response = await apiClient.facetSearch(req, facetSearchType);
  return { facetId: facetId2, response };
};
var executeCommerceFacetSearch = createAsyncThunk("commerce/facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator(false));
var executeCommerceFieldSuggest = createAsyncThunk("commerce/facetSearch/facetFieldSuggest", getExecuteFacetSearchThunkPayloadCreator(true));
var isRegularFacetSearchState = (s, facetId2) => {
  return "facetSearchSet" in s && s.facetSearchSet[facetId2] !== void 0 && s.commerceFacetSet[facetId2] !== void 0;
};
var isRegularFieldSuggestionsState = (s, facetId2) => {
  if (!("fieldSuggestionsOrder" in s)) {
    return false;
  }
  return s.fieldSuggestionsOrder.some((facet) => facet.facetId === facetId2 && facet.type === "regular");
};
var commerceFieldSuggestionNamespace = "field_suggestion:";
function getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2.slice(commerceFieldSuggestionNamespace.length) : facetId2;
}
function getFacetIdWithCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2 : `${commerceFieldSuggestionNamespace}${facetId2}`;
}

// node_modules/@coveo/headless/dist/esm/features/commerce/pagination/pagination-selectors.js
var perPagePrincipalSelector = (state) => {
  var _a;
  return ((_a = state.commercePagination) == null ? void 0 : _a.principal.perPage) || 0;
};
var totalEntriesPrincipalSelector = (state) => {
  var _a;
  return ((_a = state.commercePagination) == null ? void 0 : _a.principal.totalEntries) || 0;
};

// node_modules/@coveo/headless/dist/esm/features/commerce/product-listing/product-listing-selectors.js
var numberOfProductsSelector = (state) => {
  var _a, _b;
  return ((_a = state.productListing) == null ? void 0 : _a.results.length) || ((_b = state.productListing) == null ? void 0 : _b.products.length) || 0;
};
var moreProductsAvailableSelector = createSelector((state) => ({
  total: totalEntriesPrincipalSelector(state),
  current: numberOfProductsSelector(state)
}), ({ current: current2, total }) => current2 < total);

// node_modules/@coveo/headless/dist/esm/features/commerce/product-listing/product-listing-actions.js
var fetchProductListing = createAsyncThunk("commerce/productListing/fetch", async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const state = getState();
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const fetched = await apiClient.getProductListing({
    ...request,
    enableResults: Boolean(payload == null ? void 0 : payload.enableResults)
  });
  if (isErrorResponse2(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: fetched.success
  };
});
var fetchMoreProducts = createAsyncThunk("commerce/productListing/fetchMoreProducts", async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const state = getState();
  const moreProductsAvailable = moreProductsAvailableSelector(state);
  if (!moreProductsAvailable) {
    return null;
  }
  const perPage = perPagePrincipalSelector(state);
  const numberOfProducts = numberOfProductsSelector(state);
  const nextPageToRequest = numberOfProducts / perPage;
  const fetched = await apiClient.getProductListing({
    ...buildFilterableCommerceAPIRequest(state, navigatorContext),
    enableResults: Boolean(payload == null ? void 0 : payload.enableResults),
    page: nextPageToRequest
  });
  if (isErrorResponse2(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: fetched.success
  };
});
var promoteChildToParentDefinition = {
  child: new RecordValue({
    options: { required: true },
    values: {
      permanentid: new StringValue({ required: true })
    }
  })
};
var promoteChildToParent = createAction("commerce/productListing/promoteChildToParent", (payload) => validatePayload(payload, promoteChildToParentDefinition));

// node_modules/@coveo/headless/dist/esm/features/commerce/query-suggest/query-suggest-request-builder.js
var buildQuerySuggestRequest = (id, state, navigatorContext) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    query: state.querySet[id]
  };
};

// node_modules/@coveo/headless/dist/esm/features/commerce/query-suggest/query-suggest-actions.js
var clearQuerySuggest = createAction("commerce/querySuggest/clear", (payload) => validatePayload(payload, { id: requiredNonEmptyString }));
var fetchQuerySuggestions = createAsyncThunk("commerce/querySuggest/fetch", async (payload, { getState, rejectWithValue, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  validatePayload2(payload, {
    id: requiredNonEmptyString
  });
  const state = getState();
  const request = buildQuerySuggestRequest(payload.id, state, navigatorContext);
  const response = await apiClient.querySuggest(request);
  if (isErrorResponse2(response)) {
    return rejectWithValue(response.error);
  }
  return {
    id: payload.id,
    query: request.query,
    ...response.success
  };
});
var registerQuerySuggest = createAction("commerce/querySuggest/register", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  count: new NumberValue({ min: 0 })
}));
var selectQuerySuggestion = createAction("commerce/querySuggest/selectSuggestion", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  expression: requiredEmptyAllowedString
}));

// node_modules/@coveo/headless/dist/esm/features/commerce/facets/core-facet/core-facet-actions.js
var updateCoreFacetNumberOfValues = createAction("commerce/facets/core/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  numberOfValues: new NumberValue({ required: true, min: 1 })
}));
var updateCoreFacetIsFieldExpanded = createAction("commerce/facets/core/updateIsFieldExpanded", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  isFieldExpanded: new BooleanValue({ required: true })
}));
var clearAllCoreFacets = createAction("commerce/facets/core/clearAll");
var deleteAllCoreFacets = createAction("commerce/facets/core/deleteAll");
var deselectAllValuesInCoreFacet = createAction("commerce/facets/core/deselectAllValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString
}));
var updateCoreFacetFreezeCurrentValues = createAction("commerce/facets/core/updateFreezeCurrentValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  freezeCurrentValues: new BooleanValue({ required: true })
}));
var updateAutoSelectionForAllCoreFacets = createAction("commerce/facets/core/updateAutoSelectionForAll", (payload) => validatePayload(payload, {
  allow: new BooleanValue({ required: true })
}));

// node_modules/@coveo/headless/dist/esm/features/commerce/pagination/pagination-actions.js
var slotIdDefinition = {
  slotId: nonRequiredEmptyAllowedString
};
var setPageSizeDefinition = {
  ...slotIdDefinition,
  pageSize: new NumberValue({ required: true, min: 0 })
};
var setPageSize = createAction("commerce/pagination/setPageSize", (payload) => validatePayload(payload, setPageSizeDefinition));
var selectPageDefinition = {
  ...slotIdDefinition,
  page: new NumberValue({ required: true, min: 0 })
};
var selectPage = createAction("commerce/pagination/selectPage", (payload) => validatePayload(payload, selectPageDefinition));
var nextPage2 = createAction("commerce/pagination/nextPage", (payload) => validatePayload(payload, slotIdDefinition));
var previousPage2 = createAction("commerce/pagination/previousPage", (payload) => validatePayload(payload, slotIdDefinition));
var registerRecommendationsSlotPagination = createAction("commerce/pagination/registerRecommendationsSlot", (payload) => validatePayload(payload, {
  slotId: requiredNonEmptyString
}));

// node_modules/@coveo/headless/dist/esm/features/commerce/query/query-actions.js
var updateQuery2 = createAction("commerce/query/update", (payload) => validatePayload(payload, {
  query: new StringValue()
}));

// node_modules/@coveo/headless/dist/esm/features/commerce/triggers/triggers-actions.js
var updateIgnoreQueryTrigger2 = createAction("commerce/triggers/query/updateIgnore", (payload) => validatePayload(payload, {
  q: new StringValue({ emptyAllowed: true, required: true })
}));
var applyQueryTriggerModification2 = createAction("commerce/triggers/query/applyModification", (payload) => validatePayload(payload, new RecordValue({
  values: { originalQuery: nonEmptyString, modification: nonEmptyString }
})));

// node_modules/@coveo/headless/dist/esm/features/parameter-manager/parameter-manager-selectors.js
function getQ(section, querySelector2, initialState2) {
  if (section === void 0) {
    return {};
  }
  const q = querySelector2(section);
  const shouldInclude = q !== initialState2;
  return shouldInclude ? { q } : {};
}
function getSortCriteria(section, sortCriteriaSelector, initialState2) {
  if (section === void 0) {
    return {};
  }
  const sortCriteria = sortCriteriaSelector(section);
  const shouldInclude = sortCriteria !== initialState2;
  return shouldInclude ? { sortCriteria } : {};
}
function getFacets4(section, facetIsEnabled2, valuesSelector, out) {
  if (section === void 0) {
    return {};
  }
  const facets = Object.entries(section).filter(([facetId2]) => facetIsEnabled2(facetId2)).map(([facetId2, { request }]) => {
    const selectedValues = valuesSelector(request);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(facets).length ? { [out]: facets } : {};
}
function getTab(section, tabSelector, initialState2) {
  if (section === void 0) {
    return {};
  }
  const tab = tabSelector(section);
  const shouldInclude = tab !== initialState2;
  return shouldInclude ? { tab } : {};
}

// node_modules/@coveo/headless/dist/esm/features/commerce/search/search-selectors.js
var numberOfProductsSelector2 = (state) => {
  var _a;
  return ((_a = state.commerceSearch) == null ? void 0 : _a.products.length) || 0;
};
var moreProductsAvailableSelector2 = createSelector((state) => ({
  total: totalEntriesPrincipalSelector(state),
  current: numberOfProductsSelector2(state)
}), ({ current: current2, total }) => current2 < total);
var querySelector = (state) => {
  var _a;
  return ((_a = state.commerceQuery) == null ? void 0 : _a.query) ?? "";
};
var queryExecutedFromResponseSelector = (state, response) => {
  var _a;
  if (!isNullOrUndefined((_a = response.queryCorrection) == null ? void 0 : _a.correctedQuery)) {
    return response.queryCorrection.correctedQuery;
  }
  return querySelector(state);
};

// node_modules/@coveo/headless/dist/esm/features/commerce/search/search-actions-thunk-processor.js
var AsyncSearchThunkProcessor3 = class {
  constructor(config) {
    __publicField(this, "config");
    this.config = config;
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  async fetchFromAPI(request) {
    const startedAt = Date.now();
    const response = await this.extra.apiClient.search(request);
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().commerceQuery.query || "";
    return {
      response,
      duration,
      queryExecuted,
      requestExecuted: request,
      enableResults: Boolean("enableResults" in request && request.enableResults)
    };
  }
  processSuccessResponse(fetched) {
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      originalQuery: this.getCurrentQuery()
    };
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse2(fetched.response)) {
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { queryCorrection } = successResponse;
    const shouldExecuteQueryCorrection = !isNullOrUndefined(queryCorrection) && !isNullOrUndefined(queryCorrection.correctedQuery);
    if (!shouldExecuteQueryCorrection) {
      return null;
    }
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery ?? "");
    return {
      ...fetched,
      response: {
        ...successResponse
      },
      queryExecuted: queryExecutedFromResponseSelector(state, successResponse),
      originalQuery: originalQuery ?? ""
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    var _a, _b;
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = ((_a = successResponse.triggers.find((trigger) => trigger.type === "query")) == null ? void 0 : _a.content) || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = (_b = this.getState().triggers) == null ? void 0 : _b.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger2({ q: "" }));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery, fetched.enableResults);
    if (isErrorResponse2(retried.response)) {
      return this.rejectWithValue(retried.response.error);
    }
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      originalQuery
    };
  }
  async automaticallyRetryQueryWithTriggerModification(modified, enableResults) {
    this.dispatch(applyQueryTriggerModification2({
      newQuery: modified,
      originalQuery: this.getCurrentQuery()
    }));
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI({
      ...buildFilterableCommerceAPIRequest(this.getState(), this.navigatorContext),
      query: modified,
      enableResults: Boolean(enableResults)
    });
    return fetched;
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
  getState() {
    return this.config.getState();
  }
  get navigatorContext() {
    return this.config.extra.navigatorContext;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.commerceQuery.query !== void 0 ? state.commerceQuery.query : "";
  }
  getSuccessResponse(fetched) {
    if (isErrorResponse2(fetched.response)) {
      return null;
    }
    return fetched.response.success;
  }
  get extra() {
    return this.config.extra;
  }
  onUpdateQueryForCorrection(modification) {
    this.dispatch(updateQuery2({ query: modification }));
  }
};

// node_modules/@coveo/headless/dist/esm/features/commerce/search/search-actions.js
var executeSearch3 = createAsyncThunk("commerce/search/executeSearch", async (payload = {}, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const query2 = querySelector(state);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    enableResults: Boolean(payload == null ? void 0 : payload.enableResults)
  });
  return processor.process(fetchedResponse);
});
var fetchMoreProducts2 = createAsyncThunk("commerce/search/fetchMoreProducts", async (payload = {}, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const moreProductsAvailable = moreProductsAvailableSelector2(state);
  if (!moreProductsAvailable) {
    return null;
  }
  const perPage = perPagePrincipalSelector(state);
  const numberOfProducts = numberOfProductsSelector2(state);
  const nextPageToRequest = numberOfProducts / perPage;
  const query2 = querySelector(state);
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    page: nextPageToRequest,
    enableResults: Boolean(payload == null ? void 0 : payload.enableResults)
  });
  return processor.process(fetchedResponse);
});
var prepareForSearchWithQuery2 = createAsyncThunk("commerce/search/prepareForSearchWithQuery", (payload, thunk2) => {
  const { dispatch } = thunk2;
  validatePayload(payload, {
    query: new StringValue(),
    clearFilters: new BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deleteAllCoreFacets());
  }
  dispatch(updateAutoSelectionForAllCoreFacets({ allow: true }));
  dispatch(updateQuery2({
    query: payload.query
  }));
  dispatch(selectPage({ page: 0 }));
});
var fetchInstantProducts = createAsyncThunk("commerce/search/fetchInstantProducts", async (payload, { getState, rejectWithValue, extra }) => {
  const state = getState();
  const { apiClient, navigatorContext } = extra;
  const { q } = payload;
  const fetched = await apiClient.productSuggestions({
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    query: q
  });
  if (isErrorResponse2(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: { ...fetched.success, products: fetched.success.products }
  };
});
var promoteChildToParentDefinition2 = {
  child: new RecordValue({
    options: { required: true },
    values: {
      permanentid: new StringValue({ required: true })
    }
  })
};
var promoteChildToParent2 = createAction("commerce/search/promoteChildToParent", (payload) => validatePayload(payload, promoteChildToParentDefinition2));

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/facet-search-reducer-helpers.js
function handleFacetSearchRegistration(state, payload, buildEmptyResponse3) {
  const { facetId: facetId2 } = payload;
  if (state[facetId2]) {
    return;
  }
  const isLoading = false;
  const options = { ...defaultFacetSearchOptions, ...payload };
  const response = buildEmptyResponse3();
  state[facetId2] = {
    options,
    isLoading,
    response,
    initialNumberOfValues: options.numberOfValues,
    requestId: ""
  };
}
function handleFacetSearchUpdate(state, payload) {
  const { facetId: facetId2, ...rest } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.options = { ...search.options, ...rest };
}
function handleFacetSearchPending(state, facetId2, requestId) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = requestId;
  search.isLoading = true;
}
function handleFacetSearchRejected(state, facetId2) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.isLoading = false;
}
function handleFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  search.response = response;
}
function handleCommerceFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFacetFieldSuggestionsFulfilled(state, payload, requestId, buildEmptyResponse3) {
  const { facetId: facetId2, response } = payload;
  const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(facetId2);
  let search = state[namespacedFacetId];
  if (!search) {
    handleFacetSearchRegistration(state, { facetId: namespacedFacetId }, buildEmptyResponse3);
    search = state[namespacedFacetId];
  } else if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(state, payload, requestId, buildEmptyResponse3) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    if (fieldSuggestionFacet.facetId in state || fieldSuggestionFacet.type !== "regular") {
      continue;
    }
    state[fieldSuggestionFacet.facetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse3(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(state, payload, requestId, buildEmptyResponse3) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(fieldSuggestionFacet.facetId);
    if (namespacedFacetId in state || fieldSuggestionFacet.type !== "hierarchical") {
      continue;
    }
    state[namespacedFacetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse3(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleFacetSearchClear(state, payload, buildEmptyResponse3) {
  const { facetId: facetId2 } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = "";
  search.isLoading = false;
  search.response = buildEmptyResponse3();
  search.options.numberOfValues = search.initialNumberOfValues;
  search.options.query = defaultFacetSearchOptions.query;
}
function handleFacetSearchSetClear(state, buildEmptyResponse3) {
  Object.keys(state).forEach((facetId2) => handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse3));
}
var defaultFacetSearchOptions = {
  captions: {},
  numberOfValues: 10,
  query: ""
};

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/category/category-facet-search-request-builder.js
var buildCategoryFacetSearchRequest2 = async (id, state, navigatorContext, isFieldSuggestionsRequest) => {
  const options = state.categoryFacetSearchSet[id].options;
  const categoryFacet = state.categoryFacetSet[id].request;
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = options;
  const { field: field2, delimitingCharacter: delimitingCharacter2, basePath: basePath2, filterFacetCount: filterFacetCount2 } = categoryFacet;
  const path = getPathToSelectedCategoryFacetItem2(categoryFacet);
  const ignorePaths = path.length ? [path] : [];
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    basePath: basePath2,
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    delimitingCharacter: delimitingCharacter2,
    ignorePaths,
    filterFacetCount: filterFacetCount2,
    type: "hierarchical",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest2(state, navigatorContext)).request
    }
  };
};
var getPathToSelectedCategoryFacetItem2 = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.currentValues[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/specific/specific-facet-search-request-builder.js
var buildSpecificFacetSearchRequest = async (id, state, navigatorContext, isFieldSuggestionsRequest) => {
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = state.facetSearchSet[id].options;
  const { field: field2, currentValues, filterFacetCount: filterFacetCount2 } = state.facetSet[id].request;
  const ignoreValues = currentValues.filter((v) => v.state !== "idle").map((facetValue) => facetValue.value);
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    ignoreValues,
    filterFacetCount: filterFacetCount2,
    type: "specific",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest2(state, navigatorContext)).request
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/generic/generic-facet-search-actions.js
var getExecuteFacetSearchThunkPayloadCreator2 = (isFieldSuggestionsRequest) => async (facetId2, { getState, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  const state = getState();
  let req;
  validatePayload2(facetId2, requiredNonEmptyString);
  if (isSpecificFacetSearchState(state, facetId2)) {
    req = await buildSpecificFacetSearchRequest(facetId2, state, navigatorContext, isFieldSuggestionsRequest);
  } else {
    req = await buildCategoryFacetSearchRequest2(facetId2, state, navigatorContext, isFieldSuggestionsRequest);
  }
  const response = await apiClient.facetSearch(req);
  return { facetId: facetId2, response };
};
var executeFacetSearch = createAsyncThunk("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator2(false));
var executeFieldSuggest = createAsyncThunk("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator2(true));
var clearFacetSearch = createAction("facetSearch/clearResults", (payload) => validatePayload(payload, { facetId: facetIdDefinition }));
var isSpecificFacetSearchState = (s, facetId2) => {
  return s.facetSearchSet !== void 0 && s.facetSet !== void 0 && s.facetSet[facetId2] !== void 0;
};

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/category/category-facet-search-set-state.js
function getCategoryFacetSearchSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/category/category-facet-search-set-slice.js
var categoryFacetSearchSetReducer = createReducer(getCategoryFacetSearchSetInitialState(), (builder) => {
  builder.addCase(registerCategoryFacetSearch, (state, action) => {
    const payload = action.payload;
    handleFacetSearchRegistration(state, payload, buildEmptyResponse);
  }).addCase(updateFacetSearch, (state, action) => {
    handleFacetSearchUpdate(state, action.payload);
  }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeFacetSearch.pending, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2));
  }).addCase(executeFacetSearch.rejected, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
    handleCommerceFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
    handleCommerceFacetFieldSuggestionsFulfilled(state, action.payload, action.meta.requestId, buildEmptyResponse);
  }).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
    handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(state, action.payload, action.meta.requestId, buildEmptyResponse);
  }).addCase(executeFacetSearch.fulfilled, (state, action) => {
    handleFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(clearFacetSearch, (state, { payload: { facetId: facetId2 } }) => {
    handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse);
  }).addCase(fetchProductListing.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse)).addCase(executeSearch3.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse)).addCase(executeSearch2.fulfilled, (state) => {
    handleFacetSearchSetClear(state, buildEmptyResponse);
  });
});
function buildEmptyResponse() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/_common/facet-id-generator.js
function generateFacetId(config, logger) {
  const { field: field2, state } = config;
  if (!isFieldUsedAsFacetId(config)) {
    return field2;
  }
  const prefix = `${field2}_`;
  const id = calculateId(prefix, state);
  logWarningMessage(field2, logger);
  return `${prefix}${id}`;
}
function isFieldUsedAsFacetId(config) {
  const { field: field2, state } = config;
  const sets = extractFacetSets(state);
  return sets.some((set2) => set2 && field2 in set2);
}
function calculateId(prefix, state) {
  const sets = extractFacetSets(state);
  const keys2 = sets.map((set2) => Object.keys(set2 || {})).reduce((all, current2) => all.concat(current2), []);
  return findMaxId(keys2, prefix) + 1;
}
function extractFacetSets(state) {
  const { facetSet, numericFacetSet, dateFacetSet, categoryFacetSet } = state;
  return [facetSet, numericFacetSet, dateFacetSet, categoryFacetSet];
}
function findMaxId(keys2, prefix) {
  const defaultId = 0;
  const ids = keys2.map((key) => {
    const stringId = key.split(prefix)[1];
    const id = parseInt(stringId, 10);
    return Number.isNaN(id) ? defaultId : id;
  });
  const lastNumber = ids.sort().pop();
  return lastNumber ?? defaultId;
}
function logWarningMessage(field2, logger) {
  const message = `A facet with field "${field2}" already exists.
  To avoid unexpected behaviour, configure the #id option on the facet controller.`;
  logger.warn(message);
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/_common/facet-id-determinor.js
function determineFacetId(engine, config) {
  const { state, logger } = engine;
  const { field: field2, facetId: facetId2 } = config;
  return facetId2 || generateFacetId({ field: field2, state }, logger);
}

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/interfaces/request.js
var categoryFacetSortCriteria = [
  "alphanumeric",
  "occurrences"
];

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/category-facet/headless-core-category-facet-options.js
var categoryFacetOptionsSchema = new Schema({
  field,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  basePath,
  delimitingCharacter,
  facetId,
  facetSearch,
  filterByBasePath,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new StringValue({
    constrainTo: categoryFacetSortCriteria
  })
});

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/category-facet/headless-core-category-facet.js
function buildCoreCategoryFacet(engine, props) {
  if (!loadCategoryFacetReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const registrationOptions = {
    ...defaultCategoryFacetOptions,
    ...omit("facetSearch", props.options),
    field: props.options.field,
    facetId: facetId2,
    tabs,
    activeTab
  };
  const options = {
    facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
    ...registrationOptions
  };
  validateOptions(engine, categoryFacetOptionsSchema, options, "buildCategoryFacet");
  const getRequest = () => {
    return categoryFacetRequestSelector(engine.state, facetId2);
  };
  const getResponse = () => {
    return categoryFacetResponseSelector(engine.state, facetId2);
  };
  const getIsLoading = () => isFacetLoadingResponseSelector(engine.state);
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  dispatch(registerCategoryFacet(registrationOptions));
  return {
    ...controller,
    toggleSelect(selection) {
      const retrieveCount = options.numberOfValues;
      dispatch(toggleSelectCategoryFacetValue({ facetId: facetId2, selection, retrieveCount }));
      dispatch(updateFacetOptions());
    },
    deselectAll() {
      dispatch(deselectAllCategoryFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateCategoryFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      const request = getRequest();
      return request.sortCriteria === criterion;
    },
    showMoreValues() {
      const { numberOfValues: increment } = options;
      const { activeValue, valuesAsTrees } = this.state;
      const numberOfValues2 = ((activeValue == null ? void 0 : activeValue.children.length) ?? valuesAsTrees.length) + increment;
      dispatch(updateCategoryFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetOptions());
    },
    showLessValues() {
      const { numberOfValues: numberOfValues2 } = options;
      dispatch(updateCategoryFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetOptions());
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = getResponse();
      const isLoading = getIsLoading();
      const enabled = getIsEnabled();
      const valuesAsTrees = (response == null ? void 0 : response.values) ?? [];
      const isHierarchical = valuesAsTrees.some((value) => value.children.length > 0) ?? false;
      const { parents, values } = partitionIntoParentsAndValues(response == null ? void 0 : response.values);
      const selectedValueAncestry = findActiveValueAncestry(valuesAsTrees);
      const activeValue = selectedValueAncestry.length ? selectedValueAncestry[selectedValueAncestry.length - 1] : void 0;
      const hasActiveValues = !!activeValue;
      const canShowMoreValues = (activeValue == null ? void 0 : activeValue.moreValuesAvailable) ?? (response == null ? void 0 : response.moreValuesAvailable) ?? false;
      const canShowLessValues = activeValue ? activeValue.children.length > options.numberOfValues : valuesAsTrees.length > options.numberOfValues;
      return {
        facetId: facetId2,
        parents,
        selectedValueAncestry,
        values,
        isHierarchical,
        valuesAsTrees,
        activeValue,
        isLoading,
        hasActiveValues,
        canShowMoreValues,
        canShowLessValues,
        sortCriteria: request.sortCriteria,
        enabled
      };
    }
  };
}
function loadCategoryFacetReducers(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    facetOptions: facetOptionsReducer,
    configuration,
    search: searchReducer
  });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/facet-search/facet-search.js
function buildGenericFacetSearch(engine, props) {
  const dispatch = engine.dispatch;
  const { options, getFacetSearch, executeFacetSearchActionCreator, executeFieldSuggestActionCreator } = props;
  const { facetId: facetId2 } = options;
  return {
    /** Updates the facet search query.
     * @param text The new query.
     */
    updateText(text) {
      dispatch(updateFacetSearch({
        facetId: facetId2,
        query: text,
        numberOfValues: getFacetSearch().initialNumberOfValues
      }));
    },
    /** Increases number of results returned by numberOfResults */
    showMoreResults() {
      const { initialNumberOfValues, options: options2 } = getFacetSearch();
      dispatch(updateFacetSearch({
        facetId: facetId2,
        numberOfValues: options2.numberOfValues + initialNumberOfValues
      }));
      dispatch(props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2));
    },
    /** Executes a facet search to update the values.*/
    search() {
      dispatch(props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2));
    },
    /** Resets the query and empties the values. */
    clear() {
      dispatch(clearFacetSearch({ facetId: facetId2 }));
    },
    /**
     * Updates the facet value captions.
     * @param captions - A dictionary that maps index field values to facet value display names.
     */
    updateCaptions(captions2) {
      dispatch(updateFacetSearch({
        facetId: facetId2,
        captions: captions2
      }));
    },
    get state() {
      const { response, isLoading, options: options2 } = getFacetSearch();
      const { query: query2 } = options2;
      const values = response.values;
      return {
        ...response,
        values,
        isLoading,
        query: query2
      };
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/facet-search/category/headless-category-facet-search.js
function buildCoreCategoryFacetSearch(engine, props) {
  const { dispatch } = engine;
  const options = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => "state" in engine ? engine.state.categoryFacetSearchSet[facetId2] : engine[stateKey].categoryFacetSearchSet[facetId2];
  dispatch(registerCategoryFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: props.executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator: props.executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    select(value) {
      dispatch(selectCategoryFacetSearchResult({
        facetId: facetId2,
        value
      }));
      props.select(value);
    },
    get state() {
      return genericFacetSearch.state;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/category-facet/headless-category-facet-search.js
function buildCategoryFacetSearch(engine, props) {
  const { executeFacetSearchActionCreator, executeFieldSuggestActionCreator, select: propsSelect, isForFieldSuggestions } = props;
  const { dispatch } = engine;
  const options = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => engine.state.categoryFacetSearchSet[facetId2];
  const coreFacetSearch = buildCoreCategoryFacetSearch(engine, {
    options: {
      ...options
    },
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator,
    select: propsSelect,
    isForFieldSuggestions
  });
  dispatch(registerCategoryFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest
  });
  return {
    ...genericFacetSearch,
    ...coreFacetSearch,
    get state() {
      return {
        ...genericFacetSearch.state,
        ...coreFacetSearch.state
      };
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/category-facet/headless-category-facet.js
function buildCategoryFacet(engine, props) {
  if (!loadCategoryFacetReducers2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreCategoryFacet(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: {
      facetId: getFacetId(),
      ...props.options.facetSearch
    },
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest,
    select: (value) => {
      dispatch(updateFacetOptions());
      dispatch(executeSearch2({
        legacy: logFacetSelect({
          facetId: getFacetId(),
          facetValue: value.rawValue
        }),
        next: facetSelect()
      }));
    },
    isForFieldSuggestions: false
  });
  const { state: _state, ...restOfFacetSearch } = facetSearch2;
  return {
    ...coreController,
    facetSearch: restOfFacetSearch,
    toggleSelect(selection) {
      coreController.toggleSelect(selection);
      dispatch(executeSearch2({
        legacy: getLegacyToggleSelectAnalyticsAction(getFacetId(), selection),
        next: getToggleSelectAnalyticsAction(selection)
      }));
    },
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch2({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch2({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    showMoreValues() {
      coreController.showMoreValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowMore(getFacetId()) }));
    },
    showLessValues() {
      coreController.showLessValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowLess(getFacetId()) }));
    },
    get state() {
      return {
        ...coreController.state,
        facetSearch: facetSearch2.state
      };
    }
  };
}
function loadCategoryFacetReducers2(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    configuration,
    search: searchReducer
  });
  return true;
}
function getLegacyToggleSelectAnalyticsAction(facetId2, selection) {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  const isSelected = selection.state === "selected";
  return isSelected ? logFacetDeselect(payload) : logFacetSelect(payload);
}
function getToggleSelectAnalyticsAction(selection) {
  const isSelected = selection.state === "selected";
  return isSelected ? facetDeselect() : facetSelect();
}

// node_modules/@coveo/headless/dist/esm/features/commerce/context/context-validation.js
var currencies = Intl.supportedValuesOf("currency");
var currencyDefinition = new StringValue({
  required: true,
  emptyAllowed: false,
  constrainTo: currencies
});
var viewDefinition = {
  url: requiredNonEmptyString
};
var locationDefinition = {
  latitude: new NumberValue({ min: -90, max: 90, required: true }),
  longitude: new NumberValue({ min: -180, max: 180, required: true })
};
var customDefinition = {
  custom: new RecordValue({
    options: { required: false }
  })
};
var contextDefinition = {
  language: requiredNonEmptyString,
  country: requiredNonEmptyString,
  currency: currencyDefinition,
  view: new RecordValue({
    options: { required: true },
    values: viewDefinition
  }),
  location: new RecordValue({
    options: { required: false },
    values: locationDefinition
  }),
  custom: new RecordValue({
    options: { required: false }
  })
};
var contextSchema = new Schema(contextDefinition);

// node_modules/@coveo/headless/dist/esm/features/commerce/context/context-actions.js
var setContext3 = createAction("commerce/context/set", (payload) => validatePayload(payload, contextDefinition));
var setView = createAction("commerce/context/setView", (payload) => validatePayload(payload, viewDefinition));
var setLocation = createAction("commerce/context/setLocation", (payload) => validatePayload(payload, locationDefinition));
var setCustom = createAction("commerce/context/setCustom", (payload) => validatePayload({ custom: payload }, customDefinition));

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/specific/specific-facet-search-set-state.js
function getFacetSearchSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-search-set/specific/specific-facet-search-set-slice.js
var specificFacetSearchSetReducer = createReducer(getFacetSearchSetInitialState(), (builder) => {
  builder.addCase(registerFacetSearch, (state, action) => {
    const payload = action.payload;
    handleFacetSearchRegistration(state, payload, buildEmptyResponse2);
  }).addCase(updateFacetSearch, (state, action) => {
    handleFacetSearchUpdate(state, action.payload);
  }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2), action.meta.requestId);
  }).addCase(executeFacetSearch.pending, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2));
  }).addCase(executeFacetSearch.rejected, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
    handleCommerceFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
    handleCommerceFacetFieldSuggestionsFulfilled(state, action.payload, action.meta.requestId, buildEmptyResponse2);
  }).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
    handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(state, action.payload, action.meta.requestId, buildEmptyResponse2);
  }).addCase(executeFacetSearch.fulfilled, (state, action) => {
    handleFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(clearFacetSearch, (state, { payload }) => {
    handleFacetSearchClear(state, payload, buildEmptyResponse2);
  }).addCase(executeSearch2.fulfilled, (state) => {
    handleFacetSearchSetClear(state, buildEmptyResponse2);
  }).addCase(fetchProductListing.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)).addCase(executeSearch3.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse2)).addCase(setView, (state) => handleFacetSearchSetClear(state, buildEmptyResponse2));
});
function buildEmptyResponse2() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-controller-actions.js
var definition = {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
};
var executeToggleFacetSelect = createAsyncThunk("facet/executeToggleSelect", ({ facetId: facetId2, selection }, thunk2) => {
  const { dispatch, extra: { validatePayload: validatePayload2 } } = thunk2;
  validatePayload2({ facetId: facetId2, selection }, definition);
  dispatch(toggleSelectFacetValue({ facetId: facetId2, selection }));
  dispatch(updateFacetOptions());
});
var executeToggleFacetExclude = createAsyncThunk("facet/executeToggleExclude", ({ facetId: facetId2, selection }, thunk2) => {
  const { dispatch, extra: { validatePayload: validatePayload2 } } = thunk2;
  validatePayload2({ facetId: facetId2, selection }, definition);
  dispatch(toggleExcludeFacetValue({ facetId: facetId2, selection }));
  dispatch(updateFacetOptions());
});

// node_modules/@coveo/headless/dist/esm/features/facets/facet-api/request.js
var facetResultsMustMatch = [
  "allValues",
  "atLeastOneValue"
];

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/interfaces/request.js
var facetSortCriteria = [
  "score",
  "alphanumeric",
  "alphanumericDescending",
  "occurrences",
  "automatic",
  "alphanumericNatural",
  "alphanumericNaturalDescending"
];

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/facet/headless-core-facet-options.js
var facetOptionsSchema = new Schema({
  facetId,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  field,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new StringValue({ constrainTo: facetSortCriteria }),
  resultsMustMatch: new StringValue({ constrainTo: facetResultsMustMatch }),
  facetSearch
});

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/facet/headless-core-facet.js
function buildCoreFacet(engine, props, optionsSchema9 = facetOptionsSchema) {
  if (!loadFacetReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const controller = buildController(engine);
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const registrationOptions = {
    ...defaultFacetOptions,
    ...omit("facetSearch", props.options),
    field: props.options.field,
    facetId: facetId2,
    tabs,
    activeTab
  };
  const options = {
    facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
    ...registrationOptions
  };
  validateOptions(engine, optionsSchema9, options, "buildFacet");
  const getRequest = () => facetRequestSelector(engine.state, facetId2);
  const getResponse = () => facetResponseSelector(engine.state, facetId2);
  const getIsLoading = () => isFacetLoadingResponseSelector(engine.state);
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  const getNumberOfActiveValues = () => {
    const { currentValues } = getRequest();
    return currentValues.filter((v) => v.state !== "idle").length;
  };
  const computeCanShowLessValues = () => {
    const { currentValues } = getRequest();
    const initialNumberOfValues = options.numberOfValues;
    const hasIdleValues = !!currentValues.find((v) => v.state === "idle");
    return initialNumberOfValues < currentValues.length && hasIdleValues;
  };
  dispatch(registerFacet(registrationOptions));
  return {
    ...controller,
    toggleSelect: (selection) => dispatch(executeToggleFacetSelect({ facetId: options.facetId, selection })),
    toggleExclude: (selection) => dispatch(executeToggleFacetExclude({ facetId: options.facetId, selection })),
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleExclude: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleExclude(selection);
    },
    isValueSelected: isFacetValueSelected,
    isValueExcluded: isFacetValueExcluded,
    deselectAll() {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    showMoreValues() {
      const numberInState = getRequest().numberOfValues;
      const initialNumberOfValues = options.numberOfValues;
      const numberToNextMultipleOfConfigured = initialNumberOfValues - numberInState % initialNumberOfValues;
      const numberOfValues2 = numberInState + numberToNextMultipleOfConfigured;
      dispatch(updateFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: true }));
      dispatch(updateFacetOptions());
    },
    showLessValues() {
      const initialNumberOfValues = options.numberOfValues;
      const newNumberOfValues = Math.max(initialNumberOfValues, getNumberOfActiveValues());
      dispatch(updateFacetNumberOfValues({ facetId: facetId2, numberOfValues: newNumberOfValues }));
      dispatch(updateFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: false }));
      dispatch(updateFacetOptions());
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = getResponse();
      const isLoading = getIsLoading();
      const enabled = getIsEnabled();
      let sortCriterion;
      if (typeof request.sortCriteria === "object") {
        sortCriterion = request.sortCriteria.order === "descending" ? "alphanumericDescending" : "alphanumeric";
      } else {
        sortCriterion = request.sortCriteria;
      }
      const values = response ? response.values : [];
      const hasActiveValues = values.some((facetValue) => facetValue.state !== "idle");
      const canShowMoreValues = response ? response.moreValuesAvailable : false;
      const resultsMustMatch = request.resultsMustMatch;
      return {
        label: response == null ? void 0 : response.label,
        facetId: facetId2,
        tabs,
        values,
        sortCriterion,
        resultsMustMatch,
        isLoading,
        hasActiveValues,
        canShowMoreValues,
        canShowLessValues: computeCanShowLessValues(),
        enabled
      };
    }
  };
}
function loadFacetReducers(engine) {
  engine.addReducers({ facetSet: facetSetReducer, facetOptions: facetOptionsReducer, configuration, facetSearchSet: specificFacetSearchSetReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/facet-search/specific/headless-facet-search.js
function buildFacetSearch(engine, props) {
  const { dispatch } = engine;
  const { options, select: propsSelect, exclude: propsExclude, isForFieldSuggestions, executeFacetSearchActionCreator, executeFieldSuggestActionCreator } = props;
  const { facetId: facetId2 } = options;
  const getFacetSearch = () => "state" in engine ? engine.state.facetSearchSet[facetId2] : engine[stateKey].facetSearchSet[facetId2];
  dispatch(registerFacetSearch(options));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options,
    getFacetSearch,
    isForFieldSuggestions,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    /**
     * Selects the provided value.
     * @param result A single specificFacetSearchResult object
     */
    select(value) {
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value.
     * @param result A single specificFacetSearchResult object
     */
    exclude(value) {
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    /**
     * Selects the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleSelect(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleExclude(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    get state() {
      const { values } = genericFacetSearch.state;
      return {
        ...genericFacetSearch.state,
        values: values.map(({ count, displayValue, rawValue }) => ({
          count,
          displayValue,
          rawValue
        }))
      };
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/facet/headless-facet-options.js
var facetOptionsSchema2 = new Schema({
  facetId,
  field,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new StringValue({ constrainTo: facetSortCriteria }),
  resultsMustMatch: new StringValue({ constrainTo: facetResultsMustMatch }),
  facetSearch,
  allowedValues,
  hasBreadcrumbs,
  customSort
});

// node_modules/@coveo/headless/dist/esm/controllers/facets/facet/headless-facet.js
function buildFacet(engine, props) {
  if (!loadFacetReducers2(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const coreController = buildCoreFacet(engine, {
    ...props,
    options: {
      ...props.options,
      ...props.options.allowedValues && {
        allowedValues: {
          type: "simple",
          values: props.options.allowedValues
        }
      }
    }
  }, facetOptionsSchema2);
  const getFacetId = () => coreController.state.facetId;
  const createFacetSearch = () => {
    const { facetSearch: facetSearch3 } = props.options;
    return buildFacetSearch(engine, {
      options: { facetId: getFacetId(), ...facetSearch3 },
      select: (value) => {
        dispatch(updateFacetOptions());
        dispatch(executeSearch2({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: value.rawValue
          }),
          next: facetSelect()
        }));
      },
      exclude: (value) => {
        dispatch(updateFacetOptions());
        dispatch(executeSearch2({
          legacy: logFacetExclude({
            facetId: getFacetId(),
            facetValue: value.rawValue
          }),
          next: facetExclude()
        }));
      },
      isForFieldSuggestions: false,
      executeFacetSearchActionCreator: executeFacetSearch,
      executeFieldSuggestActionCreator: executeFieldSuggest
    });
  };
  const facetSearch2 = createFacetSearch();
  const { state: _state, ...restOfFacetSearch } = facetSearch2;
  return {
    ...coreController,
    facetSearch: restOfFacetSearch,
    toggleSelect(selection) {
      coreController.toggleSelect(selection);
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggleFacetSelect(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetSelect(selection)
      }));
    },
    toggleExclude(selection) {
      coreController.toggleExclude(selection);
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggleFacetExclude(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetExclude(selection)
      }));
    },
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch2({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch2({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    showMoreValues() {
      coreController.showMoreValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowMore(getFacetId()) }));
    },
    showLessValues() {
      coreController.showLessValues();
      dispatch(fetchFacetValues2({ legacy: logFacetShowLess(getFacetId()) }));
    },
    get state() {
      return {
        ...coreController.state,
        facetSearch: facetSearch2.state
      };
    }
  };
}
function loadFacetReducers2(engine) {
  engine.addReducers({ facetSet: facetSetReducer, configuration, facetSearchSet: specificFacetSearchSetReducer, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/range-facet-utils.js
var isRangeFacetValueSelected = (selection) => {
  return selection.state === "selected";
};
var isRangeFacetValueExcluded = (selection) => {
  return selection.state === "excluded";
};
var getLegacyAnalyticsActionForToggleRangeFacetSelect = (facetId2, selection) => {
  const facetValue = `${selection.start}..${selection.end}`;
  const payload = { facetId: facetId2, facetValue };
  return isRangeFacetValueSelected(selection) ? logFacetDeselect(payload) : logFacetSelect(payload);
};
var getAnalyticsActionForToggleFacetSelect2 = (selection) => {
  return isRangeFacetValueSelected(selection) ? facetDeselect() : facetSelect();
};
var getLegacyAnalyticsActionForToggleRangeFacetExclude = (facetId2, selection) => {
  const facetValue = `${selection.start}..${selection.end}`;
  const payload = { facetId: facetId2, facetValue };
  return isRangeFacetValueExcluded(selection) ? logFacetUnexclude(payload) : logFacetExclude(payload);
};

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/range-facet-controller-actions.js
var executeToggleRangeFacetSelect = createAction("rangeFacet/executeToggleSelect", (payload) => validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection)));
var executeToggleRangeFacetExclude = createAction("rangeFacet/executeToggleExclude", (payload) => validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection)));

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-controller-actions.js
var definition2 = {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: dateFacetValueDefinition })
};
var executeToggleDateFacetSelect = createAsyncThunk("dateFacet/executeToggleSelect", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition2);
  dispatch(toggleSelectDateFacetValue(payload));
  dispatch(executeToggleRangeFacetSelect(payload));
  dispatch(updateFacetOptions());
});
var executeToggleDateFacetExclude = createAsyncThunk("dateFacet/executeToggleExclude", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition2);
  dispatch(toggleExcludeDateFacetValue(payload));
  dispatch(executeToggleRangeFacetExclude(payload));
  dispatch(updateFacetOptions());
});

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/core-range-facet-utils.js
function assertRangeFacetOptions(options, controllerName) {
  if (!options.generateAutomaticRanges && options.currentValues === void 0) {
    const message = `currentValues should be specified for ${controllerName} when generateAutomaticRanges is false.`;
    throw new Error(message);
  }
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/headless-core-range-facet.js
function buildCoreRangeFacet(engine, props) {
  const { facetId: facetId2, getRequest } = props;
  const controller = buildController(engine);
  const dispatch = engine.dispatch;
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    isValueSelected: isRangeFacetValueSelected,
    isValueExcluded: isRangeFacetValueExcluded,
    deselectAll() {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateRangeFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = baseFacetResponseSelector(engine.state, facetId2);
      const sortCriterion = request.sortCriteria;
      const resultsMustMatch = request.resultsMustMatch;
      const values = response ? response.values : [];
      const isLoading = isFacetLoadingResponseSelector(engine.state);
      const enabled = getIsEnabled();
      const hasActiveValues = values.some((facetValue) => facetValue.state !== "idle");
      const domain = response == null ? void 0 : response.domain;
      return {
        facetId: facetId2,
        values,
        sortCriterion,
        resultsMustMatch,
        hasActiveValues,
        isLoading,
        enabled,
        domain
      };
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-api/value.js
var facetValueStates = [
  "idle",
  "selected",
  "excluded"
];

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/generic/interfaces/request.js
var rangeFacetSortCriteria = [
  "ascending",
  "descending"
];
var rangeFacetRangeAlgorithm = [
  "even",
  "equiprobable"
];

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/date-facet/headless-date-facet-options.js
var dateRangeRequestDefinition2 = {
  start: new StringValue(),
  end: new StringValue(),
  endInclusive: new BooleanValue(),
  state: new StringValue({ constrainTo: facetValueStates })
};
var dateFacetOptionsSchema = new Schema({
  facetId,
  field,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new ArrayValue({
    each: new RecordValue({ values: dateRangeRequestDefinition2 })
  }),
  sortCriteria: new StringValue({ constrainTo: rangeFacetSortCriteria }),
  rangeAlgorithm: new StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});
function validateDateFacetOptions(engine, options) {
  validateOptions(engine, dateFacetOptionsSchema, options, "buildDateFacet");
  validateManualDateRanges(options);
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/date-facet/headless-core-date-facet.js
function buildCoreDateFacet(engine, props) {
  if (!loadDateFacetReducers(engine)) {
    throw loadReducerError;
  }
  assertRangeFacetOptions(props.options, "buildDateFacet");
  const dispatch = engine.dispatch;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    currentValues: [],
    ...props.options,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateDateFacetOptions(engine, options);
  dispatch(registerDateFacet(options));
  const rangeFacet = buildCoreRangeFacet(engine, {
    facetId: facetId2,
    getRequest: () => engine.state.dateFacetSet[facetId2].request
  });
  return {
    ...rangeFacet,
    toggleSelect: (selection) => dispatch(executeToggleDateFacetSelect({ facetId: facetId2, selection })),
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    toggleExclude: (selection) => dispatch(executeToggleDateFacetExclude({ facetId: facetId2, selection })),
    toggleSingleExclude: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleExclude(selection);
    },
    get state() {
      return rangeFacet.state;
    }
  };
}
function loadDateFacetReducers(engine) {
  engine.addReducers({ configuration, search: searchReducer, dateFacetSet: dateFacetSetReducer, facetOptions: facetOptionsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/range-facet/date-facet/headless-date-facet.js
function buildDateFacet(engine, props) {
  const coreController = buildCoreDateFacet(engine, props);
  const dispatch = engine.dispatch;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch2({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch2({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    toggleSelect: (selection) => {
      coreController.toggleSelect(selection);
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggleRangeFacetSelect(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetSelect2(selection)
      }));
    },
    toggleExclude: (selection) => {
      coreController.toggleExclude(selection);
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggleRangeFacetExclude(getFacetId(), selection)
      }));
    },
    get state() {
      return coreController.state;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/date-facet/headless-core-date-filter.js
function buildCoreDateFilter(engine, props) {
  var _a;
  if (!loadDateFilterReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    ...props.options,
    currentValues: ((_a = props.initialState) == null ? void 0 : _a.range) ? [{ ...props.initialState.range, endInclusive: true, state: "selected" }] : [],
    generateAutomaticRanges: false,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateDateFacetOptions(engine, options);
  dispatch(registerDateFacet(options));
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    clear: () => {
      dispatch(updateDateFacetValues({
        facetId: facetId2,
        values: []
      }));
      dispatch(updateFacetOptions());
    },
    setRange: (range) => {
      const facetValue = {
        ...range,
        state: "selected",
        numberOfResults: 0,
        endInclusive: true
      };
      const updateFacetValuesAction = updateDateFacetValues({
        facetId: facetId2,
        values: [facetValue]
      });
      if (updateFacetValuesAction.error) {
        return false;
      }
      dispatch(updateFacetValuesAction);
      dispatch(updateFacetOptions());
      return true;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const isLoading = isFacetLoadingResponseSelector(getState());
      const enabled = getIsEnabled();
      const selectedRanges = dateFacetSelectedValuesSelector(getState(), facetId2);
      const range = selectedRanges.length ? selectedRanges[0] : void 0;
      return {
        facetId: facetId2,
        isLoading,
        range,
        enabled
      };
    }
  };
}
function loadDateFilterReducer(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/range-facet/date-facet/headless-date-filter.js
function buildDateFilter(engine, props) {
  if (!loadDateFilterReducer2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreDateFilter(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    clear: () => {
      coreController.clear();
      dispatch(executeSearch2({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    setRange: (range) => {
      const success = coreController.setRange(range);
      if (success) {
        dispatch(executeSearch2({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: `${range.start}..${range.end}`
          }),
          next: facetSelect()
        }));
      }
      return success;
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadDateFilterReducer2(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-controller-actions.js
var definition3 = {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: numericFacetValueDefinition })
};
var executeToggleNumericFacetSelect = createAsyncThunk("numericFacet/executeToggleSelect", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition3);
  dispatch(toggleSelectNumericFacetValue(payload));
  dispatch(executeToggleRangeFacetSelect(payload));
  dispatch(updateFacetOptions());
});
var executeToggleNumericFacetExclude = createAsyncThunk("numericFacet/executeToggleExclude", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition3);
  dispatch(toggleExcludeNumericFacetValue(payload));
  dispatch(executeToggleRangeFacetExclude(payload));
  dispatch(updateFacetOptions());
});

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/numeric-facet/headless-numeric-facet-options.js
var numericRangeRequestDefinition = {
  start: new NumberValue(),
  end: new NumberValue(),
  endInclusive: new BooleanValue(),
  state: new StringValue({ constrainTo: facetValueStates })
};
var numericFacetOptionsSchema = new Schema({
  facetId,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  field,
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new ArrayValue({
    each: new RecordValue({ values: numericRangeRequestDefinition })
  }),
  sortCriteria: new StringValue({ constrainTo: rangeFacetSortCriteria }),
  resultsMustMatch: new StringValue({ constrainTo: facetResultsMustMatch }),
  rangeAlgorithm: new StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});
function validateNumericFacetOptions(engine, options) {
  validateOptions(engine, numericFacetOptionsSchema, options, "buildNumericFacet");
  validateManualNumericRanges(options);
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/numeric-facet/numeric-range.js
function buildNumericRange(config) {
  return {
    endInclusive: false,
    state: "idle",
    ...config
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/numeric-facet/headless-core-numeric-facet.js
function buildCoreNumericFacet(engine, props) {
  if (!loadNumericFacetReducers(engine)) {
    throw loadReducerError;
  }
  assertRangeFacetOptions(props.options, "buildNumericFacet");
  const dispatch = engine.dispatch;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    currentValues: [],
    ...props.options,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateNumericFacetOptions(engine, options);
  dispatch(registerNumericFacet(options));
  const rangeFacet = buildCoreRangeFacet(engine, {
    facetId: facetId2,
    getRequest: () => engine.state.numericFacetSet[facetId2].request
  });
  return {
    ...rangeFacet,
    toggleSelect: (selection) => dispatch(executeToggleNumericFacetSelect({ facetId: facetId2, selection })),
    toggleSingleSelect(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    get state() {
      return rangeFacet.state;
    }
  };
}
function loadNumericFacetReducers(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/range-facet/numeric-facet/headless-numeric-facet.js
function buildNumericFacet(engine, props) {
  if (!loadNumericFacetReducers2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreNumericFacet(engine, props);
  const dispatch = engine.dispatch;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch2({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch2({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    toggleSelect: (selection) => {
      coreController.toggleSelect(selection);
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggleRangeFacetSelect(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetSelect2(selection)
      }));
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadNumericFacetReducers2(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/facets/range-facet/numeric-facet/headless-core-numeric-filter.js
function buildCoreNumericFilter(engine, props) {
  var _a;
  if (!loadNumericFilterReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options = {
    ...props.options,
    currentValues: ((_a = props.initialState) == null ? void 0 : _a.range) ? [{ ...props.initialState.range, endInclusive: true, state: "selected" }] : [],
    generateAutomaticRanges: false,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateNumericFacetOptions(engine, options);
  dispatch(registerNumericFacet(options));
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    clear: () => {
      dispatch(updateNumericFacetValues({
        facetId: facetId2,
        values: []
      }));
      dispatch(updateFacetOptions());
    },
    setRange: (range) => {
      const facetValue = {
        ...range,
        state: "selected",
        numberOfResults: 0,
        endInclusive: true
      };
      const updateFacetValuesAction = updateNumericFacetValues({
        facetId: facetId2,
        values: [facetValue]
      });
      if (updateFacetValuesAction.error) {
        return false;
      }
      dispatch(updateFacetValuesAction);
      dispatch(updateFacetOptions());
      return true;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const isLoading = isFacetLoadingResponseSelector(getState());
      const enabled = getIsEnabled();
      const selectedRanges = numericFacetSelectedValuesSelector(getState(), facetId2);
      const range = selectedRanges.length ? selectedRanges[0] : void 0;
      return {
        facetId: facetId2,
        isLoading,
        range,
        enabled
      };
    }
  };
}
function loadNumericFilterReducer(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/facets/range-facet/numeric-facet/headless-numeric-filter.js
function buildNumericFilter(engine, props) {
  if (!loadNumericFilterReducer2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreNumericFilter(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    clear: () => {
      coreController.clear();
      dispatch(executeSearch2({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    setRange: (range) => {
      const success = coreController.setRange(range);
      if (success) {
        dispatch(executeSearch2({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: `${range.start}..${range.end}`
          }),
          next: facetSelect()
        }));
      }
      return success;
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadNumericFilterReducer2(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, configuration, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/field-suggestions/category-facet/headless-category-field-suggestions.js
function buildCategoryFieldSuggestions(engine, props) {
  if (!loadCategoryFieldSuggestionsReducers(engine)) {
    throw loadReducerError;
  }
  const { facetSearch: facetSearchOptions, ...facetOptions } = props.options.facet;
  const facetId2 = determineFacetId(engine, facetOptions);
  engine.dispatch(registerCategoryFacet({
    ...defaultCategoryFacetOptions,
    ...facetOptions,
    facetId: facetId2
  }));
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: { ...facetSearchOptions, facetId: facetId2 },
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest,
    select: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(executeSearch2({
        legacy: logFacetSelect({ facetId: facetId2, facetValue: value.rawValue }),
        next: facetSelect()
      }));
    },
    isForFieldSuggestions: true
  });
  const controller = buildController(engine);
  return {
    ...controller,
    ...facetSearch2,
    updateText: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    get state() {
      return facetSearch2.state;
    }
  };
}
function loadCategoryFieldSuggestionsReducers(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    configuration,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    search: searchReducer
  });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/field-suggestions/facet/headless-field-suggestions.js
function buildFieldSuggestions(engine, props) {
  if (!loadFieldSuggestionsReducers(engine)) {
    throw loadReducerError;
  }
  const { facetSearch: facetSearchOptions, allowedValues: allowedValues2, ...facetOptions } = props.options.facet;
  const facetId2 = determineFacetId(engine, facetOptions);
  engine.dispatch(registerFacet({
    ...defaultFacetOptions,
    ...facetOptions,
    facetId: facetId2,
    ...allowedValues2 && {
      allowedValues: {
        type: "simple",
        values: allowedValues2
      }
    }
  }));
  const facetSearch2 = buildFacetSearch(engine, {
    options: { ...facetSearchOptions, facetId: facetId2 },
    select: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(executeSearch2({
        legacy: logFacetSelect({ facetId: facetId2, facetValue: value.rawValue }),
        next: facetSelect()
      }));
    },
    exclude: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(executeSearch2({
        legacy: logFacetExclude({ facetId: facetId2, facetValue: value.rawValue }),
        next: facetExclude()
      }));
    },
    isForFieldSuggestions: true,
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest
  });
  const controller = buildController(engine);
  return {
    ...controller,
    ...facetSearch2,
    updateText: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    get state() {
      return facetSearch2.state;
    }
  };
}
function loadFieldSuggestionsReducers(engine) {
  engine.addReducers({ facetSet: facetSetReducer, configuration, facetSearchSet: specificFacetSearchSetReducer, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/folding/folding-actions.js
var foldingOptionsSchemaDefinition = {
  collectionField: new StringValue({ emptyAllowed: false, required: false }),
  parentField: new StringValue({ emptyAllowed: false, required: false }),
  childField: new StringValue({ emptyAllowed: false, required: false }),
  numberOfFoldedResults: new NumberValue({ min: 0, required: false })
};
var registerFolding = createAction("folding/register", (payload) => validatePayload(payload, foldingOptionsSchemaDefinition));
var loadCollection = createAsyncThunk("folding/loadCollection", async (collectionId, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const state = getState();
  const sharedWithSearchRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest2(state) : buildSearchAndFoldingLoadCollectionRequest(state, navigatorContext);
  const response = await apiClient.search({
    ...sharedWithSearchRequest,
    q: getQForHighlighting(state),
    enableQuerySyntax: true,
    cq: `@${state.folding.fields.collection}="${collectionId}"`,
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: 100
  }, { origin: "foldingCollection" });
  if (isErrorResponse(response)) {
    return rejectWithValue(response.error);
  }
  return {
    collectionId,
    results: response.success.results,
    searchUid: response.success.searchUid,
    rootResult: state.folding.collections[collectionId].result
  };
});
function getQForHighlighting(state) {
  if (state.query.q === "") {
    return "";
  }
  return state.query.enableQuerySyntax ? `${state.query.q} OR @uri` : `( <@- ${state.query.q} -@> ) OR @uri`;
}

// node_modules/@coveo/headless/dist/esm/features/folding/folding-analytics-actions.js
var logShowMoreFoldedResults = (result) => makeAnalyticsAction("analytics/folding/showMore", (client, state) => {
  validateResultPayload(result);
  return client.makeShowMoreFoldedResults(partialDocumentInformation(result, state), documentIdentifier(result));
});
var logShowLessFoldedResults = () => makeAnalyticsAction("analytics/folding/showLess", (client) => {
  return client.makeShowLessFoldedResults();
});
var foldedResultAnalyticsClient = {
  logShowMoreFoldedResults,
  logShowLessFoldedResults
};

// node_modules/@coveo/headless/dist/esm/features/folding/folding-state.js
var getFoldingInitialState = () => ({
  enabled: false,
  fields: {
    collection: "foldingcollection",
    parent: "foldingparent",
    child: "foldingchild"
  },
  filterFieldRange: 2,
  collections: {}
});

// node_modules/@coveo/headless/dist/esm/features/folding/folding-slice.js
function getCollectionField(result, fields) {
  return result.raw[fields.collection];
}
function getParentField(result, fields) {
  return result.raw[fields.parent];
}
function getChildField(result, fields) {
  const rawValue = result.raw[fields.child];
  if (isArray2(rawValue)) {
    return rawValue[0];
  }
  return rawValue;
}
function areDefinedAndEqual(value1, value2) {
  return (value1 || value2) !== void 0 && value1 === value2;
}
function resolveChildrenFromFields(parent, results, fields, resolvedAncestors = []) {
  const sourceChildValue = getChildField(parent, fields);
  if (!sourceChildValue) {
    return [];
  }
  if (resolvedAncestors.indexOf(sourceChildValue) !== -1) {
    return [];
  }
  return results.filter((result) => {
    const isSameResultAsSource = getChildField(result, fields) === getChildField(parent, fields);
    const isChildOfSource = getParentField(result, fields) === sourceChildValue;
    return isChildOfSource && !isSameResultAsSource;
  }).map((result) => {
    const extendedResult = { ...result, searchUid: parent.searchUid };
    return {
      result: extendedResult,
      children: resolveChildrenFromFields(extendedResult, results, fields, [
        ...resolvedAncestors,
        sourceChildValue
      ])
    };
  });
}
function resolveRootFromFields(results, fields) {
  return results.find((result) => {
    const hasNoParent = getParentField(result, fields) === void 0;
    const isParentOfItself = areDefinedAndEqual(getParentField(result, fields), getChildField(result, fields));
    return hasNoParent || isParentOfItself;
  });
}
function resolveRootFromParentResult(result) {
  if (result.parentResult) {
    return resolveRootFromParentResult(result.parentResult);
  }
  return result;
}
function createCollectionFromResult(relevantResult, fields, searchUid, rootResult) {
  const resultsInCollection = getAllIncludedResultsFrom(relevantResult);
  const resultToUseAsRoot = rootResult ?? resolveRootFromFields(resultsInCollection, fields) ?? resolveRootFromParentResult(relevantResult);
  const extendedResultToUseAsRoot = { ...resultToUseAsRoot, searchUid };
  return {
    result: extendedResultToUseAsRoot,
    children: resolveChildrenFromFields(extendedResultToUseAsRoot, resultsInCollection, fields),
    // To understand why "1" instead of "0", see here : https://coveord.atlassian.net/browse/SEARCHAPI-11075. totalNumberOfChildResults is off by 1 by the index design.
    moreResultsAvailable: relevantResult.totalNumberOfChildResults > 1,
    isLoadingMoreResults: false
  };
}
function createCollections(results, fields, searchUid, rootResult) {
  const collections = {};
  results.forEach((result) => {
    const collectionId = getCollectionField(result, fields);
    if (!collectionId) {
      return;
    }
    if (!getChildField(result, fields) && !result.parentResult) {
      return;
    }
    collections[collectionId] = createCollectionFromResult(result, fields, searchUid, rootResult);
  });
  return collections;
}
function tryGetCollectionFromStateOrThrow(state, collectionId) {
  if (!state.collections[collectionId]) {
    throw new Error(`Missing collection ${collectionId} from ${Object.keys(state.collections)}: Folding most probably in an invalid state...`);
  }
  return state.collections[collectionId];
}
var foldingReducer = createReducer(getFoldingInitialState(), (builder) => builder.addCase(executeSearch2.fulfilled, (state, { payload }) => {
  state.collections = state.enabled ? createCollections(payload.response.results, state.fields, payload.response.searchUid) : {};
}).addCase(fetchPage2.fulfilled, (state, { payload }) => {
  state.collections = state.enabled ? createCollections(payload.response.results, state.fields, payload.response.searchUid) : {};
}).addCase(fetchMoreResults2.fulfilled, (state, { payload }) => {
  state.collections = state.enabled ? {
    ...state.collections,
    ...createCollections(payload.response.results, state.fields, payload.response.searchUid)
  } : {};
}).addCase(registerFolding, (state, { payload }) => state.enabled ? state : {
  enabled: true,
  collections: {},
  fields: {
    collection: payload.collectionField ?? state.fields.collection,
    parent: payload.parentField ?? state.fields.parent,
    child: payload.childField ?? state.fields.child
  },
  filterFieldRange: payload.numberOfFoldedResults ?? state.filterFieldRange
}).addCase(loadCollection.pending, (state, { meta }) => {
  const collectionId = meta.arg;
  tryGetCollectionFromStateOrThrow(state, collectionId).isLoadingMoreResults = true;
}).addCase(loadCollection.rejected, (state, { meta }) => {
  const collectionId = meta.arg;
  tryGetCollectionFromStateOrThrow(state, collectionId).isLoadingMoreResults = false;
}).addCase(loadCollection.fulfilled, (state, { payload: { collectionId, results, rootResult, searchUid } }) => {
  const newCollections = createCollections(results, state.fields, searchUid, rootResult);
  if (!newCollections || !newCollections[collectionId]) {
    throw new Error(`Unable to create collection ${collectionId} from received results: ${JSON.stringify(results)}. Folding most probably in an invalid state... `);
  }
  state.collections[collectionId] = newCollections[collectionId];
  state.collections[collectionId].moreResultsAvailable = false;
}));

// node_modules/@coveo/headless/dist/esm/features/query-suggest/query-suggest-actions.js
var idDefinition = {
  id: requiredNonEmptyString
};
var registerQuerySuggest2 = createAction("querySuggest/register", (payload) => validatePayload(payload, {
  ...idDefinition,
  count: new NumberValue({ min: 0 })
}));
var unregisterQuerySuggest = createAction("querySuggest/unregister", (payload) => validatePayload(payload, idDefinition));
var selectQuerySuggestion2 = createAction("querySuggest/selectSuggestion", (payload) => validatePayload(payload, {
  ...idDefinition,
  expression: requiredEmptyAllowedString
}));
var clearQuerySuggest2 = createAction("querySuggest/clear", (payload) => validatePayload(payload, idDefinition));
var fetchQuerySuggestions2 = createAsyncThunk("querySuggest/fetch", async (payload, { getState, rejectWithValue, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  validatePayload2(payload, idDefinition);
  const id = payload.id;
  const request = await buildQuerySuggestRequest2(id, getState(), navigatorContext);
  const response = await apiClient.querySuggest(request);
  if (isErrorResponse(response)) {
    return rejectWithValue(response.error);
  }
  return {
    id,
    q: request.q,
    ...response.success
  };
});
var buildQuerySuggestRequest2 = async (id, s, navigatorContext) => {
  return {
    accessToken: s.configuration.accessToken,
    organizationId: s.configuration.organizationId,
    url: s.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(s.configuration.organizationId, s.configuration.environment),
    count: s.querySuggest[id].count,
    q: s.querySet[id],
    locale: s.configuration.search.locale,
    timezone: s.configuration.search.timezone,
    actionsHistory: s.configuration.analytics.enabled ? history_store_default.getInstance().getHistory() : [],
    ...s.context && { context: s.context.contextValues },
    ...s.pipeline && { pipeline: s.pipeline },
    ...s.searchHub && { searchHub: s.searchHub },
    tab: s.configuration.analytics.originLevel2,
    ...s.configuration.analytics.enabled && {
      ...s.configuration.analytics.enabled && s.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams2(s.configuration.analytics) : fromAnalyticsStateToAnalyticsParams(s.configuration.analytics, navigatorContext)
    },
    ...s.configuration.search.authenticationProviders.length && {
      authentication: s.configuration.search.authenticationProviders.join(",")
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/query/query-slice.js
var queryReducer = createReducer(getQueryInitialState(), (builder) => builder.addCase(updateQuery, (state, action) => ({ ...state, ...action.payload })).addCase(applyDidYouMeanCorrection, (state, action) => {
  state.q = action.payload;
}).addCase(selectQuerySuggestion2, (state, action) => {
  state.q = action.payload.expression;
}).addCase(change.fulfilled, (state, action) => {
  var _a;
  return ((_a = action.payload) == null ? void 0 : _a.query) ?? state;
}).addCase(restoreSearchParameters, (state, action) => {
  state.q = action.payload.q ?? state.q;
  state.enableQuerySyntax = action.payload.enableQuerySyntax ?? state.enableQuerySyntax;
}));

// node_modules/@coveo/headless/dist/esm/features/fields/fields-actions.js
var registerFieldsToInclude = createAction("fields/registerFieldsToInclude", (payload) => validatePayload(payload, nonEmptyStringArray));
var enableFetchAllFields = createAction("fields/fetchall/enable");
var disableFetchAllFields = createAction("fields/fetchall/disable");
var fetchFieldsDescription = createAsyncThunk("fields/fetchDescription", async (_, { extra, getState, rejectWithValue }) => {
  const state = getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const { apiBaseUrl } = state.configuration.search;
  const descriptions = await extra.apiClient.fieldDescriptions({
    accessToken,
    organizationId,
    url: apiBaseUrl ?? getSearchApiBaseUrl(organizationId, environment)
  });
  if (isErrorResponse(descriptions)) {
    return rejectWithValue(descriptions.error);
  }
  return descriptions.success.fields;
});

// node_modules/@coveo/headless/dist/esm/features/fields/fields-state.js
var MinimumFieldsToInclude = [
  "author",
  "language",
  "urihash",
  "objecttype",
  "collection",
  "source",
  "permanentid"
];
var DefaultFieldsToInclude = [
  ...MinimumFieldsToInclude,
  "date",
  "filetype",
  "parents"
];
var EcommerceDefaultFieldsToInclude = [
  ...DefaultFieldsToInclude,
  "ec_price",
  "ec_name",
  "ec_description",
  "ec_brand",
  "ec_category",
  "ec_item_group_id",
  "ec_shortdesc",
  "ec_thumbnails",
  "ec_images",
  "ec_promo_price",
  "ec_in_stock",
  "ec_rating"
];
var getFieldsInitialState = () => ({
  fieldsToInclude: MinimumFieldsToInclude,
  fetchAllFields: false,
  fieldsDescription: []
});

// node_modules/@coveo/headless/dist/esm/features/fields/fields-slice.js
var fieldsReducer = createReducer(getFieldsInitialState(), (builder) => builder.addCase(registerFieldsToInclude, (state, action) => {
  state.fieldsToInclude = [
    ...new Set(state.fieldsToInclude.concat(action.payload))
  ];
}).addCase(enableFetchAllFields, (state) => {
  state.fetchAllFields = true;
}).addCase(disableFetchAllFields, (state) => {
  state.fetchAllFields = false;
}).addCase(fetchFieldsDescription.fulfilled, (state, { payload }) => {
  state.fieldsDescription = payload;
}).addCase(registerFolding, (state, { payload }) => {
  const defaultFields = getFoldingInitialState().fields;
  state.fieldsToInclude.push(payload.collectionField ?? defaultFields.collection, payload.parentField ?? defaultFields.parent, payload.childField ?? defaultFields.child);
}));

// node_modules/@coveo/headless/dist/esm/controllers/core/status/headless-core-status.js
function buildCoreStatus(engine) {
  if (!loadSearchStateReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        hasError: state.search.error !== null,
        isLoading: state.search.isLoading,
        hasResults: !!state.search.results.length,
        firstSearchExecuted: firstSearchExecutedSelector(state)
      };
    }
  };
}
function loadSearchStateReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/result-list/headless-core-result-list.js
var optionsSchema2 = new Schema({
  fieldsToInclude: new ArrayValue({
    required: false,
    each: new StringValue({
      required: true,
      emptyAllowed: false
    })
  })
});
function buildCoreResultList(engine, props) {
  if (!loadResultListReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const status = buildCoreStatus(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options = validateOptions(engine, optionsSchema2, props == null ? void 0 : props.options, "buildCoreResultList");
  if (options.fieldsToInclude) {
    dispatch(registerFieldsToInclude(options.fieldsToInclude));
  }
  const moreResultsAvailable = () => engine.state.search.results.length < engine.state.search.response.totalCountFiltered;
  let lastFetchCompleted = 0;
  let consecutiveFetches = 0;
  const maxConsecutiveFetches = 5;
  const minDelayBetweenFetches = 200;
  let errorLogged = false;
  const triggerFetchMoreResult = async () => {
    if (engine.state.search.isLoading) {
      return;
    }
    if (!moreResultsAvailable()) {
      engine.logger.info("No more results are available for the result list to fetch.");
      return;
    }
    const delayBetweenFetches = Date.now() - lastFetchCompleted;
    if (delayBetweenFetches < minDelayBetweenFetches) {
      consecutiveFetches++;
      if (consecutiveFetches >= maxConsecutiveFetches) {
        lastFetchCompleted = Date.now();
        !errorLogged && engine.logger.error(`The result list method "fetchMoreResults" execution prevented because it has been triggered consecutively ${maxConsecutiveFetches} times, with little delay. Please verify the conditions under which the function is called.`);
        errorLogged = true;
        return;
      }
    } else {
      consecutiveFetches = 0;
    }
    errorLogged = false;
    if (props == null ? void 0 : props.fetchMoreResultsActionCreator) {
      await dispatch(props == null ? void 0 : props.fetchMoreResultsActionCreator());
      lastFetchCompleted = Date.now();
    }
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...status.state,
        results: state.search.results,
        moreResultsAvailable: moreResultsAvailable(),
        searchResponseId: state.search.searchResponseId
      };
    },
    fetchMoreResults: triggerFetchMoreResult
  };
}
function loadResultListReducers(engine) {
  engine.addReducers({ search: searchReducer, configuration, fields: fieldsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/folded-result-list/headless-core-folded-result-list.js
var optionsSchema3 = new Schema(foldingOptionsSchemaDefinition);
function buildCoreFoldedResultList(engine, props, analyticsClient) {
  var _a;
  if (!loadFoldingReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildCoreResultList(engine, props);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options = ((_a = props.options) == null ? void 0 : _a.folding) ? validateOptions(engine, optionsSchema3, props.options.folding, "buildFoldedResultList") : {};
  dispatch(registerFolding({ ...options }));
  return {
    ...controller,
    loadCollection: (collection) => {
      dispatch(props.loadCollectionActionCreator(collection.result.raw[engine.state.folding.fields.collection]));
      dispatch(analyticsClient.logShowMoreFoldedResults(collection.result));
    },
    logShowMoreFoldedResults: (result) => {
      dispatch(analyticsClient.logShowMoreFoldedResults(result));
    },
    logShowLessFoldedResults: () => {
      dispatch(analyticsClient.logShowLessFoldedResults());
    },
    findResultById(collection) {
      return searchForResult(this.state.results, (r) => r.result.uniqueId === collection.result.uniqueId);
    },
    findResultByCollection(collection) {
      return searchForResult(this.state.results, (r) => r.result.raw.foldingcollection === collection.result.raw.foldingcollection);
    },
    get state() {
      const state = getState();
      return {
        ...controller.state,
        results: controller.state.results.map((result) => {
          const collectionId = result.raw[state.folding.fields.collection];
          if (!collectionId || !state.folding.collections[collectionId]) {
            return {
              result,
              moreResultsAvailable: false,
              isLoadingMoreResults: false,
              children: []
            };
          }
          return state.folding.collections[collectionId];
        })
      };
    }
  };
}
function loadFoldingReducer(engine) {
  engine.addReducers({ search: searchReducer, configuration: configurationReducer, folding: foldingReducer, query: queryReducer });
  return true;
}
function searchForResult(results, compareCb) {
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    if (compareCb(result)) {
      return result;
    }
    if (result.children.length) {
      const childResult = searchForResult(result.children, compareCb);
      if (childResult) {
        return childResult;
      }
    }
  }
  return null;
}

// node_modules/@coveo/headless/dist/esm/controllers/folded-result-list/headless-folded-result-list.js
function buildFoldedResultList(engine, props = {}) {
  const foldedResultList = buildCoreFoldedResultList(engine, {
    ...props,
    loadCollectionActionCreator: loadCollection,
    fetchMoreResultsActionCreator: fetchMoreResults2
  }, foldedResultAnalyticsClient);
  return {
    ...foldedResultList,
    get state() {
      return foldedResultList.state;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-state.js
function getGeneratedAnswerInitialState() {
  return {
    id: "",
    isVisible: true,
    isEnabled: true,
    isLoading: false,
    isStreaming: false,
    citations: [],
    liked: false,
    disliked: false,
    responseFormat: {
      contentFormat: ["text/plain"]
    },
    feedbackModalOpen: false,
    feedbackSubmitted: false,
    fieldsToIncludeInCitations: [],
    isAnswerGenerated: false,
    expanded: false,
    cannotAnswer: false,
    answerApiQueryParams: void 0,
    answerId: void 0,
    answerGenerationMode: "automatic"
  };
}

// node_modules/@coveo/headless/dist/esm/features/generated-answer/utils/generated-answer-citation-utils.js
function filterOutDuplicatedCitations(citations) {
  const citationUris = /* @__PURE__ */ new Set();
  return citations.filter((citation) => {
    const isCitationUriUnique = !citationUris.has(citation.uri);
    if (isCitationUriUnique) {
      citationUris.add(citation.uri);
    }
    return isCitationUriUnique;
  });
}

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-slice.js
var generatedAnswerReducer = createReducer(getGeneratedAnswerInitialState(), (builder) => builder.addCase(setIsVisible, (state, { payload }) => {
  state.isVisible = payload;
}).addCase(setIsEnabled2, (state, { payload }) => {
  state.isEnabled = payload;
}).addCase(setId, (state, { payload }) => {
  state.id = payload.id;
}).addCase(updateMessage, (state, { payload }) => {
  state.isLoading = false;
  state.isStreaming = true;
  if (!state.answer) {
    state.answer = "";
  }
  state.answer += payload.textDelta;
  delete state.error;
}).addCase(updateCitations, (state, { payload }) => {
  state.isLoading = false;
  state.isStreaming = true;
  state.citations = filterOutDuplicatedCitations([
    ...state.citations,
    ...payload.citations
  ]);
  delete state.error;
}).addCase(updateError, (state, { payload }) => {
  state.isLoading = false;
  state.isStreaming = false;
  state.error = {
    ...payload,
    isRetryable: payload.code === RETRYABLE_STREAM_ERROR_CODE
  };
  state.citations = [];
  delete state.answer;
}).addCase(likeGeneratedAnswer, (state) => {
  state.liked = true;
  state.disliked = false;
}).addCase(dislikeGeneratedAnswer, (state) => {
  state.liked = false;
  state.disliked = true;
}).addCase(openGeneratedAnswerFeedbackModal, (state) => {
  state.feedbackModalOpen = true;
}).addCase(closeGeneratedAnswerFeedbackModal, (state) => {
  state.feedbackModalOpen = false;
}).addCase(sendGeneratedAnswerFeedback, (state) => {
  state.feedbackSubmitted = true;
}).addCase(resetAnswer, (state) => {
  return {
    ...getGeneratedAnswerInitialState(),
    ...state.answerConfigurationId ? { answerConfigurationId: state.answerConfigurationId } : {},
    responseFormat: state.responseFormat,
    fieldsToIncludeInCitations: state.fieldsToIncludeInCitations,
    isVisible: state.isVisible,
    id: state.id
  };
}).addCase(setIsLoading, (state, { payload }) => {
  state.isLoading = payload;
}).addCase(setIsStreaming, (state, { payload }) => {
  state.isStreaming = payload;
}).addCase(setAnswerContentFormat, (state, { payload }) => {
  state.answerContentFormat = payload;
}).addCase(updateResponseFormat, (state, { payload }) => {
  state.responseFormat = payload;
}).addCase(registerFieldsToIncludeInCitations, (state, action) => {
  state.fieldsToIncludeInCitations = [
    ...new Set(state.fieldsToIncludeInCitations.concat(action.payload))
  ];
}).addCase(setIsAnswerGenerated, (state, { payload }) => {
  state.isAnswerGenerated = payload;
}).addCase(expandGeneratedAnswer, (state) => {
  state.expanded = true;
}).addCase(collapseGeneratedAnswer, (state) => {
  state.expanded = false;
}).addCase(updateAnswerConfigurationId, (state, { payload }) => {
  state.answerConfigurationId = payload;
}).addCase(setCannotAnswer, (state, { payload }) => {
  state.cannotAnswer = payload;
}).addCase(setAnswerApiQueryParams, (state, { payload }) => {
  state.answerApiQueryParams = payload;
}).addCase(setAnswerId2, (state, { payload }) => {
  state.answerId = payload;
}).addCase(setAnswerGenerationMode, (state, { payload }) => {
  state.answerGenerationMode = payload;
}));

// node_modules/@coveo/headless/dist/esm/controllers/core/generated-answer/headless-core-generated-answer.js
function buildCoreGeneratedAnswer(engine, analyticsClient, props = {}) {
  var _a, _b, _c;
  if (!loadGeneratedAnswerReducer(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const controller = buildController(engine);
  const getState = () => engine.state;
  const isVisible = (_a = props.initialState) == null ? void 0 : _a.isVisible;
  if (isVisible !== void 0) {
    dispatch(setIsVisible(isVisible));
  }
  const initialResponseFormat = (_b = props.initialState) == null ? void 0 : _b.responseFormat;
  if (initialResponseFormat) {
    dispatch(updateResponseFormat(initialResponseFormat));
  }
  const fieldsToIncludeInCitations = props.fieldsToIncludeInCitations;
  if (fieldsToIncludeInCitations) {
    dispatch(registerFieldsToIncludeInCitations(fieldsToIncludeInCitations));
  }
  const expanded = (_c = props.initialState) == null ? void 0 : _c.expanded;
  if (expanded) {
    dispatch(expandGeneratedAnswer());
  }
  return {
    ...controller,
    get state() {
      return getState().generatedAnswer;
    },
    like() {
      if (!this.state.liked) {
        dispatch(likeGeneratedAnswer());
        dispatch(analyticsClient.logLikeGeneratedAnswer());
      }
    },
    dislike() {
      if (!this.state.disliked) {
        dispatch(dislikeGeneratedAnswer());
        dispatch(analyticsClient.logDislikeGeneratedAnswer());
      }
    },
    openFeedbackModal() {
      dispatch(openGeneratedAnswerFeedbackModal());
    },
    closeFeedbackModal() {
      dispatch(closeGeneratedAnswerFeedbackModal());
    },
    sendFeedback(feedback) {
      dispatch(analyticsClient.logGeneratedAnswerFeedback(feedback));
      dispatch(sendGeneratedAnswerFeedback());
    },
    logCitationClick(citationId) {
      dispatch(analyticsClient.logOpenGeneratedAnswerSource(citationId));
    },
    logCitationHover(citationId, citationHoverTimeMs) {
      dispatch(analyticsClient.logHoverCitation(citationId, citationHoverTimeMs));
    },
    show() {
      if (!this.state.isVisible) {
        dispatch(setIsVisible(true));
        dispatch(analyticsClient.logGeneratedAnswerShowAnswers());
      }
    },
    hide() {
      if (this.state.isVisible) {
        dispatch(setIsVisible(false));
        dispatch(analyticsClient.logGeneratedAnswerHideAnswers());
      }
    },
    expand() {
      if (!this.state.expanded) {
        dispatch(expandGeneratedAnswer());
        dispatch(analyticsClient.logGeneratedAnswerExpand());
      }
    },
    collapse() {
      if (this.state.expanded) {
        dispatch(collapseGeneratedAnswer());
        dispatch(analyticsClient.logGeneratedAnswerCollapse());
      }
    },
    enable() {
      if (!this.state.isEnabled) {
        dispatch(setIsEnabled2(true));
      }
    },
    disable() {
      if (this.state.isEnabled) {
        dispatch(setIsEnabled2(false));
      }
    },
    logCopyToClipboard() {
      dispatch(analyticsClient.logCopyGeneratedAnswer());
    },
    retry() {
    }
  };
}
function loadGeneratedAnswerReducer(engine) {
  engine.addReducers({ generatedAnswer: generatedAnswerReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/generated-answer/headless-searchapi-generated-answer.js
var subscribeStateManager = {
  engines: {},
  setAbortControllerRef: (ref, genQaEngineId) => {
    subscribeStateManager.engines[genQaEngineId].abortController = ref;
  },
  getIsStreamInProgress: (genQaEngineId) => {
    var _a;
    if (!subscribeStateManager.engines[genQaEngineId].abortController || ((_a = subscribeStateManager.engines[genQaEngineId].abortController) == null ? void 0 : _a.signal.aborted)) {
      subscribeStateManager.engines[genQaEngineId].abortController = void 0;
      return false;
    }
    return true;
  },
  subscribeToSearchRequests: (engine) => {
    const strictListener = () => {
      var _a;
      const state = engine.state;
      const requestId = state.search.requestId;
      const streamId = state.search.extendedResults.generativeQuestionAnsweringId;
      const genQaEngineId = state.generatedAnswer.id;
      if (subscribeStateManager.engines[genQaEngineId].lastRequestId !== requestId) {
        subscribeStateManager.engines[genQaEngineId].lastRequestId = requestId;
        (_a = subscribeStateManager.engines[genQaEngineId].abortController) == null ? void 0 : _a.abort();
        if (state.generatedAnswer.isEnabled === false) {
          return;
        }
        engine.dispatch(resetAnswer());
      }
      const isStreamInProgress = subscribeStateManager.getIsStreamInProgress(genQaEngineId);
      if (!isStreamInProgress && streamId && streamId !== subscribeStateManager.engines[genQaEngineId].lastStreamId) {
        subscribeStateManager.engines[genQaEngineId].lastStreamId = streamId;
        if (state.generatedAnswer.isEnabled === false) {
          return;
        }
        engine.dispatch(streamAnswer({
          setAbortControllerRef: (ref) => subscribeStateManager.setAbortControllerRef(ref, genQaEngineId)
        }));
      }
    };
    return engine.subscribe(strictListener);
  }
};
function buildSearchAPIGeneratedAnswer(engine, analyticsClient, props = {}) {
  if (!loadGeneratedAnswerReducer2(engine)) {
    throw loadReducerError;
  }
  const controller = buildCoreGeneratedAnswer(engine, analyticsClient, props);
  const getState = () => engine.state;
  if (engine.state.generatedAnswer.id && !subscribeStateManager.engines[engine.state.generatedAnswer.id]) {
    subscribeStateManager.engines[engine.state.generatedAnswer.id] = {
      abortController: void 0,
      lastRequestId: engine.state.search.requestId,
      lastStreamId: engine.state.search.extendedResults.generativeQuestionAnsweringId ?? ""
    };
  }
  if (!engine.state.generatedAnswer.id) {
    const genQaEngineId = randomID("genQA-", 12);
    engine.dispatch(setId({ id: genQaEngineId }));
  }
  if (!subscribeStateManager.engines[engine.state.generatedAnswer.id]) {
    subscribeStateManager.engines[engine.state.generatedAnswer.id] = {
      abortController: void 0,
      lastRequestId: "",
      lastStreamId: ""
    };
  }
  subscribeStateManager.subscribeToSearchRequests(engine);
  const isSearchEngine = (engine2) => "executeFirstSearchAfterStandaloneSearchBoxRedirect" in engine2;
  return {
    ...controller,
    get state() {
      return getState().generatedAnswer;
    },
    retry() {
      if (!isSearchEngine(engine)) {
        return;
      }
      engine.dispatch(executeSearch2({
        legacy: analyticsClient.logRetryGeneratedAnswer()
      }));
    }
  };
}
function loadGeneratedAnswerReducer2(engine) {
  engine.addReducers({ generatedAnswer: generatedAnswerReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/api/knowledge/post-answer-evaluation.js
var answerEvaluation = answerSlice.injectEndpoints({
  endpoints: (builder) => ({
    /**
     * Based on the RTKQuery documentation, the `query` method is typically utilized for GET requests,
     * while the `mutation` method is designed for POST requests.
     * However, in this instance,
     * we hypothesize that the use of `mutation` is incompatible when paired with an empty response body and an 'application/json' content-type response header.
     * This should be updated as soon as we can remove the content-type header from the response.
     * @see https://redux-toolkit.js.org/rtk-query/usage/mutations#mutations
     */
    post: builder.query({
      query: (body) => ({
        url: "/evaluations",
        method: "POST",
        body
      })
    })
  })
});

// node_modules/@coveo/headless/dist/esm/controllers/knowledge/generated-answer/headless-answerapi-generated-answer.js
var parseEvaluationDetails2 = (detail) => {
  if (detail === "yes") {
    return true;
  }
  if (detail === "no") {
    return false;
  }
  return null;
};
var parseEvaluationArguments = ({ answerApiState, feedback, query: query2 }) => ({
  additionalNotes: feedback.details ?? null,
  answer: {
    text: answerApiState.answer,
    responseId: answerApiState.answerId,
    format: answerApiState.contentFormat ?? "text/plain"
  },
  correctAnswerUrl: feedback.documentUrl ?? null,
  details: {
    correctTopic: parseEvaluationDetails2(feedback.correctTopic),
    documented: parseEvaluationDetails2(feedback.documented),
    hallucinationFree: parseEvaluationDetails2(feedback.hallucinationFree),
    readable: parseEvaluationDetails2(feedback.readable)
  },
  helpful: feedback.helpful,
  question: query2
});
var subscribeToSearchRequest = (engine) => {
  let lastRequestId = "";
  const strictListener = () => {
    var _a;
    const state = engine.state;
    const triggerParams = selectAnswerTriggerParams(state);
    const currentRequestId = triggerParams.requestId;
    const newSearchRequestDetected = currentRequestId !== lastRequestId;
    if (newSearchRequestDetected) {
      lastRequestId = currentRequestId;
      engine.dispatch(resetAnswer());
      if (((_a = triggerParams.q) == null ? void 0 : _a.length) > 0) {
        engine.dispatch(generateAnswer());
      }
    }
  };
  engine.subscribe(strictListener);
};
function buildAnswerApiGeneratedAnswer(engine, analyticsClient, props = {}) {
  if (!loadAnswerApiReducers(engine)) {
    throw loadReducerError;
  }
  warnIfUsingNextAnalyticsModeForServiceFeature(engine.state.configuration.analytics.analyticsMode);
  const { ...controller } = buildCoreGeneratedAnswer(engine, analyticsClient, props);
  const getState = () => engine.state;
  engine.dispatch(updateAnswerConfigurationId(props.answerConfigurationId));
  subscribeToSearchRequest(engine);
  return {
    ...controller,
    get state() {
      var _a, _b;
      const answerApiState = selectAnswer2(engine.state).data;
      const state = getState().generatedAnswer;
      return {
        ...state,
        answer: answerApiState == null ? void 0 : answerApiState.answer,
        citations: filterOutDuplicatedCitations((answerApiState == null ? void 0 : answerApiState.citations) ?? []),
        error: {
          message: (_a = answerApiState == null ? void 0 : answerApiState.error) == null ? void 0 : _a.message,
          statusCode: (_b = answerApiState == null ? void 0 : answerApiState.error) == null ? void 0 : _b.code
        },
        isLoading: (answerApiState == null ? void 0 : answerApiState.isLoading) ?? false,
        isStreaming: (answerApiState == null ? void 0 : answerApiState.isStreaming) ?? false,
        answerContentFormat: (answerApiState == null ? void 0 : answerApiState.contentFormat) ?? "text/plain",
        isAnswerGenerated: (answerApiState == null ? void 0 : answerApiState.generated) ?? false,
        cannotAnswer: state.cannotAnswer || (answerApiState == null ? void 0 : answerApiState.generated) === false && !(answerApiState == null ? void 0 : answerApiState.isLoading) && !(answerApiState == null ? void 0 : answerApiState.isStreaming)
      };
    },
    retry() {
      const answerApiQueryParams = selectAnswerApiQueryParams(getState());
      engine.dispatch(fetchAnswer(answerApiQueryParams ?? skipToken));
    },
    reset() {
      engine.dispatch(resetAnswer());
    },
    async sendFeedback(feedback) {
      engine.dispatch(analyticsClient.logGeneratedAnswerFeedback(feedback));
      const args = parseEvaluationArguments({
        query: getState().query.q,
        feedback,
        answerApiState: selectAnswer2(engine.state).data
      });
      engine.dispatch(answerEvaluation.endpoints.post.initiate(args));
      engine.dispatch(sendGeneratedAnswerFeedback());
    }
  };
}
function loadAnswerApiReducers(engine) {
  engine.addReducers({ [answerApi.reducerPath]: answerApi.reducer, query: queryReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/follow-up-answers/follow-up-answers-state.js
function getFollowUpAnswersInitialState() {
  return {
    conversationId: "",
    isEnabled: false,
    followUpAnswers: []
  };
}
var createInitialFollowUpAnswer = (question) => ({
  question,
  isLoading: false,
  isStreaming: false,
  citations: [],
  liked: false,
  disliked: false,
  feedbackSubmitted: false,
  cannotAnswer: false,
  isActive: true
});

// node_modules/@coveo/headless/dist/esm/features/follow-up-answers/follow-up-answers-slice.js
function getActiveFollowUp(state) {
  return state.followUpAnswers.find((a) => a.isActive);
}
function getFollowUpByAnswerId(state, answerId) {
  return state.followUpAnswers.find((a) => a.answerId === answerId);
}
var followUpAnswersReducer = createReducer(getFollowUpAnswersInitialState(), (builder) => builder.addCase(setIsEnabled, (state, { payload }) => {
  state.isEnabled = payload;
}).addCase(setFollowUpAnswersConversationId, (state, { payload }) => {
  state.conversationId = payload;
}).addCase(createFollowUpAnswer, (state, { payload }) => {
  const active = getActiveFollowUp(state);
  if (active) {
    active.isActive = false;
  }
  state.followUpAnswers.push(createInitialFollowUpAnswer(payload.question));
}).addCase(setActiveFollowUpAnswerId, (state, { payload }) => {
  const activeFollowUp = getActiveFollowUp(state);
  if (!activeFollowUp || activeFollowUp.answerId) {
    return;
  }
  activeFollowUp.answerId = payload;
}).addCase(setFollowUpAnswerContentFormat, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.answerContentFormat = payload.contentFormat;
}).addCase(setFollowUpIsLoading, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.isLoading = payload.isLoading;
}).addCase(followUpMessageChunkReceived, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.isLoading = false;
  followUpAnswer.isStreaming = true;
  if (!followUpAnswer.answer) {
    followUpAnswer.answer = "";
  }
  followUpAnswer.answer += payload.textDelta;
  delete followUpAnswer.error;
}).addCase(followUpCitationsReceived, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.isLoading = false;
  followUpAnswer.isStreaming = true;
  followUpAnswer.citations = filterOutDuplicatedCitations([
    ...followUpAnswer.citations,
    ...payload.citations
  ]);
  delete followUpAnswer.error;
}).addCase(followUpCompleted, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.isLoading = false;
  followUpAnswer.isStreaming = false;
  followUpAnswer.isActive = false;
  followUpAnswer.cannotAnswer = !!payload.cannotAnswer;
}).addCase(followUpFailed, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.isLoading = false;
  followUpAnswer.isStreaming = false;
  followUpAnswer.error = { message: payload.message, code: payload.code };
  followUpAnswer.citations = [];
  delete followUpAnswer.answer;
}).addCase(likeFollowUp, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.liked = true;
  followUpAnswer.disliked = false;
}).addCase(dislikeFollowUp, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.liked = false;
  followUpAnswer.disliked = true;
}).addCase(submitFollowUpFeedback, (state, { payload }) => {
  const followUpAnswer = getFollowUpByAnswerId(state, payload.answerId);
  if (!followUpAnswer) {
    return;
  }
  followUpAnswer.feedbackSubmitted = true;
}).addCase(resetFollowUpAnswers, (state) => {
  state.followUpAnswers = [];
  state.conversationId = "";
}));

// node_modules/@coveo/headless/dist/esm/controllers/knowledge/generated-answer/headless-generated-answer-with-follow-ups.js
function buildGeneratedAnswerWithFollowUps(engine, analyticsClient, props) {
  if (!props.agentId || props.agentId.trim() === "") {
    throw new Error("agentId is required for GeneratedAnswerWithFollowUps");
  }
  if (!loadReducers2(engine)) {
    throw loadReducerError;
  }
  const { ...controller } = buildCoreGeneratedAnswer(engine, analyticsClient, props);
  const getState = () => engine.state;
  engine.dispatch(setAgentId(props.agentId));
  return {
    ...controller,
    get state() {
      var _a;
      const clientState = getState().generatedAnswer;
      const answerApiQueryParams = selectAnswerApiQueryParams(engine.state) ?? {};
      const headAnswerArgs = {
        ...answerApiQueryParams,
        strategyKey: "head-answer"
      };
      const serverState = (_a = selectAnswer(headAnswerArgs, engine.state)) == null ? void 0 : _a.data;
      const followUpAnswersState = getState().followUpAnswers;
      return {
        /** Server-owned (RTK Query) */
        answer: serverState == null ? void 0 : serverState.answer,
        answerContentFormat: (serverState == null ? void 0 : serverState.contentFormat) ?? "text/plain",
        citations: (serverState == null ? void 0 : serverState.citations) ?? [],
        isLoading: (serverState == null ? void 0 : serverState.isLoading) ?? false,
        isStreaming: (serverState == null ? void 0 : serverState.isStreaming) ?? false,
        ...(serverState == null ? void 0 : serverState.error) && { error: serverState.error },
        answerId: serverState == null ? void 0 : serverState.answerId,
        isAnswerGenerated: Boolean(serverState == null ? void 0 : serverState.generated),
        cannotAnswer: (serverState == null ? void 0 : serverState.generated) === false,
        /** Client-owned (Redux) */
        isVisible: clientState.isVisible,
        expanded: clientState.expanded,
        liked: clientState.liked,
        disliked: clientState.disliked,
        feedbackSubmitted: clientState.feedbackSubmitted,
        feedbackModalOpen: clientState.feedbackModalOpen,
        isEnabled: clientState.isEnabled,
        responseFormat: clientState.responseFormat,
        fieldsToIncludeInCitations: clientState.fieldsToIncludeInCitations,
        answerGenerationMode: clientState.answerGenerationMode,
        id: clientState.id,
        /** Follow-up answers state */
        followUpAnswers: followUpAnswersState
      };
    },
    retry() {
      engine.dispatch(generateHeadAnswer());
    },
    like(answerId) {
      if (!answerId || this.state.answerId === answerId) {
        controller.like();
        return;
      }
      engine.dispatch(likeFollowUp({ answerId }));
    },
    dislike(answerId) {
      if (!answerId || this.state.answerId === answerId) {
        controller.dislike();
        return;
      }
      engine.dispatch(dislikeFollowUp({ answerId }));
    },
    logCopyToClipboard(answerId) {
      if (!answerId || this.state.answerId === answerId) {
        controller.logCopyToClipboard();
        return;
      }
      console.warn("Method not yet implemented to send analytics for copy to clipboard on a followup answer");
    },
    askFollowUp(question) {
      if (!question || question.trim() === "") {
        return;
      }
      engine.dispatch(generateFollowUpAnswer(question));
    }
  };
}
function loadReducers2(engine) {
  engine.addReducers({
    [answerGenerationApi.reducerPath]: answerGenerationApi.reducer,
    followUpAnswers: followUpAnswersReducer
  });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/generated-answer/headless-generated-answer.js
function buildGeneratedAnswer(engine, props = {}) {
  warnIfUsingNextAnalyticsModeForServiceFeature(engine.state.configuration.analytics.analyticsMode);
  let controller;
  if (props.agentId && props.agentId.trim() !== "") {
    controller = buildGeneratedAnswerWithFollowUps(engine, generatedAnswerAnalyticsClient, { ...props, agentId: props.agentId });
  } else if (props.answerConfigurationId && props.answerConfigurationId.trim() !== "") {
    controller = buildAnswerApiGeneratedAnswer(engine, generatedAnswerAnalyticsClient, props);
  } else {
    controller = buildSearchAPIGeneratedAnswer(engine, generatedAnswerAnalyticsClient, props);
  }
  return {
    ...controller,
    get state() {
      return controller.state;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/interactive-result/headless-core-interactive-result.js
function buildInteractiveResultCore(engine, props, action) {
  if (!loadInteractiveResultCoreReducers(engine)) {
    throw loadReducerError;
  }
  const defaultDelay = 1e3;
  const options = {
    selectionDelay: defaultDelay,
    debounceWait: defaultDelay,
    ...props.options
  };
  let longPressTimer;
  return {
    select: debounce(action, options.debounceWait, { isImmediate: true }),
    beginDelayedSelect() {
      longPressTimer = setTimeout(action, options.selectionDelay);
    },
    cancelPendingSelect() {
      longPressTimer && clearTimeout(longPressTimer);
    }
  };
}
function loadInteractiveResultCoreReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/generated-answer/headless-core-interactive-citation.js
function buildInteractiveCitationCore(engine, analyticsClient, props) {
  let wasOpened = false;
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(analyticsClient.logOpenGeneratedAnswerSource(props.options.citation.id));
  };
  const action = () => {
    logAnalyticsIfNeverOpened();
  };
  return buildInteractiveResultCore(engine, props, action);
}

// node_modules/@coveo/headless/dist/esm/controllers/generated-answer/headless-interactive-citation.js
function buildInteractiveCitation(engine, props) {
  return buildInteractiveCitationCore(engine, generatedAnswerAnalyticsClient, props);
}

// node_modules/@coveo/headless/dist/esm/features/commerce/parameters/parameters-schema.js
var parametersDefinition = {
  f: new RecordValue(),
  fExcluded: new RecordValue(),
  lf: new RecordValue(),
  cf: new RecordValue(),
  nf: new RecordValue(),
  nfExcluded: new RecordValue(),
  mnf: new RecordValue(),
  mnfExcluded: new RecordValue(),
  df: new RecordValue(),
  dfExcluded: new RecordValue(),
  sortCriteria: new RecordValue(),
  page: new NumberValue({ min: 0 }),
  perPage: new NumberValue({ min: 1 })
};

// node_modules/@coveo/headless/dist/esm/features/commerce/product-listing-parameters/product-listing-parameters-actions.js
var restoreProductListingParameters = createAction("commerce/productListingParameters/restore", (payload) => validatePayload(payload, parametersDefinition));

// node_modules/@coveo/headless/dist/esm/features/commerce/search-parameters/search-parameters-schema.js
var searchParametersDefinition2 = {
  q: new StringValue(),
  ...parametersDefinition
};

// node_modules/@coveo/headless/dist/esm/features/commerce/search-parameters/search-parameters-actions.js
var restoreSearchParameters2 = createAction("commerce/searchParameters/restore", (payload) => validatePayload(payload, searchParametersDefinition2));

// node_modules/@coveo/headless/dist/esm/features/facets/facet-order/facet-order-slice.js
var facetOrderReducer = createReducer(getFacetOrderInitialState(), (builder) => {
  builder.addCase(executeSearch2.fulfilled, handleQueryFulfilled).addCase(fetchProductListing.fulfilled, handleQueryFulfilled).addCase(executeSearch3.fulfilled, handleQueryFulfilled).addCase(restoreSearchParameters2, handleRestoreParameters).addCase(restoreProductListingParameters, handleRestoreParameters).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.facetOrder) ?? state;
  }).addCase(setView, () => getFacetOrderInitialState()).addCase(setContext3, () => getFacetOrderInitialState());
});
function handleQueryFulfilled(_, action) {
  return action.payload.response.facets.map((facet) => facet.facetId);
}
function handleRestoreParameters(_, action) {
  return [
    ...Object.keys(action.payload.f ?? {}),
    ...Object.keys(action.payload.lf ?? {}),
    ...Object.keys(action.payload.nf ?? {}),
    ...Object.keys(action.payload.df ?? {}),
    ...Object.keys(action.payload.cf ?? {}),
    ...Object.keys(action.payload.mnf ?? {})
  ];
}

// node_modules/@coveo/headless/dist/esm/features/history/history-analytics-actions.js
var logNavigateForward = () => makeAnalyticsAction(
  "history/analytics/forward",
  (client) => client.makeSearchEvent("historyForward")
  // TODO: Need to create this event natively in coveo.analytics to remove cast
);
var logNavigateBackward = () => makeAnalyticsAction(
  "history/analytics/backward",
  (client) => client.makeSearchEvent("historyBackward")
  // TODO: Need to create this event natively in coveo.analytics to remove cast
);
var logNoResultsBack = () => makeAnalyticsAction("history/analytics/noresultsback", (client) => client.makeNoResultsBack());

// node_modules/@coveo/headless/dist/esm/app/undoable.js
var MAX_PAST_HISTORY_ENTRY_COUNT = 10;
var makeHistory = (state) => ({
  past: [],
  present: state,
  future: []
});
var undo2 = (state) => {
  const { past, present, future } = state;
  if (!present) {
    return state;
  }
  if (past.length === 0) {
    return state;
  }
  const previous = past[past.length - 1];
  const newPast = past.slice(0, past.length - 1);
  return {
    past: newPast,
    present: previous,
    future: [present, ...future]
  };
};
var redo2 = (state) => {
  const { past, present, future } = state;
  if (!present) {
    return state;
  }
  if (future.length === 0) {
    return state;
  }
  const next = future[0];
  const newFuture = future.slice(1);
  return {
    past: [...past, present],
    present: next,
    future: newFuture
  };
};
var updateHistory = (options) => {
  const { action, state, reducer } = options;
  const { past, present } = state;
  const newPresent = reducer(present, action);
  if (!present) {
    return makeHistory(newPresent);
  }
  if (present === newPresent) {
    return state;
  }
  return {
    past: [...past, present].slice(-MAX_PAST_HISTORY_ENTRY_COUNT),
    present: newPresent,
    future: []
  };
};
var undoable = (options) => {
  const { actionTypes, reducer } = options;
  const emptyHistoryState = makeHistory();
  return (state = emptyHistoryState, action) => {
    switch (action.type) {
      case actionTypes.undo:
        return undo2(state);
      case actionTypes.redo:
        return redo2(state);
      case actionTypes.snapshot:
        return updateHistory({
          state,
          reducer,
          action
        });
      default:
        return state;
    }
  };
};

// node_modules/fast-equals/dist/esm/index.mjs
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual2(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    var cache2 = state.cache;
    var cachedA = cache2.get(a);
    var cachedB = cache2.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache2.set(a, b);
    cache2.set(b, a);
    var result = areItemsEqual(a, b, state);
    cache2.delete(a);
    cache2.delete(b);
    return result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || function(object, property) {
  return hasOwnProperty.call(object, property);
};
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var keys = Object.keys;
function areArraysEqual(a, b, state) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.entries();
  var aResult;
  var bResult;
  var index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value;
      var bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  var properties = keys(a);
  var index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  var properties = getStrictProperties(a);
  var index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var URL_TAG = "[object URL]";
var isArray3 = Array.isArray;
var isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign2 = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a) {
  var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areErrorsEqual2 = _a.areErrorsEqual, areFunctionsEqual2 = _a.areFunctionsEqual, areMapsEqual2 = _a.areMapsEqual, areNumbersEqual2 = _a.areNumbersEqual, areObjectsEqual2 = _a.areObjectsEqual, arePrimitiveWrappersEqual2 = _a.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, areTypedArraysEqual2 = _a.areTypedArraysEqual, areUrlsEqual2 = _a.areUrlsEqual;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    var type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    var constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (isArray3(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (isTypedArray != null && isTypedArray(a)) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    var tag = getTag(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a) {
  var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;
  var config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig) {
    config = assign2({}, config, createCustomConfig(config));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign2({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a, b, state);
  };
}
function createIsEqual(_a) {
  var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;
  if (createState) {
    return function isEqual2(a, b) {
      var _a2 = createState(), _b = _a2.cache, cache2 = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a2.meta;
      return comparator(a, b, {
        cache: cache2,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual2(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual2(a, b) {
    return comparator(a, b, state);
  };
}
var deepEqual = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;
  var config = createEqualityComparatorConfig(options);
  var comparator = createEqualityComparator(config);
  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// node_modules/@coveo/headless/dist/esm/utils/compare-utils.js
function arrayEqual(firstArray, secondArray, isEqual2 = (first, second) => first === second) {
  return firstArray.length === secondArray.length && firstArray.findIndex((val, i) => !isEqual2(secondArray[i], val)) === -1;
}
function arrayEqualAnyOrder(firstArray, secondArray) {
  if (firstArray.length !== secondArray.length) {
    return false;
  }
  return firstArray.every((firstVal) => secondArray.findIndex((secondVal) => deepEqualAnyOrder(firstVal, secondVal)) !== -1);
}
var deepEqualAnyOrder = createCustomEqual({
  createCustomConfig: (config) => {
    return {
      ...config,
      areArraysEqual: arrayEqualAnyOrder
    };
  }
});

// node_modules/@coveo/headless/dist/esm/features/history/history-slice.js
var historyReducer = createReducer(getHistoryInitialState(), (builder) => {
  builder.addCase(snapshot, (state, action) => isEqual(state, action.payload) ? void 0 : action.payload);
});
var isEqual = (current2, next) => {
  return isContextEqual(current2.context, next.context) && isDictionaryFieldContextEqual(current2.dictionaryFieldContext, next.dictionaryFieldContext) && isAdvancedSearchQueriesEqual(current2.advancedSearchQueries, next.advancedSearchQueries) && isTabSetEqual(current2.tabSet, next.tabSet) && isStaticFilterSetEqual(current2.staticFilterSet, next.staticFilterSet) && isFacetsEqual(current2.facetSet, next.facetSet) && isFacetsEqual(current2.dateFacetSet, next.dateFacetSet) && isFacetsEqual(current2.numericFacetSet, next.numericFacetSet) && isAutomaticFacetsEqual(current2.automaticFacetSet, next.automaticFacetSet) && isCategoryFacetsEqual(current2.categoryFacetSet, next.categoryFacetSet) && isPaginationEqual(current2.pagination, next.pagination) && isQueryEqual(current2.query, next.query) && isSortEqual(current2, next) && isPipelineEqual(current2.pipeline, next.pipeline) && isSearchHubEqual(current2.searchHub, next.searchHub) && isFacetOrderEqual(current2.facetOrder, next.facetOrder) && isDebugEqual(current2.debug, next.debug);
};
var isContextEqual = (current2, next) => JSON.stringify(current2.contextValues) === JSON.stringify(next.contextValues);
var isDictionaryFieldContextEqual = (current2, next) => JSON.stringify(current2.contextValues) === JSON.stringify(next.contextValues);
var isTabSetEqual = (current2, next) => {
  const currentTab = findActiveTab(current2);
  const nextTab = findActiveTab(next);
  return (currentTab == null ? void 0 : currentTab.id) === (nextTab == null ? void 0 : nextTab.id);
};
var findActiveTab = (tabSet) => {
  return Object.values(tabSet).find((tab) => tab.isActive);
};
var isStaticFilterSetEqual = (current2, next) => {
  for (const [id, filter] of Object.entries(next)) {
    if (!current2[id]) {
      return false;
    }
    const currentValues = getActiveStaticFilterValues(current2[id]);
    const nextValues = getActiveStaticFilterValues(filter);
    if (JSON.stringify(currentValues) !== JSON.stringify(nextValues)) {
      return false;
    }
  }
  return true;
};
var getActiveStaticFilterValues = (filter) => {
  return filter.values.filter((value) => value.state !== "idle");
};
var isFacetsEqual = (current2, next) => {
  for (const [key, value] of Object.entries(next)) {
    if (!current2[key]) {
      return false;
    }
    const currentSelectedValues = current2[key].request.currentValues.filter((value2) => value2.state !== "idle");
    const nextSelectedValues = value.request.currentValues.filter((value2) => value2.state !== "idle");
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
var isCategoryFacetsEqual = (current2, next) => {
  var _a;
  for (const [key, value] of Object.entries(next)) {
    if (!current2[key]) {
      return false;
    }
    const currentSelectedValues = findActiveValueAncestry((_a = current2[key]) == null ? void 0 : _a.request.currentValues).map(({ value: value2 }) => value2);
    const nextSelectedValues = findActiveValueAncestry(value == null ? void 0 : value.request.currentValues).map(({ value: value2 }) => value2);
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
var isAutomaticFacetsEqual = (current2, next) => {
  for (const [key, value] of Object.entries(next.set)) {
    if (!current2.set[key]) {
      return false;
    }
    const currentSelectedValues = current2.set[key].response.values.filter((value2) => value2.state !== "idle");
    const nextSelectedValues = value.response.values.filter((value2) => value2.state !== "idle");
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
var isPaginationEqual = (current2, next) => current2.firstResult === next.firstResult && current2.numberOfResults === next.numberOfResults;
var isQueryEqual = (current2, next) => JSON.stringify(current2) === JSON.stringify(next);
var isAdvancedSearchQueriesEqual = (current2, next) => JSON.stringify(current2) === JSON.stringify(next);
var isSortEqual = (current2, next) => current2.sortCriteria === next.sortCriteria;
var isPipelineEqual = (current2, next) => current2 === next;
var isSearchHubEqual = (current2, next) => current2 === next;
var isFacetOrderEqual = (current2, next) => arrayEqual(current2, next);
var isDebugEqual = (current2, next) => current2 === next;
var history2 = undoable({
  actionTypes: {
    redo: redo.type,
    undo: undo.type,
    snapshot: snapshot.type
  },
  reducer: historyReducer
});

// node_modules/@coveo/headless/dist/esm/controllers/history-manager/headless-history-manager.js
function buildHistoryManager(engine) {
  if (!loadHistoryManagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const canGoBack = (state) => {
    return state.past.length > 0 && !isNullOrUndefined(state.present);
  };
  return {
    ...controller,
    // TODO: https://coveord.atlassian.net/browse/KIT-2969:
    // Should be able to get rid of this local optimization following history management change
    subscribe(listener2) {
      listener2();
      let previous = JSON.stringify(getState().history.present);
      const strictListener = () => {
        const current2 = JSON.stringify(getState().history.present);
        const hasChanged = previous !== current2;
        if (hasChanged) {
          previous = current2;
          listener2();
        }
      };
      return engine.subscribe(() => strictListener());
    },
    get state() {
      return getState().history;
    },
    async back() {
      if (!canGoBack(this.state)) {
        return;
      }
      await dispatch(back());
      dispatch(executeSearch2({
        legacy: logNavigateBackward()
      }));
    },
    async forward() {
      if (!this.state.future.length || !this.state.present) {
        return;
      }
      await dispatch(forward());
      dispatch(executeSearch2({
        legacy: logNavigateForward()
      }));
    },
    async backOnNoResults() {
      if (!canGoBack(this.state)) {
        return;
      }
      await dispatch(back());
      dispatch(executeSearch2({
        legacy: logNoResultsBack()
      }));
    }
  };
}
function loadHistoryManagerReducers(engine) {
  engine.addReducers({ history: history2, configuration, facetOrder: facetOrderReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/recent-results/recent-results-actions.js
var registerRecentResultsPayloadDefinition = {
  results: new ArrayValue({
    required: true,
    each: new RecordValue({ values: resultPartialDefinition })
  }),
  maxLength: new NumberValue({ required: true, min: 1, default: 10 })
};
var registerRecentResults = createAction("recentResults/registerRecentResults", (payload) => validatePayload(payload, registerRecentResultsPayloadDefinition));
var pushRecentResult = createAction("recentResults/pushRecentResult", (payload) => {
  validateResultPayload(payload);
  return {
    payload
  };
});
var clearRecentResults = createAction("recentResults/clearRecentResults");

// node_modules/@coveo/headless/dist/esm/controllers/instant-results/headless-interactive-instant-result.js
function buildInteractiveInstantResult(engine, props) {
  let wasOpened = false;
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(logInstantResultOpen(props.options.result));
  };
  const action = () => {
    logAnalyticsIfNeverOpened();
    engine.dispatch(pushRecentResult(props.options.result));
  };
  return buildInteractiveResultCore(engine, props, action);
}

// node_modules/@coveo/headless/dist/esm/features/instant-items/instant-items-state.js
function hasExpired(cached) {
  if (!cached) {
    return false;
  }
  return cached.expiresAt && Date.now() >= cached.expiresAt;
}

// node_modules/@coveo/headless/dist/esm/features/instant-items/instant-items-slice.js
var registerInstantItem = (payload, state) => {
  const { id } = payload;
  if (state[id]) {
    return;
  }
  state[id] = { q: "", cache: {} };
  return state;
};
var updateInstantItemQuery = (payload, state) => {
  const { q, id } = payload;
  if (!q) {
    return;
  }
  state[id].q = q;
};
var clearExpiredItems = (payload, state) => {
  const { id } = payload;
  Object.entries(state[id].cache).forEach(([q, cached]) => {
    if (hasExpired(cached)) {
      delete state[id].cache[q];
    }
  });
};
var fetchItemsPending = (payload, state, toSetEmptyIfNotFound) => {
  for (const id in state) {
    for (const query2 in state[id].cache) {
      state[id].cache[query2].isActive = false;
    }
  }
  if (!getCached(payload, state)) {
    makeEmptyCache(payload, state, toSetEmptyIfNotFound);
    return;
  }
  const cached = getCached(payload, state);
  cached.isLoading = true;
  cached.isActive = true;
  cached.error = null;
};
var fetchItemsFulfilled = (payload, state, toAddToCache) => {
  const { id, q, searchUid, cacheTimeout, totalCountFiltered, duration } = payload;
  state[id].cache[q] = {
    ...getCached(payload, state),
    ...toAddToCache,
    isActive: true,
    searchUid,
    isLoading: false,
    error: null,
    expiresAt: cacheTimeout ? cacheTimeout + Date.now() : 0,
    totalCountFiltered,
    duration
  };
};
var fetchItemsRejected = (payload, state) => {
  const { id, q, error } = payload;
  state[id].cache[q].error = error || null;
  state[id].cache[q].isLoading = false;
  state[id].cache[q].isActive = false;
};
var getCached = (payload, state) => {
  const { q, id } = payload;
  return state[id].cache[q] || null;
};
var makeEmptyCache = (payload, state, setToEmpty) => {
  const { q, id } = payload;
  state[id].cache[q] = {
    isLoading: true,
    error: null,
    expiresAt: 0,
    isActive: true,
    searchUid: "",
    totalCountFiltered: 0,
    duration: 0,
    ...setToEmpty
  };
};

// node_modules/@coveo/headless/dist/esm/features/instant-results/instant-results-state.js
function getInstantResultsInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/instant-results/instant-results-slice.js
var instantResultsReducer = createReducer(getInstantResultsInitialState(), (builder) => {
  builder.addCase(registerInstantResults, (state, action) => {
    registerInstantItem(action.payload, state);
  });
  builder.addCase(updateInstantResultsQuery, (state, action) => {
    updateInstantItemQuery(action.payload, state);
  });
  builder.addCase(clearExpiredResults, (state, action) => {
    clearExpiredItems(action.payload, state);
  });
  builder.addCase(fetchInstantResults2.pending, (state, action) => {
    fetchItemsPending(action.meta.arg, state, { results: [] });
  });
  builder.addCase(fetchInstantResults2.fulfilled, (state, action) => {
    const results = action.payload.results.map((result) => ({
      ...result,
      searchUid: action.payload.searchUid
    }));
    fetchItemsFulfilled({ ...action.payload, ...action.meta.arg }, state, {
      results
    });
  });
  builder.addCase(fetchInstantResults2.rejected, (state, action) => {
    fetchItemsRejected(action.meta.arg, state);
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/instant-results/instant-results-options.js
var instantResultsOptionDefinitions = {
  searchBoxId: nonEmptyString,
  maxResultsPerQuery: new NumberValue({
    required: true,
    min: 1
  }),
  cacheTimeout: new NumberValue()
};
var instantResultsOptionsSchema = new Schema(instantResultsOptionDefinitions);

// node_modules/@coveo/headless/dist/esm/controllers/instant-results/instant-results.js
function buildInstantResults(engine, props) {
  if (!loadInstantResultsReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options = {
    searchBoxId: props.options.searchBoxId || randomID("instant-results-"),
    cacheTimeout: props.options.cacheTimeout || 6e4,
    maxResultsPerQuery: props.options.maxResultsPerQuery
  };
  validateOptions(engine, instantResultsOptionsSchema, options, "buildInstantResults");
  const searchBoxId = options.searchBoxId;
  dispatch(registerInstantResults({ id: searchBoxId }));
  const getStateForSearchBox = () => getState().instantResults[searchBoxId];
  const getCached2 = (q) => getStateForSearchBox().cache[q];
  const getQ2 = () => getStateForSearchBox().q;
  const getResults = () => {
    const cached = getCached2(getQ2());
    if (!cached) {
      return [];
    }
    if (cached.isLoading) {
      return [];
    }
    return cached.results;
  };
  return {
    ...controller,
    updateQuery(q) {
      if (!q) {
        return;
      }
      const cached = getCached2(q);
      if (!cached || !cached.isLoading && (cached.error || hasExpired(cached))) {
        dispatch(fetchInstantResults2({
          id: searchBoxId,
          q,
          maxResultsPerQuery: options.maxResultsPerQuery,
          cacheTimeout: options.cacheTimeout
        }));
      }
      dispatch(updateInstantResultsQuery({ id: searchBoxId, q }));
    },
    clearExpired() {
      dispatch(clearExpiredResults({
        id: searchBoxId
      }));
    },
    get state() {
      const q = getQ2();
      const cached = getCached2(q);
      return {
        q,
        isLoading: (cached == null ? void 0 : cached.isLoading) || false,
        error: (cached == null ? void 0 : cached.error) || null,
        results: getResults()
      };
    }
  };
}
function loadInstantResultsReducers(engine) {
  engine.addReducers({ instantResults: instantResultsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-slice.js
var paginationReducer = createReducer(getPaginationInitialState(), (builder) => {
  builder.addCase(registerNumberOfResults, (state, action) => {
    const page = determineCurrentPage(state);
    const newNumberOfResults = action.payload;
    state.defaultNumberOfResults = state.numberOfResults = newNumberOfResults;
    state.firstResult = calculateFirstResult(page, newNumberOfResults);
  }).addCase(updateNumberOfResults, (state, action) => {
    state.numberOfResults = action.payload;
    state.firstResult = 0;
  }).addCase(updateActiveTab, (state) => {
    state.firstResult = 0;
  }).addCase(registerPage, (state, action) => {
    const page = action.payload;
    state.firstResult = calculateFirstResult(page, state.numberOfResults);
  }).addCase(updatePage, (state, action) => {
    const page = action.payload;
    state.firstResult = calculateFirstResult(page, state.numberOfResults);
  }).addCase(previousPage, (state) => {
    const page = determineCurrentPage(state);
    const previousPage3 = Math.max(page - 1, minimumPage);
    state.firstResult = calculateFirstResult(previousPage3, state.numberOfResults);
  }).addCase(nextPage, (state) => {
    const page = determineCurrentPage(state);
    const maxPage = determineMaxPage(state);
    const nextPage3 = Math.min(page + 1, maxPage);
    state.firstResult = calculateFirstResult(nextPage3, state.numberOfResults);
  }).addCase(change.fulfilled, (state, action) => {
    if (action.payload) {
      state.numberOfResults = action.payload.pagination.numberOfResults;
      state.firstResult = action.payload.pagination.firstResult;
    }
  }).addCase(restoreSearchParameters, (state, action) => {
    state.firstResult = action.payload.firstResult ?? state.firstResult;
    state.numberOfResults = action.payload.numberOfResults ?? state.defaultNumberOfResults;
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const { response } = action.payload;
    state.totalCountFiltered = response.totalCountFiltered;
  }).addCase(fetchPage2.fulfilled, (state, action) => {
    const { response } = action.payload;
    state.totalCountFiltered = response.totalCountFiltered;
  }).addCase(deselectAllFacetValues, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleExcludeDateFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleExcludeFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleExcludeNumericFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(excludeFacetSearchResult, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleSelectFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(deselectAllCategoryFacetValues, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleSelectCategoryFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(selectCategoryFacetSearchResult, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleSelectDateFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleSelectNumericFacetValue, (state) => {
    handlePaginationReset(state);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    handlePaginationReset(state);
  }).addCase(updateDateFacetValues, (state) => {
    handlePaginationReset(state);
  }).addCase(updateNumericFacetValues, (state) => {
    handlePaginationReset(state);
  }).addCase(selectFacetSearchResult, (state) => {
    handlePaginationReset(state);
  }).addCase(toggleSelectAutomaticFacetValue, (state) => {
    handlePaginationReset(state);
  });
});
function handlePaginationReset(state) {
  state.firstResult = getPaginationInitialState().firstResult;
}
function determineCurrentPage(state) {
  const { firstResult, numberOfResults } = state;
  return calculatePage(firstResult, numberOfResults);
}
function determineMaxPage(state) {
  const { totalCountFiltered, numberOfResults } = state;
  return calculateMaxPage(totalCountFiltered, numberOfResults);
}
function calculateFirstResult(page, numberOfResults) {
  return (page - 1) * numberOfResults;
}
function calculatePage(firstResult, numberOfResults) {
  return Math.round(firstResult / numberOfResults) + 1;
}
function calculateMaxPage(totalCountFiltered, numberOfResults) {
  const totalCount = Math.min(totalCountFiltered, maximumNumberOfResultsFromIndex);
  return Math.ceil(totalCount / numberOfResults);
}

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-selectors.js
function firstResultSelector(state) {
  return state.pagination.firstResult;
}
function numberOfResultsSelector(state) {
  return state.pagination.numberOfResults;
}
function totalCountFilteredSelector(state) {
  return state.pagination.totalCountFiltered;
}
var currentPageSelector = (state) => {
  const firstResult = firstResultSelector(state);
  const numberOfResults = numberOfResultsSelector(state);
  return calculatePage(firstResult, numberOfResults);
};
var maxPageSelector = (state) => {
  const totalCountFiltered = totalCountFilteredSelector(state);
  const numberOfResults = numberOfResultsSelector(state);
  return calculateMaxPage(totalCountFiltered, numberOfResults);
};
var currentPagesSelector = (state, desiredNumberOfPages) => {
  const page = currentPageSelector(state);
  const maxPage = maxPageSelector(state);
  let range = buildRange(page, desiredNumberOfPages);
  range = shiftRightIfNeeded(range);
  range = shiftLeftIfNeeded(range, maxPage);
  return buildCurrentPages(range);
};
function buildRange(page, desiredNumberOfPages) {
  const isEven = desiredNumberOfPages % 2 === 0;
  const leftCapacity = Math.floor(desiredNumberOfPages / 2);
  const rightCapacity = isEven ? leftCapacity - 1 : leftCapacity;
  const start = page - leftCapacity;
  const end = page + rightCapacity;
  return { start, end };
}
function shiftRightIfNeeded(range) {
  const leftExcess = Math.max(minimumPage - range.start, 0);
  const start = range.start + leftExcess;
  const end = range.end + leftExcess;
  return { start, end };
}
function shiftLeftIfNeeded(range, maxPage) {
  const rightExcess = Math.max(range.end - maxPage, 0);
  const start = Math.max(range.start - rightExcess, minimumPage);
  const end = range.end - rightExcess;
  return { start, end };
}
function buildCurrentPages(range) {
  const currentPages = [];
  for (let counter = range.start; counter <= range.end; ++counter) {
    currentPages.push(counter);
  }
  return currentPages;
}

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-analytics-actions.js
var logPagerResize = () => makeAnalyticsAction("analytics/pager/resize", (client, state) => {
  var _a;
  return client.makePagerResize({
    currentResultsPerPage: ((_a = state.pagination) == null ? void 0 : _a.numberOfResults) || getPaginationInitialState().numberOfResults
  });
});
var logPageNumber = () => makeAnalyticsAction("analytics/pager/number", (client, state) => client.makePagerNumber({
  pagerNumber: currentPageSelector(state)
}));
var logPageNext = () => makeAnalyticsAction("analytics/pager/next", (client, state) => client.makePagerNext({
  pagerNumber: currentPageSelector(state)
}));
var logPagePrevious = () => makeAnalyticsAction("analytics/pager/previous", (client, state) => client.makePagerPrevious({
  pagerNumber: currentPageSelector(state)
}));
var browseResults = () => ({
  actionCause: SearchPageEvents2.browseResults
});

// node_modules/@coveo/headless/dist/esm/controllers/core/pager/headless-core-pager.js
var optionsSchema4 = new Schema({
  numberOfPages: new NumberValue({ default: 5, min: 0 })
});
var initialStateSchema2 = new Schema({
  page: new NumberValue({ min: 1 })
});
function buildCorePager(engine, props = {}) {
  if (!loadPagerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const options = validateOptions(engine, optionsSchema4, props.options, "buildPager");
  const initialState2 = validateInitialState(engine, initialStateSchema2, props.initialState, "buildPager");
  const page = initialState2.page;
  if (page) {
    dispatch(registerPage(page));
  }
  const getCurrentPage = () => {
    return currentPageSelector(engine.state);
  };
  const getCurrentPages = () => {
    const { numberOfPages } = options;
    return currentPagesSelector(engine.state, numberOfPages);
  };
  const getMaxPage = () => {
    return maxPageSelector(engine.state);
  };
  return {
    ...controller,
    get state() {
      const currentPage = getCurrentPage();
      const maxPage = getMaxPage();
      const hasPreviousPage = currentPage > minimumPage && maxPage > 0;
      const hasNextPage = currentPage < maxPage;
      return {
        currentPage,
        currentPages: getCurrentPages(),
        maxPage,
        hasPreviousPage,
        hasNextPage
      };
    },
    selectPage(page2) {
      dispatch(updatePage(page2));
    },
    nextPage() {
      dispatch(nextPage());
    },
    previousPage() {
      dispatch(previousPage());
    },
    isCurrentPage(page2) {
      return page2 === this.state.currentPage;
    }
  };
}
function loadPagerReducers(engine) {
  engine.addReducers({ configuration, pagination: paginationReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/pager/headless-pager.js
function buildPager(engine, props = {}) {
  const { dispatch } = engine;
  const pager = buildCorePager(engine, props);
  return {
    ...pager,
    get state() {
      return pager.state;
    },
    selectPage(page) {
      pager.selectPage(page);
      dispatch(fetchPage2({ legacy: logPageNumber(), next: browseResults() }));
    },
    nextPage() {
      pager.nextPage();
      dispatch(fetchPage2({ legacy: logPageNext(), next: browseResults() }));
    },
    previousPage() {
      pager.previousPage();
      dispatch(fetchPage2({ legacy: logPagePrevious(), next: browseResults() }));
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/query-error/headless-core-query-error.js
function buildCoreQueryError(engine) {
  if (!loadQueryErrorReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      return {
        hasError: getState().search.error !== null,
        error: getState().search.error
      };
    }
  };
}
function loadQueryErrorReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/query-error/headless-query-error.js
function buildQueryError(engine) {
  return buildCoreQueryError(engine);
}

// node_modules/@coveo/headless/dist/esm/controllers/core/query-summary/headless-core-query-summary.js
function buildCoreQuerySummary(engine) {
  if (!loadQuerySummaryReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const searchStatus = buildCoreStatus(engine);
  const getState = () => engine.state;
  const durationInSeconds = () => {
    const inSeconds = getState().search.duration / 1e3;
    return Math.round((inSeconds + Number.EPSILON) * 100) / 100;
  };
  return {
    ...controller,
    get state() {
      return {
        ...searchStatus.state,
        durationInMilliseconds: getState().search.duration,
        durationInSeconds: durationInSeconds(),
        firstResult: getState().pagination.firstResult + 1,
        hasDuration: getState().search.duration !== 0,
        hasQuery: getState().search.queryExecuted !== "",
        lastResult: getState().pagination.firstResult + getState().search.results.length,
        query: getState().search.queryExecuted,
        total: getState().pagination.totalCountFiltered
      };
    }
  };
}
function loadQuerySummaryReducers(engine) {
  engine.addReducers({ search: searchReducer, pagination: paginationReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/query-summary/headless-query-summary.js
function buildQuerySummary(engine) {
  return buildCoreQuerySummary(engine);
}

// node_modules/@coveo/headless/dist/esm/features/result-preview/result-preview-request-builder.js
async function buildResultPreviewRequest(state, options) {
  var _a;
  const { search, accessToken, organizationId } = state.configuration;
  const q = ((_a = state.query) == null ? void 0 : _a.q) || "";
  return {
    url: search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    accessToken,
    organizationId,
    enableNavigation: false,
    q,
    ...options,
    requestedOutputSize: options.requestedOutputSize || 0,
    ...search.authenticationProviders.length && {
      authentication: search.authenticationProviders.join(",")
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/result-preview/result-preview-actions.js
var fetchResultContent = createAsyncThunk("resultPreview/fetchResultContent", async (options, { extra, getState, rejectWithValue }) => {
  const state = getState();
  const req = await buildResultPreviewRequest(state, options);
  const res = await extra.apiClient.html(req);
  if (isErrorResponse(res)) {
    return rejectWithValue(res.error);
  }
  return {
    content: res.success,
    uniqueId: options.uniqueId
  };
});
var nextPreview = createAction("resultPreview/next");
var previousPreview = createAction("resultPreview/previous");
var preparePreviewPagination = createAction("resultPreview/prepare", (payload) => validatePayload(payload, { results: new ArrayValue({ required: true }) }));
var MAX_GET_LENGTH = 2048;
var updateContentURL = createAsyncThunk("resultPreview/updateContentURL", async (options, { getState, extra }) => {
  const state = getState();
  const contentURL = buildContentURL(await options.buildResultPreviewRequest(state, {
    uniqueId: options.uniqueId,
    requestedOutputSize: options.requestedOutputSize
  }), options.path);
  if ((contentURL == null ? void 0 : contentURL.length) > MAX_GET_LENGTH) {
    extra.logger.error(`The content URL was truncated as it exceeds the maximum allowed length of ${MAX_GET_LENGTH} characters.`);
  }
  return {
    contentURL
  };
});

// node_modules/@coveo/headless/dist/esm/features/result-preview/result-preview-analytics-actions.js
var logDocumentQuickview = (result) => {
  return makeAnalyticsAction({
    prefix: "analytics/resultPreview/open",
    __legacy__getBuilder: (client, state) => {
      validateResultPayload(result);
      const info = partialDocumentInformation(result, state);
      const id = documentIdentifier(result);
      return client.makeDocumentQuickview(info, id);
    },
    analyticsType: "itemClick",
    analyticsPayloadBuilder: (state) => {
      const docInfo = partialDocumentInformation(result, state);
      const docId = documentIdentifier(result);
      return {
        responseId: result.searchUid ?? "",
        position: docInfo.documentPosition,
        itemMetadata: {
          uniqueFieldName: docId.contentIDKey,
          uniqueFieldValue: docId.contentIDValue,
          title: docInfo.documentTitle,
          author: docInfo.documentAuthor,
          url: docInfo.documentUrl
        }
      };
    }
  });
};

// node_modules/@coveo/headless/dist/esm/features/result-preview/result-preview-state.js
function getResultPreviewInitialState() {
  return {
    uniqueId: "",
    content: "",
    isLoading: false,
    position: -1,
    resultsWithPreview: []
  };
}

// node_modules/@coveo/headless/dist/esm/features/result-preview/result-preview-slice.js
var resetPreviewContentState = (state) => {
  const { content, isLoading, uniqueId, contentURL } = getResultPreviewInitialState();
  state.content = content;
  state.isLoading = isLoading;
  state.uniqueId = uniqueId;
  state.contentURL = contentURL;
};
var getUniqueIdsOfResultsWithHTMLVersion = (results) => results.filter((r) => r.hasHtmlVersion).map((r) => r.uniqueId);
var resultPreviewReducer = createReducer(getResultPreviewInitialState(), (builder) => {
  builder.addCase(fetchResultContent.pending, (state) => {
    state.isLoading = true;
  }).addCase(fetchResultContent.fulfilled, (state, action) => {
    const { content, uniqueId } = action.payload;
    state.position = state.resultsWithPreview.indexOf(uniqueId);
    state.content = content;
    state.uniqueId = uniqueId;
    state.isLoading = false;
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    resetPreviewContentState(state);
    state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(action.payload.response.results);
  }).addCase(fetchMoreResults2.fulfilled, (state, action) => {
    resetPreviewContentState(state);
    state.resultsWithPreview = state.resultsWithPreview.concat(getUniqueIdsOfResultsWithHTMLVersion(action.payload.response.results));
  }).addCase(fetchPage2.fulfilled, resetPreviewContentState).addCase(preparePreviewPagination, (state, action) => {
    state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(action.payload.results);
  }).addCase(nextPreview, (state) => {
    if (state.isLoading) {
      return;
    }
    let newPos = state.position + 1;
    if (newPos > state.resultsWithPreview.length - 1) {
      newPos = 0;
    }
    state.position = newPos;
  }).addCase(previousPreview, (state) => {
    if (state.isLoading) {
      return;
    }
    let newPos = state.position - 1;
    if (newPos < 0) {
      newPos = state.resultsWithPreview.length - 1;
    }
    state.position = newPos;
  }).addCase(updateContentURL.fulfilled, (state, action) => {
    state.contentURL = action.payload.contentURL;
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/core/quickview/headless-core-quickview.js
function buildCoreQuickview(engine, props, buildResultPreviewRequest2, path, fetchResultContentCallback) {
  if (!loadQuickviewReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const controller = buildController(engine);
  const { result, maximumPreviewSize } = props.options;
  const getUniqueIdFromPosition = () => {
    const { resultsWithPreview, position } = getState().resultPreview;
    return resultsWithPreview[position];
  };
  const onFetchContent = (uniqueId) => {
    dispatch(updateContentURL({
      uniqueId,
      requestedOutputSize: maximumPreviewSize,
      buildResultPreviewRequest: buildResultPreviewRequest2,
      path
    }));
    if (!props.options.onlyContentURL) {
      dispatch(fetchResultContent({
        uniqueId,
        requestedOutputSize: maximumPreviewSize
      }));
    }
    if (fetchResultContentCallback) {
      fetchResultContentCallback();
    }
  };
  return {
    ...controller,
    fetchResultContent() {
      onFetchContent(result.uniqueId);
    },
    next() {
      dispatch(nextPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    previous() {
      dispatch(previousPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    get state() {
      const state = getState();
      const resultHasPreview = result.hasHtmlVersion;
      const preview = state.resultPreview;
      const content = result.uniqueId === preview.uniqueId ? preview.content : "";
      const isLoading = preview.isLoading;
      const contentURL = preview.contentURL;
      const currentResultUniqueId = getUniqueIdFromPosition();
      return {
        content,
        resultHasPreview,
        isLoading,
        contentURL,
        currentResultUniqueId
      };
    }
  };
}
function loadQuickviewReducers(engine) {
  engine.addReducers({ configuration, resultPreview: resultPreviewReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/quickview/headless-quickview.js
function buildQuickview(engine, props) {
  if (!loadSearchQuickviewReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getResults = () => getState().search.results;
  const fetchResultContentCallback = () => {
    engine.dispatch(logDocumentQuickview(props.options.result));
  };
  const path = "/html";
  const core = buildCoreQuickview(engine, props, buildResultPreviewRequest, path, fetchResultContentCallback);
  dispatch(preparePreviewPagination({ results: getResults() }));
  return {
    ...core,
    get state() {
      return {
        ...core.state,
        currentResult: getResults().findIndex((r) => r.uniqueId === core.state.currentResultUniqueId) + 1,
        totalResults: getResults().length
      };
    }
  };
}
function loadSearchQuickviewReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/recent-queries/recent-queries-analytics-actions.js
var logClearRecentQueries = () => makeAnalyticsAction("analytics/recentQueries/clear", (client) => {
  return client.makeClearRecentQueries();
});
var logRecentQueryClick = () => makeAnalyticsAction("analytics/recentQueries/click", (client) => {
  return client.makeRecentQueryClick();
});

// node_modules/@coveo/headless/dist/esm/features/recent-queries/recent-queries-actions.js
var registerRecentQueriesPayloadDefinition = {
  queries: new ArrayValue({
    required: true,
    each: new StringValue({ emptyAllowed: false })
  }),
  maxLength: new NumberValue({ required: true, min: 1, default: 10 })
};
var registerRecentQueries = createAction("recentQueries/registerRecentQueries", (payload) => validatePayload(payload, registerRecentQueriesPayloadDefinition));
var clearRecentQueries = createAction("recentQueries/clearRecentQueries");

// node_modules/@coveo/headless/dist/esm/features/recent-queries/recent-queries-state.js
function getRecentQueriesInitialState() {
  return {
    queries: [],
    maxLength: 10
  };
}

// node_modules/@coveo/headless/dist/esm/features/recent-queries/recent-queries-slice.js
var recentQueriesReducer = createReducer(getRecentQueriesInitialState(), (builder) => {
  builder.addCase(registerRecentQueries, handleRegisterQueries).addCase(clearRecentQueries, handleClearRecentQueries).addCase(executeSearch2.fulfilled, (state, action) => {
    const query2 = action.payload.queryExecuted;
    const results = action.payload.response.results;
    if (!query2.length || !results.length) {
      return;
    }
    handleExecuteSearchFulfilled(query2, state);
  });
});
function handleRegisterQueries(state, action) {
  state.queries = Array.from(new Set(action.payload.queries.map((query2) => query2.trim().toLowerCase()))).slice(0, action.payload.maxLength);
  state.maxLength = action.payload.maxLength;
}
function handleClearRecentQueries(state) {
  state.queries = [];
}
function handleExecuteSearchFulfilled(query2, state) {
  const cleanNewQuery = query2.trim().toLowerCase();
  if (cleanNewQuery === "") {
    return;
  }
  const previousQueries = Array.from(new Set(state.queries.filter((query3) => query3.trim().toLowerCase() !== cleanNewQuery))).slice(0, state.maxLength - 1);
  state.queries = [cleanNewQuery, ...previousQueries];
}

// node_modules/@coveo/headless/dist/esm/controllers/core/recent-queries-list/headless-core-recent-queries-list.js
var defaultRecentQueriesState = {
  queries: []
};
var defaultRecentQueriesOptions = {
  maxLength: 10,
  clearFilters: true
};
var initialStateSchema3 = new Schema({
  queries: new ArrayValue({ required: true })
});
var optionsSchema5 = new Schema({
  maxLength: new NumberValue({ required: true, min: 1 }),
  clearFilters: new BooleanValue()
});
function validateRecentQueriesProps(engine, props) {
  validateOptions(engine, optionsSchema5, props == null ? void 0 : props.options, "buildRecentQueriesList");
  validateInitialState(engine, initialStateSchema3, props == null ? void 0 : props.initialState, "buildRecentQueriesList");
}
function buildCoreRecentQueriesList(engine, props) {
  if (!loadRecentQueriesListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const registrationOptions = {
    ...defaultRecentQueriesOptions,
    ...props == null ? void 0 : props.options
  };
  const registrationState = {
    ...defaultRecentQueriesState,
    ...props == null ? void 0 : props.initialState
  };
  validateRecentQueriesProps(engine, {
    options: registrationOptions,
    initialState: registrationState
  });
  const options = {
    queries: registrationState.queries,
    maxLength: registrationOptions.maxLength
  };
  dispatch(registerRecentQueries(options));
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...state.recentQueries,
        analyticsEnabled: state.configuration.analytics.enabled
      };
    },
    clear() {
      dispatch(clearRecentQueries());
    },
    updateRecentQueries(queries) {
      const errorMessage = new ArrayValue({
        required: true,
        each: new StringValue({ required: true }),
        min: 1
      }).validate(queries);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      dispatch(registerRecentQueries({
        queries,
        maxLength: registrationOptions.maxLength
      }));
    },
    executeRecentQuery(index) {
      var _a;
      const errorMessage = new NumberValue({
        required: true,
        min: 0,
        max: this.state.queries.length
      }).validate(index);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      const queryOptions = {
        q: this.state.queries[index],
        clearFilters: registrationOptions.clearFilters
      };
      if (isBoolean((_a = engine.state.query) == null ? void 0 : _a.enableQuerySyntax)) {
        queryOptions.enableQuerySyntax = engine.state.query.enableQuerySyntax;
      }
      dispatch(prepareForSearchWithQuery(queryOptions));
    }
  };
}
function loadRecentQueriesListReducer(engine) {
  engine.addReducers({ search: searchReducer, recentQueries: recentQueriesReducer, query: queryReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/recent-queries-list/headless-recent-queries-list.js
function buildRecentQueriesList(engine, props) {
  const coreController = buildCoreRecentQueriesList(engine, props);
  const { dispatch } = engine;
  return {
    ...coreController,
    get state() {
      return coreController.state;
    },
    clear() {
      dispatch(logClearRecentQueries());
      coreController.clear();
    },
    executeRecentQuery(index) {
      coreController.executeRecentQuery(index);
      dispatch(executeSearch2({
        legacy: logRecentQueryClick(),
        next: { actionCause: SearchPageEvents2.recentQueriesClick }
      }));
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/recent-results/recent-results-analytics-actions.js
var logRecentResultClick = (result) => makeAnalyticsAction("analytics/recentResults/click", (client, state) => {
  validateResultPayload(result);
  return client.makeRecentResultClick(partialDocumentInformation(result, state), documentIdentifier(result));
});
var logClearRecentResults = () => makeAnalyticsAction("analytics/recentResults/clear", (client) => client.makeClearRecentResults());

// node_modules/@coveo/headless/dist/esm/controllers/recent-results-list/headless-interactive-recent-result.js
function buildInteractiveRecentResult(engine, props) {
  const logAnalytics = () => engine.dispatch(logRecentResultClick(props.options.result));
  return buildInteractiveResultCore(engine, props, logAnalytics);
}

// node_modules/@coveo/headless/dist/esm/features/recent-results/recent-results-state.js
function getRecentResultsInitialState() {
  return {
    results: [],
    maxLength: 10
  };
}

// node_modules/@coveo/headless/dist/esm/features/recent-results/recent-results-slice.js
var recentResultsReducer = createReducer(getRecentResultsInitialState(), (builder) => {
  builder.addCase(registerRecentResults, (state, action) => {
    state.results = action.payload.results.slice(0, action.payload.maxLength);
    state.maxLength = action.payload.maxLength;
  }).addCase(clearRecentResults, (state) => {
    state.results = [];
  }).addCase(pushRecentResult, (state, action) => {
    const result = action.payload;
    state.results = state.results.filter((r) => r.uniqueId !== result.uniqueId);
    const remaining = state.results.slice(0, state.maxLength - 1);
    state.results = [result, ...remaining];
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/recent-results-list/headless-recent-results-list.js
var defaultRecentResultsProps = {
  initialState: {
    results: []
  },
  options: {
    maxLength: 10
  }
};
var initialStateSchema4 = new Schema({
  results: new ArrayValue({ required: true })
});
var optionsSchema6 = new Schema({
  maxLength: new NumberValue({ required: true, min: 1 })
});
function validateRecentResultsProps(engine, props) {
  validateOptions(engine, optionsSchema6, props == null ? void 0 : props.options, "buildRecentResultsList");
  validateInitialState(engine, initialStateSchema4, props == null ? void 0 : props.initialState, "buildRecentResultsList");
}
function buildRecentResultsList(engine, props) {
  if (!loadRecentResultsListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const registrationProps = {
    ...defaultRecentResultsProps,
    ...props
  };
  validateRecentResultsProps(engine, registrationProps);
  const options = {
    results: registrationProps.initialState.results,
    maxLength: registrationProps.options.maxLength
  };
  dispatch(registerRecentResults(options));
  return {
    ...controller,
    get state() {
      return getState().recentResults;
    },
    clear() {
      dispatch(logClearRecentResults());
      dispatch(clearRecentResults());
    }
  };
}
function loadRecentResultsListReducer(engine) {
  engine.addReducers({ recentResults: recentResultsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/debug/ranking-info-parser.js
var parseRankingInfo = (value) => {
  const REGEX_EXTRACT_DOCUMENT_WEIGHTS = /Document weights:\n((?:.)*?)\n+/g;
  const REGEX_EXTRACT_TERMS_WEIGHTS = /Terms weights:\n((?:.|\n)*)\n+/g;
  const REGEX_EXTRACT_TOTAL_WEIGHTS = /Total weight: ([0-9]+)/g;
  if (!value) {
    return null;
  }
  const docWeightsRegexResult = REGEX_EXTRACT_DOCUMENT_WEIGHTS.exec(value);
  const termsWeightRegexResult = REGEX_EXTRACT_TERMS_WEIGHTS.exec(value);
  const totalWeightRegexResult = REGEX_EXTRACT_TOTAL_WEIGHTS.exec(value);
  const qreWeights = parseQREWeights(value);
  const documentWeights = parseWeights(docWeightsRegexResult ? docWeightsRegexResult[1] : null);
  const termsWeight = parseTermsWeights(termsWeightRegexResult);
  const totalWeight = totalWeightRegexResult ? Number(totalWeightRegexResult[1]) : null;
  return {
    documentWeights,
    termsWeight,
    totalWeight,
    qreWeights
  };
};
var parseWeights = (value) => {
  const REGEX_EXTRACT_LIST_OF_WEIGHTS = /(\w+(?:\s\w+)*): ([-0-9]+)/g;
  const REGEX_EXTRACT_WEIGHT_GROUP = /^(\w+(?:\s\w+)*): ([-0-9]+)$/;
  if (!value) {
    return null;
  }
  const listOfWeight = value.match(REGEX_EXTRACT_LIST_OF_WEIGHTS);
  if (!listOfWeight) {
    return null;
  }
  const weights = {};
  for (const weight of listOfWeight) {
    const weightGroup = weight.match(REGEX_EXTRACT_WEIGHT_GROUP);
    if (weightGroup) {
      const weightAppliedOn = weightGroup[1];
      const weightValue = weightGroup[2];
      weights[weightAppliedOn] = Number(weightValue);
    }
  }
  return weights;
};
var matchExec = (value, regex) => {
  const results = [];
  let arr;
  while (true) {
    arr = regex.exec(value);
    if (arr === null) {
      break;
    }
    results.push(arr);
  }
  return results;
};
var parseTermsWeights = (termsWeight) => {
  const REGEX_EXTRACT_GROUP_OF_TERMS = /((?:[^:]+: [0-9]+, [0-9]+; )+)\n((?:\w+: [0-9]+; )+)/g;
  const REGEX_EXTRACT_SINGLE_TERM = /([^:]+): ([0-9]+), ([0-9]+); /g;
  if (!termsWeight || !termsWeight[1]) {
    return null;
  }
  const listOfTerms = matchExec(termsWeight[1], REGEX_EXTRACT_GROUP_OF_TERMS);
  if (!listOfTerms) {
    return null;
  }
  const terms = {};
  for (const term of listOfTerms) {
    const listOfWords = matchExec(term[1], REGEX_EXTRACT_SINGLE_TERM);
    const words = {};
    for (const word of listOfWords) {
      words[word[1]] = {
        Correlation: Number(word[2]),
        "TF-IDF": Number(word[3])
      };
    }
    const weights = parseWeights(term[2]);
    terms[Object.keys(words).join(", ")] = {
      terms: words,
      Weights: weights
    };
  }
  return terms;
};
var parseQREWeights = (value) => {
  const REGEX_EXTRACT_QRE_WEIGHTS = /(Expression:\s".*")\sScore:\s(?!0)([-0-9]+)\n+/g;
  let qreWeightsRegexResult = REGEX_EXTRACT_QRE_WEIGHTS.exec(value);
  const qreWeights = [];
  while (qreWeightsRegexResult) {
    qreWeights.push({
      expression: qreWeightsRegexResult[1],
      score: parseInt(qreWeightsRegexResult[2], 10)
    });
    qreWeightsRegexResult = REGEX_EXTRACT_QRE_WEIGHTS.exec(value);
  }
  return qreWeights;
};

// node_modules/@coveo/headless/dist/esm/features/debug/debug-selectors.js
function rankingInformationSelector(state) {
  const results = state.search.response.results;
  return results.map((result) => {
    const ranking = parseRankingInfo(result.rankingInfo);
    return {
      result,
      ranking
    };
  });
}

// node_modules/@coveo/headless/dist/esm/controllers/relevance-inspector/headless-relevance-inspector.js
var initialStateSchema5 = new Schema({
  enabled: new BooleanValue({ default: false })
});
function buildRelevanceInspector(engine, props = {}) {
  if (!loadRelevanceInspectorReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const initialState2 = validateInitialState(engine, initialStateSchema5, props.initialState, "buildRelevanceInspector");
  if (initialState2.enabled) {
    dispatch(enableDebug());
  }
  const warnProductionEnvironment = (flag) => {
    engine.logger.warn(`Flag [ ${flag} ] is now activated. This should *not* be used in any production environment as it negatively impact performance.`);
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      const isEnabled = state.debug;
      if (!state.debug) {
        return { isEnabled };
      }
      const { executionReport, basicExpression, advancedExpression, constantExpression, userIdentities, rankingExpressions } = state.search.response;
      const { fieldsDescription, fetchAllFields } = state.fields;
      return {
        isEnabled,
        rankingInformation: rankingInformationSelector(state),
        executionReport,
        expressions: {
          basicExpression,
          advancedExpression,
          constantExpression
        },
        userIdentities,
        rankingExpressions,
        fieldsDescription,
        fetchAllFields
      };
    },
    enable() {
      dispatch(enableDebug());
      warnProductionEnvironment("debug");
    },
    disable() {
      dispatch(disableDebug());
      dispatch(disableFetchAllFields());
    },
    enableFetchAllFields() {
      dispatch(enableFetchAllFields());
      warnProductionEnvironment("fetchAllFields");
    },
    disableFetchAllFields() {
      dispatch(disableFetchAllFields());
    },
    fetchFieldsDescription() {
      !this.state.isEnabled && dispatch(enableDebug());
      dispatch(fetchFieldsDescription());
      warnProductionEnvironment("fieldsDescription");
      engine.logger.warn(`For production environment, please specify the necessary fields either when instantiating a ResultList controller, or by dispatching a registerFieldsToInclude action.
        
        https://docs.coveo.com/en/headless/latest/reference/interfaces/Search.ResultListOptions.html
        https://docs.coveo.com/en/headless/latest/reference/interfaces/Search.FieldActionCreators.html#registerfieldstoinclude`);
    }
  };
}
function loadRelevanceInspectorReducers(engine) {
  engine.addReducers({
    debug: debugReducer,
    search: searchReducer,
    configuration,
    fields: fieldsReducer
  });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/result/result-analytics-actions.js
var logDocumentOpen = (result) => makeAnalyticsAction({
  prefix: "analytics/result/open",
  __legacy__getBuilder: (client, state) => {
    validateResultPayload(result);
    return client.makeDocumentOpen(partialDocumentInformation(result, state), documentIdentifier(result));
  },
  analyticsType: "itemClick",
  analyticsPayloadBuilder: (state) => {
    const docInfo = partialDocumentInformation(result, state);
    const docId = documentIdentifier(result);
    return {
      responseId: result.searchUid ?? "",
      position: docInfo.documentPosition,
      itemMetadata: {
        uniqueFieldName: docId.contentIDKey,
        uniqueFieldValue: docId.contentIDValue,
        title: docInfo.documentTitle,
        author: docInfo.documentAuthor,
        url: docInfo.documentUrl
      }
    };
  }
});

// node_modules/@coveo/headless/dist/esm/controllers/result-list/headless-interactive-result.js
function buildInteractiveResult(engine, props) {
  let wasOpened = false;
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(logDocumentOpen(props.options.result));
  };
  const action = () => {
    logAnalyticsIfNeverOpened();
    engine.dispatch(pushRecentResult(props.options.result));
  };
  return buildInteractiveResultCore(engine, props, action);
}

// node_modules/@coveo/headless/dist/esm/controllers/result-list/headless-result-list.js
function buildResultList(engine, props) {
  return buildCoreResultList(engine, {
    ...props,
    fetchMoreResultsActionCreator: fetchMoreResults2
  });
}

// node_modules/@coveo/headless/dist/esm/controllers/core/results-per-page/headless-core-results-per-page.js
var initialStateSchema6 = new Schema({
  numberOfResults: new NumberValue({ min: 0 })
});
function buildCoreResultsPerPage(engine, props = {}) {
  if (!loadResultsPerPageReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const validated = validateInitialState(engine, initialStateSchema6, props.initialState, "buildResultsPerPage");
  const num = validated.numberOfResults;
  if (num !== void 0) {
    dispatch(registerNumberOfResults(num));
  }
  return {
    ...controller,
    get state() {
      return {
        numberOfResults: getState().pagination.numberOfResults
      };
    },
    set(num2) {
      dispatch(updateNumberOfResults(num2));
    },
    isSetTo(num2) {
      return num2 === this.state.numberOfResults;
    }
  };
}
function loadResultsPerPageReducers(engine) {
  engine.addReducers({ pagination: paginationReducer, configuration });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/results-per-page/headless-results-per-page.js
function buildResultsPerPage(engine, props = {}) {
  if (!loadResultsPerPageReducers2(engine)) {
    throw loadReducerError;
  }
  const coreController = buildCoreResultsPerPage(engine, props);
  const { dispatch } = engine;
  return {
    ...coreController,
    get state() {
      return {
        ...coreController.state
      };
    },
    set(num) {
      coreController.set(num);
      dispatch(fetchPage2({ legacy: logPagerResize(), next: browseResults() }));
    }
  };
}
function loadResultsPerPageReducers2(engine) {
  engine.addReducers({ pagination: paginationReducer, configuration });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/query/query-analytics-actions.js
var logSearchboxSubmit = () => makeAnalyticsAction("analytics/searchbox/submit", (client) => client.makeSearchboxSubmit());
var searchboxSubmit = () => ({
  actionCause: SearchPageEvents2.searchboxSubmit
});

// node_modules/@coveo/headless/dist/esm/features/query-set/query-set-actions.js
var querySetDefinition = {
  id: requiredNonEmptyString,
  query: requiredEmptyAllowedString
};
var registerQuerySetQuery = createAction("querySet/register", (payload) => validatePayload(payload, querySetDefinition));
var updateQuerySetQuery = createAction("querySet/update", (payload) => validatePayload(payload, querySetDefinition));

// node_modules/@coveo/headless/dist/esm/features/commerce/query-set/query-set-actions.js
var registerQuerySetQuery2 = createAction("commerce/querySet/register", (payload) => validatePayload(payload, querySetDefinition));
var updateQuerySetQuery2 = createAction("commerce/querySet/update", (payload) => validatePayload(payload, querySetDefinition));

// node_modules/@coveo/headless/dist/esm/features/query-set/query-set-slice.js
var querySetReducer = createReducer(getQuerySetInitialState(), (builder) => {
  builder.addCase(registerQuerySetQuery, (state, action) => registerQuery(state, action.payload)).addCase(registerQuerySetQuery2, (state, action) => registerQuery(state, action.payload)).addCase(updateQuerySetQuery, (state, action) => {
    const { id, query: query2 } = action.payload;
    updateQuery3(state, id, query2);
  }).addCase(updateQuerySetQuery2, (state, action) => {
    const { id, query: query2 } = action.payload;
    updateQuery3(state, id, query2);
  }).addCase(selectQuerySuggestion2, (state, action) => {
    const { id, expression } = action.payload;
    updateQuery3(state, id, expression);
  }).addCase(selectQuerySuggestion, (state, action) => {
    const { id, expression } = action.payload;
    updateQuery3(state, id, expression);
  }).addCase(executeSearch3.fulfilled, (state, action) => {
    const { queryExecuted } = action.payload;
    updateAllQuerySetQuery(state, queryExecuted);
  }).addCase(executeSearch2.fulfilled, (state, action) => {
    const { queryExecuted } = action.payload;
    updateAllQuerySetQuery(state, queryExecuted);
  }).addCase(restoreSearchParameters, handleRestoreSearchParameters).addCase(restoreSearchParameters2, handleRestoreSearchParameters).addCase(change.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    for (const [id, query2] of Object.entries(action.payload.querySet)) {
      updateQuery3(state, id, query2);
    }
  });
});
function handleRestoreSearchParameters(state, action) {
  if (!isNullOrUndefined(action.payload.q)) {
    updateAllQuerySetQuery(state, action.payload.q);
  }
}
function updateAllQuerySetQuery(state, query2) {
  Object.keys(state).forEach((id) => {
    state[id] = query2;
  });
}
var updateQuery3 = (state, id, query2) => {
  if (id in state) {
    state[id] = query2;
  }
};
var registerQuery = (state, actionPayload) => {
  const { id, query: query2 } = actionPayload;
  if (id in state) {
    return;
  }
  state[id] = query2;
};

// node_modules/@coveo/headless/dist/esm/features/query-suggest/query-suggest-analytics-actions.js
var logQuerySuggestionClick = (payload) => makeAnalyticsAction("analytics/querySuggest", (client, state) => {
  const metadata = buildOmniboxSuggestionMetadata(state, payload);
  return client.makeOmniboxAnalytics(metadata);
});
var omniboxAnalytics = () => ({
  actionCause: SearchPageEvents2.omniboxAnalytics
});
function buildOmniboxSuggestionMetadata(state, payload) {
  var _a;
  const { id, suggestion } = payload;
  const querySuggest = (_a = state.querySuggest) == null ? void 0 : _a[id];
  if (!querySuggest) {
    throw new Error(`Unable to determine the query suggest analytics metadata to send because no query suggest with id "${id}" was found. Please check the sent #id.`);
  }
  const suggestions = querySuggest.completions.map((completion) => completion.expression);
  const lastIndex = querySuggest.partialQueries.length - 1;
  const partialQuery = querySuggest.partialQueries[lastIndex] || "";
  const querySuggestResponseId = querySuggest.responseId;
  return {
    suggestionRanking: suggestions.indexOf(suggestion),
    partialQuery,
    partialQueries: querySuggest.partialQueries,
    suggestions,
    querySuggestResponseId
  };
}

// node_modules/@coveo/headless/dist/esm/features/query-suggest/query-suggest-state.js
var getQuerySuggestSetInitialState = () => ({});

// node_modules/@coveo/headless/dist/esm/features/query-suggest/query-suggest-slice.js
var querySuggestReducer = createReducer(getQuerySuggestSetInitialState(), (builder) => builder.addCase(registerQuerySuggest2, (state, action) => {
  handleRegisterQuerySuggest(state, action.payload);
}).addCase(registerQuerySuggest, (state, action) => {
  handleRegisterQuerySuggest(state, action.payload);
}).addCase(unregisterQuerySuggest, (state, action) => {
  delete state[action.payload.id];
}).addCase(fetchQuerySuggestions2.pending, handleFetchPending).addCase(fetchQuerySuggestions2.fulfilled, (state, action) => {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
    return;
  }
  const { q } = action.payload;
  if (q) {
    querySuggest.partialQueries.push(q.replace(/;/, encodeURIComponent(";")));
  }
  querySuggest.responseId = action.payload.responseId;
  querySuggest.completions = action.payload.completions;
  querySuggest.isLoading = false;
  querySuggest.error = null;
}).addCase(fetchQuerySuggestions2.rejected, handleFetchRejected).addCase(fetchQuerySuggestions.pending, handleFetchPending).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
    return;
  }
  const { query: query2 } = action.payload;
  if (query2) {
    querySuggest.partialQueries.push(query2.replace(/;/, encodeURIComponent(";")));
  }
  querySuggest.responseId = action.payload.responseId;
  querySuggest.completions = action.payload.completions.map((completion) => ({
    expression: completion.expression,
    highlighted: completion.highlighted,
    score: 0,
    executableConfidence: 0
  }));
  querySuggest.isLoading = false;
  querySuggest.error = null;
}).addCase(fetchQuerySuggestions.rejected, handleFetchRejected).addCase(clearQuerySuggest2, (state, action) => {
  handleClearQuerySuggest(state, action.payload);
}).addCase(clearQuerySuggest, (state, action) => {
  handleClearQuerySuggest(state, action.payload);
}).addCase(setError, (state, action) => {
  Object.keys(state).forEach((slotId) => {
    const slot = state[slotId];
    if (slot) {
      slot.error = action.payload;
      slot.isLoading = false;
    }
  });
}));
function handleRegisterQuerySuggest(state, payload) {
  const id = payload.id;
  if (id in state) {
    return;
  }
  state[id] = buildQuerySuggest(payload);
}
function buildQuerySuggest(config) {
  return {
    id: "",
    completions: [],
    responseId: "",
    count: 5,
    currentRequestId: "",
    error: null,
    partialQueries: [],
    isLoading: false,
    ...config
  };
}
function handleFetchPending(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.currentRequestId = action.meta.requestId;
  querySuggest.isLoading = true;
}
function handleFetchRejected(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.error = action.payload || null;
  querySuggest.isLoading = false;
}
function handleClearQuerySuggest(state, payload) {
  const querySuggest = state[payload.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.responseId = "";
  querySuggest.completions = [];
  querySuggest.partialQueries = [];
}

// node_modules/@coveo/headless/dist/esm/controllers/core/search-box/headless-core-search-box-options.js
var defaultSearchBoxOptions = {
  enableQuerySyntax: false,
  numberOfSuggestions: 5,
  clearFilters: true
};
var openCloseDelimitersDefinition = {
  open: new StringValue(),
  close: new StringValue()
};
var searchBoxOptionDefinitions = {
  id: requiredNonEmptyString,
  numberOfSuggestions: new NumberValue({ min: 0 }),
  enableQuerySyntax: new BooleanValue(),
  highlightOptions: new RecordValue({
    values: {
      notMatchDelimiters: new RecordValue({
        values: openCloseDelimitersDefinition
      }),
      exactMatchDelimiters: new RecordValue({
        values: openCloseDelimitersDefinition
      }),
      correctionDelimiters: new RecordValue({
        values: openCloseDelimitersDefinition
      })
    }
  }),
  clearFilters: new BooleanValue()
};
var searchBoxOptionsSchema = new Schema(searchBoxOptionDefinitions);

// node_modules/@coveo/headless/dist/esm/controllers/core/search-box/headless-core-search-box.js
function buildCoreSearchBox(engine, props) {
  var _a, _b;
  if (!loadSearchBoxReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const id = ((_a = props.options) == null ? void 0 : _a.id) || randomID("search_box");
  const options = {
    id,
    highlightOptions: { ...(_b = props.options) == null ? void 0 : _b.highlightOptions },
    ...defaultSearchBoxOptions,
    ...props.options
  };
  validateOptions(engine, searchBoxOptionsSchema, options, "buildSearchBox");
  dispatch(registerQuerySetQuery({ id, query: engine.state.query.q }));
  if (options.numberOfSuggestions) {
    dispatch(registerQuerySuggest2({
      id,
      count: options.numberOfSuggestions
    }));
  }
  if (options.enableQuerySyntax) {
    dispatch(updateQuery({ enableQuerySyntax: options.enableQuerySyntax }));
  }
  const getValue = () => engine.state.querySet[options.id];
  const performSearch = async (analytics) => {
    const { enableQuerySyntax, clearFilters } = options;
    dispatch(prepareForSearchWithQuery({
      q: getValue(),
      enableQuerySyntax,
      clearFilters
    }));
    if (props.isNextAnalyticsReady) {
      dispatch(props.executeSearchActionCreator(analytics));
    } else {
      dispatch(props.executeSearchActionCreator(analytics.legacy));
    }
  };
  return {
    ...controller,
    updateText(value) {
      dispatch(updateQuerySetQuery({ id, query: value }));
      this.showSuggestions();
    },
    clear() {
      dispatch(updateQuerySetQuery({ id, query: "" }));
      dispatch(clearQuerySuggest2({ id }));
    },
    showSuggestions() {
      if (options.numberOfSuggestions) {
        dispatch(props.fetchQuerySuggestionsActionCreator({ id }));
      }
    },
    selectSuggestion(value) {
      dispatch(selectQuerySuggestion2({ id, expression: value }));
      performSearch({
        legacy: logQuerySuggestionClick({ id, suggestion: value }),
        next: omniboxAnalytics()
      }).then(() => {
        dispatch(clearQuerySuggest2({ id }));
      });
    },
    submit(legacyAnalytics = logSearchboxSubmit(), nextAnalytics) {
      performSearch({ legacy: legacyAnalytics, next: nextAnalytics });
      dispatch(clearQuerySuggest2({ id }));
    },
    get state() {
      const state = getState();
      const querySuggest = state.querySuggest[options.id];
      const suggestions = getSuggestions(querySuggest, options.highlightOptions);
      const isLoadingSuggestions = querySuggest ? querySuggest.isLoading : false;
      return {
        searchBoxId: id,
        value: getValue(),
        suggestions,
        isLoading: state.search.isLoading,
        isLoadingSuggestions
      };
    }
  };
}
function getSuggestions(state, highlightOptions) {
  if (!state) {
    return [];
  }
  return state.completions.map((completion) => ({
    highlightedValue: getHighlightedSuggestion(completion.highlighted, highlightOptions),
    rawValue: completion.expression
  }));
}
function loadSearchBoxReducers(engine) {
  engine.addReducers({ query: queryReducer, querySuggest: querySuggestReducer, configuration, querySet: querySetReducer, search: searchReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/search-box/headless-search-box.js
function buildSearchBox(engine, props = {}) {
  const searchBox = buildCoreSearchBox(engine, {
    ...props,
    executeSearchActionCreator: executeSearch2,
    fetchQuerySuggestionsActionCreator: fetchQuerySuggestions2,
    isNextAnalyticsReady: true
  });
  return {
    ...searchBox,
    submit() {
      searchBox.submit(logSearchboxSubmit(), searchboxSubmit());
    },
    get state() {
      return searchBox.state;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/sort-criteria-analytics-actions.js
var logResultsSort = () => makeAnalyticsAction("analytics/sort/results", (client, state) => client.makeResultsSort({
  resultsSortBy: state.sortCriteria || getSortCriteriaInitialState()
}));
var resultsSort = () => ({
  actionCause: SearchPageEvents2.resultsSort
});

// node_modules/@coveo/headless/dist/esm/features/search-parameters/search-parameter-analytics-actions.js
function legacyLogParametersChange(previousParameters, newParameters) {
  if (previousParameters.q !== newParameters.q) {
    return logSearchboxSubmit();
  }
  if (previousParameters.sortCriteria !== newParameters.sortCriteria) {
    return logResultsSort();
  }
  if (previousParameters.firstResult !== newParameters.firstResult) {
    return logPageNumber();
  }
  if (previousParameters.numberOfResults !== newParameters.numberOfResults) {
    return logPagerResize();
  }
  if (areFacetParamsNotEqual(previousParameters.f, newParameters.f)) {
    return legacyLogFacetAnalyticsAction(previousParameters.f, newParameters.f);
  }
  if (areFacetParamsNotEqual(previousParameters.fExcluded, newParameters.fExcluded)) {
    return legacyLogFacetAnalyticsAction(previousParameters.fExcluded, newParameters.fExcluded, true);
  }
  if (areFacetParamsNotEqual(previousParameters.cf, newParameters.cf)) {
    return legacyLogFacetAnalyticsAction(previousParameters.cf, newParameters.cf);
  }
  if (areFacetParamsNotEqual(previousParameters.af, newParameters.af)) {
    return legacyLogFacetAnalyticsAction(previousParameters.af, newParameters.af);
  }
  if (areFacetParamsNotEqual(previousParameters.nf, newParameters.nf)) {
    return legacyLogRangeFacetAnalyticsAction(previousParameters.nf, newParameters.nf);
  }
  if (areFacetParamsNotEqual(previousParameters.df, newParameters.df)) {
    return legacyLogRangeFacetAnalyticsAction(previousParameters.df, newParameters.df);
  }
  return logInterfaceChange();
}
function legacyLogFacetAnalyticsAction(previousFacets = {}, newFacets = {}, excluded = false) {
  const previousIds = Object.keys(previousFacets);
  const newIds = Object.keys(newFacets);
  const removedIds = previousIds.filter((id) => !newIds.includes(id));
  if (removedIds.length) {
    const facetId2 = removedIds[0];
    switch (true) {
      case previousFacets[facetId2].length > 1:
        return logFacetClearAll(facetId2);
      case excluded:
        return logFacetUnexclude({
          facetId: facetId2,
          facetValue: previousFacets[facetId2][0]
        });
      default:
        return logFacetDeselect({
          facetId: facetId2,
          facetValue: previousFacets[facetId2][0]
        });
    }
  }
  const addedIds = newIds.filter((id) => !previousIds.includes(id));
  if (addedIds.length) {
    const facetId2 = addedIds[0];
    return excluded ? logFacetExclude({
      facetId: facetId2,
      facetValue: newFacets[facetId2][0]
    }) : logFacetSelect({
      facetId: facetId2,
      facetValue: newFacets[facetId2][0]
    });
  }
  const facetIdWithDifferentValues = newIds.find((key) => newFacets[key].filter((facetValue) => previousFacets[key].includes(facetValue)));
  if (!facetIdWithDifferentValues) {
    return logInterfaceChange();
  }
  const previousValues = previousFacets[facetIdWithDifferentValues];
  const newValues = newFacets[facetIdWithDifferentValues];
  const addedValues = newValues.filter((value) => !previousValues.includes(value));
  if (addedValues.length) {
    return excluded ? logFacetExclude({
      facetId: facetIdWithDifferentValues,
      facetValue: addedValues[0]
    }) : logFacetSelect({
      facetId: facetIdWithDifferentValues,
      facetValue: addedValues[0]
    });
  }
  const removedValues = previousValues.filter((value) => !newValues.includes(value));
  if (removedValues.length) {
    return excluded ? logFacetUnexclude({
      facetId: facetIdWithDifferentValues,
      facetValue: removedValues[0]
    }) : logFacetDeselect({
      facetId: facetIdWithDifferentValues,
      facetValue: removedValues[0]
    });
  }
  return logInterfaceChange();
}
function legacyLogRangeFacetAnalyticsAction(previousFacets = {}, newFacets = {}) {
  return legacyLogFacetAnalyticsAction(parseRangeFacetParams(previousFacets), parseRangeFacetParams(newFacets));
}
function parametersChange(previousParameters, newParameters) {
  if (previousParameters.q !== newParameters.q) {
    return searchboxSubmit();
  }
  if (previousParameters.sortCriteria !== newParameters.sortCriteria) {
    return resultsSort();
  }
  if (areFacetParamsNotEqual(previousParameters.f, newParameters.f)) {
    return facetAction(previousParameters.f, newParameters.f);
  }
  if (areFacetParamsNotEqual(previousParameters.fExcluded, newParameters.fExcluded)) {
    return facetAction(previousParameters.fExcluded, newParameters.fExcluded, true);
  }
  if (areFacetParamsNotEqual(previousParameters.cf, newParameters.cf)) {
    return facetAction(previousParameters.cf, newParameters.cf);
  }
  if (areFacetParamsNotEqual(previousParameters.af, newParameters.af)) {
    return facetAction(previousParameters.af, newParameters.af);
  }
  if (areFacetParamsNotEqual(previousParameters.nf, newParameters.nf)) {
    return facetAction(parseRangeFacetParams(previousParameters.nf), parseRangeFacetParams(newParameters.nf));
  }
  if (areFacetParamsNotEqual(previousParameters.df, newParameters.df)) {
    return facetAction(parseRangeFacetParams(previousParameters.df), parseRangeFacetParams(newParameters.df));
  }
  return interfaceChange();
}
function areFacetParamsNotEqual(previousFacetParams = {}, newFacetParams = {}) {
  return JSON.stringify(previousFacetParams) !== JSON.stringify(newFacetParams);
}
function facetAction(previousFacets = {}, newFacets = {}, excluded = false) {
  const previousIds = Object.keys(previousFacets);
  const newIds = Object.keys(newFacets);
  const removedIds = previousIds.filter((id) => !newIds.includes(id));
  if (removedIds.length) {
    const facetId2 = removedIds[0];
    return previousFacets[facetId2].length > 1 ? facetClearAll() : facetDeselect();
  }
  const addedIds = newIds.filter((id) => !previousIds.includes(id));
  if (addedIds.length) {
    return excluded ? facetExclude() : facetSelect();
  }
  const facetIdWithDifferentValues = newIds.find((key) => newFacets[key].filter((facetValue) => previousFacets[key].includes(facetValue)));
  if (!facetIdWithDifferentValues) {
    return interfaceChange();
  }
  const previousValues = previousFacets[facetIdWithDifferentValues];
  const newValues = newFacets[facetIdWithDifferentValues];
  const addedValues = newValues.filter((value) => !previousValues.includes(value));
  if (addedValues.length) {
    return excluded ? facetExclude() : facetSelect();
  }
  const removedValues = previousValues.filter((value) => !newValues.includes(value));
  if (removedValues.length) {
    return facetDeselect();
  }
  return interfaceChange();
}
function parseRangeFacetParams(facetsParams = {}) {
  const formattedParams = {};
  Object.keys(facetsParams).forEach((key) => {
    formattedParams[key] = facetsParams[key].map((facetValue) => `${facetValue.start}..${facetValue.end}`);
  });
  return formattedParams;
}

// node_modules/@coveo/headless/dist/esm/features/search-parameters/search-parameter-selectors.js
function initialSearchParameterSelector(state) {
  var _a, _b, _c;
  return {
    q: getQueryInitialState().q,
    enableQuerySyntax: getQueryInitialState().enableQuerySyntax,
    aq: ((_a = state.advancedSearchQueries) == null ? void 0 : _a.defaultFilters.aq) ?? getAdvancedSearchQueriesInitialState().defaultFilters.aq,
    cq: ((_b = state.advancedSearchQueries) == null ? void 0 : _b.defaultFilters.cq) ?? getAdvancedSearchQueriesInitialState().defaultFilters.cq,
    firstResult: getPaginationInitialState().firstResult,
    numberOfResults: ((_c = state.pagination) == null ? void 0 : _c.defaultNumberOfResults) ?? getPaginationInitialState().defaultNumberOfResults,
    sortCriteria: getSortCriteriaInitialState(),
    f: {},
    fExcluded: {},
    cf: {},
    nf: {},
    df: {},
    debug: getDebugInitialState(),
    sf: {},
    tab: "",
    af: {},
    mnf: {}
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/search-parameter-manager/headless-core-search-parameter-manager.js
var initialStateSchema7 = new Schema({
  parameters: new RecordValue({
    options: { required: true },
    values: searchParametersDefinition
  })
});
function buildCoreSearchParameterManager(engine, props) {
  const { dispatch } = engine;
  const controller = buildController(engine);
  validateInitialState(engine, initialStateSchema7, props.initialState, "buildSearchParameterManager");
  const parametersWithValidTab = ensureTabIsValid(engine.state.tabSet, props.initialState.parameters);
  dispatch(restoreSearchParameters(parametersWithValidTab));
  return {
    ...controller,
    synchronize(parameters) {
      const enrichedParametersWithValidTab = ensureTabIsValid(engine.state.tabSet, enrichParameters(engine, parameters));
      dispatch(restoreSearchParameters(enrichedParametersWithValidTab));
    },
    get state() {
      const parameters = getCoreActiveSearchParameters(engine);
      return { parameters };
    }
  };
}
function enrichParameters(engine, parameters) {
  return {
    ...initialSearchParameterSelector(engine.state),
    ...parameters
  };
}
function ensureTabIsValid(tabSet, parameters) {
  if (parameters.tab && tabSet) {
    const tabExists = Object.values(tabSet).some((tab) => tab.id === parameters.tab);
    const currentActiveTab = Object.values(tabSet).find((tab) => tab.isActive);
    if (!tabExists && currentActiveTab) {
      return { ...parameters, tab: currentActiveTab.id };
    } else if (!tabExists) {
      return { ...parameters, tab: "" };
    }
  }
  return parameters;
}
function getCoreActiveSearchParameters(engine) {
  const state = engine.state;
  return {
    ...getQ(state.query, (s) => s.q, getQueryInitialState().q),
    ...getTab(state.tabSet, (tabSet) => {
      const activeTab = Object.values(tabSet ?? {}).find((tab) => tab.isActive);
      return activeTab ? activeTab.id : Object.keys(tabSet ?? {})[0];
    }, state.tabSet ? Object.keys(state.tabSet)[0] : ""),
    ...getSortCriteria(state.sortCriteria, (sortCriteria) => sortCriteria, getSortCriteriaInitialState()),
    ...getFacets4(state.facetSet, facetIsEnabled(state), getSelectedValues, "f"),
    ...getFacets4(state.facetSet, facetIsEnabled(state), getExcludedValues, "fExcluded"),
    ...getCategoryFacets(state),
    ...getNumericFacets(state),
    ...getDateFacets(state),
    ...getAutomaticFacets4(state)
  };
}
function facetIsEnabled(state) {
  return (facetId2) => {
    var _a, _b;
    return ((_b = (_a = state.facetOptions) == null ? void 0 : _a.facets[facetId2]) == null ? void 0 : _b.enabled) ?? true;
  };
}
function getSelectedValues(request) {
  return request.currentValues.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getSelectedRangeValues(request) {
  return request.currentValues.filter((fv) => fv.state === "selected");
}
function getExcludedValues(request) {
  return request.currentValues.filter((fv) => fv.state === "excluded").map((fv) => fv.value);
}
function getCategoryFacets(state) {
  return getFacets4(state.categoryFacetSet, facetIsEnabled(state), (request) => findActiveValueAncestry(request.currentValues).map((v) => v.value), "cf");
}
function getNumericFacets(state) {
  return getFacets4(state.numericFacetSet, facetIsEnabled(state), getSelectedRangeValues, "nf");
}
function getDateFacets(state) {
  return getFacets4(state.dateFacetSet, facetIsEnabled(state), getSelectedRangeValues, "df");
}
function getAutomaticFacets4(state) {
  var _a;
  const set2 = (_a = state.automaticFacetSet) == null ? void 0 : _a.set;
  if (set2 === void 0) {
    return {};
  }
  const af = Object.entries(set2).map(([facetId2, { response }]) => {
    const selectedValues = getSelectedResponseValues(response);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(af).length ? { af } : {};
}
function getSelectedResponseValues(response) {
  return response.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}

// node_modules/@coveo/headless/dist/esm/controllers/search-parameter-manager/headless-search-parameter-manager.js
function buildSearchParameterManager(engine, props) {
  const { dispatch } = engine;
  const controller = buildCoreSearchParameterManager(engine, props);
  return {
    ...controller,
    synchronize(parameters) {
      const activeParams = getActiveSearchParameters(engine);
      const oldParams = enrichParameters(engine, activeParams);
      const newParams = enrichParameters(engine, parameters);
      if (deepEqualAnyOrder(oldParams, newParams)) {
        return;
      }
      controller.synchronize(parameters);
      dispatch(executeSearch2({
        legacy: legacyLogParametersChange(oldParams, newParams),
        next: parametersChange(oldParams, newParams)
      }));
    },
    get state() {
      const parameters = getActiveSearchParameters(engine);
      return { parameters };
    }
  };
}
function getActiveSearchParameters(engine) {
  const state = engine.state;
  return {
    ...getCoreActiveSearchParameters(engine),
    ...getEnableQuerySyntax(state),
    ...getAq(state),
    ...getCq(state),
    ...getFirstResult(state),
    ...getNumberOfResults(state),
    ...getDebug(state),
    ...getStaticFilters(state)
  };
}
function getEnableQuerySyntax(state) {
  if (state.query === void 0) {
    return {};
  }
  const enableQuerySyntax = state.query.enableQuerySyntax;
  const shouldInclude = enableQuerySyntax !== void 0 && enableQuerySyntax !== getQueryInitialState().enableQuerySyntax;
  return shouldInclude ? { enableQuerySyntax } : {};
}
function getAq(state) {
  if (state.advancedSearchQueries === void 0) {
    return {};
  }
  const { aq, defaultFilters } = state.advancedSearchQueries;
  const shouldInclude = aq !== defaultFilters.aq;
  return shouldInclude ? { aq } : {};
}
function getCq(state) {
  if (state.advancedSearchQueries === void 0) {
    return {};
  }
  const { cq, defaultFilters } = state.advancedSearchQueries;
  const shouldInclude = cq !== defaultFilters.cq;
  return shouldInclude ? { cq } : {};
}
function getFirstResult(state) {
  if (state.pagination === void 0) {
    return {};
  }
  const firstResult = state.pagination.firstResult;
  const shouldInclude = firstResult !== getPaginationInitialState().firstResult;
  return shouldInclude ? { firstResult } : {};
}
function getNumberOfResults(state) {
  if (state.pagination === void 0) {
    return {};
  }
  const { numberOfResults, defaultNumberOfResults } = state.pagination;
  const shouldInclude = numberOfResults !== defaultNumberOfResults;
  return shouldInclude ? { numberOfResults } : {};
}
function getStaticFilters(state) {
  if (state.staticFilterSet === void 0) {
    return {};
  }
  const sf = Object.entries(state.staticFilterSet).map(([id, filter]) => {
    const selectedCaptions = getSelectedStaticFilterCaptions(filter.values);
    return selectedCaptions.length ? { [id]: selectedCaptions } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(sf).length ? { sf } : {};
}
function getSelectedStaticFilterCaptions(values) {
  return values.filter((v) => v.state === "selected").map((v) => v.caption);
}
function getDebug(state) {
  if (state.debug === void 0) {
    return {};
  }
  const debug = state.debug;
  const shouldInclude = debug !== getDebugInitialState();
  return shouldInclude ? { debug } : {};
}

// node_modules/@coveo/headless/dist/esm/controllers/search-status/headless-search-status.js
function buildSearchStatus(engine) {
  return buildCoreStatus(engine);
}

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-document-id.js
var uniqueIdentifierPayloadDefinition = () => new RecordValue({
  values: {
    questionAnswerId: requiredNonEmptyString
  },
  options: { required: true }
});
var inlineLinkPayloadDefinition = () => new RecordValue({
  values: {
    linkText: requiredEmptyAllowedString,
    linkURL: requiredEmptyAllowedString
  },
  options: { required: true }
});
function validateQuestionAnsweringActionCreatorPayload(payload) {
  return validatePayload(payload, uniqueIdentifierPayloadDefinition());
}

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-selectors.js
function answerSourceSelector(state, documentIdentifier2) {
  var _a, _b;
  const documentId = documentIdentifier2 ?? ((_b = (_a = state.search) == null ? void 0 : _a.questionAnswer) == null ? void 0 : _b.documentId);
  return documentId && state.search && resultFromFieldSelector(state, documentId.contentIdKey, documentId.contentIdValue);
}
function relatedQuestionSelector(state, questionAnswerId) {
  var _a, _b, _c, _d;
  const index = ((_a = state.questionAnswering) == null ? void 0 : _a.relatedQuestions.findIndex((relatedQuestion) => relatedQuestion.questionAnswerId === questionAnswerId)) ?? -1;
  if (index === -1) {
    return null;
  }
  const searchQuestionState = (_d = (_c = (_b = state.search) == null ? void 0 : _b.questionAnswer) == null ? void 0 : _c.relatedQuestions) == null ? void 0 : _d[index];
  return searchQuestionState ?? null;
}

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-analytics-actions.js
var logExpandSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/expand",
  __legacy__getBuilder: (client) => {
    return client.makeExpandSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        action: "expand",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logCollapseSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/collapse",
  __legacy__getBuilder: (client) => {
    return client.makeCollapseSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        action: "collapse",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logLikeSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/like",
  __legacy__getBuilder: (client) => {
    return client.makeLikeSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        action: "like",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logDislikeSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/dislike",
  __legacy__getBuilder: (client) => {
    return client.makeDislikeSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        action: "dislike",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetSource = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/source/open",
  __legacy__getBuilder: (client, state) => {
    const result = answerSourceSelector(state);
    return client.makeOpenSmartSnippetSource(partialDocumentInformation(result, state), documentIdentifier(result));
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetInlineLink = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(payload, inlineLinkPayloadDefinition());
    const result = answerSourceSelector(state);
    if (!result) {
      return null;
    }
    return client.makeOpenSmartSnippetInlineLink(partialDocumentInformation(result, state), {
      ...documentIdentifier(result),
      ...payload
    });
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetFeedbackModal = () => makeAnalyticsAction("analytics/smartSnippet/feedbackModal/open", (client) => client.makeOpenSmartSnippetFeedbackModal());
var logCloseSmartSnippetFeedbackModal = () => makeAnalyticsAction("analytics/smartSnippet/feedbackModal/close", (client) => client.makeCloseSmartSnippetFeedbackModal());
var smartSnippetFeedbackMap = {
  does_not_answer: "doesNotAnswer",
  partially_answers: "partiallyAnswers",
  was_not_a_question: "wasNotAQuestion"
};
var logSmartSnippetFeedback = (feedback) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/sendFeedback",
  __legacy__getBuilder: (client) => {
    return client.makeSmartSnippetFeedbackReason(feedback);
  },
  analyticsType: "SmartSnippets.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        responseId: searchUid,
        snippetType: "SmartSnippet",
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        },
        reason: smartSnippetFeedbackMap[feedback]
      };
    }
  }
});
var logSmartSnippetDetailedFeedback = (details) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/sendFeedback",
  __legacy__getBuilder: (client) => {
    return client.makeSmartSnippetFeedbackReason("other", details);
  },
  analyticsType: "SmartSnippets.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid) {
      return {
        responseId: searchUid,
        snippetType: "SmartSnippet",
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        },
        reason: "other",
        additionalNotes: details
      };
    }
  }
});
var logExpandSmartSnippetSuggestion = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/expand",
  __legacy__getBuilder: (client, state) => {
    validateQuestionAnsweringActionCreatorPayload(payload);
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    return client.makeExpandSmartSnippetSuggestion({
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        action: "expand",
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source == null ? void 0 : source.title,
          url: source == null ? void 0 : source.clickUri
        }
      };
    }
  }
});
var logCollapseSmartSnippetSuggestion = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/collapse",
  __legacy__getBuilder: (client, state) => {
    validateQuestionAnsweringActionCreatorPayload(payload);
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    return client.makeCollapseSmartSnippetSuggestion({
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        action: "collapse",
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source == null ? void 0 : source.title,
          url: source == null ? void 0 : source.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetSuggestionSource = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(payload, uniqueIdentifierPayloadDefinition());
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    const source = answerSourceSelector(state, relatedQuestion.documentId);
    if (!source) {
      return null;
    }
    return client.makeOpenSmartSnippetSuggestionSource(partialDocumentInformation(source, state), {
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source == null ? void 0 : source.title,
          url: source == null ? void 0 : source.clickUri
        }
      };
    }
  }
});
var logOpenSmartSnippetSuggestionInlineLink = (identifier, link) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(identifier, uniqueIdentifierPayloadDefinition());
    validatePayload(link, inlineLinkPayloadDefinition());
    const relatedQuestion = relatedQuestionSelector(state, identifier.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    const source = answerSourceSelector(state, relatedQuestion.documentId);
    if (!source) {
      return null;
    }
    return client.makeOpenSmartSnippetSuggestionInlineLink(partialDocumentInformation(source, state), {
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId,
      linkText: link.linkText,
      linkURL: link.linkURL
    });
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    var _a;
    const relatedQuestion = relatedQuestionSelector(state, identifier.questionAnswerId);
    const searchUid = (_a = state.search) == null ? void 0 : _a.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source == null ? void 0 : source.title,
          url: source == null ? void 0 : source.clickUri
        }
      };
    }
  }
});
var smartSnippetAnalyticsClient = {
  logExpandSmartSnippet,
  logCollapseSmartSnippet,
  logLikeSmartSnippet,
  logDislikeSmartSnippet,
  logOpenSmartSnippetSource,
  logOpenSmartSnippetInlineLink,
  logOpenSmartSnippetFeedbackModal,
  logCloseSmartSnippetFeedbackModal,
  logSmartSnippetFeedback,
  logSmartSnippetDetailedFeedback,
  logExpandSmartSnippetSuggestion,
  logCollapseSmartSnippetSuggestion,
  logOpenSmartSnippetSuggestionSource
};

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-actions.js
var expandSmartSnippet = createAction("smartSnippet/expand");
var collapseSmartSnippet = createAction("smartSnippet/collapse");
var likeSmartSnippet = createAction("smartSnippet/like");
var dislikeSmartSnippet = createAction("smartSnippet/dislike");
var openFeedbackModal = createAction("smartSnippet/feedbackModal/open");
var closeFeedbackModal = createAction("smartSnippet/feedbackModal/close");
var expandSmartSnippetRelatedQuestion = createAction("smartSnippet/related/expand", (payload) => validateQuestionAnsweringActionCreatorPayload(payload));
var collapseSmartSnippetRelatedQuestion = createAction("smartSnippet/related/collapse", (payload) => validateQuestionAnsweringActionCreatorPayload(payload));

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-state.js
var getQuestionAnsweringInitialState = () => ({
  liked: false,
  disliked: false,
  expanded: false,
  feedbackModalOpen: false,
  relatedQuestions: []
});

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-slice.js
var findRelatedQuestionIdx = (relatedQuestions, identifier) => relatedQuestions.findIndex((relatedQuestion) => relatedQuestion.questionAnswerId === identifier.questionAnswerId);
function hashQuestionAnswer({ question, answerSnippet, documentId: { contentIdKey, contentIdValue } }) {
  return getObjectHash({
    question,
    answerSnippet,
    contentIdKey,
    contentIdValue
  });
}
function buildQuestionAnsweringRelatedQuestionState(responseQuestionAnswer, currentState) {
  const id = hashQuestionAnswer(responseQuestionAnswer);
  if (currentState && id === currentState.questionAnswerId) {
    return currentState;
  }
  return {
    contentIdKey: responseQuestionAnswer.documentId.contentIdKey,
    contentIdValue: responseQuestionAnswer.documentId.contentIdValue,
    expanded: false,
    questionAnswerId: id
  };
}
var questionAnsweringReducer = createReducer(getQuestionAnsweringInitialState(), (builder) => builder.addCase(expandSmartSnippet, (state) => {
  state.expanded = true;
}).addCase(collapseSmartSnippet, (state) => {
  state.expanded = false;
}).addCase(likeSmartSnippet, (state) => {
  state.liked = true;
  state.disliked = false;
  state.feedbackModalOpen = false;
}).addCase(dislikeSmartSnippet, (state) => {
  state.liked = false;
  state.disliked = true;
}).addCase(openFeedbackModal, (state) => {
  state.feedbackModalOpen = true;
}).addCase(closeFeedbackModal, (state) => {
  state.feedbackModalOpen = false;
}).addCase(executeSearch2.fulfilled, (state, action) => {
  const relatedQuestions = action.payload.response.questionAnswer.relatedQuestions.map((relatedQuestion, i) => buildQuestionAnsweringRelatedQuestionState(relatedQuestion, state.relatedQuestions[i]));
  const questionAnswerId = hashQuestionAnswer(action.payload.response.questionAnswer);
  if (state.questionAnswerId === questionAnswerId) {
    return {
      ...state,
      relatedQuestions
    };
  }
  return {
    ...getQuestionAnsweringInitialState(),
    relatedQuestions,
    questionAnswerId
  };
}).addCase(expandSmartSnippetRelatedQuestion, (state, action) => {
  const idx = findRelatedQuestionIdx(state.relatedQuestions, action.payload);
  if (idx === -1) {
    return;
  }
  state.relatedQuestions[idx].expanded = true;
}).addCase(collapseSmartSnippetRelatedQuestion, (state, action) => {
  const idx = findRelatedQuestionIdx(state.relatedQuestions, action.payload);
  if (idx === -1) {
    return;
  }
  state.relatedQuestions[idx].expanded = false;
}));

// node_modules/@coveo/headless/dist/esm/controllers/core/smart-snippet/headless-core-smart-snippet.js
function buildCoreSmartSnippet(engine, analyticsClient, props) {
  var _a;
  if (!loadSmartSnippetReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  const getResult = () => answerSourceSelector(getState());
  let lastSearchResponseId = null;
  const interactiveResult = buildInteractiveResultCore(engine, { options: { selectionDelay: (_a = props == null ? void 0 : props.options) == null ? void 0 : _a.selectionDelay } }, () => {
    const result = getResult();
    if (!result) {
      lastSearchResponseId = null;
      return;
    }
    const { searchResponseId } = getState().search;
    if (lastSearchResponseId === searchResponseId) {
      return;
    }
    lastSearchResponseId = searchResponseId;
    engine.dispatch(analyticsClient.logOpenSmartSnippetSource());
    engine.dispatch(pushRecentResult(result));
  });
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        question: state.search.questionAnswer.question,
        answer: state.search.questionAnswer.answerSnippet,
        documentId: state.search.questionAnswer.documentId,
        expanded: state.questionAnswering.expanded,
        answerFound: state.search.questionAnswer.answerSnippet !== "",
        liked: state.questionAnswering.liked,
        disliked: state.questionAnswering.disliked,
        feedbackModalOpen: state.questionAnswering.feedbackModalOpen,
        source: getResult()
      };
    },
    expand() {
      engine.dispatch(analyticsClient.logExpandSmartSnippet());
      engine.dispatch(expandSmartSnippet());
    },
    collapse() {
      engine.dispatch(analyticsClient.logCollapseSmartSnippet());
      engine.dispatch(collapseSmartSnippet());
    },
    like() {
      engine.dispatch(analyticsClient.logLikeSmartSnippet());
      engine.dispatch(likeSmartSnippet());
    },
    dislike() {
      engine.dispatch(analyticsClient.logDislikeSmartSnippet());
      engine.dispatch(dislikeSmartSnippet());
    },
    openFeedbackModal() {
      engine.dispatch(analyticsClient.logOpenSmartSnippetFeedbackModal());
      engine.dispatch(openFeedbackModal());
    },
    closeFeedbackModal() {
      engine.dispatch(analyticsClient.logCloseSmartSnippetFeedbackModal());
      engine.dispatch(closeFeedbackModal());
    },
    sendFeedback(feedback) {
      engine.dispatch(analyticsClient.logSmartSnippetFeedback(feedback));
      engine.dispatch(closeFeedbackModal());
    },
    sendDetailedFeedback(details) {
      engine.dispatch(analyticsClient.logSmartSnippetDetailedFeedback(details));
      engine.dispatch(closeFeedbackModal());
    },
    selectSource() {
      interactiveResult.select();
    },
    beginDelayedSelectSource() {
      interactiveResult.beginDelayedSelect();
    },
    cancelPendingSelectSource() {
      interactiveResult.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetReducers(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/smart-snippet/headless-smart-snippet-interactive-inline-links.js
function buildSmartSnippetInteractiveInlineLinks(engine, props) {
  if (!loadSmartSnippetInteractiveInlineLinksReducer(engine)) {
    throw loadReducerError;
  }
  const getState = () => engine.state;
  const clickedRelatedQuestions = /* @__PURE__ */ new Set();
  const inlineLinkWasClicked = (linkId) => {
    if (clickedRelatedQuestions.has(linkId)) {
      return true;
    }
    clickedRelatedQuestions.add(linkId);
    return false;
  };
  let lastSearchResponseId = null;
  const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
    if (lastSearchResponseId !== currentSearchResponseId) {
      lastSearchResponseId = currentSearchResponseId;
      interactiveResultsPerInlineLink = {};
      clickedRelatedQuestions.clear();
    }
  };
  const buildInlineLinkInteractiveResult = (link, linkId, questionAnswerId) => {
    var _a;
    return buildInteractiveResultCore(engine, { options: { selectionDelay: (_a = props == null ? void 0 : props.options) == null ? void 0 : _a.selectionDelay } }, () => {
      if (inlineLinkWasClicked(linkId)) {
        return;
      }
      engine.dispatch(questionAnswerId ? logOpenSmartSnippetSuggestionInlineLink({ questionAnswerId }, link) : logOpenSmartSnippetInlineLink(link));
    });
  };
  let interactiveResultsPerInlineLink = {};
  const getInteractiveResult = (link, questionAnswerId) => {
    const { searchResponseId } = getState().search;
    resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
    const linkId = getObjectHash({ ...link, questionAnswerId });
    if (linkId in interactiveResultsPerInlineLink) {
      return interactiveResultsPerInlineLink[linkId];
    }
    interactiveResultsPerInlineLink[linkId] = buildInlineLinkInteractiveResult(link, linkId, questionAnswerId);
    return interactiveResultsPerInlineLink[linkId];
  };
  return {
    selectInlineLink(link, questionAnswerId) {
      var _a;
      (_a = getInteractiveResult(link, questionAnswerId)) == null ? void 0 : _a.select();
    },
    beginDelayedSelectInlineLink(link, questionAnswerId) {
      var _a;
      (_a = getInteractiveResult(link, questionAnswerId)) == null ? void 0 : _a.beginDelayedSelect();
    },
    cancelPendingSelectInlineLink(link, questionAnswerId) {
      var _a;
      (_a = getInteractiveResult(link, questionAnswerId)) == null ? void 0 : _a.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetInteractiveInlineLinksReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/smart-snippet/headless-smart-snippet.js
function buildSmartSnippet(engine, props) {
  var _a;
  warnIfUsingNextAnalyticsModeForServiceFeature(engine.state.configuration.analytics.analyticsMode);
  const smartSnippet = buildCoreSmartSnippet(engine, smartSnippetAnalyticsClient, props);
  const interactiveInlineLinks = buildSmartSnippetInteractiveInlineLinks(engine, { options: { selectionDelay: (_a = props == null ? void 0 : props.options) == null ? void 0 : _a.selectionDelay } });
  return {
    ...smartSnippet,
    get state() {
      return smartSnippet.state;
    },
    selectInlineLink(link) {
      interactiveInlineLinks.selectInlineLink(link);
    },
    beginDelayedSelectInlineLink(link) {
      interactiveInlineLinks.beginDelayedSelectInlineLink(link);
    },
    cancelPendingSelectInlineLink(link) {
      interactiveInlineLinks.cancelPendingSelectInlineLink(link);
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/core/smart-snippet-questions-list/headless-core-smart-snippet-questions-list.js
function buildCoreSmartSnippetQuestionsList(engine, analyticsClient) {
  if (!loadSmartSnippetQuestionsListReducer(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const getState = () => engine.state;
  const getResult = (identifier) => {
    const { contentIdKey, contentIdValue } = identifier;
    return engine.state.search.results.find((result) => getResultProperty(result, contentIdKey) === contentIdValue);
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        questions: state.search.questionAnswer.relatedQuestions.map((relatedQuestion, i) => ({
          question: relatedQuestion.question,
          answer: relatedQuestion.answerSnippet,
          documentId: relatedQuestion.documentId,
          questionAnswerId: state.questionAnswering.relatedQuestions[i].questionAnswerId,
          expanded: state.questionAnswering.relatedQuestions[i].expanded,
          source: getResult(relatedQuestion.documentId)
        }))
      };
    },
    expand(identifier) {
      const payload = { questionAnswerId: identifier };
      engine.dispatch(analyticsClient.logExpandSmartSnippetSuggestion(payload));
      engine.dispatch(expandSmartSnippetRelatedQuestion(payload));
    },
    collapse(identifier) {
      const payload = { questionAnswerId: identifier };
      engine.dispatch(analyticsClient.logCollapseSmartSnippetSuggestion(payload));
      engine.dispatch(collapseSmartSnippetRelatedQuestion(payload));
    }
  };
}
function loadSmartSnippetQuestionsListReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/smart-snippet-questions-list/headless-smart-snippet-interactive-questions.js
function buildSmartSnippetInteractiveQuestions(engine, props) {
  if (!loadSmartSnippetInteractiveQuestionsReducer(engine)) {
    throw loadReducerError;
  }
  const getState = () => engine.state;
  const getSource2 = (questionAnswerId) => {
    const state = getState();
    const questionAnswer = relatedQuestionSelector(state, questionAnswerId);
    if (!questionAnswer) {
      return null;
    }
    return answerSourceSelector(state, questionAnswer.documentId);
  };
  const clickedRelatedQuestions = /* @__PURE__ */ new Set();
  const relatedQuestionWasClicked = (questionAnswerId) => {
    if (clickedRelatedQuestions.has(questionAnswerId)) {
      return true;
    }
    clickedRelatedQuestions.add(questionAnswerId);
    return false;
  };
  let lastSearchResponseId = null;
  const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
    if (lastSearchResponseId !== currentSearchResponseId) {
      lastSearchResponseId = currentSearchResponseId;
      interactiveResultsPerRelatedQuestion = {};
      clickedRelatedQuestions.clear();
    }
  };
  const buildRelatedQuestionInteractiveResult = (source, questionAnswerId) => {
    var _a;
    return buildInteractiveResultCore(engine, { options: { selectionDelay: (_a = props == null ? void 0 : props.options) == null ? void 0 : _a.selectionDelay } }, () => {
      if (relatedQuestionWasClicked(questionAnswerId)) {
        return;
      }
      engine.dispatch(logOpenSmartSnippetSuggestionSource({
        questionAnswerId
      }));
      engine.dispatch(pushRecentResult(source));
    });
  };
  let interactiveResultsPerRelatedQuestion = {};
  const getInteractiveResult = (questionAnswerId) => {
    const { searchResponseId } = getState().search;
    resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
    const source = getSource2(questionAnswerId);
    if (!source) {
      return null;
    }
    if (questionAnswerId in interactiveResultsPerRelatedQuestion) {
      return interactiveResultsPerRelatedQuestion[questionAnswerId];
    }
    interactiveResultsPerRelatedQuestion[questionAnswerId] = buildRelatedQuestionInteractiveResult(source, questionAnswerId);
    return interactiveResultsPerRelatedQuestion[questionAnswerId];
  };
  return {
    selectSource(questionAnswerId) {
      var _a;
      (_a = getInteractiveResult(questionAnswerId)) == null ? void 0 : _a.select();
    },
    beginDelayedSelectSource(questionAnswerId) {
      var _a;
      (_a = getInteractiveResult(questionAnswerId)) == null ? void 0 : _a.beginDelayedSelect();
    },
    cancelPendingSelectSource(questionAnswerId) {
      var _a;
      (_a = getInteractiveResult(questionAnswerId)) == null ? void 0 : _a.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetInteractiveQuestionsReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/smart-snippet-questions-list/headless-smart-snippet-questions-list.js
function buildSmartSnippetQuestionsList(engine, props) {
  var _a, _b;
  warnIfUsingNextAnalyticsModeForServiceFeature(engine.state.configuration.analytics.analyticsMode);
  const smartSnippetQuestionList = buildCoreSmartSnippetQuestionsList(engine, smartSnippetAnalyticsClient);
  const interactiveInlineLinks = buildSmartSnippetInteractiveInlineLinks(engine, {
    options: { selectionDelay: (_a = props == null ? void 0 : props.options) == null ? void 0 : _a.selectionDelay }
  });
  const interactiveQuestions = buildSmartSnippetInteractiveQuestions(engine, {
    options: { selectionDelay: (_b = props == null ? void 0 : props.options) == null ? void 0 : _b.selectionDelay }
  });
  return {
    ...smartSnippetQuestionList,
    get state() {
      return smartSnippetQuestionList.state;
    },
    selectSource(identifier) {
      interactiveQuestions.selectSource(identifier);
    },
    beginDelayedSelectSource(identifier) {
      interactiveQuestions.beginDelayedSelectSource(identifier);
    },
    cancelPendingSelectSource(identifier) {
      interactiveQuestions.cancelPendingSelectSource(identifier);
    },
    selectInlineLink(identifier, link) {
      interactiveInlineLinks.selectInlineLink(link, identifier);
    },
    beginDelayedSelectInlineLink(identifier, link) {
      interactiveInlineLinks.beginDelayedSelectInlineLink(link, identifier);
    },
    cancelPendingSelectInlineLink(identifier, link) {
      interactiveInlineLinks.cancelPendingSelectInlineLink(link, identifier);
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/sort-criteria-actions.js
var criterionDefinition2 = {
  by: new EnumValue({ enum: SortBy, required: true })
};
var registerSortCriterion = createAction("sortCriteria/register", (payload) => validate3(payload));
var updateSortCriterion = createAction("sortCriteria/update", (payload) => validate3(payload));
var validate3 = (payload) => {
  if (isArray(payload)) {
    payload.forEach((p) => validatePayload(p, criterionDefinition2));
    return { payload };
  }
  return validatePayload(payload, criterionDefinition2);
};

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/sort-criteria-slice.js
var sortCriteriaReducer = createReducer(getSortCriteriaInitialState(), (builder) => {
  builder.addCase(registerSortCriterion, (_, action) => buildCriterionExpression(action.payload)).addCase(updateSortCriterion, (_, action) => buildCriterionExpression(action.payload)).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.sortCriteria) ?? state;
  }).addCase(restoreSearchParameters, (state, action) => {
    return action.payload.sortCriteria ?? state;
  });
});

// node_modules/@coveo/headless/dist/esm/controllers/core/sort/headless-core-sort.js
function validateSortInitialState(engine, state) {
  if (!state) {
    return;
  }
  const schema = new Schema({
    criterion: new ArrayValue({ each: criterionDefinition })
  });
  const criterion = getCriterionAsArray(state);
  const initialState2 = { ...state, criterion };
  validateInitialState(engine, schema, initialState2, "buildSort");
}
function getCriterionAsArray(state) {
  if (!state.criterion) {
    return [];
  }
  return isArray(state.criterion) ? state.criterion : [state.criterion];
}
function buildCoreSort(engine, props) {
  var _a;
  if (!loadSortReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  validateSortInitialState(engine, props.initialState);
  const criterion = (_a = props.initialState) == null ? void 0 : _a.criterion;
  if (criterion) {
    dispatch(registerSortCriterion(criterion));
  }
  return {
    ...controller,
    sortBy(criterion2) {
      dispatch(updateSortCriterion(criterion2));
      dispatch(updatePage(1));
    },
    isSortedBy(criterion2) {
      return this.state.sortCriteria === buildCriterionExpression(criterion2);
    },
    get state() {
      return {
        sortCriteria: getState().sortCriteria
      };
    }
  };
}
function loadSortReducers(engine) {
  engine.addReducers({ configuration, sortCriteria: sortCriteriaReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/sort/headless-sort.js
function buildSort(engine, props = {}) {
  const { dispatch } = engine;
  const sort = buildCoreSort(engine, props);
  const search = () => dispatch(executeSearch2({
    legacy: logResultsSort(),
    next: resultsSort()
  }));
  return {
    ...sort,
    get state() {
      return sort.state;
    },
    sortBy(criterion) {
      sort.sortBy(criterion);
      search();
    }
  };
}

// node_modules/@coveo/headless/dist/esm/api/common/trigger.js
function isRedirectTrigger(trigger) {
  return trigger.type === "redirect";
}

// node_modules/@coveo/headless/dist/esm/api/search/plan/plan-endpoint.js
var ExecutionPlan = class {
  constructor(response) {
    __publicField(this, "response");
    this.response = response;
  }
  /**
   * Gets the final value of the basic expression (`q`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get basicExpression() {
    return this.response.parsedInput.basicExpression;
  }
  /**
   * Gets the final value of the large expression (`lq`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get largeExpression() {
    return this.response.parsedInput.largeExpression;
  }
  /**
   * Gets the URL to redirect the browser to, if the search request satisfies the condition of a `redirect` trigger rule in the query pipeline.
   *
   * Returns `null` otherwise.
   */
  get redirectionUrl() {
    const redirects = this.response.preprocessingOutput.triggers.filter(isRedirectTrigger);
    return redirects.length ? redirects[0].content : null;
  }
};

// node_modules/@coveo/headless/dist/esm/features/standalone-search-box-set/standalone-search-box-set-actions.js
var registerStandaloneSearchBox = createAction("standaloneSearchBox/register", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  redirectionUrl: requiredNonEmptyString,
  overwrite: new BooleanValue({ required: false })
}));
var updateStandaloneSearchBoxRedirectionUrl = createAction("standaloneSearchBox/updateRedirectionUrl", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  redirectionUrl: requiredNonEmptyString
}));
var resetStandaloneSearchBox = createAction("standaloneSearchBox/reset", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString
}));
var updateAnalyticsToSearchFromLink = createAction("standaloneSearchBox/updateAnalyticsToSearchFromLink", (payload) => validatePayload(payload, { id: requiredNonEmptyString }));
var updateAnalyticsToOmniboxFromLink = createAction("standaloneSearchBox/updateAnalyticsToOmniboxFromLink");
var fetchRedirectUrl = createAsyncThunk("standaloneSearchBox/fetchRedirect", async (payload, { dispatch, getState, rejectWithValue, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  validatePayload2(payload, { id: new StringValue({ emptyAllowed: false }) });
  const request = await buildPlanRequest(getState(), navigatorContext);
  const response = await apiClient.plan(request);
  if (isErrorResponse(response)) {
    return rejectWithValue(response.error);
  }
  const { redirectionUrl } = new ExecutionPlan(response.success);
  if (redirectionUrl) {
    dispatch(logRedirect(redirectionUrl));
  }
  return redirectionUrl || "";
});
var logRedirect = (url) => makeAnalyticsAction("analytics/standaloneSearchBox/redirect", (client) => client.makeTriggerRedirect({ redirectedTo: url }));
var buildPlanRequest = async (state, navigatorContext) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    locale: state.configuration.search.locale,
    timezone: state.configuration.search.timezone,
    q: state.query.q,
    ...state.context && { context: state.context.contextValues },
    ...state.pipeline && { pipeline: state.pipeline },
    ...state.searchHub && { searchHub: state.searchHub },
    ...state.configuration.analytics.enabled && state.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams2(state.configuration.analytics) : fromAnalyticsStateToAnalyticsParams(state.configuration.analytics, navigatorContext),
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};

// node_modules/@coveo/headless/dist/esm/features/standalone-search-box-set/standalone-search-box-set-state.js
function getStandaloneSearchBoxSetInitialState() {
  return {};
}

// node_modules/@coveo/headless/dist/esm/features/standalone-search-box-set/standalone-search-box-set-slice.js
var standaloneSearchBoxSetReducer = createReducer(getStandaloneSearchBoxSetInitialState(), (builder) => builder.addCase(registerStandaloneSearchBox, (state, action) => {
  const { id, redirectionUrl, overwrite } = action.payload;
  if (!overwrite && id in state) {
    return;
  }
  state[id] = buildStandaloneSearchBoxEntry(redirectionUrl);
}).addCase(resetStandaloneSearchBox, (state, action) => {
  const { id } = action.payload;
  const searchBox = state[id];
  if (searchBox) {
    state[id] = buildStandaloneSearchBoxEntry(searchBox.defaultRedirectionUrl);
    return;
  }
}).addCase(updateStandaloneSearchBoxRedirectionUrl, (state, action) => {
  const { id, redirectionUrl } = action.payload;
  if (!(id in state)) {
    return;
  }
  state[id] = buildStandaloneSearchBoxEntry(redirectionUrl);
}).addCase(fetchRedirectUrl.pending, (state, action) => {
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.isLoading = true;
}).addCase(fetchRedirectUrl.fulfilled, (state, action) => {
  const url = action.payload;
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.redirectTo = url ? url : searchBox.defaultRedirectionUrl;
  searchBox.isLoading = false;
}).addCase(fetchRedirectUrl.rejected, (state, action) => {
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.isLoading = false;
}).addCase(updateAnalyticsToSearchFromLink, (state, action) => {
  const searchBox = state[action.payload.id];
  if (!searchBox) {
    return;
  }
  searchBox.analytics.cause = "searchFromLink";
}).addCase(updateAnalyticsToOmniboxFromLink, (state, action) => {
  const searchBox = state[action.payload.id];
  if (!searchBox) {
    return;
  }
  searchBox.analytics.cause = "omniboxFromLink";
  searchBox.analytics.metadata = action.payload.metadata;
}));
function buildStandaloneSearchBoxEntry(defaultRedirectionUrl) {
  return {
    defaultRedirectionUrl,
    redirectTo: "",
    isLoading: false,
    analytics: {
      cause: "",
      metadata: null
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/standalone-search-box/headless-standalone-search-box-options.js
var standaloneSearchBoxSchema = new Schema({
  ...searchBoxOptionDefinitions,
  redirectionUrl: new StringValue({
    required: true,
    emptyAllowed: false
  }),
  overwrite: new BooleanValue({
    required: false
  })
});

// node_modules/@coveo/headless/dist/esm/controllers/standalone-search-box/headless-standalone-search-box.js
function buildStandaloneSearchBox(engine, props) {
  if (!loadStandaloneSearchBoxReducers(engine)) {
    throw loadReducerError;
  }
  const { dispatch } = engine;
  const getState = () => engine.state;
  const id = props.options.id || randomID("standalone_search_box");
  const options = {
    id,
    highlightOptions: { ...props.options.highlightOptions },
    ...defaultSearchBoxOptions,
    ...{ overwrite: false },
    ...props.options
  };
  validateOptions(engine, standaloneSearchBoxSchema, options, "buildStandaloneSearchBox");
  const searchBox = buildSearchBox(engine, { options });
  dispatch(registerStandaloneSearchBox({
    id,
    redirectionUrl: options.redirectionUrl,
    overwrite: options.overwrite
  }));
  return {
    ...searchBox,
    updateText(value) {
      searchBox.updateText(value);
      dispatch(updateAnalyticsToSearchFromLink({ id }));
    },
    selectSuggestion(value) {
      const metadata = buildOmniboxSuggestionMetadata(getState(), {
        id,
        suggestion: value
      });
      dispatch(selectQuerySuggestion2({ id, expression: value }));
      dispatch(updateAnalyticsToOmniboxFromLink({ id, metadata }));
      this.submit();
    },
    afterRedirection() {
      dispatch(resetStandaloneSearchBox({ id }));
    },
    updateRedirectUrl(url) {
      dispatch(updateStandaloneSearchBoxRedirectionUrl({ id, redirectionUrl: url }));
    },
    submit() {
      dispatch(updateQuery({
        q: this.state.value,
        enableQuerySyntax: options.enableQuerySyntax
      }));
      dispatch(fetchRedirectUrl({ id }));
    },
    get state() {
      const state = getState();
      const standaloneSearchBoxState = state.standaloneSearchBoxSet[id];
      return {
        ...searchBox.state,
        isLoading: standaloneSearchBoxState.isLoading,
        redirectTo: standaloneSearchBoxState.redirectTo,
        analytics: standaloneSearchBoxState.analytics
      };
    }
  };
}
function loadStandaloneSearchBoxReducers(engine) {
  engine.addReducers({
    standaloneSearchBoxSet: standaloneSearchBoxSetReducer,
    configuration,
    query: queryReducer,
    querySuggest: querySuggestReducer
  });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/static-filter-set/static-filter-set-slice.js
var staticFilterSetReducer = createReducer(getStaticFilterSetInitialState(), (builder) => builder.addCase(registerStaticFilter, (state, action) => {
  const filter = action.payload;
  const { id } = filter;
  if (id in state) {
    return;
  }
  state[id] = filter;
}).addCase(toggleSelectStaticFilterValue, (state, action) => {
  const { id, value } = action.payload;
  const filter = state[id];
  if (!filter) {
    return;
  }
  const target = filter.values.find((v) => v.caption === value.caption);
  if (!target) {
    return;
  }
  const isSelected = target.state === "selected";
  target.state = isSelected ? "idle" : "selected";
}).addCase(toggleExcludeStaticFilterValue, (state, action) => {
  const { id, value } = action.payload;
  const filter = state[id];
  if (!filter) {
    return;
  }
  const target = filter.values.find((v) => v.caption === value.caption);
  if (!target) {
    return;
  }
  const isExcluded = target.state === "excluded";
  target.state = isExcluded ? "idle" : "excluded";
}).addCase(deselectAllStaticFilterValues, (state, action) => {
  const id = action.payload;
  const filter = state[id];
  if (!filter) {
    return;
  }
  filter.values.forEach((v) => {
    v.state = "idle";
  });
}).addCase(deselectAllBreadcrumbs, (state) => {
  Object.values(state).forEach((filter) => {
    filter.values.forEach((v) => {
      v.state = "idle";
    });
  });
}).addCase(restoreSearchParameters, (state, action) => {
  const sf = action.payload.sf || {};
  Object.entries(state).forEach(([id, filter]) => {
    const selected = sf[id] || [];
    filter.values.forEach((value) => {
      value.state = selected.includes(value.caption) ? "selected" : "idle";
    });
  });
}));

// node_modules/@coveo/headless/dist/esm/controllers/static-filter/static-filter-value.js
function buildStaticFilterValue(config) {
  return {
    state: "idle",
    ...config
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/static-filter/headless-static-filter.js
var optionsSchema7 = new Schema({
  id: staticFilterIdSchema,
  values: staticFilterValuesSchema
});
function buildStaticFilter(engine, props) {
  if (!loadReducers3(engine)) {
    throw loadReducerError;
  }
  validateOptions(engine, optionsSchema7, props.options, "buildStaticFilter");
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const { id } = props.options;
  dispatch(registerStaticFilter(props.options));
  return {
    ...controller,
    toggleSelect(value) {
      dispatch(toggleSelectStaticFilterValue({ id, value }));
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggledValue(id, value)
      }));
    },
    toggleSingleSelect(value) {
      if (value.state === "idle") {
        dispatch(deselectAllStaticFilterValues(id));
      }
      dispatch(toggleSelectStaticFilterValue({ id, value }));
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggledValue(id, value)
      }));
    },
    toggleExclude(value) {
      dispatch(toggleExcludeStaticFilterValue({ id, value }));
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggledValue(id, value)
      }));
    },
    toggleSingleExclude(value) {
      if (value.state === "idle") {
        dispatch(deselectAllStaticFilterValues(id));
      }
      dispatch(toggleExcludeStaticFilterValue({ id, value }));
      dispatch(executeSearch2({
        legacy: getLegacyAnalyticsActionForToggledValue(id, value)
      }));
    },
    deselectAll() {
      dispatch(deselectAllStaticFilterValues(id));
      dispatch(executeSearch2({
        legacy: logStaticFilterClearAll({ staticFilterId: id })
      }));
    },
    isValueSelected(value) {
      return value.state === "selected";
    },
    isValueExcluded(value) {
      return value.state === "excluded";
    },
    get state() {
      var _a;
      const values = ((_a = getState().staticFilterSet[id]) == null ? void 0 : _a.values) || [];
      const hasActiveValues = values.some((value) => value.state !== "idle");
      return {
        id,
        values,
        hasActiveValues
      };
    }
  };
}
function loadReducers3(engine) {
  engine.addReducers({ staticFilterSet: staticFilterSetReducer });
  return true;
}
function getLegacyAnalyticsActionForToggledValue(id, value) {
  const { caption, expression, state } = value;
  const analytics = state === "idle" ? logStaticFilterSelect : logStaticFilterDeselect;
  return analytics({
    staticFilterId: id,
    staticFilterValue: { caption, expression }
  });
}

// node_modules/@coveo/headless/dist/esm/controllers/core/tab/headless-core-tab.js
var optionsSchema8 = new Schema({
  expression: requiredEmptyAllowedString,
  id: requiredNonEmptyString,
  clearFiltersOnTabChange: new BooleanValue()
});
var initialStateSchema8 = new Schema({
  isActive: new BooleanValue()
});
function buildCoreTab(engine, props) {
  assertIdNotEqualToDefaultOriginLevel2(props.options.id);
  if (!loadTabReducers2(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  validateOptions(engine, optionsSchema8, props.options, "buildTab");
  const initialState2 = validateInitialState(engine, initialStateSchema8, props.initialState, "buildTab");
  const { id, expression } = props.options;
  dispatch(registerTab({ id, expression }));
  const isFirstTab = Object.keys(engine.state.tabSet).length === 1;
  if (isFirstTab) {
    initialState2.isActive = true;
  }
  if (initialState2.isActive) {
    dispatch(updateActiveTab(id));
  }
  return {
    ...controller,
    select() {
      if (props.options.clearFiltersOnTabChange) {
        dispatch(prepareForSearchWithQuery({
          q: "",
          clearFilters: true
        }));
      }
      dispatch(updateActiveTab(id));
    },
    get state() {
      var _a;
      const isActive = (_a = engine.state.tabSet[id]) == null ? void 0 : _a.isActive;
      return {
        isActive
      };
    }
  };
}
function loadTabReducers2(engine) {
  engine.addReducers({ configuration, tabSet: tabSetReducer });
  return true;
}
function assertIdNotEqualToDefaultOriginLevel2(id) {
  const defaultOriginLevel2 = getConfigurationInitialState().analytics.originLevel2;
  if (id === defaultOriginLevel2) {
    throw new Error(`The #id option on the Tab controller cannot use the reserved value "${defaultOriginLevel2}". Please specify a different value.`);
  }
}

// node_modules/@coveo/headless/dist/esm/controllers/tab/headless-tab.js
function buildTab(engine, props) {
  const { dispatch } = engine;
  const tab = buildCoreTab(engine, props);
  const search = () => dispatch(executeSearch2({
    legacy: logInterfaceChange(),
    next: interfaceChange()
  }));
  return {
    ...tab,
    get state() {
      return tab.state;
    },
    select() {
      tab.select();
      search();
    }
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/tab-manager/headless-tab-manager.js
function buildTabManager(engine) {
  const tabManager = buildCoreTabManager(engine);
  return {
    ...tabManager,
    get state() {
      return tabManager.state;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/triggers/triggers-slice-functions.js
function handleFetchItemsPending(state) {
  state.query = "";
  state.queryModification = {
    originalQuery: "",
    newQuery: "",
    queryToIgnore: state.queryModification.queryToIgnore
  };
  return state;
}
function handleFetchItemsFulfilled(state, triggers) {
  const redirectTriggers = [];
  const queryTriggers = [];
  const executeTriggers = [];
  const notifyTriggers = [];
  triggers.forEach((trigger) => {
    switch (trigger.type) {
      case "redirect":
        redirectTriggers.push(trigger.content);
        break;
      case "query":
        queryTriggers.push(trigger.content);
        break;
      case "execute":
        executeTriggers.push({
          functionName: trigger.content.name,
          params: trigger.content.params
        });
        break;
      case "notify":
        notifyTriggers.push(trigger.content);
        break;
    }
  });
  state.redirectTo = redirectTriggers[0] ?? "";
  state.query = state.queryModification.newQuery;
  state.executions = executeTriggers;
  state.notifications = notifyTriggers;
  return state;
}
function handleApplyQueryTriggerModification(state, payload) {
  state.queryModification = { ...payload, queryToIgnore: "" };
  return state;
}
function handleUpdateIgnoreQueryTrigger(state, payload) {
  state.queryModification.queryToIgnore = payload;
  return state;
}

// node_modules/@coveo/headless/dist/esm/features/triggers/triggers-state.js
var getTriggerInitialState = () => ({
  redirectTo: "",
  query: "",
  executions: [],
  notifications: [],
  queryModification: { originalQuery: "", newQuery: "", queryToIgnore: "" }
});

// node_modules/@coveo/headless/dist/esm/features/triggers/triggers-slice.js
var triggerReducer = createReducer(getTriggerInitialState(), (builder) => builder.addCase(executeSearch2.pending, handleFetchItemsPending).addCase(executeSearch2.fulfilled, (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)).addCase(applyQueryTriggerModification, (state, action) => handleApplyQueryTriggerModification(state, action.payload)).addCase(updateIgnoreQueryTrigger, (state, action) => handleUpdateIgnoreQueryTrigger(state, action.payload)));

// node_modules/@coveo/headless/dist/esm/controllers/triggers/headless-execute-trigger.js
function buildExecuteTrigger(engine) {
  if (!loadExecuteTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousExecutions = getState().triggers.executions;
  return {
    ...controller,
    subscribe(listener2) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(this.state.executions, previousExecutions, (first, second) => first.functionName === second.functionName && arrayEqual(first.params, second.params));
        previousExecutions = this.state.executions;
        if (hasChanged && this.state.executions.length) {
          listener2();
          dispatch(logTriggerExecute());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        executions: getState().triggers.executions
      };
    }
  };
}
function loadExecuteTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/core/triggers/headless-core-notify-trigger.js
function buildCoreNotifyTrigger(engine, props) {
  const logNotifyTrigger2 = props.options.logNotifyTriggerActionCreator;
  if (!loadNotifyTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousNotifications = getState().triggers.notifications;
  return {
    ...controller,
    subscribe(listener2) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(previousNotifications, this.state.notifications);
        previousNotifications = this.state.notifications;
        if (hasChanged) {
          listener2();
          dispatch(logNotifyTrigger2());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        notifications: getState().triggers.notifications
      };
    }
  };
}
function loadNotifyTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/triggers/headless-notify-trigger.js
function buildNotifyTrigger(engine) {
  return buildCoreNotifyTrigger(engine, {
    options: {
      logNotifyTriggerActionCreator: logNotifyTrigger
    }
  });
}

// node_modules/@coveo/headless/dist/esm/controllers/triggers/headless-query-trigger.js
function buildQueryTrigger(engine) {
  if (!loadQueryTriggerReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const modification = () => getState().triggers.queryModification.newQuery;
  const originalQuery = () => getState().triggers.queryModification.originalQuery;
  return {
    ...controller,
    get state() {
      return {
        newQuery: modification(),
        originalQuery: originalQuery(),
        wasQueryModified: modification() !== ""
      };
    },
    undo() {
      dispatch(updateIgnoreQueryTrigger(modification()));
      dispatch(updateQuery({ q: originalQuery() }));
      dispatch(executeSearch2({
        legacy: logUndoTriggerQuery({
          undoneQuery: modification()
        })
      }));
    }
  };
}
function loadQueryTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer, query: queryReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/controllers/triggers/headless-redirection-trigger.js
function buildRedirectionTrigger(engine) {
  if (!loadRedirectionReducers(engine)) {
    throw loadReducerError;
  }
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousRedirectTo = getState().triggers.redirectTo;
  return {
    ...controller,
    subscribe(listener2) {
      const strictListener = () => {
        const hasChanged = previousRedirectTo !== this.state.redirectTo;
        previousRedirectTo = this.state.redirectTo;
        if (hasChanged && this.state.redirectTo) {
          listener2();
          dispatch(logTriggerRedirect());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        redirectTo: getState().triggers.redirectTo
      };
    }
  };
}
function loadRedirectionReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/search-parameters/search-parameter-serializer.js
var rangeDelimiterExclusive = "..";
var rangeDelimiterInclusive = "...";
var facetSearchParamRegex = /^(f|fExcluded|cf|nf|df|sf|af|mnf)-(.+)$/;
var supportedFacetParameters = {
  f: true,
  fExcluded: true,
  cf: true,
  sf: true,
  af: true,
  nf: true,
  df: true,
  mnf: true
};
var delimiter = "&";
var equal = "=";
function buildSearchParameterSerializer() {
  return { serialize: serialize(serializePair), deserialize };
}
function keyHasObjectValue(key) {
  return key in supportedFacetParameters;
}
function isValidBasicKey(key) {
  const supportedBasicParameters = {
    q: true,
    aq: true,
    cq: true,
    enableQuerySyntax: true,
    firstResult: true,
    numberOfResults: true,
    sortCriteria: true,
    debug: true,
    tab: true
  };
  return key in supportedBasicParameters;
}
function isRangeFacetKey(key) {
  const supportedRangeFacetParameters = {
    nf: true,
    df: true,
    mnf: true
  };
  const isRangeFacet = key in supportedRangeFacetParameters;
  return keyHasObjectValue(key) && isRangeFacet;
}
function isValidKey(key) {
  return isValidBasicKey(key) || keyHasObjectValue(key);
}
var serialize = (pairSerializer) => (obj) => {
  return Object.entries(obj).map(pairSerializer).filter((str) => str).join(delimiter);
};
function serializePair(pair) {
  const [key, val] = pair;
  if (!isValidKey(key)) {
    return "";
  }
  if (keyHasObjectValue(key) && !isRangeFacetKey(key)) {
    return isFacetObject(val) ? serializeFacets(key, val) : "";
  }
  if (key === "nf" || key === "df") {
    return isRangeFacetObject(val) ? serializeRangeFacets(key, val) : "";
  }
  return serializeSpecialCharacters(key, val);
}
function serializeSpecialCharacters(key, val) {
  return `${key}${equal}${encodeURIComponent(val)}`;
}
function isFacetObject(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isValidValue = (v) => typeof v === "string";
  return allEntriesAreValid(obj, isValidValue);
}
function isRangeFacetObject(obj) {
  if (!isObject2(obj)) {
    return false;
  }
  const isRangeValue = (v) => isObject2(v) && "start" in v && "end" in v;
  return allEntriesAreValid(obj, isRangeValue);
}
function isObject2(obj) {
  return !!(obj && typeof obj === "object");
}
function allEntriesAreValid(obj, isValidValue) {
  const invalidEntries = Object.entries(obj).filter((entry) => {
    const values = entry[1];
    return !Array.isArray(values) || !values.every(isValidValue);
  });
  return invalidEntries.length === 0;
}
function serializeFacets(key, facets) {
  return Object.entries(facets).map(([facetId2, values]) => `${key}-${facetId2}${equal}${values.map((value) => encodeURIComponent(value)).join(",")}`).join(delimiter);
}
function serializeRangeFacets(key, facets) {
  return Object.entries(facets).map(([facetId2, ranges]) => {
    const value = ranges.map(({ start, end, endInclusive }) => `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`).join(",");
    return `${key}-${facetId2}${equal}${value}`;
  }).join(delimiter);
}
function deserialize(fragment) {
  const parts = fragment.split(delimiter);
  const keyValuePairs = parts.map((part) => splitOnFirstEqual(part)).map((parts2) => preprocessObjectPairs(parts2)).filter(isValidPair).map((pair) => cast(pair));
  return keyValuePairs.reduce((acc, pair) => {
    const [key, val] = pair;
    if (keyHasObjectValue(key)) {
      const mergedValues = { ...acc[key], ...val };
      return { ...acc, [key]: mergedValues };
    }
    return { ...acc, [key]: val };
  }, {});
}
function splitOnFirstEqual(str) {
  const [first, ...rest] = str.split(equal);
  const second = rest.join(equal);
  return [first, second];
}
function preprocessObjectPairs(pair, regex = facetSearchParamRegex) {
  const [key, val] = pair;
  const result = regex.exec(key);
  if (!result) {
    return pair;
  }
  const paramKey = result[1];
  const id = result[2];
  const values = val.split(",");
  const processedValues = processObjectValues(paramKey, values);
  const obj = { [id]: processedValues };
  return [paramKey, JSON.stringify(obj)];
}
function processObjectValues(key, values) {
  if (key === "nf" || key === "mnf") {
    return buildNumericRanges(values, "selected");
  }
  if (key === "df") {
    return buildDateRanges(values, "selected");
  }
  return values;
}
function buildNumericRanges(ranges, state) {
  const numericRanges = [];
  for (const range of ranges) {
    const { startAsString, endAsString, isEndInclusive } = splitRangeValueAsStringByDelimiter(range);
    const start = parseFloat(startAsString);
    const end = parseFloat(endAsString);
    if (!Number.isFinite(start) || !Number.isFinite(end)) {
      continue;
    }
    numericRanges.push(buildNumericRange({ start, end, state, endInclusive: isEndInclusive }));
  }
  return numericRanges;
}
function isValidDateRangeValue(date) {
  try {
    if (isSearchApiDate(date)) {
      validateAbsoluteDate(date, API_DATE_FORMAT);
      return true;
    }
    if (isRelativeDateFormat(date)) {
      validateRelativeDate(date);
      return true;
    }
    return false;
  } catch (_) {
    return false;
  }
}
function buildDateRanges(ranges, state) {
  const dateRanges = [];
  for (const range of ranges) {
    const { isEndInclusive, startAsString, endAsString } = splitRangeValueAsStringByDelimiter(range);
    if (!isValidDateRangeValue(startAsString) || !isValidDateRangeValue(endAsString)) {
      continue;
    }
    dateRanges.push(buildDateRange({
      start: startAsString,
      end: endAsString,
      state,
      endInclusive: isEndInclusive
    }));
  }
  return dateRanges;
}
function isValidPair(pair) {
  const validKey = isValidKey(pair[0]);
  const lengthOfTwo = pair.length === 2;
  return validKey && lengthOfTwo;
}
function cast(pair, decode = true) {
  const [key, value] = pair;
  if (key === "enableQuerySyntax") {
    return [key, value === "true"];
  }
  if (key === "debug") {
    return [key, value === "true"];
  }
  if (key === "firstResult") {
    return [key, parseInt(value)];
  }
  if (key === "numberOfResults") {
    return [key, parseInt(value)];
  }
  if (keyHasObjectValue(key)) {
    return [key, castUnknownObject(value)];
  }
  return [key, decode ? decodeURIComponent(value) : value];
}
function castUnknownObject(value) {
  const jsonParsed = JSON.parse(value);
  const ret = {};
  Object.entries(jsonParsed).forEach((entry) => {
    const [id, values] = entry;
    ret[id] = values.map((v) => isString(v) ? decodeURIComponent(v) : v);
  });
  return ret;
}
function splitRangeValueAsStringByDelimiter(str) {
  const isEndInclusive = str.indexOf(rangeDelimiterInclusive) !== -1;
  const [startAsString, endAsString] = str.split(isEndInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive);
  return {
    isEndInclusive,
    startAsString,
    endAsString
  };
}

// node_modules/@coveo/headless/dist/esm/controllers/url-manager/headless-url-manager.js
var initialStateSchema9 = new Schema({
  fragment: new StringValue()
});
function buildUrlManager(engine, props) {
  let lastRequestId;
  function updateLastRequestId() {
    lastRequestId = engine.state.search.requestId;
  }
  function hasRequestIdChanged() {
    return lastRequestId !== engine.state.search.requestId;
  }
  if (!loadUrlManagerReducers(engine)) {
    throw loadReducerError;
  }
  validateInitialState(engine, initialStateSchema9, props.initialState, "buildUrlManager");
  const controller = buildController(engine);
  let previousFragment = props.initialState.fragment;
  updateLastRequestId();
  const searchParameterManager = buildSearchParameterManager(engine, {
    initialState: {
      parameters: deserializeFragment(previousFragment)
    }
  });
  return {
    ...controller,
    subscribe(listener2) {
      const strictListener = () => {
        const newFragment = this.state.fragment;
        if (!areFragmentsEquivalent(previousFragment, newFragment) && hasRequestIdChanged()) {
          previousFragment = newFragment;
          listener2();
        }
        updateLastRequestId();
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        fragment: buildSearchParameterSerializer().serialize(searchParameterManager.state.parameters)
      };
    },
    synchronize(fragment) {
      previousFragment = fragment;
      const parameters = deserializeFragment(fragment);
      searchParameterManager.synchronize(parameters);
    }
  };
}
function areFragmentsEquivalent(fragment1, fragment2) {
  if (fragment1 === fragment2) {
    return true;
  }
  const params1 = deserializeFragment(fragment1);
  const params2 = deserializeFragment(fragment2);
  return deepEqualAnyOrder(params1, params2);
}
function deserializeFragment(fragment) {
  return buildSearchParameterSerializer().deserialize(fragment);
}
function loadUrlManagerReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/actions-history/ipx-actions-history-actions.js
var addPageViewEntryInActionsHistory = createAsyncThunk("analytics/addPageViewEntry", async (itemPermanentId, { getState }) => {
  const state = getState();
  if (state.configuration.analytics.enabled) {
    history_store_default.getInstance().addElement({
      name: "PageView",
      value: itemPermanentId,
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
});

// node_modules/@coveo/headless/dist/esm/features/actions-history/ipx-actions-history-actions-loader.js
function loadIPXActionsHistoryActions(engine) {
  engine.addReducers({});
  return {
    addPageViewEntryInActionsHistory
  };
}

// node_modules/@coveo/headless/dist/esm/features/advanced-search-queries/advanced-search-queries-actions.js
var optionalAndPossiblyEmpty = () => new StringValue({ required: false, emptyAllowed: true });
var updateAdvancedSearchQueries = createAction("advancedSearchQueries/update", (payload) => validatePayload(payload, {
  aq: optionalAndPossiblyEmpty(),
  cq: optionalAndPossiblyEmpty(),
  lq: optionalAndPossiblyEmpty(),
  dq: optionalAndPossiblyEmpty()
}));
var registerAdvancedSearchQueries = createAction("advancedSearchQueries/register", (payload) => validatePayload(payload, {
  aq: optionalAndPossiblyEmpty(),
  cq: optionalAndPossiblyEmpty(),
  lq: optionalAndPossiblyEmpty(),
  dq: optionalAndPossiblyEmpty()
}));

// node_modules/@coveo/headless/dist/esm/features/advanced-search-queries/advanced-search-queries-slice.js
var advancedSearchQueriesReducer = createReducer(getAdvancedSearchQueriesInitialState(), (builder) => {
  builder.addCase(updateAdvancedSearchQueries, (state, action) => {
    const { aq, cq, lq, dq } = action.payload;
    if (!isUndefined(aq)) {
      state.aq = aq;
      state.aqWasSet = true;
    }
    if (!isUndefined(cq)) {
      state.cq = cq;
      state.cqWasSet = true;
    }
    if (!isUndefined(lq)) {
      state.lq = lq;
      state.lqWasSet = true;
    }
    if (!isUndefined(dq)) {
      state.dq = dq;
      state.dqWasSet = true;
    }
  }).addCase(registerAdvancedSearchQueries, (state, action) => {
    const { aq, cq, lq, dq } = action.payload;
    if (!isUndefined(aq)) {
      state.defaultFilters.aq = aq;
      if (!state.aqWasSet) {
        state.aq = aq;
      }
    }
    if (!isUndefined(cq)) {
      state.defaultFilters.cq = cq;
      if (!state.cqWasSet) {
        state.cq = cq;
      }
    }
    if (!isUndefined(lq)) {
      state.defaultFilters.lq = lq;
      if (!state.lqWasSet) {
        state.lq = lq;
      }
    }
    if (!isUndefined(dq)) {
      state.defaultFilters.dq = dq;
      if (!state.dqWasSet) {
        state.dq = dq;
      }
    }
  }).addCase(change.fulfilled, (state, action) => {
    var _a;
    return ((_a = action.payload) == null ? void 0 : _a.advancedSearchQueries) ?? state;
  }).addCase(restoreSearchParameters, (state, action) => {
    const { aq, cq } = action.payload;
    if (!isUndefined(aq)) {
      state.aq = aq;
      state.aqWasSet = true;
    }
    if (!isUndefined(cq)) {
      state.cq = cq;
      state.cqWasSet = true;
    }
  });
});

// node_modules/@coveo/headless/dist/esm/features/advanced-search-queries/advanced-search-queries-actions-loader.js
function loadAdvancedSearchQueryActions(engine) {
  engine.addReducers({ advancedSearchQueries: advancedSearchQueriesReducer });
  return {
    updateAdvancedSearchQueries,
    registerAdvancedSearchQueries
  };
}

// node_modules/@coveo/headless/dist/esm/features/analytics/click-analytics-actions-loader.js
function loadClickAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logDocumentOpen,
    logOpenSmartSnippetSource,
    logOpenSmartSnippetSuggestionSource,
    logOpenSmartSnippetInlineLink,
    logOpenSmartSnippetSuggestionInlineLink
  };
}

// node_modules/@coveo/headless/dist/esm/features/analytics/generic-analytics-actions-loader.js
function loadGenericAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logSearchEvent,
    logClickEvent,
    logCustomEvent
  };
}

// node_modules/@coveo/headless/dist/esm/features/analytics/search-analytics-actions-loader.js
function loadSearchAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logClearBreadcrumbs,
    logInterfaceLoad,
    logSearchFromLink,
    logOmniboxFromLink,
    logInterfaceChange,
    logDidYouMeanClick,
    logCategoryFacetBreadcrumb,
    logFacetBreadcrumb,
    logFacetClearAll,
    logFacetUnexclude,
    logFacetExclude,
    logFacetDeselect,
    logFacetSelect,
    logFacetShowLess,
    logFacetShowMore,
    logFacetUpdateSort,
    logDateFacetBreadcrumb,
    logNumericFacetBreadcrumb,
    logNavigateBackward,
    logNavigateForward,
    logPageNext,
    logPageNumber,
    logPagePrevious,
    logPagerResize,
    logSearchboxSubmit,
    logQuerySuggestionClick,
    logResultsSort,
    logDislikeSmartSnippet,
    logLikeSmartSnippet,
    logOpenSmartSnippetFeedbackModal,
    logCloseSmartSnippetFeedbackModal,
    logSmartSnippetFeedback,
    logSmartSnippetDetailedFeedback,
    logExpandSmartSnippet,
    logCollapseSmartSnippet,
    logExpandSmartSnippetSuggestion,
    logCollapseSmartSnippetSuggestion,
    logNoResultsBack,
    logStaticFilterSelect,
    logStaticFilterDeselect,
    logStaticFilterClearAll,
    logTriggerQuery,
    logUndoTriggerQuery,
    logNotifyTrigger,
    logTriggerRedirect,
    logTriggerExecute
  };
}

// node_modules/@coveo/headless/dist/esm/features/breadcrumb/breadcrumb-actions-loader.js
function loadBreadcrumbActions(engine) {
  engine.addReducers({});
  return {
    deselectAllBreadcrumbs,
    deselectAllNonBreadcrumbs
  };
}

// node_modules/@coveo/headless/dist/esm/features/configuration/configuration-actions-loader.js
function loadConfigurationActions(engine) {
  engine.addReducers({ configuration });
  return {
    disableAnalytics,
    enableAnalytics,
    setOriginLevel2,
    setOriginLevel3,
    updateAnalyticsConfiguration,
    updateBasicConfiguration
  };
}

// node_modules/@coveo/headless/dist/esm/features/configuration/search-configuration-actions-loader.js
function loadSearchConfigurationActions(engine) {
  engine.addReducers({ configuration, pipeline: pipelineReducer, searchHub: searchHubReducer });
  return {
    updateSearchConfiguration
  };
}

// node_modules/@coveo/headless/dist/esm/features/context/context-actions-loader.js
function loadContextActions(engine) {
  engine.addReducers({ context: contextReducer });
  return {
    addContext,
    removeContext,
    setContext
  };
}

// node_modules/@coveo/headless/dist/esm/features/debug/debug-actions-loader.js
function loadDebugActions(engine) {
  engine.addReducers({ debug: debugReducer });
  return {
    disableDebug,
    enableDebug
  };
}

// node_modules/@coveo/headless/dist/esm/features/dictionary-field-context/dictionary-field-context-actions-loader.js
function loadDictionaryFieldContextActions(engine) {
  engine.addReducers({ dictionaryFieldContext: dictionaryFieldContextReducer });
  return {
    addContext: addContext2,
    removeContext: removeContext2,
    setContext: setContext2
  };
}

// node_modules/@coveo/headless/dist/esm/features/did-you-mean/did-you-mean-actions-loader.js
function loadDidYouMeanActions(engine) {
  engine.addReducers({ didYouMean: didYouMeanReducer, query: queryReducer });
  return {
    applyDidYouMeanCorrection,
    disableDidYouMean,
    enableDidYouMean,
    enableAutomaticQueryCorrection,
    disableAutomaticQueryCorrection,
    setCorrectionMode
  };
}

// node_modules/@coveo/headless/dist/esm/features/excerpt-length/excerpt-length-actions.js
var setExcerptLength = createAction("excerptLength/set", (length) => validatePayload(length, new NumberValue({ min: 0, required: true })));

// node_modules/@coveo/headless/dist/esm/features/excerpt-length/excerpt-length-state.js
function getExcerptLengthInitialState() {
  return {
    length: void 0
  };
}

// node_modules/@coveo/headless/dist/esm/features/excerpt-length/excerpt-length-slice.js
var excerptLengthReducer = createReducer(getExcerptLengthInitialState(), (builder) => {
  builder.addCase(setExcerptLength, (state, action) => {
    state.length = action.payload;
  });
});

// node_modules/@coveo/headless/dist/esm/features/excerpt-length/excerpt-length-actions-loader.js
function loadExcerptLengthActions(engine) {
  engine.addReducers({ excerptLength: excerptLengthReducer });
  return {
    setExcerptLength
  };
}

// node_modules/@coveo/headless/dist/esm/features/facet-options/facet-options-actions-loader.js
function loadFacetOptionsActions(engine) {
  engine.addReducers({ facetOptions: facetOptionsReducer });
  return {
    updateFacetOptions,
    enableFacet,
    disableFacet
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/automatic-facet-set/automatic-facet-set-actions-loader.js
function loadAutomaticFacetSetActions(engine) {
  engine.addReducers({ automaticFacetSet: automaticFacetSetReducer });
  return {
    setOptions,
    deselectAllAutomaticFacetValues,
    toggleSelectAutomaticFacetValue
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/category-facet-set/category-facet-set-actions-loader.js
function loadCategoryFacetSetActions(engine) {
  engine.addReducers({ categoryFacetSet: categoryFacetSetReducer });
  return {
    deselectAllCategoryFacetValues,
    registerCategoryFacet,
    toggleSelectCategoryFacetValue,
    updateCategoryFacetNumberOfValues,
    updateCategoryFacetSortCriterion,
    updateFacetAutoSelection,
    updateCategoryFacetBasePath
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/facet-set/facet-set-actions-loader.js
function loadFacetSetActions(engine) {
  engine.addReducers({ facetSet: facetSetReducer });
  return {
    deselectAllFacetValues,
    registerFacet,
    toggleSelectFacetValue,
    toggleExcludeFacetValue,
    updateFacetIsFieldExpanded,
    updateFacetNumberOfValues,
    updateFacetSortCriterion,
    updateFreezeCurrentValues,
    updateFacetAutoSelection
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/date-facet-set/date-facet-actions-loader.js
function loadDateFacetSetActions(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer });
  return {
    deselectAllDateFacetValues,
    registerDateFacet,
    toggleSelectDateFacetValue,
    toggleExcludeDateFacetValue,
    updateDateFacetSortCriterion,
    updateDateFacetValues
  };
}

// node_modules/@coveo/headless/dist/esm/features/facets/range-facets/numeric-facet-set/numeric-facet-actions-loader.js
function loadNumericFacetSetActions(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer });
  return {
    deselectAllNumericFacetValues,
    registerNumericFacet,
    toggleSelectNumericFacetValue,
    toggleExcludeNumericFacetValue,
    updateNumericFacetSortCriterion,
    updateNumericFacetValues
  };
}

// node_modules/@coveo/headless/dist/esm/features/fields/fields-actions-loader.js
function loadFieldActions(engine) {
  engine.addReducers({ fields: fieldsReducer });
  return {
    registerFieldsToInclude,
    enableFetchAllFields,
    disableFetchAllFields,
    fetchFieldsDescription
  };
}

// node_modules/@coveo/headless/dist/esm/features/folding/folding-actions-loader.js
function loadFoldingActions(engine) {
  engine.addReducers({ folding: foldingReducer });
  return {
    registerFolding,
    loadCollection
  };
}

// node_modules/@coveo/headless/dist/esm/features/generated-answer/generated-answer-actions-loader.js
function loadGeneratedAnswerActions(engine) {
  engine.addReducers({ generatedAnswer: generatedAnswerReducer });
  return {
    generateAnswer,
    resetAnswer,
    setAnswerGenerationMode
  };
}

// node_modules/@coveo/headless/dist/esm/features/history/history-actions-loader.js
function loadHistoryActions(engine) {
  engine.addReducers({ history: history2, facetOrder: facetOrderReducer });
  return {
    back,
    forward
  };
}

// node_modules/@coveo/headless/dist/esm/features/instant-results/instant-results-actions-loader.js
function loadInstantResultsActions(engine) {
  engine.addReducers({ instantResults: instantResultsReducer });
  return {
    registerInstantResults,
    updateInstantResultsQuery,
    clearExpiredResults
  };
}

// node_modules/@coveo/headless/dist/esm/features/pagination/pagination-actions-loader.js
function loadPaginationActions(engine) {
  engine.addReducers({ pagination: paginationReducer });
  return {
    nextPage,
    previousPage,
    registerNumberOfResults,
    registerPage,
    updateNumberOfResults,
    updatePage
  };
}

// node_modules/@coveo/headless/dist/esm/features/pipeline/pipeline-actions-loader.js
function loadPipelineActions(engine) {
  engine.addReducers({ pipeline: pipelineReducer });
  return {
    setPipeline
  };
}

// node_modules/@coveo/headless/dist/esm/features/query/query-actions-loader.js
function loadQueryActions(engine) {
  engine.addReducers({ query: queryReducer });
  return {
    updateQuery
  };
}

// node_modules/@coveo/headless/dist/esm/features/query-set/query-set-actions-loader.js
function loadQuerySetActions(engine) {
  engine.addReducers({ querySet: querySetReducer });
  return {
    registerQuerySetQuery,
    updateQuerySetQuery
  };
}

// node_modules/@coveo/headless/dist/esm/features/query-suggest/query-suggest-actions-loader.js
function loadQuerySuggestActions(engine) {
  engine.addReducers({ querySuggest: querySuggestReducer, querySet: querySetReducer });
  return {
    clearQuerySuggest: clearQuerySuggest2,
    fetchQuerySuggestions: fetchQuerySuggestions2,
    registerQuerySuggest: registerQuerySuggest2,
    selectQuerySuggestion: selectQuerySuggestion2
  };
}

// node_modules/@coveo/headless/dist/esm/features/question-answering/question-answering-actions-loader.js
function loadQuestionAnsweringActions(engine) {
  engine.addReducers({ questionAnswering: questionAnsweringReducer });
  return {
    collapseSmartSnippet,
    expandSmartSnippet,
    dislikeSmartSnippet,
    likeSmartSnippet,
    openFeedbackModal,
    closeFeedbackModal,
    expandSmartSnippetRelatedQuestion,
    collapseSmartSnippetRelatedQuestion
  };
}

// node_modules/@coveo/headless/dist/esm/features/recent-queries/recent-queries-actions-loader.js
function loadRecentQueriesActions(engine) {
  engine.addReducers({ recentQueries: recentQueriesReducer });
  return {
    registerRecentQueries,
    clearRecentQueries
  };
}

// node_modules/@coveo/headless/dist/esm/features/recent-results/recent-results-actions-loader.js
function loadRecentResultsActions(engine) {
  engine.addReducers({ recentResults: recentResultsReducer });
  return {
    registerRecentResults,
    clearRecentResults,
    pushRecentResult
  };
}

// node_modules/@coveo/headless/dist/esm/features/result-preview/result-preview-actions-loader.js
function loadResultPreviewActions(engine) {
  engine.addReducers({ resultPreview: resultPreviewReducer });
  return {
    fetchResultContent,
    updateContentURL,
    nextPreview,
    previousPreview,
    preparePreviewPagination
  };
}

// node_modules/@coveo/headless/dist/esm/features/templates/templates-manager.js
var templateSchema = new Schema({
  content: new Value({ required: true }),
  conditions: new Value({ required: true }),
  priority: new NumberValue({ required: false, default: 0, min: 0 }),
  fields: new ArrayValue({
    required: false,
    each: requiredNonEmptyString
  })
});
function buildTemplatesManager() {
  const templates = [];
  const validateTemplate = (template) => {
    const validated = templateSchema.validate(template);
    const areConditionsValid = template.conditions.every((condition) => condition instanceof Function);
    if (!areConditionsValid) {
      throw new SchemaValidationError("Each template condition should be a function that takes a Result or Product as an argument and returns a boolean");
    }
    return validated;
  };
  return {
    registerTemplates(...newTemplates) {
      newTemplates.forEach((template) => {
        const templatesWithDefault = {
          ...validateTemplate(template),
          fields: template.fields || []
        };
        templates.push(templatesWithDefault);
      });
      templates.sort((a, b) => b.priority - a.priority);
    },
    selectTemplate(item) {
      const template = templates.find((template2) => template2.conditions.every((condition) => condition(item)));
      return template ? template.content : null;
    },
    selectLinkTemplate(item) {
      const template = templates.find((template2) => template2.conditions.every((condition) => condition(item)));
      return template ? template.linkContent : null;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/features/result-templates/result-templates-manager.js
function buildResultTemplatesManager(engine) {
  if (!loadResultTemplatesManagerReducers(engine)) {
    throw loadReducerError;
  }
  const { registerTemplates: coreRegisterTemplates, selectTemplate, selectLinkTemplate } = buildTemplatesManager();
  return {
    registerTemplates: (...newTemplates) => {
      coreRegisterTemplates(...newTemplates);
      const fields = [];
      newTemplates.forEach((template) => {
        template.fields && fields.push(...template.fields);
      });
      engine.dispatch(registerFieldsToInclude(fields));
    },
    selectTemplate,
    selectLinkTemplate
  };
}
function loadResultTemplatesManagerReducers(engine) {
  engine.addReducers({ fields: fieldsReducer });
  return true;
}

// node_modules/@coveo/headless/dist/esm/features/search/search-actions-loader.js
function loadSearchActions(engine) {
  engine.addReducers({ search: searchReducer });
  return {
    executeSearch,
    fetchMoreResults,
    fetchFacetValues,
    fetchPage,
    fetchInstantResults
  };
}

// node_modules/@coveo/headless/dist/esm/features/search-hub/search-hub-actions-loader.js
function loadSearchHubActions(engine) {
  engine.addReducers({ searchHub: searchHubReducer });
  return { setSearchHub };
}

// node_modules/@coveo/headless/dist/esm/features/search-parameters/search-parameter-actions-loader.js
function loadSearchParameterActions(engine) {
  engine.addReducers({
    facetOrder: facetOrderReducer,
    facetSet: facetSetReducer,
    pagination: paginationReducer,
    query: queryReducer,
    querySet: querySetReducer
  });
  return {
    restoreSearchParameters,
    restoreTab
  };
}

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/sort-criteria-actions-loader.js
function loadSortCriteriaActions(engine) {
  engine.addReducers({ sortCriteria: sortCriteriaReducer });
  return {
    registerSortCriterion,
    updateSortCriterion
  };
}

// node_modules/@coveo/headless/dist/esm/features/standalone-search-box-set/standalone-search-box-set-actions-loader.js
function loadStandaloneSearchBoxSetActions(engine) {
  engine.addReducers({ standaloneSearchBoxSet: standaloneSearchBoxSetReducer });
  return {
    registerStandaloneSearchBox,
    fetchRedirectUrl,
    updateStandaloneSearchBoxRedirectionUrl,
    updateAnalyticsToSearchFromLink,
    updateAnalyticsToOmniboxFromLink,
    resetStandaloneSearchBox
  };
}

// node_modules/@coveo/headless/dist/esm/features/static-filter-set/static-filter-set-actions-loader.js
function loadStaticFilterSetActions(engine) {
  engine.addReducers({ staticFilterSet: staticFilterSetReducer });
  return {
    registerStaticFilter,
    toggleSelectStaticFilterValue,
    toggleExcludeStaticFilterValue,
    deselectAllStaticFilterValues
  };
}

// node_modules/@coveo/headless/dist/esm/features/tab-set/tab-set-actions-loader.js
function loadTabSetActions(engine) {
  engine.addReducers({ tabSet: tabSetReducer });
  return {
    registerTab,
    updateActiveTab
  };
}

// node_modules/@coveo/headless/dist/esm/features/sort-criteria/criteria-parser.js
function parseCriterion(criterion) {
  const { by, order } = criterion;
  switch (by) {
    case SortBy.Relevancy:
      return buildRelevanceSortCriterion();
    case SortBy.QRE:
      return buildQueryRankingExpressionSortCriterion();
    case SortBy.NoSort:
      return buildNoSortCriterion();
    case SortBy.Date:
      if (!order) {
        throw new Error('An order (i.e., ascending or descending) should be specified for a sort criterion sorted by "date"');
      }
      return buildDateSortCriterion(order);
    default:
      if (!order) {
        throw new Error(`An order (i.e., ascending or descending) should be specified for a sort criterion sorted by a field, such as "${by}"`);
      }
      return buildFieldSortCriterion(by, order);
  }
}
function isSortOrder(order) {
  return order === void 0 || order === SortOrder.Ascending || order === SortOrder.Descending;
}
function parseCriterionExpression(expression) {
  const criteria = expression.split(",");
  const wrongFormatError = new Error(`Wrong criterion expression format for "${expression}"`);
  if (!criteria.length) {
    throw wrongFormatError;
  }
  return criteria.map((criterion) => {
    var _a;
    const criterionValues = criterion.trim().split(" ");
    const by = criterionValues[0].toLowerCase();
    const order = (_a = criterionValues[1]) == null ? void 0 : _a.toLowerCase();
    if (criterionValues.length > 2) {
      throw wrongFormatError;
    }
    if (by === "") {
      throw wrongFormatError;
    }
    if (!isSortOrder(order)) {
      throw new Error(`Wrong criterion sort order "${order}" in expression "${expression}". Order should either be "${SortOrder.Ascending}" or "${SortOrder.Descending}"`);
    }
    return parseCriterion({ by, order });
  });
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/common/negatable.js
function getNegationPrefix(config) {
  return config.negate ? "NOT " : "";
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/common/operator.js
function getOperatorSymbol(operator) {
  const dictionary = {
    contains: "=",
    differentThan: "<>",
    fuzzyMatch: "~=",
    greaterThan: ">",
    greaterThanOrEqual: ">=",
    isExactly: "==",
    lowerThan: "<",
    lowerThanOrEqual: "<=",
    phoneticMatch: "%=",
    regexMatch: "/=",
    wildcardMatch: "*="
  };
  return dictionary[operator];
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/date-field/date-field.js
function buildDateField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const operator = getOperatorSymbol(config.operator);
      const prefix = getNegationPrefix(config);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/date-range-field/date-range-field.js
function buildDateRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/exact-match/exact-match.js
function buildExactMatch(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { expression } = config;
      return `${prefix}"${expression}"`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/field-exists/field-exists.js
function buildFieldExists(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2 } = config;
      return `${prefix}@${field2}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/keyword/keyword.js
function buildKeyword(config) {
  return {
    toQuerySyntax() {
      const { expression, negate } = config;
      return negate ? `NOT (${expression})` : expression;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/near/near.js
function buildNear(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { startTerm, otherTerms } = config;
      const otherTermsExpression = buildOtherTerms(otherTerms);
      const expression = `${startTerm} ${otherTermsExpression}`;
      return config.negate ? `${prefix}(${expression})` : expression;
    }
  };
}
function buildOtherTerms(terms) {
  return terms.map((term) => {
    const { endTerm, maxKeywordsBetween } = term;
    return `near:${maxKeywordsBetween} ${endTerm}`;
  }).join(" ");
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/numeric-field/numeric-field.js
function buildNumericField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/numeric-range-field/numeric-range-field.js
function buildNumericRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/query-extension/query-extension.js
function buildQueryExtension(config) {
  return {
    toQuerySyntax() {
      const { name, parameters } = config;
      const argumentExpression = buildParameters(parameters);
      return `$${name}(${argumentExpression})`;
    }
  };
}
function buildParameters(params) {
  return Object.entries(params).map((entry) => {
    const [name, value] = entry;
    const formatted = typeof value === "string" ? value : value.toQuerySyntax();
    return `${name}: ${formatted}`;
  }).join(", ");
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/string-facet-field/string-facet-field.js
function buildStringFacetField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, operator, value } = config;
      const symbol = getOperatorSymbol(operator);
      const formattedValue = operator === "fuzzyMatch" ? ` $quoteVar(value: ${value})` : `("${value}")`;
      return `${prefix}@${field2}${symbol}${formattedValue}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/string-field/string-field.js
function buildStringField(config) {
  return {
    toQuerySyntax() {
      const { field: field2 } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      const processed = config.values.map((value) => `"${value}"`);
      const values = processed.length === 1 ? processed[0] : `(${processed.join(",")})`;
      return `${prefix}@${field2}${operator}${values}`;
    }
  };
}

// node_modules/@coveo/headless/dist/esm/utils/query-expression/query-expression.js
function buildQueryExpression() {
  const parts = [];
  let booleanOperator = "and";
  return {
    addExpression(expression) {
      parts.push(expression);
      return this;
    },
    addKeyword(expression) {
      parts.push(buildKeyword(expression));
      return this;
    },
    addNear(expression) {
      parts.push(buildNear(expression));
      return this;
    },
    addExactMatch(expression) {
      parts.push(buildExactMatch(expression));
      return this;
    },
    addFieldExists(expression) {
      parts.push(buildFieldExists(expression));
      return this;
    },
    addStringField(expression) {
      parts.push(buildStringField(expression));
      return this;
    },
    addStringFacetField(expression) {
      parts.push(buildStringFacetField(expression));
      return this;
    },
    addNumericField(expression) {
      parts.push(buildNumericField(expression));
      return this;
    },
    addNumericRangeField(expression) {
      parts.push(buildNumericRangeField(expression));
      return this;
    },
    addDateField(expression) {
      parts.push(buildDateField(expression));
      return this;
    },
    addDateRangeField(expression) {
      parts.push(buildDateRangeField(expression));
      return this;
    },
    addQueryExtension(expression) {
      parts.push(buildQueryExtension(expression));
      return this;
    },
    joinUsing(operator) {
      booleanOperator = operator;
      return this;
    },
    toQuerySyntax() {
      const symbol = getBooleanOperatorSymbol(booleanOperator);
      const expression = parts.map((part) => part.toQuerySyntax()).join(`) ${symbol} (`);
      return parts.length <= 1 ? expression : `(${expression})`;
    }
  };
}
function getBooleanOperatorSymbol(operator) {
  return operator === "and" ? "AND" : "OR";
}
export {
  API_DATE_FORMAT,
  DefaultFieldsToInclude,
  EcommerceDefaultFieldsToInclude,
  highlight_exports as HighlightUtils,
  MinimumFieldsToInclude,
  ResultTemplatesHelpers,
  SortBy,
  SortOrder,
  VERSION,
  baseFacetResponseSelector,
  buildAutomaticFacetGenerator,
  buildBreadcrumbManager,
  buildCategoryFacet,
  buildCategoryFieldSuggestions,
  buildContext,
  buildController,
  buildCriterionExpression,
  buildDateFacet,
  buildDateFilter,
  buildDateRange,
  buildDateSortCriterion,
  buildDictionaryFieldContext,
  buildDidYouMean,
  buildExecuteTrigger,
  buildFacet,
  buildCoreFacetConditionsManager as buildFacetConditionsManager,
  buildFacetManager,
  buildFieldSortCriterion,
  buildFieldSuggestions,
  buildFoldedResultList,
  buildGeneratedAnswer,
  buildHistoryManager,
  buildInstantResults,
  buildInteractiveCitation,
  buildInteractiveInstantResult,
  buildInteractiveRecentResult,
  buildInteractiveResult,
  buildNoSortCriterion,
  buildNotifyTrigger,
  buildNumericFacet,
  buildNumericFilter,
  buildNumericRange,
  buildPager,
  buildQueryError,
  buildQueryExpression,
  buildQueryRankingExpressionSortCriterion,
  buildQuerySummary,
  buildQueryTrigger,
  buildQuickview,
  buildRecentQueriesList,
  buildRecentResultsList,
  buildRedirectionTrigger,
  buildRelevanceInspector,
  buildRelevanceSortCriterion,
  buildResultList,
  buildResultTemplatesManager,
  buildResultsPerPage,
  buildSearchBox,
  buildSearchEngine,
  buildSearchParameterManager,
  buildSearchParameterSerializer,
  buildSearchStatus,
  buildSmartSnippet,
  buildSmartSnippetQuestionsList,
  buildSort,
  buildStandaloneSearchBox,
  buildStaticFilter,
  buildStaticFilterValue,
  buildTab,
  buildTabManager,
  buildUrlManager,
  currentPageSelector,
  currentPagesSelector,
  deserializeRelativeDate,
  facetRequestSelector,
  facetResponseSelectedValuesSelector,
  facetResponseSelector,
  getAnalyticsNextApiBaseUrl,
  getOrganizationEndpoint,
  getSampleSearchEngineConfiguration,
  getSearchApiBaseUrl,
  loadAdvancedSearchQueryActions,
  loadAutomaticFacetSetActions,
  loadBreadcrumbActions,
  loadCategoryFacetSetActions,
  loadClickAnalyticsActions,
  loadConfigurationActions,
  loadContextActions,
  loadDateFacetSetActions,
  loadDebugActions,
  loadDictionaryFieldContextActions,
  loadDidYouMeanActions,
  loadExcerptLengthActions,
  loadFacetOptionsActions,
  loadFacetSetActions,
  loadFieldActions,
  loadFoldingActions,
  loadGeneratedAnswerActions,
  loadGenericAnalyticsActions,
  loadHistoryActions,
  loadIPXActionsHistoryActions,
  loadInstantResultsActions,
  loadNumericFacetSetActions,
  loadPaginationActions,
  loadPipelineActions,
  loadQueryActions,
  loadQuerySetActions,
  loadQuerySuggestActions,
  loadQuestionAnsweringActions,
  loadRecentQueriesActions,
  loadRecentResultsActions,
  loadResultPreviewActions,
  loadSearchActions,
  loadSearchAnalyticsActions,
  loadSearchConfigurationActions,
  loadSearchHubActions,
  loadSearchParameterActions,
  loadSortCriteriaActions,
  loadStandaloneSearchBoxSetActions,
  loadStaticFilterSetActions,
  loadTabSetActions,
  maxPageSelector,
  parseCriterionExpression,
  validateRelativeDate
};
/*! Bundled license information:

@coveo/bueno/dist/bueno.esm.js:
  (**
   * @license
   *
   * Copyright 2026 Coveo Solutions Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   *       http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=@coveo_headless.js.map
